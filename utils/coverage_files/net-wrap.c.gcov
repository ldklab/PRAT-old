        -:    0:Source:net.c
        -:    0:Graph:net.gcno
        -:    0:Data:net.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:Copyright (c) 2009-2018 Roger Light <roger@atchoo.org>
        -:    3:
        -:    4:All rights reserved. This program and the accompanying materials
        -:    5:are made available under the terms of the Eclipse Public License v1.0
        -:    6:and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: 
        -:    8:The Eclipse Public License is available at
        -:    9:   http://www.eclipse.org/legal/epl-v10.html
        -:   10:and the Eclipse Distribution License is available at
        -:   11:  http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: 
        -:   13:Contributors:
        -:   14:   Roger Light - initial implementation and documentation.
        -:   15:*/
        -:   16:
        -:   17:#include "config.h"
        -:   18:
        -:   19:#ifndef WIN32
        -:   20:#include <netdb.h>
        -:   21:#include <unistd.h>
        -:   22:#include <arpa/inet.h>
        -:   23:#include <sys/socket.h>
        -:   24:#include <netinet/tcp.h>
        -:   25:#else
        -:   26:#include <winsock2.h>
        -:   27:#include <ws2tcpip.h>
        -:   28:#endif
        -:   29:
        -:   30:#include <assert.h>
        -:   31:#include <errno.h>
        -:   32:#include <fcntl.h>
        -:   33:#include <stdio.h>
        -:   34:#include <string.h>
        -:   35:#ifdef WITH_WRAP
        -:   36:#include <tcpd.h>
        -:   37:#endif
        -:   38:
        -:   39:#ifdef HAVE_NETINET_IN_H
        -:   40:#  include <netinet/in.h>
        -:   41:#endif
        -:   42:
        -:   43:#ifdef __QNX__
        -:   44:#include <net/netbyte.h>
        -:   45:#endif
        -:   46:
        -:   47:#include "mosquitto_broker_internal.h"
        -:   48:#include "mqtt3_protocol.h"
        -:   49:#include "memory_mosq.h"
        -:   50:#include "net_mosq.h"
        -:   51:#include "util_mosq.h"
        -:   52:
        -:   53:#ifdef WITH_TLS
        -:   54:#include "tls_mosq.h"
        -:   55:#include <openssl/err.h>
        -:   56:static int tls_ex_index_context = -1;
        -:   57:static int tls_ex_index_listener = -1;
        -:   58:#endif
        -:   59:
        -:   60:#include "sys_tree.h"
        -:   61:
        -:   62:/* For EMFILE handling */
        -:   63:static mosq_sock_t spare_sock = INVALID_SOCKET;
        -:   64:
        1:   65:void net__broker_init(void)
        -:   66:{
        1:   67:	spare_sock = socket(AF_INET, SOCK_STREAM, 0);
        1:   68:	net__init();
        1:   69:}
        -:   70:
        -:   71:
        1:   72:void net__broker_cleanup(void)
        -:   73:{
        1:   74:	if(spare_sock != INVALID_SOCKET){
        1:   75:		COMPAT_CLOSE(spare_sock);
        1:   76:		spare_sock = INVALID_SOCKET;
        -:   77:	}
        1:   78:	net__cleanup();
        1:   79:}
        -:   80:
        -:   81:
    #####:   82:static void net__print_error(int log, const char *format_str)
        -:   83:{
        -:   84:	char *buf;
        -:   85:
        -:   86:#ifdef WIN32
        -:   87:	FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
        -:   88:			NULL, WSAGetLastError(), LANG_NEUTRAL, &buf, 0, NULL);
        -:   89:
        -:   90:	log__printf(NULL, log, format_str, buf);
        -:   91:	LocalFree(buf);
        -:   92:#else
    #####:   93:	buf = strerror(errno);
    #####:   94:	log__printf(NULL, log, format_str, buf);
        -:   95:#endif
    #####:   96:}
        -:   97:
        -:   98:
    #####:   99:int net__socket_accept(struct mosquitto_db *db, mosq_sock_t listensock)
        -:  100:{
        -:  101:	int i;
        -:  102:	int j;
    #####:  103:	mosq_sock_t new_sock = INVALID_SOCKET;
        -:  104:	struct mosquitto *new_context;
        -:  105:#ifdef WITH_TLS
        -:  106:	BIO *bio;
        -:  107:	int rc;
        -:  108:	char ebuf[256];
        -:  109:	unsigned long e;
        -:  110:#endif
        -:  111:#ifdef WITH_WRAP
        -:  112:	struct request_info wrap_req;
        -:  113:	char address[1024];
        -:  114:#endif
        -:  115:
    #####:  116:	new_sock = accept(listensock, NULL, 0);
    #####:  117:	if(new_sock == INVALID_SOCKET){
        -:  118:#ifdef WIN32
        -:  119:		errno = WSAGetLastError();
        -:  120:		if(errno == WSAEMFILE){
        -:  121:#else
    #####:  122:		if(errno == EMFILE || errno == ENFILE){
        -:  123:#endif
        -:  124:			/* Close the spare socket, which means we should be able to accept
        -:  125:			 * this connection. Accept it, then close it immediately and create
        -:  126:			 * a new spare_sock. This prevents the situation of ever properly
        -:  127:			 * running out of sockets.
        -:  128:			 * It would be nice to send a "server not available" connack here,
        -:  129:			 * but there are lots of reasons why this would be tricky (TLS
        -:  130:			 * being the big one). */
    #####:  131:			COMPAT_CLOSE(spare_sock);
    #####:  132:			new_sock = accept(listensock, NULL, 0);
    #####:  133:			if(new_sock != INVALID_SOCKET){
    #####:  134:				COMPAT_CLOSE(new_sock);
        -:  135:			}
    #####:  136:			spare_sock = socket(AF_INET, SOCK_STREAM, 0);
    #####:  137:			log__printf(NULL, MOSQ_LOG_WARNING,
        -:  138:					"Unable to accept new connection, system socket count has been exceeded. Try increasing \"ulimit -n\" or equivalent.");
        -:  139:		}
        -:  140:		return -1;
        -:  141:	}
        -:  142:
    #####:  143:	G_SOCKET_CONNECTIONS_INC();
        -:  144:
    #####:  145:	if(net__socket_nonblock(&new_sock)){
        -:  146:		return INVALID_SOCKET;
        -:  147:	}
        -:  148:
        -:  149:#ifdef WITH_WRAP
        -:  150:	/* Use tcpd / libwrap to determine whether a connection is allowed. */
    #####:  151:	request_init(&wrap_req, RQ_FILE, new_sock, RQ_DAEMON, "mosquitto", 0);
    #####:  152:	fromhost(&wrap_req);
    #####:  153:	if(!hosts_access(&wrap_req)){
        -:  154:		/* Access is denied */
    #####:  155:		if(db->config->connection_messages == true){
    #####:  156:			if(!net__socket_get_address(new_sock, address, 1024)){
    #####:  157:				log__printf(NULL, MOSQ_LOG_NOTICE, "Client connection from %s denied access by tcpd.", address);
        -:  158:			}
        -:  159:		}
    #####:  160:		COMPAT_CLOSE(new_sock);
    #####:  161:		return -1;
        -:  162:	}
        -:  163:#endif
        -:  164:
    #####:  165:	if(db->config->set_tcp_nodelay){
    #####:  166:		int flag = 1;
    #####:  167:		if(setsockopt(new_sock, IPPROTO_TCP, TCP_NODELAY, &flag, sizeof(int)) != 0){
    #####:  168:			log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Unable to set TCP_NODELAY.");
        -:  169:		}
        -:  170:	}
        -:  171:
    #####:  172:	new_context = context__init(db, new_sock);
    #####:  173:	if(!new_context){
    #####:  174:		COMPAT_CLOSE(new_sock);
    #####:  175:		return -1;
        -:  176:	}
    #####:  177:	for(i=0; i<db->config->listener_count; i++){
    #####:  178:		for(j=0; j<db->config->listeners[i].sock_count; j++){
    #####:  179:			if(db->config->listeners[i].socks[j] == listensock){
    #####:  180:				new_context->listener = &db->config->listeners[i];
    #####:  181:				new_context->listener->client_count++;
    #####:  182:				break;
        -:  183:			}
        -:  184:		}
        -:  185:	}
    #####:  186:	if(!new_context->listener){
    #####:  187:		context__cleanup(db, new_context, true);
    #####:  188:		return -1;
        -:  189:	}
        -:  190:
    #####:  191:	if(new_context->listener->max_connections > 0 && new_context->listener->client_count > new_context->listener->max_connections){
    #####:  192:		if(db->config->connection_messages == true){
    #####:  193:			log__printf(NULL, MOSQ_LOG_NOTICE, "Client connection from %s denied: max_connections exceeded.", new_context->address);
        -:  194:		}
    #####:  195:		context__cleanup(db, new_context, true);
    #####:  196:		return -1;
        -:  197:	}
        -:  198:
        -:  199:#ifdef WITH_TLS
        -:  200:	/* TLS init */
    #####:  201:	for(i=0; i<db->config->listener_count; i++){
    #####:  202:		for(j=0; j<db->config->listeners[i].sock_count; j++){
    #####:  203:			if(db->config->listeners[i].socks[j] == listensock){
    #####:  204:				if(db->config->listeners[i].ssl_ctx){
    #####:  205:					new_context->ssl = SSL_new(db->config->listeners[i].ssl_ctx);
    #####:  206:					if(!new_context->ssl){
    #####:  207:						context__cleanup(db, new_context, true);
    #####:  208:						return -1;
        -:  209:					}
    #####:  210:					SSL_set_ex_data(new_context->ssl, tls_ex_index_context, new_context);
    #####:  211:					SSL_set_ex_data(new_context->ssl, tls_ex_index_listener, &db->config->listeners[i]);
    #####:  212:					new_context->want_write = true;
    #####:  213:					bio = BIO_new_socket(new_sock, BIO_NOCLOSE);
    #####:  214:					SSL_set_bio(new_context->ssl, bio, bio);
    #####:  215:					ERR_clear_error();
    #####:  216:					rc = SSL_accept(new_context->ssl);
    #####:  217:					if(rc != 1){
    #####:  218:						rc = SSL_get_error(new_context->ssl, rc);
    #####:  219:						if(rc == SSL_ERROR_WANT_READ){
        -:  220:							/* We always want to read. */
    #####:  221:						}else if(rc == SSL_ERROR_WANT_WRITE){
    #####:  222:							new_context->want_write = true;
        -:  223:						}else{
    #####:  224:							if(db->config->connection_messages == true){
    #####:  225:								e = ERR_get_error();
    #####:  226:								while(e){
    #####:  227:									log__printf(NULL, MOSQ_LOG_NOTICE,
        -:  228:											"Client connection from %s failed: %s.",
        -:  229:											new_context->address, ERR_error_string(e, ebuf));
    #####:  230:									e = ERR_get_error();
        -:  231:								}
        -:  232:							}
    #####:  233:							context__cleanup(db, new_context, true);
    #####:  234:							return -1;
        -:  235:						}
        -:  236:					}
        -:  237:				}
        -:  238:			}
        -:  239:		}
        -:  240:	}
        -:  241:#endif
        -:  242:
    #####:  243:	if(db->config->connection_messages == true){
    #####:  244:		log__printf(NULL, MOSQ_LOG_NOTICE, "New connection from %s on port %d.", new_context->address, new_context->listener->port);
        -:  245:	}
        -:  246:
    #####:  247:	return new_sock;
        -:  248:}
        -:  249:
        -:  250:#ifdef WITH_TLS
    #####:  251:static int client_certificate_verify(int preverify_ok, X509_STORE_CTX *ctx)
        -:  252:{
        -:  253:	/* Preverify should check expiry, revocation. */
    #####:  254:	return preverify_ok;
        -:  255:}
        -:  256:#endif
        -:  257:
        -:  258:#ifdef FINAL_WITH_TLS_PSK
    #####:  259:static unsigned int psk_server_callback(SSL *ssl, const char *identity, unsigned char *psk, unsigned int max_psk_len)
        -:  260:{
        -:  261:	struct mosquitto_db *db;
        -:  262:	struct mosquitto *context;
        -:  263:	struct mosquitto__listener *listener;
    #####:  264:	char *psk_key = NULL;
        -:  265:	int len;
        -:  266:	const char *psk_hint;
        -:  267:
    #####:  268:	if(!identity) return 0;
        -:  269:
    #####:  270:	db = mosquitto__get_db();
        -:  271:
    #####:  272:	context = SSL_get_ex_data(ssl, tls_ex_index_context);
    #####:  273:	if(!context) return 0;
        -:  274:
    #####:  275:	listener = SSL_get_ex_data(ssl, tls_ex_index_listener);
    #####:  276:	if(!listener) return 0;
        -:  277:
    #####:  278:	psk_hint = listener->psk_hint;
        -:  279:
        -:  280:	/* The hex to BN conversion results in the length halving, so we can pass
        -:  281:	 * max_psk_len*2 as the max hex key here. */
    #####:  282:	psk_key = mosquitto__calloc(1, max_psk_len*2 + 1);
    #####:  283:	if(!psk_key) return 0;
        -:  284:
    #####:  285:	if(mosquitto_psk_key_get(db, context, psk_hint, identity, psk_key, max_psk_len*2) != MOSQ_ERR_SUCCESS){
    #####:  286:		mosquitto__free(psk_key);
    #####:  287:		return 0;
        -:  288:	}
        -:  289:
    #####:  290:	len = mosquitto__hex2bin(psk_key, psk, max_psk_len);
    #####:  291:	if (len < 0){
    #####:  292:		mosquitto__free(psk_key);
    #####:  293:		return 0;
        -:  294:	}
        -:  295:
    #####:  296:	if(listener->use_identity_as_username){
    #####:  297:		context->username = mosquitto__strdup(identity);
    #####:  298:		if(!context->username){
    #####:  299:			mosquitto__free(psk_key);
    #####:  300:			return 0;
        -:  301:		}
        -:  302:	}
        -:  303:
    #####:  304:	mosquitto__free(psk_key);
    #####:  305:	return len;
        -:  306:}
        -:  307:#endif
        -:  308:
        -:  309:#ifdef WITH_TLS
    #####:  310:static int mosquitto__tls_server_ctx(struct mosquitto__listener *listener)
        -:  311:{
        -:  312:	char buf[256];
        -:  313:	int rc;
        -:  314:
        -:  315:
        -:  316:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  317:	listener->ssl_ctx = SSL_CTX_new(SSLv23_server_method());
        -:  318:#else
    #####:  319:	listener->ssl_ctx = SSL_CTX_new(TLS_server_method());
        -:  320:#endif
        -:  321:
    #####:  322:	if(!listener->ssl_ctx){
    #####:  323:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to create TLS context.");
    #####:  324:		return 1;
        -:  325:	}
        -:  326:
    #####:  327:	if(listener->tls_version == NULL){
    #####:  328:		SSL_CTX_set_options(listener->ssl_ctx, SSL_OP_NO_SSLv3);
    #####:  329:	}else if(!strcmp(listener->tls_version, "tlsv1.2")){
    #####:  330:		SSL_CTX_set_options(listener->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1);
    #####:  331:	}else if(!strcmp(listener->tls_version, "tlsv1.1")){
    #####:  332:		SSL_CTX_set_options(listener->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1_2 | SSL_OP_NO_TLSv1);
    #####:  333:	}else if(!strcmp(listener->tls_version, "tlsv1")){
    #####:  334:		SSL_CTX_set_options(listener->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1_2 | SSL_OP_NO_TLSv1_1);
        -:  335:	}
        -:  336:
        -:  337:#ifdef SSL_OP_NO_COMPRESSION
        -:  338:	/* Disable compression */
    #####:  339:	SSL_CTX_set_options(listener->ssl_ctx, SSL_OP_NO_COMPRESSION);
        -:  340:#endif
        -:  341:#ifdef SSL_OP_CIPHER_SERVER_PREFERENCE
        -:  342:	/* Server chooses cipher */
    #####:  343:	SSL_CTX_set_options(listener->ssl_ctx, SSL_OP_CIPHER_SERVER_PREFERENCE);
        -:  344:#endif
        -:  345:
        -:  346:#ifdef SSL_MODE_RELEASE_BUFFERS
        -:  347:	/* Use even less memory per SSL connection. */
    #####:  348:	SSL_CTX_set_mode(listener->ssl_ctx, SSL_MODE_RELEASE_BUFFERS);
        -:  349:#endif
        -:  350:
        -:  351:#ifdef WITH_EC
        -:  352:#if OPENSSL_VERSION_NUMBER >= 0x10002000L && OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  353:	SSL_CTX_set_ecdh_auto(listener->ssl_ctx, 1);
        -:  354:#endif
        -:  355:#endif
        -:  356:
    #####:  357:	snprintf(buf, 256, "mosquitto-%d", listener->port);
    #####:  358:	SSL_CTX_set_session_id_context(listener->ssl_ctx, (unsigned char *)buf, strlen(buf));
        -:  359:
    #####:  360:	if(listener->ciphers){
    #####:  361:		rc = SSL_CTX_set_cipher_list(listener->ssl_ctx, listener->ciphers);
    #####:  362:		if(rc == 0){
    #####:  363:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to set TLS ciphers. Check cipher list \"%s\".", listener->ciphers);
    #####:  364:			return 1;
        -:  365:		}
        -:  366:	}else{
    #####:  367:		rc = SSL_CTX_set_cipher_list(listener->ssl_ctx, "DEFAULT:!aNULL:!eNULL:!LOW:!EXPORT:!SSLv2:@STRENGTH");
    #####:  368:		if(rc == 0){
    #####:  369:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to set TLS ciphers. Check cipher list \"%s\".", listener->ciphers);
    #####:  370:			return 1;
        -:  371:		}
        -:  372:	}
        -:  373:	return MOSQ_ERR_SUCCESS;
        -:  374:}
        -:  375:#endif
        -:  376:
        -:  377:/* Creates a socket and listens on port 'port'.
        -:  378: * Returns 1 on failure
        -:  379: * Returns 0 on success.
        -:  380: */
        1:  381:int net__socket_listen(struct mosquitto__listener *listener)
        -:  382:{
        1:  383:	mosq_sock_t sock = INVALID_SOCKET;
        -:  384:	struct addrinfo hints;
        -:  385:	struct addrinfo *ainfo, *rp;
        -:  386:	char service[10];
        -:  387:#ifndef WIN32
        1:  388:	int ss_opt = 1;
        -:  389:#else
        -:  390:	char ss_opt = 1;
        -:  391:#endif
        -:  392:#ifdef WITH_TLS
        -:  393:	int rc;
        -:  394:	X509_STORE *store;
        -:  395:	X509_LOOKUP *lookup;
        -:  396:#endif
        -:  397:
        1:  398:	if(!listener) return MOSQ_ERR_INVAL;
        -:  399:
        2:  400:	snprintf(service, 10, "%d", listener->port);
        1:  401:	memset(&hints, 0, sizeof(struct addrinfo));
        1:  402:	if(listener->socket_domain){
    #####:  403:		hints.ai_family = listener->socket_domain;
        -:  404:	}else{
        -:  405:		hints.ai_family = AF_UNSPEC;
        -:  406:	}
        1:  407:	hints.ai_flags = AI_PASSIVE;
        1:  408:	hints.ai_socktype = SOCK_STREAM;
        -:  409:
        1:  410:	if(getaddrinfo(listener->host, service, &hints, &ainfo)) return INVALID_SOCKET;
        -:  411:
        1:  412:	listener->sock_count = 0;
        1:  413:	listener->socks = NULL;
        -:  414:
        3:  415:	for(rp = ainfo; rp; rp = rp->ai_next){
        2:  416:		if(rp->ai_family == AF_INET){
        1:  417:			log__printf(NULL, MOSQ_LOG_INFO, "Opening ipv4 listen socket on port %d.", ntohs(((struct sockaddr_in *)rp->ai_addr)->sin_port));
        1:  418:		}else if(rp->ai_family == AF_INET6){
        1:  419:			log__printf(NULL, MOSQ_LOG_INFO, "Opening ipv6 listen socket on port %d.", ntohs(((struct sockaddr_in6 *)rp->ai_addr)->sin6_port));
        -:  420:		}else{
    #####:  421:			continue;
        -:  422:		}
        -:  423:
        2:  424:		sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        2:  425:		if(sock == INVALID_SOCKET){
    #####:  426:			net__print_error(MOSQ_LOG_WARNING, "Warning: %s");
    #####:  427:			continue;
        -:  428:		}
        2:  429:		listener->sock_count++;
        2:  430:		listener->socks = mosquitto__realloc(listener->socks, sizeof(mosq_sock_t)*listener->sock_count);
        2:  431:		if(!listener->socks){
    #####:  432:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  433:			return MOSQ_ERR_NOMEM;
        -:  434:		}
        2:  435:		listener->socks[listener->sock_count-1] = sock;
        -:  436:
        -:  437:#ifndef WIN32
        2:  438:		ss_opt = 1;
        2:  439:		setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, &ss_opt, sizeof(ss_opt));
        -:  440:#endif
        2:  441:		ss_opt = 1;
        2:  442:		setsockopt(sock, IPPROTO_IPV6, IPV6_V6ONLY, &ss_opt, sizeof(ss_opt));
        -:  443:
        2:  444:		if(net__socket_nonblock(&sock)){
        -:  445:			return 1;
        -:  446:		}
        -:  447:
        2:  448:		if(bind(sock, rp->ai_addr, rp->ai_addrlen) == -1){
    #####:  449:			net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  450:			COMPAT_CLOSE(sock);
    #####:  451:			return 1;
        -:  452:		}
        -:  453:
        2:  454:		if(listen(sock, 100) == -1){
    #####:  455:			net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  456:			COMPAT_CLOSE(sock);
    #####:  457:			return 1;
        -:  458:		}
        -:  459:	}
        1:  460:	freeaddrinfo(ainfo);
        -:  461:
        -:  462:	/* We need to have at least one working socket. */
        1:  463:	if(listener->sock_count > 0){
        -:  464:#ifdef WITH_TLS
        1:  465:		if((listener->cafile || listener->capath) && listener->certfile && listener->keyfile){
    #####:  466:			if(mosquitto__tls_server_ctx(listener)){
    #####:  467:				COMPAT_CLOSE(sock);
    #####:  468:				return 1;
        -:  469:			}
        -:  470:
    #####:  471:			rc = SSL_CTX_load_verify_locations(listener->ssl_ctx, listener->cafile, listener->capath);
    #####:  472:			if(rc == 0){
    #####:  473:				if(listener->cafile && listener->capath){
    #####:  474:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to load CA certificates. Check cafile \"%s\" and capath \"%s\".", listener->cafile, listener->capath);
    #####:  475:				}else if(listener->cafile){
    #####:  476:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to load CA certificates. Check cafile \"%s\".", listener->cafile);
        -:  477:				}else{
    #####:  478:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to load CA certificates. Check capath \"%s\".", listener->capath);
        -:  479:				}
    #####:  480:				net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  481:				COMPAT_CLOSE(sock);
    #####:  482:				return 1;
        -:  483:			}
        -:  484:			/* FIXME user data? */
    #####:  485:			if(listener->require_certificate){
    #####:  486:				SSL_CTX_set_verify(listener->ssl_ctx, SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT, client_certificate_verify);
        -:  487:			}else{
    #####:  488:				SSL_CTX_set_verify(listener->ssl_ctx, SSL_VERIFY_NONE, client_certificate_verify);
        -:  489:			}
    #####:  490:			rc = SSL_CTX_use_certificate_chain_file(listener->ssl_ctx, listener->certfile);
    #####:  491:			if(rc != 1){
    #####:  492:				log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to load server certificate \"%s\". Check certfile.", listener->certfile);
    #####:  493:				net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  494:				COMPAT_CLOSE(sock);
    #####:  495:				return 1;
        -:  496:			}
    #####:  497:			rc = SSL_CTX_use_PrivateKey_file(listener->ssl_ctx, listener->keyfile, SSL_FILETYPE_PEM);
    #####:  498:			if(rc != 1){
    #####:  499:				log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to load server key file \"%s\". Check keyfile.", listener->keyfile);
    #####:  500:				net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  501:				COMPAT_CLOSE(sock);
    #####:  502:				return 1;
        -:  503:			}
    #####:  504:			rc = SSL_CTX_check_private_key(listener->ssl_ctx);
    #####:  505:			if(rc != 1){
    #####:  506:				log__printf(NULL, MOSQ_LOG_ERR, "Error: Server certificate/key are inconsistent.");
    #####:  507:				net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  508:				COMPAT_CLOSE(sock);
    #####:  509:				return 1;
        -:  510:			}
        -:  511:			/* Load CRLs if they exist. */
    #####:  512:			if(listener->crlfile){
    #####:  513:				store = SSL_CTX_get_cert_store(listener->ssl_ctx);
    #####:  514:				if(!store){
    #####:  515:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to obtain TLS store.");
    #####:  516:					net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  517:					COMPAT_CLOSE(sock);
    #####:  518:					return 1;
        -:  519:				}
    #####:  520:				lookup = X509_STORE_add_lookup(store, X509_LOOKUP_file());
    #####:  521:				rc = X509_load_crl_file(lookup, listener->crlfile, X509_FILETYPE_PEM);
    #####:  522:				if(rc != 1){
    #####:  523:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to load certificate revocation file \"%s\". Check crlfile.", listener->crlfile);
    #####:  524:					net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  525:					COMPAT_CLOSE(sock);
    #####:  526:					return 1;
        -:  527:				}
    #####:  528:				X509_STORE_set_flags(store, X509_V_FLAG_CRL_CHECK);
        -:  529:			}
        -:  530:
        -:  531:#  ifdef FINAL_WITH_TLS_PSK
        1:  532:		}else if(listener->psk_hint){
    #####:  533:			if(tls_ex_index_context == -1){
    #####:  534:				tls_ex_index_context = SSL_get_ex_new_index(0, "client context", NULL, NULL, NULL);
        -:  535:			}
    #####:  536:			if(tls_ex_index_listener == -1){
    #####:  537:				tls_ex_index_listener = SSL_get_ex_new_index(0, "listener", NULL, NULL, NULL);
        -:  538:			}
        -:  539:
    #####:  540:			if(mosquitto__tls_server_ctx(listener)){
    #####:  541:				COMPAT_CLOSE(sock);
    #####:  542:				return 1;
        -:  543:			}
    #####:  544:			SSL_CTX_set_psk_server_callback(listener->ssl_ctx, psk_server_callback);
    #####:  545:			if(listener->psk_hint){
    #####:  546:				rc = SSL_CTX_use_psk_identity_hint(listener->ssl_ctx, listener->psk_hint);
    #####:  547:				if(rc == 0){
    #####:  548:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to set TLS PSK hint.");
    #####:  549:					net__print_error(MOSQ_LOG_ERR, "Error: %s");
    #####:  550:					COMPAT_CLOSE(sock);
    #####:  551:					return 1;
        -:  552:				}
        -:  553:			}
        -:  554:#  endif /* FINAL_WITH_TLS_PSK */
        -:  555:		}
        -:  556:#endif /* WITH_TLS */
        -:  557:		return 0;
        -:  558:	}else{
        -:  559:		return 1;
        -:  560:	}
        -:  561:}
        -:  562:
    #####:  563:int net__socket_get_address(mosq_sock_t sock, char *buf, int len)
        -:  564:{
        -:  565:	struct sockaddr_storage addr;
        -:  566:	socklen_t addrlen;
        -:  567:
    #####:  568:	addrlen = sizeof(addr);
    #####:  569:	if(!getpeername(sock, (struct sockaddr *)&addr, &addrlen)){
    #####:  570:		if(addr.ss_family == AF_INET){
    #####:  571:			if(inet_ntop(AF_INET, &((struct sockaddr_in *)&addr)->sin_addr.s_addr, buf, len)){
        -:  572:				return 0;
        -:  573:			}
    #####:  574:		}else if(addr.ss_family == AF_INET6){
    #####:  575:			if(inet_ntop(AF_INET6, &((struct sockaddr_in6 *)&addr)->sin6_addr.s6_addr, buf, len)){
        -:  576:				return 0;
        -:  577:			}
        -:  578:		}
        -:  579:	}
        -:  580:	return 1;
        -:  581:}
