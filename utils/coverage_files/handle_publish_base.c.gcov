        -:    0:Source:handle_publish.c
        -:    0:Graph:handle_publish.gcno
        -:    0:Data:handle_publish.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:Copyright (c) 2009-2018 Roger Light <roger@atchoo.org>
        -:    3:
        -:    4:All rights reserved. This program and the accompanying materials
        -:    5:are made available under the terms of the Eclipse Public License v1.0
        -:    6:and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7:
        -:    8:The Eclipse Public License is available at
        -:    9:   http://www.eclipse.org/legal/epl-v10.html
        -:   10:and the Eclipse Distribution License is available at
        -:   11:  http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12:
        -:   13:Contributors:
        -:   14:   Roger Light - initial implementation and documentation.
        -:   15:*/
        -:   16:
        -:   17:#include "config.h"
        -:   18:
        -:   19:#include <assert.h>
        -:   20:#include <stdio.h>
        -:   21:#include <string.h>
        -:   22:
        -:   23:#include "mosquitto_broker_internal.h"
        -:   24:#include "mqtt3_protocol.h"
        -:   25:#include "memory_mosq.h"
        -:   26:#include "packet_mosq.h"
        -:   27:#include "read_handle.h"
        -:   28:#include "send_mosq.h"
        -:   29:#include "sys_tree.h"
        -:   30:#include "util_mosq.h"
        -:   31:
        -:   32:
    #####:   33:int handle__publish(struct mosquitto_db *db, struct mosquitto *context)
        -:   34:{
        -:   35:	char *topic;
        -:   36:	mosquitto__payload_uhpa payload;
        -:   37:	uint32_t payloadlen;
        -:   38:	uint8_t dup, qos, retain;
    #####:   39:	uint16_t mid = 0;
    #####:   40:	int rc = 0;
    #####:   41:	uint8_t header = context->in_packet.command;
    #####:   42:	int res = 0;
    #####:   43:	struct mosquitto_msg_store *stored = NULL;
        -:   44:	int len;
        -:   45:	int slen;
        -:   46:	char *topic_mount;
        -:   47:#ifdef WITH_BRIDGE
        -:   48:	char *topic_temp;
        -:   49:	int i;
        -:   50:	struct mosquitto__bridge_topic *cur_topic;
        -:   51:	bool match;
        -:   52:#endif
        -:   53:
    #####:   54:	payload.ptr = NULL;
        -:   55:
    #####:   56:	dup = (header & 0x08)>>3;
    #####:   57:	qos = (header & 0x06)>>1;
    #####:   58:	if(qos == 3){
    #####:   59:		log__printf(NULL, MOSQ_LOG_INFO,
        -:   60:				"Invalid QoS in PUBLISH from %s, disconnecting.", context->id);
    #####:   61:		return 1;
        -:   62:	}
    #####:   63:	retain = (header & 0x01);
        -:   64:
    #####:   65:	if(packet__read_string(&context->in_packet, &topic, &slen)) return 1;
    #####:   66:	if(!slen){
        -:   67:		/* Invalid publish topic, disconnect client. */
    #####:   68:		mosquitto__free(topic);
    #####:   69:		return 1;
        -:   70:	}
        -:   71:
    #####:   72:	if(mosquitto_validate_utf8(topic, slen) != MOSQ_ERR_SUCCESS){
    #####:   73:		log__printf(NULL, MOSQ_LOG_INFO, "Client %s sent topic with invalid UTF-8, disconnecting.", context->id);
    #####:   74:		mosquitto__free(topic);
    #####:   75:		return 1;
        -:   76:	}
        -:   77:
        -:   78:#ifdef WITH_BRIDGE
    #####:   79:	if(context->bridge && context->bridge->topics && context->bridge->topic_remapping){
    #####:   80:		for(i=0; i<context->bridge->topic_count; i++){
    #####:   81:			cur_topic = &context->bridge->topics[i];
    #####:   82:			if((cur_topic->direction == bd_both || cur_topic->direction == bd_in)
    #####:   83:					&& (cur_topic->remote_prefix || cur_topic->local_prefix)){
        -:   84:
        -:   85:				/* Topic mapping required on this topic if the message matches */
        -:   86:
    #####:   87:				rc = mosquitto_topic_matches_sub(cur_topic->remote_topic, topic, &match);
    #####:   88:				if(rc){
    #####:   89:					mosquitto__free(topic);
    #####:   90:					return rc;
        -:   91:				}
    #####:   92:				if(match){
    #####:   93:					if(cur_topic->remote_prefix){
        -:   94:						/* This prefix needs removing. */
    #####:   95:						if(!strncmp(cur_topic->remote_prefix, topic, strlen(cur_topic->remote_prefix))){
    #####:   96:							topic_temp = mosquitto__strdup(topic+strlen(cur_topic->remote_prefix));
    #####:   97:							if(!topic_temp){
    #####:   98:								mosquitto__free(topic);
    #####:   99:								return MOSQ_ERR_NOMEM;
        -:  100:							}
    #####:  101:							mosquitto__free(topic);
    #####:  102:							topic = topic_temp;
        -:  103:						}
        -:  104:					}
        -:  105:
    #####:  106:					if(cur_topic->local_prefix){
        -:  107:						/* This prefix needs adding. */
    #####:  108:						len = strlen(topic) + strlen(cur_topic->local_prefix)+1;
    #####:  109:						topic_temp = mosquitto__malloc(len+1);
    #####:  110:						if(!topic_temp){
    #####:  111:							mosquitto__free(topic);
    #####:  112:							return MOSQ_ERR_NOMEM;
        -:  113:						}
    #####:  114:						snprintf(topic_temp, len, "%s%s", cur_topic->local_prefix, topic);
    #####:  115:						topic_temp[len] = '\0';
        -:  116:
    #####:  117:						mosquitto__free(topic);
    #####:  118:						topic = topic_temp;
        -:  119:					}
        -:  120:					break;
        -:  121:				}
        -:  122:			}
        -:  123:		}
        -:  124:	}
        -:  125:#endif
    #####:  126:	if(mosquitto_pub_topic_check(topic) != MOSQ_ERR_SUCCESS){
        -:  127:		/* Invalid publish topic, just swallow it. */
    #####:  128:		mosquitto__free(topic);
    #####:  129:		return 1;
        -:  130:	}
        -:  131:
    #####:  132:	if(qos > 0){
    #####:  133:		if(packet__read_uint16(&context->in_packet, &mid)){
    #####:  134:			mosquitto__free(topic);
    #####:  135:			return 1;
        -:  136:		}
        -:  137:	}
        -:  138:
    #####:  139:	payloadlen = context->in_packet.remaining_length - context->in_packet.pos;
    #####:  140:	G_PUB_BYTES_RECEIVED_INC(payloadlen);
    #####:  141:	if(context->listener && context->listener->mount_point){
    #####:  142:		len = strlen(context->listener->mount_point) + strlen(topic) + 1;
    #####:  143:		topic_mount = mosquitto__malloc(len+1);
    #####:  144:		if(!topic_mount){
    #####:  145:			mosquitto__free(topic);
    #####:  146:			return MOSQ_ERR_NOMEM;
        -:  147:		}
    #####:  148:		snprintf(topic_mount, len, "%s%s", context->listener->mount_point, topic);
    #####:  149:		topic_mount[len] = '\0';
        -:  150:
    #####:  151:		mosquitto__free(topic);
    #####:  152:		topic = topic_mount;
        -:  153:	}
        -:  154:
    #####:  155:	if(payloadlen){
    #####:  156:		if(db->config->message_size_limit && payloadlen > db->config->message_size_limit){
    #####:  157:			log__printf(NULL, MOSQ_LOG_DEBUG, "Dropped too large PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))", context->id, dup, qos, retain, mid, topic, (long)payloadlen);
    #####:  158:			goto process_bad_message;
        -:  159:		}
    #####:  160:		if(UHPA_ALLOC(payload, payloadlen+1) == 0){
    #####:  161:			mosquitto__free(topic);
    #####:  162:			return MOSQ_ERR_NOMEM;
        -:  163:		}
    #####:  164:		if(packet__read_bytes(&context->in_packet, UHPA_ACCESS(payload, payloadlen), payloadlen)){
    #####:  165:			mosquitto__free(topic);
    #####:  166:			UHPA_FREE(payload, payloadlen);
        -:  167:			return 1;
        -:  168:		}
        -:  169:	}
        -:  170:
        -:  171:	/* Check for topic access */
    #####:  172:	rc = mosquitto_acl_check(db, context, topic, payloadlen, UHPA_ACCESS(payload, payloadlen), qos, retain, MOSQ_ACL_WRITE);
    #####:  173:	if(rc == MOSQ_ERR_ACL_DENIED){
    #####:  174:		log__printf(NULL, MOSQ_LOG_DEBUG, "Denied PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))", context->id, dup, qos, retain, mid, topic, (long)payloadlen);
    #####:  175:		goto process_bad_message;
    #####:  176:	}else if(rc != MOSQ_ERR_SUCCESS){
    #####:  177:		mosquitto__free(topic);
    #####:  178:		UHPA_FREE(payload, payloadlen);
        -:  179:		return rc;
        -:  180:	}
        -:  181:
    #####:  182:	log__printf(NULL, MOSQ_LOG_DEBUG, "Received PUBLISH from %s (d%d, q%d, r%d, m%d, '%s', ... (%ld bytes))", context->id, dup, qos, retain, mid, topic, (long)payloadlen);
    #####:  183:	if(qos > 0){
    #####:  184:		db__message_store_find(context, mid, &stored);
        -:  185:	}
    #####:  186:	if(!stored){
    #####:  187:		dup = 0;
    #####:  188:		if(db__message_store(db, context, mid, topic, qos, payloadlen, &payload, retain, &stored, 0)){
        -:  189:			return 1;
        -:  190:		}
        -:  191:	}else{
    #####:  192:		mosquitto__free(topic);
    #####:  193:		topic = stored->topic;
    #####:  194:		dup = 1;
        -:  195:	}
        -:  196:
    #####:  197:	switch(qos){
    #####:  198:		case 0:
    #####:  199:			if(sub__messages_queue(db, context->id, topic, qos, retain, &stored)) rc = 1;
        -:  200:			break;
    #####:  201:		case 1:
    #####:  202:			if(sub__messages_queue(db, context->id, topic, qos, retain, &stored)) rc = 1;
    #####:  203:			if(send__puback(context, mid)) rc = 1;
        -:  204:			break;
    #####:  205:		case 2:
    #####:  206:			if(!dup){
    #####:  207:				res = db__message_insert(db, context, mid, mosq_md_in, qos, retain, stored);
        -:  208:			}else{
        -:  209:				res = 0;
        -:  210:			}
        -:  211:			/* db__message_insert() returns 2 to indicate dropped message
        -:  212:			 * due to queue. This isn't an error so don't disconnect them. */
    #####:  213:			if(!res){
    #####:  214:				if(send__pubrec(context, mid)) rc = 1;
    #####:  215:			}else if(res == 1){
    #####:  216:				rc = 1;
        -:  217:			}
        -:  218:			break;
        -:  219:	}
        -:  220:
        -:  221:	return rc;
    #####:  222:process_bad_message:
    #####:  223:	mosquitto__free(topic);
    #####:  224:	UHPA_FREE(payload, payloadlen);
    #####:  225:	switch(qos){
        -:  226:		case 0:
        -:  227:			return MOSQ_ERR_SUCCESS;
    #####:  228:		case 1:
    #####:  229:			return send__puback(context, mid);
    #####:  230:		case 2:
    #####:  231:			db__message_store_find(context, mid, &stored);
    #####:  232:			if(!stored){
    #####:  233:				if(db__message_store(db, context, mid, NULL, qos, 0, NULL, false, &stored, 0)){
        -:  234:					return 1;
        -:  235:				}
    #####:  236:				res = db__message_insert(db, context, mid, mosq_md_in, qos, false, stored);
        -:  237:			}else{
        -:  238:				res = 0;
        -:  239:			}
    #####:  240:			if(!res){
    #####:  241:				res = send__pubrec(context, mid);
        -:  242:			}
        -:  243:			return res;
        -:  244:	}
    #####:  245:	return 1;
        -:  246:}
        -:  247:
