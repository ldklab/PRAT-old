        -:    0:Source:DdsDcpsCoreTypeSupportImpl.cpp
        -:    0:Programs:72
        -:    1:/* Generated by /home/ryan/git/OpenDDS-debloat/bin/opendds_idl version 3.13 (ACE version 6.2a_p15) running on input file DdsDcpsCore.idl */
        -:    2:#include "DCPS/DdsDcps_pch.h"
        -:    3:#include "DdsDcpsCoreTypeSupportImpl.h"
        -:    4:
        -:    5:#include <cstring>
        -:    6:#include <stdexcept>
        -:    7:#include "dds/CorbaSeq/LongSeqTypeSupportImpl.h"
        -:    8:#include "dds/CorbaSeq/OctetSeqTypeSupportImpl.h"
        -:    9:#include "dds/DCPS/BuiltInTopicUtils.h"
        -:   10:#include "dds/DCPS/ContentFilteredTopicImpl.h"
        -:   11:#include "dds/DCPS/DataReaderImpl_T.h"
        -:   12:#include "dds/DCPS/DataWriterImpl_T.h"
        -:   13:#include "dds/DCPS/FilterEvaluator.h"
        -:   14:#include "dds/DCPS/MultiTopicDataReader_T.h"
        -:   15:#include "dds/DCPS/PoolAllocator.h"
        -:   16:#include "dds/DCPS/PublicationInstance.h"
        -:   17:#include "dds/DCPS/PublisherImpl.h"
        -:   18:#include "dds/DCPS/Qos_Helper.h"
        -:   19:#include "dds/DCPS/RakeData.h"
        -:   20:#include "dds/DCPS/RakeResults_T.h"
        -:   21:#include "dds/DCPS/ReceivedDataElementList.h"
        -:   22:#include "dds/DCPS/Registered_Data_Types.h"
        -:   23:#include "dds/DCPS/Service_Participant.h"
        -:   24:#include "dds/DCPS/SubscriberImpl.h"
        -:   25:#include "dds/DCPS/Util.h"
        -:   26:#include "dds/DCPS/debug.h"
        -:   27:#include "dds/DdsDcpsDomainC.h"
        -:   28:
        -:   29:
        -:   30:/* Begin MODULE: CORBA */
        -:   31:
        -:   32:
        -:   33:/* End MODULE: CORBA */
        -:   34:
        -:   35:
        -:   36:/* Begin MODULE: CORBA */
        -:   37:
        -:   38:
        -:   39:
        -:   40:/* Begin TYPEDEF: StringSeq */
        -:   41:
        -:   42:
        -:   43:/* End TYPEDEF: StringSeq */
        -:   44:
        -:   45:/* End MODULE: CORBA */
        -:   46:
        -:   47:
        -:   48:/* Begin MODULE: CORBA */
        -:   49:
        -:   50:
        -:   51:
        -:   52:/* Begin TYPEDEF: LongSeq */
        -:   53:
        -:   54:
        -:   55:/* End TYPEDEF: LongSeq */
        -:   56:
        -:   57:/* End MODULE: CORBA */
        -:   58:
        -:   59:
        -:   60:/* Begin MODULE: DDS */
        -:   61:
        -:   62:
        -:   63:
        -:   64:/* Begin TYPEDEF: StringSeq */
        -:   65:
        -:   66:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   67:namespace OpenDDS { namespace DCPS {
        -:   68:
        6:   69:void gen_find_size(const DDS::StringSeq& seq, size_t& size, size_t& padding)
        -:   70:{
        -:   71:  ACE_UNUSED_ARG(seq);
        -:   72:  ACE_UNUSED_ARG(size);
        -:   73:  ACE_UNUSED_ARG(padding);
        6:   74:  find_size_ulong(size, padding);
        6:   75:  if (seq.length() == 0) {
        6:   76:    return;
        -:   77:  }
    #####:   78:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####:   79:    find_size_ulong(size, padding);
    #####:   80:    if (seq[i]) {
    #####:   81:      size += ACE_OS::strlen(seq[i]) + 1;
        -:   82:    }
        -:   83:  }
        -:   84:}
        -:   85:
        6:   86:bool operator<<(Serializer& strm, const DDS::StringSeq& seq)
        -:   87:{
        -:   88:  ACE_UNUSED_ARG(strm);
        -:   89:  ACE_UNUSED_ARG(seq);
        6:   90:  const CORBA::ULong length = seq.length();
        6:   91:  if (!(strm << length)) {
    #####:   92:    return false;
        -:   93:  }
        6:   94:  if (length == 0) {
        6:   95:    return true;
        -:   96:  }
    #####:   97:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:   98:    if (!(strm << seq[i])) {
    #####:   99:      return false;
        -:  100:    }
        -:  101:  }
    #####:  102:  return true;
        -:  103:}
        -:  104:
    #####:  105:bool operator>>(Serializer& strm, DDS::StringSeq& seq)
        -:  106:{
        -:  107:  ACE_UNUSED_ARG(strm);
        -:  108:  ACE_UNUSED_ARG(seq);
        -:  109:  CORBA::ULong length;
    #####:  110:  if (!(strm >> length)) {
    #####:  111:    return false;
        -:  112:  }
    #####:  113:  seq.length(length);
    #####:  114:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  115:    if (!(strm >> seq.get_buffer()[i])) {
    #####:  116:      return false;
        -:  117:    }
        -:  118:  }
    #####:  119:  return true;
        -:  120:}
        -:  121:
        -:  122:}  }
        -:  123:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  124:
        -:  125:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  126:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  127:namespace OpenDDS { namespace DCPS {
        -:  128:
    #####:  129:bool gen_skip_over(Serializer& ser, DDS::StringSeq*)
        -:  130:{
        -:  131:  ACE_UNUSED_ARG(ser);
        -:  132:  ACE_CDR::ULong length;
    #####:  133:  if (!(ser >> length)) return false;
    #####:  134:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
        -:  135:    ACE_CDR::ULong strlength;
    #####:  136:    if (!(ser >> strlength)) return false;
    #####:  137:    if (!ser.skip(static_cast<ACE_UINT16>(strlength))) return false;
        -:  138:  }
    #####:  139:  return true;
        -:  140:}
        -:  141:
        -:  142:}  }
        -:  143:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  144:
        -:  145:#endif
        -:  146:
        -:  147:/* End TYPEDEF: StringSeq */
        -:  148:
        -:  149:
        -:  150:/* Begin TYPEDEF: InstanceHandle_t */
        -:  151:
        -:  152:
        -:  153:/* End TYPEDEF: InstanceHandle_t */
        -:  154:
        -:  155:
        -:  156:/* Begin TYPEDEF: BuiltinTopicKeyValue */
        -:  157:
        -:  158:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  159:namespace OpenDDS { namespace DCPS {
        -:  160:
       24:  161:void gen_find_size(const DDS::BuiltinTopicKeyValue_forany& arr, size_t& size, size_t& padding)
        -:  162:{
        -:  163:  ACE_UNUSED_ARG(arr);
        -:  164:  ACE_UNUSED_ARG(size);
        -:  165:  ACE_UNUSED_ARG(padding);
       24:  166:  if ((size + padding) % 4) {
    #####:  167:    padding += 4 - ((size + padding) % 4);
        -:  168:  }
       24:  169:  size += 3 * gen_max_marshaled_size(CORBA::Long());
       24:  170:}
        -:  171:
       24:  172:bool operator<<(Serializer& strm, const DDS::BuiltinTopicKeyValue_forany& arr)
        -:  173:{
        -:  174:  ACE_UNUSED_ARG(strm);
        -:  175:  ACE_UNUSED_ARG(arr);
       24:  176:  return strm.write_long_array(arr.in(), 3);
        -:  177:}
        -:  178:
    #####:  179:bool operator>>(Serializer& strm, DDS::BuiltinTopicKeyValue_forany& arr)
        -:  180:{
        -:  181:  ACE_UNUSED_ARG(strm);
        -:  182:  ACE_UNUSED_ARG(arr);
    #####:  183:  return strm.read_long_array(arr.out(), 3);
        -:  184:}
        -:  185:
        -:  186:}  }
        -:  187:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  188:
        -:  189:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  190:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  191:namespace OpenDDS { namespace DCPS {
        -:  192:
    #####:  193:bool gen_skip_over(Serializer& ser, DDS::BuiltinTopicKeyValue_forany*)
        -:  194:{
        -:  195:  ACE_UNUSED_ARG(ser);
    #####:  196:  return ser.skip(static_cast<ACE_UINT16>(3), 4);
        -:  197:}
        -:  198:
        -:  199:}  }
        -:  200:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  201:
        -:  202:#endif
        -:  203:
        -:  204:/* End TYPEDEF: BuiltinTopicKeyValue */
        -:  205:
        -:  206:
        -:  207:/* Begin TYPEDEF: InstanceHandleSeq */
        -:  208:
        -:  209:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  210:namespace OpenDDS { namespace DCPS {
        -:  211:
    #####:  212:void gen_find_size(const DDS::InstanceHandleSeq& seq, size_t& size, size_t& padding)
        -:  213:{
        -:  214:  ACE_UNUSED_ARG(seq);
        -:  215:  ACE_UNUSED_ARG(size);
        -:  216:  ACE_UNUSED_ARG(padding);
    #####:  217:  find_size_ulong(size, padding);
    #####:  218:  if (seq.length() == 0) {
    #####:  219:    return;
        -:  220:  }
    #####:  221:  size += seq.length() * gen_max_marshaled_size(CORBA::Long());
        -:  222:}
        -:  223:
    #####:  224:bool operator<<(Serializer& strm, const DDS::InstanceHandleSeq& seq)
        -:  225:{
        -:  226:  ACE_UNUSED_ARG(strm);
        -:  227:  ACE_UNUSED_ARG(seq);
    #####:  228:  const CORBA::ULong length = seq.length();
    #####:  229:  if (!(strm << length)) {
    #####:  230:    return false;
        -:  231:  }
    #####:  232:  if (length == 0) {
    #####:  233:    return true;
        -:  234:  }
    #####:  235:  return strm.write_long_array(seq.get_buffer(), length);
        -:  236:}
        -:  237:
    #####:  238:bool operator>>(Serializer& strm, DDS::InstanceHandleSeq& seq)
        -:  239:{
        -:  240:  ACE_UNUSED_ARG(strm);
        -:  241:  ACE_UNUSED_ARG(seq);
        -:  242:  CORBA::ULong length;
    #####:  243:  if (!(strm >> length)) {
    #####:  244:    return false;
        -:  245:  }
    #####:  246:  seq.length(length);
    #####:  247:  if (length == 0) {
    #####:  248:    return true;
        -:  249:  }
    #####:  250:  return strm.read_long_array(seq.get_buffer(), length);
        -:  251:}
        -:  252:
        -:  253:}  }
        -:  254:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  255:
        -:  256:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  257:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  258:namespace OpenDDS { namespace DCPS {
        -:  259:
    #####:  260:bool gen_skip_over(Serializer& ser, DDS::InstanceHandleSeq*)
        -:  261:{
        -:  262:  ACE_UNUSED_ARG(ser);
        -:  263:  ACE_CDR::ULong length;
    #####:  264:  if (!(ser >> length)) return false;
    #####:  265:  return ser.skip(static_cast<ACE_UINT16>(length), 4);
        -:  266:}
        -:  267:
        -:  268:}  }
        -:  269:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  270:
        -:  271:#endif
        -:  272:
        -:  273:/* End TYPEDEF: InstanceHandleSeq */
        -:  274:
        -:  275:
        -:  276:/* Begin TYPEDEF: QosPolicyId_t */
        -:  277:
        -:  278:
        -:  279:/* End TYPEDEF: QosPolicyId_t */
        -:  280:
        -:  281:
        -:  282:/* Begin STRUCT: QosPolicyCount */
        -:  283:
        -:  284:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  285:namespace OpenDDS { namespace DCPS {
        -:  286:
    #####:  287:void gen_find_size(const DDS::QosPolicyCount& stru, size_t& size, size_t& padding)
        -:  288:{
        -:  289:  ACE_UNUSED_ARG(stru);
        -:  290:  ACE_UNUSED_ARG(size);
        -:  291:  ACE_UNUSED_ARG(padding);
    #####:  292:  if ((size + padding) % 4) {
    #####:  293:    padding += 4 - ((size + padding) % 4);
        -:  294:  }
    #####:  295:  size += gen_max_marshaled_size(stru.policy_id);
    #####:  296:  if ((size + padding) % 4) {
    #####:  297:    padding += 4 - ((size + padding) % 4);
        -:  298:  }
    #####:  299:  size += gen_max_marshaled_size(stru.count);
    #####:  300:}
        -:  301:
    #####:  302:bool operator<<(Serializer& strm, const DDS::QosPolicyCount& stru)
        -:  303:{
        -:  304:  ACE_UNUSED_ARG(strm);
        -:  305:  ACE_UNUSED_ARG(stru);
    #####:  306:  return (strm << stru.policy_id)
    #####:  307:    && (strm << stru.count);
        -:  308:}
        -:  309:
    #####:  310:bool operator>>(Serializer& strm, DDS::QosPolicyCount& stru)
        -:  311:{
        -:  312:  ACE_UNUSED_ARG(strm);
        -:  313:  ACE_UNUSED_ARG(stru);
    #####:  314:  return (strm >> stru.policy_id)
    #####:  315:    && (strm >> stru.count);
        -:  316:}
        -:  317:
        -:  318:}  }
        -:  319:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  320:
        -:  321:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  322:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  323:namespace OpenDDS { namespace DCPS {
        -:  324:
        -:  325:template<>
    #####:  326:struct MetaStructImpl<DDS::QosPolicyCount> : MetaStruct {
        -:  327:  typedef DDS::QosPolicyCount T;
        -:  328:
        -:  329:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  330:  void* allocate() const { return new T; }
        -:  331:
    #####:  332:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:  333:
    #####:  334:  size_t numDcpsKeys() const { return 0; }
        -:  335:
        -:  336:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  337:
    #####:  338:  bool isDcpsKey(const char* field) const
        -:  339:  {
        -:  340:    ACE_UNUSED_ARG(field);
    #####:  341:    return false;
        -:  342:  }
        -:  343:
    #####:  344:  Value getValue(const void* stru, const char* field) const
        -:  345:  {
    #####:  346:    const DDS::QosPolicyCount& typed = *static_cast<const DDS::QosPolicyCount*>(stru);
    #####:  347:    if (std::strcmp(field, "policy_id") == 0) {
    #####:  348:      return typed.policy_id;
        -:  349:    }
    #####:  350:    if (std::strcmp(field, "count") == 0) {
    #####:  351:      return typed.count;
        -:  352:    }
        -:  353:    ACE_UNUSED_ARG(typed);
    #####:  354:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
        -:  355:  }
        -:  356:
    #####:  357:  Value getValue(Serializer& ser, const char* field) const
        -:  358:  {
    #####:  359:    if (std::strcmp(field, "policy_id") == 0) {
        -:  360:      ACE_CDR::Long val;
    #####:  361:      if (!(ser >> val)) {
    #####:  362:        throw std::runtime_error("Field 'policy_id' could not be deserialized");
        -:  363:      }
    #####:  364:      return val;
        -:  365:    } else {
    #####:  366:      if (!ser.skip(1, 4)) {
    #####:  367:        throw std::runtime_error("Field 'policy_id' could not be skipped");
        -:  368:      }
        -:  369:    }
    #####:  370:    if (std::strcmp(field, "count") == 0) {
        -:  371:      ACE_CDR::Long val;
    #####:  372:      if (!(ser >> val)) {
    #####:  373:        throw std::runtime_error("Field 'count' could not be deserialized");
        -:  374:      }
    #####:  375:      return val;
        -:  376:    } else {
    #####:  377:      if (!ser.skip(1, 4)) {
    #####:  378:        throw std::runtime_error("Field 'count' could not be skipped");
        -:  379:      }
        -:  380:    }
    #####:  381:    if (!field[0]) {
    #####:  382:      return 0;
        -:  383:    }
    #####:  384:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::QosPolicyCount");
        -:  385:  }
        -:  386:
    #####:  387:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:  388:  {
        -:  389:    ACE_UNUSED_ARG(next);
    #####:  390:    if (std::strcmp(field, "policy_id") == 0) {
    #####:  391:      return make_field_cmp(&T::policy_id, next);
        -:  392:    }
    #####:  393:    if (std::strcmp(field, "count") == 0) {
    #####:  394:      return make_field_cmp(&T::count, next);
        -:  395:    }
    #####:  396:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
        -:  397:  }
        -:  398:
        -:  399:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  400:  const char** getFieldNames() const
        -:  401:  {
        -:  402:    static const char* names[] = {"policy_id", "count", 0};
    #####:  403:    return names;
        -:  404:  }
        -:  405:
    #####:  406:  const void* getRawField(const void* stru, const char* field) const
        -:  407:  {
    #####:  408:    if (std::strcmp(field, "policy_id") == 0) {
    #####:  409:      return &static_cast<const T*>(stru)->policy_id;
        -:  410:    }
    #####:  411:    if (std::strcmp(field, "count") == 0) {
    #####:  412:      return &static_cast<const T*>(stru)->count;
        -:  413:    }
    #####:  414:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
        -:  415:  }
        -:  416:
    #####:  417:  void assign(void* lhs, const char* field, const void* rhs,
        -:  418:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:  419:  {
        -:  420:    ACE_UNUSED_ARG(lhs);
        -:  421:    ACE_UNUSED_ARG(field);
        -:  422:    ACE_UNUSED_ARG(rhs);
        -:  423:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:  424:    ACE_UNUSED_ARG(rhsMeta);
    #####:  425:    if (std::strcmp(field, "policy_id") == 0) {
    #####:  426:      static_cast<T*>(lhs)->policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  427:      return;
        -:  428:    }
    #####:  429:    if (std::strcmp(field, "count") == 0) {
    #####:  430:      static_cast<T*>(lhs)->count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  431:      return;
        -:  432:    }
    #####:  433:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
        -:  434:  }
        -:  435:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  436:
    #####:  437:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:  438:  {
        -:  439:    ACE_UNUSED_ARG(lhs);
        -:  440:    ACE_UNUSED_ARG(field);
        -:  441:    ACE_UNUSED_ARG(rhs);
    #####:  442:    if (std::strcmp(field, "policy_id") == 0) {
    #####:  443:      return static_cast<const T*>(lhs)->policy_id == static_cast<const T*>(rhs)->policy_id;
        -:  444:    }
    #####:  445:    if (std::strcmp(field, "count") == 0) {
    #####:  446:      return static_cast<const T*>(lhs)->count == static_cast<const T*>(rhs)->count;
        -:  447:    }
    #####:  448:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::QosPolicyCount)");
        -:  449:  }
        -:  450:};
        -:  451:
        -:  452:template<>
    #####:  453:const MetaStruct& getMetaStruct<DDS::QosPolicyCount>()
        -:  454:{
    #####:  455:  static MetaStructImpl<DDS::QosPolicyCount> msi;
    #####:  456:  return msi;
        -:  457:}
        -:  458:
    #####:  459:bool gen_skip_over(Serializer& ser, DDS::QosPolicyCount*)
        -:  460:{
        -:  461:  ACE_UNUSED_ARG(ser);
    #####:  462:  MetaStructImpl<DDS::QosPolicyCount>().getValue(ser, "");
    #####:  463:  return true;
        -:  464:}
        -:  465:
        -:  466:}  }
        -:  467:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  468:
        -:  469:#endif
        -:  470:
        -:  471:/* End STRUCT: QosPolicyCount */
        -:  472:
        -:  473:
        -:  474:/* Begin TYPEDEF: QosPolicyCountSeq */
        -:  475:
        -:  476:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  477:namespace OpenDDS { namespace DCPS {
        -:  478:
    #####:  479:void gen_find_size(const DDS::QosPolicyCountSeq& seq, size_t& size, size_t& padding)
        -:  480:{
        -:  481:  ACE_UNUSED_ARG(seq);
        -:  482:  ACE_UNUSED_ARG(size);
        -:  483:  ACE_UNUSED_ARG(padding);
    #####:  484:  find_size_ulong(size, padding);
    #####:  485:  if (seq.length() == 0) {
    #####:  486:    return;
        -:  487:  }
    #####:  488:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####:  489:    gen_find_size(seq[i], size, padding);
        -:  490:  }
        -:  491:}
        -:  492:
    #####:  493:bool operator<<(Serializer& strm, const DDS::QosPolicyCountSeq& seq)
        -:  494:{
        -:  495:  ACE_UNUSED_ARG(strm);
        -:  496:  ACE_UNUSED_ARG(seq);
    #####:  497:  const CORBA::ULong length = seq.length();
    #####:  498:  if (!(strm << length)) {
    #####:  499:    return false;
        -:  500:  }
    #####:  501:  if (length == 0) {
    #####:  502:    return true;
        -:  503:  }
    #####:  504:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  505:    if (!(strm << seq[i])) {
    #####:  506:      return false;
        -:  507:    }
        -:  508:  }
    #####:  509:  return true;
        -:  510:}
        -:  511:
    #####:  512:bool operator>>(Serializer& strm, DDS::QosPolicyCountSeq& seq)
        -:  513:{
        -:  514:  ACE_UNUSED_ARG(strm);
        -:  515:  ACE_UNUSED_ARG(seq);
        -:  516:  CORBA::ULong length;
    #####:  517:  if (!(strm >> length)) {
    #####:  518:    return false;
        -:  519:  }
    #####:  520:  seq.length(length);
    #####:  521:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  522:    if (!(strm >> seq[i])) {
    #####:  523:      return false;
        -:  524:    }
        -:  525:  }
    #####:  526:  return true;
        -:  527:}
        -:  528:
        -:  529:}  }
        -:  530:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  531:
        -:  532:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  533:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  534:namespace OpenDDS { namespace DCPS {
        -:  535:
    #####:  536:bool gen_skip_over(Serializer& ser, DDS::QosPolicyCountSeq*)
        -:  537:{
        -:  538:  ACE_UNUSED_ARG(ser);
        -:  539:  ACE_CDR::ULong length;
    #####:  540:  if (!(ser >> length)) return false;
    #####:  541:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####:  542:    if (!gen_skip_over(ser, static_cast<DDS::QosPolicyCount*>(0))) return false;
        -:  543:  }
    #####:  544:  return true;
        -:  545:}
        -:  546:
        -:  547:}  }
        -:  548:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  549:
        -:  550:#endif
        -:  551:
        -:  552:/* End TYPEDEF: QosPolicyCountSeq */
        -:  553:
        -:  554:
        -:  555:/* Begin TYPEDEF: OctetSeq */
        -:  556:
        -:  557:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  558:namespace OpenDDS { namespace DCPS {
        -:  559:
       30:  560:void gen_find_size(const DDS::OctetSeq& seq, size_t& size, size_t& padding)
        -:  561:{
        -:  562:  ACE_UNUSED_ARG(seq);
        -:  563:  ACE_UNUSED_ARG(size);
        -:  564:  ACE_UNUSED_ARG(padding);
       30:  565:  find_size_ulong(size, padding);
       30:  566:  if (seq.length() == 0) {
       30:  567:    return;
        -:  568:  }
    #####:  569:  size += seq.length() * max_marshaled_size_octet();
        -:  570:}
        -:  571:
       30:  572:bool operator<<(Serializer& strm, const DDS::OctetSeq& seq)
        -:  573:{
        -:  574:  ACE_UNUSED_ARG(strm);
        -:  575:  ACE_UNUSED_ARG(seq);
       30:  576:  const CORBA::ULong length = seq.length();
       30:  577:  if (!(strm << length)) {
    #####:  578:    return false;
        -:  579:  }
       30:  580:  if (length == 0) {
       30:  581:    return true;
        -:  582:  }
    #####:  583:  return strm.write_octet_array(seq.get_buffer(), length);
        -:  584:}
        -:  585:
    #####:  586:bool operator>>(Serializer& strm, DDS::OctetSeq& seq)
        -:  587:{
        -:  588:  ACE_UNUSED_ARG(strm);
        -:  589:  ACE_UNUSED_ARG(seq);
        -:  590:  CORBA::ULong length;
    #####:  591:  if (!(strm >> length)) {
    #####:  592:    return false;
        -:  593:  }
    #####:  594:  seq.length(length);
    #####:  595:  if (length == 0) {
    #####:  596:    return true;
        -:  597:  }
    #####:  598:  return strm.read_octet_array(seq.get_buffer(), length);
        -:  599:}
        -:  600:
        -:  601:}  }
        -:  602:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  603:
        -:  604:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  605:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  606:namespace OpenDDS { namespace DCPS {
        -:  607:
    #####:  608:bool gen_skip_over(Serializer& ser, DDS::OctetSeq*)
        -:  609:{
        -:  610:  ACE_UNUSED_ARG(ser);
        -:  611:  ACE_CDR::ULong length;
    #####:  612:  if (!(ser >> length)) return false;
    #####:  613:  return ser.skip(static_cast<ACE_UINT16>(length), 1);
        -:  614:}
        -:  615:
        -:  616:}  }
        -:  617:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  618:
        -:  619:#endif
        -:  620:
        -:  621:/* End TYPEDEF: OctetSeq */
        -:  622:
        -:  623:
        -:  624:/* Begin STRUCT: Duration_t */
        -:  625:
        -:  626:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  627:namespace OpenDDS { namespace DCPS {
        -:  628:
       69:  629:void gen_find_size(const DDS::Duration_t& stru, size_t& size, size_t& padding)
        -:  630:{
        -:  631:  ACE_UNUSED_ARG(stru);
        -:  632:  ACE_UNUSED_ARG(size);
        -:  633:  ACE_UNUSED_ARG(padding);
       69:  634:  if ((size + padding) % 4) {
    #####:  635:    padding += 4 - ((size + padding) % 4);
        -:  636:  }
       69:  637:  size += gen_max_marshaled_size(stru.sec);
       69:  638:  if ((size + padding) % 4) {
    #####:  639:    padding += 4 - ((size + padding) % 4);
        -:  640:  }
       69:  641:  size += gen_max_marshaled_size(stru.nanosec);
       69:  642:}
        -:  643:
       69:  644:bool operator<<(Serializer& strm, const DDS::Duration_t& stru)
        -:  645:{
        -:  646:  ACE_UNUSED_ARG(strm);
        -:  647:  ACE_UNUSED_ARG(stru);
       69:  648:  return (strm << stru.sec)
       69:  649:    && (strm << stru.nanosec);
        -:  650:}
        -:  651:
    #####:  652:bool operator>>(Serializer& strm, DDS::Duration_t& stru)
        -:  653:{
        -:  654:  ACE_UNUSED_ARG(strm);
        -:  655:  ACE_UNUSED_ARG(stru);
    #####:  656:  return (strm >> stru.sec)
    #####:  657:    && (strm >> stru.nanosec);
        -:  658:}
        -:  659:
        -:  660:}  }
        -:  661:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  662:
        -:  663:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  664:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  665:namespace OpenDDS { namespace DCPS {
        -:  666:
        -:  667:template<>
    #####:  668:struct MetaStructImpl<DDS::Duration_t> : MetaStruct {
        -:  669:  typedef DDS::Duration_t T;
        -:  670:
        -:  671:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  672:  void* allocate() const { return new T; }
        -:  673:
    #####:  674:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:  675:
    #####:  676:  size_t numDcpsKeys() const { return 0; }
        -:  677:
        -:  678:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  679:
    #####:  680:  bool isDcpsKey(const char* field) const
        -:  681:  {
        -:  682:    ACE_UNUSED_ARG(field);
    #####:  683:    return false;
        -:  684:  }
        -:  685:
    #####:  686:  Value getValue(const void* stru, const char* field) const
        -:  687:  {
    #####:  688:    const DDS::Duration_t& typed = *static_cast<const DDS::Duration_t*>(stru);
    #####:  689:    if (std::strcmp(field, "sec") == 0) {
    #####:  690:      return typed.sec;
        -:  691:    }
    #####:  692:    if (std::strcmp(field, "nanosec") == 0) {
    #####:  693:      return typed.nanosec;
        -:  694:    }
        -:  695:    ACE_UNUSED_ARG(typed);
    #####:  696:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
        -:  697:  }
        -:  698:
    #####:  699:  Value getValue(Serializer& ser, const char* field) const
        -:  700:  {
    #####:  701:    if (std::strcmp(field, "sec") == 0) {
        -:  702:      ACE_CDR::Long val;
    #####:  703:      if (!(ser >> val)) {
    #####:  704:        throw std::runtime_error("Field 'sec' could not be deserialized");
        -:  705:      }
    #####:  706:      return val;
        -:  707:    } else {
    #####:  708:      if (!ser.skip(1, 4)) {
    #####:  709:        throw std::runtime_error("Field 'sec' could not be skipped");
        -:  710:      }
        -:  711:    }
    #####:  712:    if (std::strcmp(field, "nanosec") == 0) {
        -:  713:      ACE_CDR::ULong val;
    #####:  714:      if (!(ser >> val)) {
    #####:  715:        throw std::runtime_error("Field 'nanosec' could not be deserialized");
        -:  716:      }
    #####:  717:      return val;
        -:  718:    } else {
    #####:  719:      if (!ser.skip(1, 4)) {
    #####:  720:        throw std::runtime_error("Field 'nanosec' could not be skipped");
        -:  721:      }
        -:  722:    }
    #####:  723:    if (!field[0]) {
    #####:  724:      return 0;
        -:  725:    }
    #####:  726:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::Duration_t");
        -:  727:  }
        -:  728:
    #####:  729:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:  730:  {
        -:  731:    ACE_UNUSED_ARG(next);
    #####:  732:    if (std::strcmp(field, "sec") == 0) {
    #####:  733:      return make_field_cmp(&T::sec, next);
        -:  734:    }
    #####:  735:    if (std::strcmp(field, "nanosec") == 0) {
    #####:  736:      return make_field_cmp(&T::nanosec, next);
        -:  737:    }
    #####:  738:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
        -:  739:  }
        -:  740:
        -:  741:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  742:  const char** getFieldNames() const
        -:  743:  {
        -:  744:    static const char* names[] = {"sec", "nanosec", 0};
    #####:  745:    return names;
        -:  746:  }
        -:  747:
    #####:  748:  const void* getRawField(const void* stru, const char* field) const
        -:  749:  {
    #####:  750:    if (std::strcmp(field, "sec") == 0) {
    #####:  751:      return &static_cast<const T*>(stru)->sec;
        -:  752:    }
    #####:  753:    if (std::strcmp(field, "nanosec") == 0) {
    #####:  754:      return &static_cast<const T*>(stru)->nanosec;
        -:  755:    }
    #####:  756:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
        -:  757:  }
        -:  758:
    #####:  759:  void assign(void* lhs, const char* field, const void* rhs,
        -:  760:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:  761:  {
        -:  762:    ACE_UNUSED_ARG(lhs);
        -:  763:    ACE_UNUSED_ARG(field);
        -:  764:    ACE_UNUSED_ARG(rhs);
        -:  765:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:  766:    ACE_UNUSED_ARG(rhsMeta);
    #####:  767:    if (std::strcmp(field, "sec") == 0) {
    #####:  768:      static_cast<T*>(lhs)->sec = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  769:      return;
        -:  770:    }
    #####:  771:    if (std::strcmp(field, "nanosec") == 0) {
    #####:  772:      static_cast<T*>(lhs)->nanosec = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  773:      return;
        -:  774:    }
    #####:  775:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
        -:  776:  }
        -:  777:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  778:
    #####:  779:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:  780:  {
        -:  781:    ACE_UNUSED_ARG(lhs);
        -:  782:    ACE_UNUSED_ARG(field);
        -:  783:    ACE_UNUSED_ARG(rhs);
    #####:  784:    if (std::strcmp(field, "sec") == 0) {
    #####:  785:      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
        -:  786:    }
    #####:  787:    if (std::strcmp(field, "nanosec") == 0) {
    #####:  788:      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
        -:  789:    }
    #####:  790:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Duration_t)");
        -:  791:  }
        -:  792:};
        -:  793:
        -:  794:template<>
    #####:  795:const MetaStruct& getMetaStruct<DDS::Duration_t>()
        -:  796:{
    #####:  797:  static MetaStructImpl<DDS::Duration_t> msi;
    #####:  798:  return msi;
        -:  799:}
        -:  800:
    #####:  801:bool gen_skip_over(Serializer& ser, DDS::Duration_t*)
        -:  802:{
        -:  803:  ACE_UNUSED_ARG(ser);
    #####:  804:  MetaStructImpl<DDS::Duration_t>().getValue(ser, "");
    #####:  805:  return true;
        -:  806:}
        -:  807:
        -:  808:}  }
        -:  809:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  810:
        -:  811:#endif
        -:  812:
        -:  813:/* End STRUCT: Duration_t */
        -:  814:
        -:  815:
        -:  816:/* Begin CONST: DURATION_INFINITE_SEC */
        -:  817:
        -:  818:
        -:  819:/* End CONST: DURATION_INFINITE_SEC */
        -:  820:
        -:  821:
        -:  822:/* Begin CONST: DURATION_INFINITE_NSEC */
        -:  823:
        -:  824:
        -:  825:/* End CONST: DURATION_INFINITE_NSEC */
        -:  826:
        -:  827:
        -:  828:/* Begin CONST: DURATION_ZERO_SEC */
        -:  829:
        -:  830:
        -:  831:/* End CONST: DURATION_ZERO_SEC */
        -:  832:
        -:  833:
        -:  834:/* Begin CONST: DURATION_ZERO_NSEC */
        -:  835:
        -:  836:
        -:  837:/* End CONST: DURATION_ZERO_NSEC */
        -:  838:
        -:  839:
        -:  840:/* Begin STRUCT: Property_t */
        -:  841:
        -:  842:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  843:namespace OpenDDS { namespace DCPS {
        -:  844:
    #####:  845:void gen_find_size(const DDS::Property_t& stru, size_t& size, size_t& padding)
        -:  846:{
        -:  847:  ACE_UNUSED_ARG(stru);
        -:  848:  ACE_UNUSED_ARG(size);
        -:  849:  ACE_UNUSED_ARG(padding);
    #####:  850:  if (stru.propagate) {
    #####:  851:    find_size_ulong(size, padding);
    #####:  852:    size += ACE_OS::strlen(stru.name.in()) + 1;
    #####:  853:    find_size_ulong(size, padding);
    #####:  854:    size += ACE_OS::strlen(stru.value.in()) + 1;
        -:  855:  }
    #####:  856:}
        -:  857:
    #####:  858:bool operator<<(Serializer& strm, const DDS::Property_t& stru)
        -:  859:{
        -:  860:  ACE_UNUSED_ARG(strm);
        -:  861:  ACE_UNUSED_ARG(stru);
    #####:  862:  if (stru.propagate) {
    #####:  863:    return (strm << stru.name.in()) && (strm << stru.value.in());
        -:  864:  }
    #####:  865:  return true;
        -:  866:}
        -:  867:
    #####:  868:bool operator>>(Serializer& strm, DDS::Property_t& stru)
        -:  869:{
        -:  870:  ACE_UNUSED_ARG(strm);
        -:  871:  ACE_UNUSED_ARG(stru);
    #####:  872:  stru.propagate = true;
    #####:  873:  return (strm >> stru.name.out()) && (strm >> stru.value.out());
        -:  874:}
        -:  875:
        -:  876:}  }
        -:  877:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  878:
        -:  879:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  880:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  881:namespace OpenDDS { namespace DCPS {
        -:  882:
        -:  883:template<>
    #####:  884:struct MetaStructImpl<DDS::Property_t> : MetaStruct {
        -:  885:  typedef DDS::Property_t T;
        -:  886:
        -:  887:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  888:  void* allocate() const { return new T; }
        -:  889:
    #####:  890:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:  891:
    #####:  892:  size_t numDcpsKeys() const { return 0; }
        -:  893:
        -:  894:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  895:
    #####:  896:  bool isDcpsKey(const char* field) const
        -:  897:  {
        -:  898:    ACE_UNUSED_ARG(field);
    #####:  899:    return false;
        -:  900:  }
        -:  901:
    #####:  902:  Value getValue(const void* stru, const char* field) const
        -:  903:  {
    #####:  904:    const DDS::Property_t& typed = *static_cast<const DDS::Property_t*>(stru);
    #####:  905:    if (std::strcmp(field, "name") == 0) {
    #####:  906:      return typed.name.in();
        -:  907:    }
    #####:  908:    if (std::strcmp(field, "value") == 0) {
    #####:  909:      return typed.value.in();
        -:  910:    }
    #####:  911:    if (std::strcmp(field, "propagate") == 0) {
    #####:  912:      return typed.propagate;
        -:  913:    }
        -:  914:    ACE_UNUSED_ARG(typed);
    #####:  915:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Property_t)");
        -:  916:  }
        -:  917:
    #####:  918:  Value getValue(Serializer& ser, const char* field) const
        -:  919:  {
    #####:  920:    if (std::strcmp(field, "name") == 0) {
    #####:  921:      TAO::String_Manager val;
    #####:  922:      if (!(ser >> val.out())) {
    #####:  923:        throw std::runtime_error("Field 'name' could not be deserialized");
        -:  924:      }
    #####:  925:      return val;
        -:  926:    } else {
        -:  927:      ACE_CDR::ULong len;
    #####:  928:      if (!(ser >> len)) {
    #####:  929:        throw std::runtime_error("String 'name' length could not be deserialized");
        -:  930:      }
    #####:  931:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####:  932:        throw std::runtime_error("String 'name' contents could not be skipped");
        -:  933:      }
        -:  934:    }
    #####:  935:    if (std::strcmp(field, "value") == 0) {
    #####:  936:      TAO::String_Manager val;
    #####:  937:      if (!(ser >> val.out())) {
    #####:  938:        throw std::runtime_error("Field 'value' could not be deserialized");
        -:  939:      }
    #####:  940:      return val;
        -:  941:    } else {
        -:  942:      ACE_CDR::ULong len;
    #####:  943:      if (!(ser >> len)) {
    #####:  944:        throw std::runtime_error("String 'value' length could not be deserialized");
        -:  945:      }
    #####:  946:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####:  947:        throw std::runtime_error("String 'value' contents could not be skipped");
        -:  948:      }
        -:  949:    }
    #####:  950:    if (std::strcmp(field, "propagate") == 0) {
        -:  951:      ACE_CDR::Boolean val;
    #####:  952:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####:  953:        throw std::runtime_error("Field 'propagate' could not be deserialized");
        -:  954:      }
    #####:  955:      return val;
        -:  956:    } else {
    #####:  957:      if (!ser.skip(1, 1)) {
    #####:  958:        throw std::runtime_error("Field 'propagate' could not be skipped");
        -:  959:      }
        -:  960:    }
    #####:  961:    if (!field[0]) {
    #####:  962:      return 0;
        -:  963:    }
    #####:  964:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::Property_t");
        -:  965:  }
        -:  966:
    #####:  967:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:  968:  {
        -:  969:    ACE_UNUSED_ARG(next);
    #####:  970:    if (std::strcmp(field, "name") == 0) {
    #####:  971:      return make_field_cmp(&T::name, next);
        -:  972:    }
    #####:  973:    if (std::strcmp(field, "value") == 0) {
    #####:  974:      return make_field_cmp(&T::value, next);
        -:  975:    }
    #####:  976:    if (std::strcmp(field, "propagate") == 0) {
    #####:  977:      return make_field_cmp(&T::propagate, next);
        -:  978:    }
    #####:  979:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Property_t)");
        -:  980:  }
        -:  981:
        -:  982:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  983:  const char** getFieldNames() const
        -:  984:  {
        -:  985:    static const char* names[] = {"name", "value", "propagate", 0};
    #####:  986:    return names;
        -:  987:  }
        -:  988:
    #####:  989:  const void* getRawField(const void* stru, const char* field) const
        -:  990:  {
    #####:  991:    if (std::strcmp(field, "name") == 0) {
    #####:  992:      return &static_cast<const T*>(stru)->name;
        -:  993:    }
    #####:  994:    if (std::strcmp(field, "value") == 0) {
    #####:  995:      return &static_cast<const T*>(stru)->value;
        -:  996:    }
    #####:  997:    if (std::strcmp(field, "propagate") == 0) {
    #####:  998:      return &static_cast<const T*>(stru)->propagate;
        -:  999:    }
    #####: 1000:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Property_t)");
        -: 1001:  }
        -: 1002:
    #####: 1003:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1004:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1005:  {
        -: 1006:    ACE_UNUSED_ARG(lhs);
        -: 1007:    ACE_UNUSED_ARG(field);
        -: 1008:    ACE_UNUSED_ARG(rhs);
        -: 1009:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1010:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1011:    if (std::strcmp(field, "name") == 0) {
    #####: 1012:      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1013:      return;
        -: 1014:    }
    #####: 1015:    if (std::strcmp(field, "value") == 0) {
    #####: 1016:      static_cast<T*>(lhs)->value = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1017:      return;
        -: 1018:    }
    #####: 1019:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1020:      static_cast<T*>(lhs)->propagate = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1021:      return;
        -: 1022:    }
    #####: 1023:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Property_t)");
        -: 1024:  }
        -: 1025:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1026:
    #####: 1027:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1028:  {
        -: 1029:    ACE_UNUSED_ARG(lhs);
        -: 1030:    ACE_UNUSED_ARG(field);
        -: 1031:    ACE_UNUSED_ARG(rhs);
    #####: 1032:    if (std::strcmp(field, "name") == 0) {
    #####: 1033:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
        -: 1034:    }
    #####: 1035:    if (std::strcmp(field, "value") == 0) {
    #####: 1036:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->value.in(), static_cast<const T*>(rhs)->value.in());
        -: 1037:    }
    #####: 1038:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1039:      return static_cast<const T*>(lhs)->propagate == static_cast<const T*>(rhs)->propagate;
        -: 1040:    }
    #####: 1041:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Property_t)");
        -: 1042:  }
        -: 1043:};
        -: 1044:
        -: 1045:template<>
    #####: 1046:const MetaStruct& getMetaStruct<DDS::Property_t>()
        -: 1047:{
    #####: 1048:  static MetaStructImpl<DDS::Property_t> msi;
    #####: 1049:  return msi;
        -: 1050:}
        -: 1051:
    #####: 1052:bool gen_skip_over(Serializer& ser, DDS::Property_t*)
        -: 1053:{
        -: 1054:  ACE_UNUSED_ARG(ser);
    #####: 1055:  MetaStructImpl<DDS::Property_t>().getValue(ser, "");
    #####: 1056:  return true;
        -: 1057:}
        -: 1058:
        -: 1059:}  }
        -: 1060:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1061:
        -: 1062:#endif
        -: 1063:
        -: 1064:/* End STRUCT: Property_t */
        -: 1065:
        -: 1066:
        -: 1067:/* Begin TYPEDEF: PropertySeq */
        -: 1068:
        -: 1069:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1070:namespace OpenDDS { namespace DCPS {
        -: 1071:
    #####: 1072:void gen_find_size(const DDS::PropertySeq& seq, size_t& size, size_t& padding)
        -: 1073:{
        -: 1074:  ACE_UNUSED_ARG(seq);
        -: 1075:  ACE_UNUSED_ARG(size);
        -: 1076:  ACE_UNUSED_ARG(padding);
    #####: 1077:  find_size_ulong(size, padding);
    #####: 1078:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1079:    gen_find_size(seq[i], size, padding);
        -: 1080:  }
    #####: 1081:}
        -: 1082:
    #####: 1083:bool operator<<(Serializer& strm, const DDS::PropertySeq& seq)
        -: 1084:{
        -: 1085:  ACE_UNUSED_ARG(strm);
        -: 1086:  ACE_UNUSED_ARG(seq);
    #####: 1087:  CORBA::ULong serlen = 0;
    #####: 1088:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1089:    if (seq[i].propagate) {
    #####: 1090:      ++serlen;
        -: 1091:    }
        -: 1092:  }
    #####: 1093:  if (!(strm << serlen)) {
    #####: 1094:    return false;
        -: 1095:  }
    #####: 1096:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1097:    if (!(strm << seq[i])) {
    #####: 1098:      return false;
        -: 1099:    }
        -: 1100:  }
    #####: 1101:  return true;
        -: 1102:}
        -: 1103:
    #####: 1104:bool operator>>(Serializer& strm, DDS::PropertySeq& seq)
        -: 1105:{
        -: 1106:  ACE_UNUSED_ARG(strm);
        -: 1107:  ACE_UNUSED_ARG(seq);
        -: 1108:  CORBA::ULong length;
    #####: 1109:  if (!(strm >> length)) {
    #####: 1110:    return false;
        -: 1111:  }
    #####: 1112:  seq.length(length);
    #####: 1113:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 1114:    if (!(strm >> seq[i])) {
    #####: 1115:      return false;
        -: 1116:    }
        -: 1117:  }
    #####: 1118:  return true;
        -: 1119:}
        -: 1120:
        -: 1121:}  }
        -: 1122:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1123:
        -: 1124:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1125:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1126:namespace OpenDDS { namespace DCPS {
        -: 1127:
    #####: 1128:bool gen_skip_over(Serializer& ser, DDS::PropertySeq*)
        -: 1129:{
        -: 1130:  ACE_UNUSED_ARG(ser);
        -: 1131:  ACE_CDR::ULong length;
    #####: 1132:  if (!(ser >> length)) return false;
    #####: 1133:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####: 1134:    if (!gen_skip_over(ser, static_cast<DDS::Property_t*>(0))) return false;
        -: 1135:  }
    #####: 1136:  return true;
        -: 1137:}
        -: 1138:
        -: 1139:}  }
        -: 1140:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1141:
        -: 1142:#endif
        -: 1143:
        -: 1144:/* End TYPEDEF: PropertySeq */
        -: 1145:
        -: 1146:
        -: 1147:/* Begin STRUCT: BinaryProperty_t */
        -: 1148:
        -: 1149:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1150:namespace OpenDDS { namespace DCPS {
        -: 1151:
    #####: 1152:void gen_find_size(const DDS::BinaryProperty_t& stru, size_t& size, size_t& padding)
        -: 1153:{
        -: 1154:  ACE_UNUSED_ARG(stru);
        -: 1155:  ACE_UNUSED_ARG(size);
        -: 1156:  ACE_UNUSED_ARG(padding);
    #####: 1157:  if (stru.propagate) {
    #####: 1158:    find_size_ulong(size, padding);
    #####: 1159:    size += ACE_OS::strlen(stru.name.in()) + 1;
    #####: 1160:    gen_find_size(stru.value, size, padding);
        -: 1161:  }
    #####: 1162:}
        -: 1163:
    #####: 1164:bool operator<<(Serializer& strm, const DDS::BinaryProperty_t& stru)
        -: 1165:{
        -: 1166:  ACE_UNUSED_ARG(strm);
        -: 1167:  ACE_UNUSED_ARG(stru);
    #####: 1168:  if (stru.propagate) {
    #####: 1169:    return (strm << stru.name.in()) && (strm << stru.value);
        -: 1170:  }
    #####: 1171:  return true;
        -: 1172:}
        -: 1173:
    #####: 1174:bool operator>>(Serializer& strm, DDS::BinaryProperty_t& stru)
        -: 1175:{
        -: 1176:  ACE_UNUSED_ARG(strm);
        -: 1177:  ACE_UNUSED_ARG(stru);
    #####: 1178:  stru.propagate = true;
    #####: 1179:  return (strm >> stru.name.out()) && (strm >> stru.value);
        -: 1180:}
        -: 1181:
        -: 1182:}  }
        -: 1183:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1184:
        -: 1185:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1186:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1187:namespace OpenDDS { namespace DCPS {
        -: 1188:
        -: 1189:template<>
    #####: 1190:struct MetaStructImpl<DDS::BinaryProperty_t> : MetaStruct {
        -: 1191:  typedef DDS::BinaryProperty_t T;
        -: 1192:
        -: 1193:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1194:  void* allocate() const { return new T; }
        -: 1195:
    #####: 1196:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1197:
    #####: 1198:  size_t numDcpsKeys() const { return 0; }
        -: 1199:
        -: 1200:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1201:
    #####: 1202:  bool isDcpsKey(const char* field) const
        -: 1203:  {
        -: 1204:    ACE_UNUSED_ARG(field);
    #####: 1205:    return false;
        -: 1206:  }
        -: 1207:
    #####: 1208:  Value getValue(const void* stru, const char* field) const
        -: 1209:  {
    #####: 1210:    const DDS::BinaryProperty_t& typed = *static_cast<const DDS::BinaryProperty_t*>(stru);
    #####: 1211:    if (std::strcmp(field, "name") == 0) {
    #####: 1212:      return typed.name.in();
        -: 1213:    }
    #####: 1214:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1215:      return typed.propagate;
        -: 1216:    }
        -: 1217:    ACE_UNUSED_ARG(typed);
    #####: 1218:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BinaryProperty_t)");
        -: 1219:  }
        -: 1220:
    #####: 1221:  Value getValue(Serializer& ser, const char* field) const
        -: 1222:  {
    #####: 1223:    if (std::strcmp(field, "name") == 0) {
    #####: 1224:      TAO::String_Manager val;
    #####: 1225:      if (!(ser >> val.out())) {
    #####: 1226:        throw std::runtime_error("Field 'name' could not be deserialized");
        -: 1227:      }
    #####: 1228:      return val;
        -: 1229:    } else {
        -: 1230:      ACE_CDR::ULong len;
    #####: 1231:      if (!(ser >> len)) {
    #####: 1232:        throw std::runtime_error("String 'name' length could not be deserialized");
        -: 1233:      }
    #####: 1234:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 1235:        throw std::runtime_error("String 'name' contents could not be skipped");
        -: 1236:      }
        -: 1237:    }
    #####: 1238:    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) {
    #####: 1239:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1240:    }
    #####: 1241:    if (std::strcmp(field, "propagate") == 0) {
        -: 1242:      ACE_CDR::Boolean val;
    #####: 1243:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 1244:        throw std::runtime_error("Field 'propagate' could not be deserialized");
        -: 1245:      }
    #####: 1246:      return val;
        -: 1247:    } else {
    #####: 1248:      if (!ser.skip(1, 1)) {
    #####: 1249:        throw std::runtime_error("Field 'propagate' could not be skipped");
        -: 1250:      }
        -: 1251:    }
    #####: 1252:    if (!field[0]) {
    #####: 1253:      return 0;
        -: 1254:    }
    #####: 1255:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::BinaryProperty_t");
        -: 1256:  }
        -: 1257:
    #####: 1258:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1259:  {
        -: 1260:    ACE_UNUSED_ARG(next);
    #####: 1261:    if (std::strcmp(field, "name") == 0) {
    #####: 1262:      return make_field_cmp(&T::name, next);
        -: 1263:    }
    #####: 1264:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1265:      return make_field_cmp(&T::propagate, next);
        -: 1266:    }
    #####: 1267:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BinaryProperty_t)");
        -: 1268:  }
        -: 1269:
        -: 1270:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1271:  const char** getFieldNames() const
        -: 1272:  {
        -: 1273:    static const char* names[] = {"name", "value", "propagate", 0};
    #####: 1274:    return names;
        -: 1275:  }
        -: 1276:
    #####: 1277:  const void* getRawField(const void* stru, const char* field) const
        -: 1278:  {
    #####: 1279:    if (std::strcmp(field, "name") == 0) {
    #####: 1280:      return &static_cast<const T*>(stru)->name;
        -: 1281:    }
    #####: 1282:    if (std::strcmp(field, "value") == 0) {
    #####: 1283:      return &static_cast<const T*>(stru)->value;
        -: 1284:    }
    #####: 1285:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1286:      return &static_cast<const T*>(stru)->propagate;
        -: 1287:    }
    #####: 1288:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BinaryProperty_t)");
        -: 1289:  }
        -: 1290:
    #####: 1291:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1292:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1293:  {
        -: 1294:    ACE_UNUSED_ARG(lhs);
        -: 1295:    ACE_UNUSED_ARG(field);
        -: 1296:    ACE_UNUSED_ARG(rhs);
        -: 1297:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1298:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1299:    if (std::strcmp(field, "name") == 0) {
    #####: 1300:      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1301:      return;
        -: 1302:    }
    #####: 1303:    if (std::strcmp(field, "value") == 0) {
    #####: 1304:      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1305:      return;
        -: 1306:    }
    #####: 1307:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1308:      static_cast<T*>(lhs)->propagate = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1309:      return;
        -: 1310:    }
    #####: 1311:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BinaryProperty_t)");
        -: 1312:  }
        -: 1313:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1314:
    #####: 1315:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1316:  {
        -: 1317:    ACE_UNUSED_ARG(lhs);
        -: 1318:    ACE_UNUSED_ARG(field);
        -: 1319:    ACE_UNUSED_ARG(rhs);
    #####: 1320:    if (std::strcmp(field, "name") == 0) {
    #####: 1321:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
        -: 1322:    }
    #####: 1323:    if (std::strcmp(field, "propagate") == 0) {
    #####: 1324:      return static_cast<const T*>(lhs)->propagate == static_cast<const T*>(rhs)->propagate;
        -: 1325:    }
    #####: 1326:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BinaryProperty_t)");
        -: 1327:  }
        -: 1328:};
        -: 1329:
        -: 1330:template<>
    #####: 1331:const MetaStruct& getMetaStruct<DDS::BinaryProperty_t>()
        -: 1332:{
    #####: 1333:  static MetaStructImpl<DDS::BinaryProperty_t> msi;
    #####: 1334:  return msi;
        -: 1335:}
        -: 1336:
    #####: 1337:bool gen_skip_over(Serializer& ser, DDS::BinaryProperty_t*)
        -: 1338:{
        -: 1339:  ACE_UNUSED_ARG(ser);
    #####: 1340:  MetaStructImpl<DDS::BinaryProperty_t>().getValue(ser, "");
    #####: 1341:  return true;
        -: 1342:}
        -: 1343:
        -: 1344:}  }
        -: 1345:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1346:
        -: 1347:#endif
        -: 1348:
        -: 1349:/* End STRUCT: BinaryProperty_t */
        -: 1350:
        -: 1351:
        -: 1352:/* Begin TYPEDEF: BinaryPropertySeq */
        -: 1353:
        -: 1354:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1355:namespace OpenDDS { namespace DCPS {
        -: 1356:
    #####: 1357:void gen_find_size(const DDS::BinaryPropertySeq& seq, size_t& size, size_t& padding)
        -: 1358:{
        -: 1359:  ACE_UNUSED_ARG(seq);
        -: 1360:  ACE_UNUSED_ARG(size);
        -: 1361:  ACE_UNUSED_ARG(padding);
    #####: 1362:  find_size_ulong(size, padding);
    #####: 1363:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1364:    gen_find_size(seq[i], size, padding);
        -: 1365:  }
    #####: 1366:}
        -: 1367:
    #####: 1368:bool operator<<(Serializer& strm, const DDS::BinaryPropertySeq& seq)
        -: 1369:{
        -: 1370:  ACE_UNUSED_ARG(strm);
        -: 1371:  ACE_UNUSED_ARG(seq);
    #####: 1372:  CORBA::ULong serlen = 0;
    #####: 1373:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1374:    if (seq[i].propagate) {
    #####: 1375:      ++serlen;
        -: 1376:    }
        -: 1377:  }
    #####: 1378:  if (!(strm << serlen)) {
    #####: 1379:    return false;
        -: 1380:  }
    #####: 1381:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1382:    if (!(strm << seq[i])) {
    #####: 1383:      return false;
        -: 1384:    }
        -: 1385:  }
    #####: 1386:  return true;
        -: 1387:}
        -: 1388:
    #####: 1389:bool operator>>(Serializer& strm, DDS::BinaryPropertySeq& seq)
        -: 1390:{
        -: 1391:  ACE_UNUSED_ARG(strm);
        -: 1392:  ACE_UNUSED_ARG(seq);
        -: 1393:  CORBA::ULong length;
    #####: 1394:  if (!(strm >> length)) {
    #####: 1395:    return false;
        -: 1396:  }
    #####: 1397:  seq.length(length);
    #####: 1398:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 1399:    if (!(strm >> seq[i])) {
    #####: 1400:      return false;
        -: 1401:    }
        -: 1402:  }
    #####: 1403:  return true;
        -: 1404:}
        -: 1405:
        -: 1406:}  }
        -: 1407:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1408:
        -: 1409:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1410:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1411:namespace OpenDDS { namespace DCPS {
        -: 1412:
    #####: 1413:bool gen_skip_over(Serializer& ser, DDS::BinaryPropertySeq*)
        -: 1414:{
        -: 1415:  ACE_UNUSED_ARG(ser);
        -: 1416:  ACE_CDR::ULong length;
    #####: 1417:  if (!(ser >> length)) return false;
    #####: 1418:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####: 1419:    if (!gen_skip_over(ser, static_cast<DDS::BinaryProperty_t*>(0))) return false;
        -: 1420:  }
    #####: 1421:  return true;
        -: 1422:}
        -: 1423:
        -: 1424:}  }
        -: 1425:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1426:
        -: 1427:#endif
        -: 1428:
        -: 1429:/* End TYPEDEF: BinaryPropertySeq */
        -: 1430:
        -: 1431:
        -: 1432:/* Begin STRUCT: PropertyQosPolicy */
        -: 1433:
        -: 1434:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1435:namespace OpenDDS { namespace DCPS {
        -: 1436:
    #####: 1437:void gen_find_size(const DDS::PropertyQosPolicy& stru, size_t& size, size_t& padding)
        -: 1438:{
        -: 1439:  ACE_UNUSED_ARG(stru);
        -: 1440:  ACE_UNUSED_ARG(size);
        -: 1441:  ACE_UNUSED_ARG(padding);
    #####: 1442:  gen_find_size(stru.value, size, padding);
    #####: 1443:  gen_find_size(stru.binary_value, size, padding);
    #####: 1444:}
        -: 1445:
    #####: 1446:bool operator<<(Serializer& strm, const DDS::PropertyQosPolicy& stru)
        -: 1447:{
        -: 1448:  ACE_UNUSED_ARG(strm);
        -: 1449:  ACE_UNUSED_ARG(stru);
    #####: 1450:  return (strm << stru.value)
    #####: 1451:    && (strm << stru.binary_value);
        -: 1452:}
        -: 1453:
    #####: 1454:bool operator>>(Serializer& strm, DDS::PropertyQosPolicy& stru)
        -: 1455:{
        -: 1456:  ACE_UNUSED_ARG(strm);
        -: 1457:  ACE_UNUSED_ARG(stru);
    #####: 1458:  if (!(strm >> stru.value)) {
    #####: 1459:    return false;
        -: 1460:  }
    #####: 1461:  if (!strm.length() || !strm.skip(0, 4) || !strm.length()) {
    #####: 1462:    return true; // optional member missing
        -: 1463:  }
    #####: 1464:  return strm >> stru.binary_value;
        -: 1465:}
        -: 1466:
        -: 1467:}  }
        -: 1468:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1469:
        -: 1470:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1471:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1472:namespace OpenDDS { namespace DCPS {
        -: 1473:
        -: 1474:template<>
    #####: 1475:struct MetaStructImpl<DDS::PropertyQosPolicy> : MetaStruct {
        -: 1476:  typedef DDS::PropertyQosPolicy T;
        -: 1477:
        -: 1478:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1479:  void* allocate() const { return new T; }
        -: 1480:
    #####: 1481:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1482:
    #####: 1483:  size_t numDcpsKeys() const { return 0; }
        -: 1484:
        -: 1485:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1486:
    #####: 1487:  bool isDcpsKey(const char* field) const
        -: 1488:  {
        -: 1489:    ACE_UNUSED_ARG(field);
    #####: 1490:    return false;
        -: 1491:  }
        -: 1492:
    #####: 1493:  Value getValue(const void* stru, const char* field) const
        -: 1494:  {
    #####: 1495:    const DDS::PropertyQosPolicy& typed = *static_cast<const DDS::PropertyQosPolicy*>(stru);
        -: 1496:    ACE_UNUSED_ARG(typed);
    #####: 1497:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PropertyQosPolicy)");
        -: 1498:  }
        -: 1499:
    #####: 1500:  Value getValue(Serializer& ser, const char* field) const
        -: 1501:  {
    #####: 1502:    if (!gen_skip_over(ser, static_cast<DDS::PropertySeq*>(0))) {
    #####: 1503:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1504:    }
    #####: 1505:    if (!gen_skip_over(ser, static_cast<DDS::BinaryPropertySeq*>(0))) {
    #####: 1506:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1507:    }
    #####: 1508:    if (!field[0]) {
    #####: 1509:      return 0;
        -: 1510:    }
    #####: 1511:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PropertyQosPolicy");
        -: 1512:  }
        -: 1513:
    #####: 1514:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1515:  {
        -: 1516:    ACE_UNUSED_ARG(next);
    #####: 1517:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PropertyQosPolicy)");
        -: 1518:  }
        -: 1519:
        -: 1520:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1521:  const char** getFieldNames() const
        -: 1522:  {
        -: 1523:    static const char* names[] = {"value", "binary_value", 0};
    #####: 1524:    return names;
        -: 1525:  }
        -: 1526:
    #####: 1527:  const void* getRawField(const void* stru, const char* field) const
        -: 1528:  {
    #####: 1529:    if (std::strcmp(field, "value") == 0) {
    #####: 1530:      return &static_cast<const T*>(stru)->value;
        -: 1531:    }
    #####: 1532:    if (std::strcmp(field, "binary_value") == 0) {
    #####: 1533:      return &static_cast<const T*>(stru)->binary_value;
        -: 1534:    }
    #####: 1535:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PropertyQosPolicy)");
        -: 1536:  }
        -: 1537:
    #####: 1538:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1539:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1540:  {
        -: 1541:    ACE_UNUSED_ARG(lhs);
        -: 1542:    ACE_UNUSED_ARG(field);
        -: 1543:    ACE_UNUSED_ARG(rhs);
        -: 1544:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1545:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1546:    if (std::strcmp(field, "value") == 0) {
    #####: 1547:      static_cast<T*>(lhs)->value = *static_cast<const DDS::PropertySeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1548:      return;
        -: 1549:    }
    #####: 1550:    if (std::strcmp(field, "binary_value") == 0) {
    #####: 1551:      static_cast<T*>(lhs)->binary_value = *static_cast<const DDS::BinaryPropertySeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1552:      return;
        -: 1553:    }
    #####: 1554:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PropertyQosPolicy)");
        -: 1555:  }
        -: 1556:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1557:
    #####: 1558:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1559:  {
        -: 1560:    ACE_UNUSED_ARG(lhs);
        -: 1561:    ACE_UNUSED_ARG(field);
        -: 1562:    ACE_UNUSED_ARG(rhs);
    #####: 1563:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PropertyQosPolicy)");
        -: 1564:  }
        -: 1565:};
        -: 1566:
        -: 1567:template<>
    #####: 1568:const MetaStruct& getMetaStruct<DDS::PropertyQosPolicy>()
        -: 1569:{
    #####: 1570:  static MetaStructImpl<DDS::PropertyQosPolicy> msi;
    #####: 1571:  return msi;
        -: 1572:}
        -: 1573:
    #####: 1574:bool gen_skip_over(Serializer& ser, DDS::PropertyQosPolicy*)
        -: 1575:{
        -: 1576:  ACE_UNUSED_ARG(ser);
    #####: 1577:  MetaStructImpl<DDS::PropertyQosPolicy>().getValue(ser, "");
    #####: 1578:  return true;
        -: 1579:}
        -: 1580:
        -: 1581:}  }
        -: 1582:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1583:
        -: 1584:#endif
        -: 1585:
        -: 1586:/* End STRUCT: PropertyQosPolicy */
        -: 1587:
        -: 1588:
        -: 1589:/* Begin STRUCT: UserDataQosPolicy */
        -: 1590:
        -: 1591:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1592:namespace OpenDDS { namespace DCPS {
        -: 1593:
       12: 1594:void gen_find_size(const DDS::UserDataQosPolicy& stru, size_t& size, size_t& padding)
        -: 1595:{
        -: 1596:  ACE_UNUSED_ARG(stru);
        -: 1597:  ACE_UNUSED_ARG(size);
        -: 1598:  ACE_UNUSED_ARG(padding);
       12: 1599:  gen_find_size(stru.value, size, padding);
       12: 1600:}
        -: 1601:
       12: 1602:bool operator<<(Serializer& strm, const DDS::UserDataQosPolicy& stru)
        -: 1603:{
        -: 1604:  ACE_UNUSED_ARG(strm);
        -: 1605:  ACE_UNUSED_ARG(stru);
       12: 1606:  return (strm << stru.value);
        -: 1607:}
        -: 1608:
    #####: 1609:bool operator>>(Serializer& strm, DDS::UserDataQosPolicy& stru)
        -: 1610:{
        -: 1611:  ACE_UNUSED_ARG(strm);
        -: 1612:  ACE_UNUSED_ARG(stru);
    #####: 1613:  return (strm >> stru.value);
        -: 1614:}
        -: 1615:
        -: 1616:}  }
        -: 1617:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1618:
        -: 1619:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1620:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1621:namespace OpenDDS { namespace DCPS {
        -: 1622:
        -: 1623:template<>
    #####: 1624:struct MetaStructImpl<DDS::UserDataQosPolicy> : MetaStruct {
        -: 1625:  typedef DDS::UserDataQosPolicy T;
        -: 1626:
        -: 1627:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1628:  void* allocate() const { return new T; }
        -: 1629:
    #####: 1630:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1631:
    #####: 1632:  size_t numDcpsKeys() const { return 0; }
        -: 1633:
        -: 1634:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1635:
    #####: 1636:  bool isDcpsKey(const char* field) const
        -: 1637:  {
        -: 1638:    ACE_UNUSED_ARG(field);
    #####: 1639:    return false;
        -: 1640:  }
        -: 1641:
    #####: 1642:  Value getValue(const void* stru, const char* field) const
        -: 1643:  {
    #####: 1644:    const DDS::UserDataQosPolicy& typed = *static_cast<const DDS::UserDataQosPolicy*>(stru);
        -: 1645:    ACE_UNUSED_ARG(typed);
    #####: 1646:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
        -: 1647:  }
        -: 1648:
    #####: 1649:  Value getValue(Serializer& ser, const char* field) const
        -: 1650:  {
    #####: 1651:    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) {
    #####: 1652:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1653:    }
    #####: 1654:    if (!field[0]) {
    #####: 1655:      return 0;
        -: 1656:    }
    #####: 1657:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::UserDataQosPolicy");
        -: 1658:  }
        -: 1659:
    #####: 1660:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1661:  {
        -: 1662:    ACE_UNUSED_ARG(next);
    #####: 1663:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
        -: 1664:  }
        -: 1665:
        -: 1666:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1667:  const char** getFieldNames() const
        -: 1668:  {
        -: 1669:    static const char* names[] = {"value", 0};
    #####: 1670:    return names;
        -: 1671:  }
        -: 1672:
    #####: 1673:  const void* getRawField(const void* stru, const char* field) const
        -: 1674:  {
    #####: 1675:    if (std::strcmp(field, "value") == 0) {
    #####: 1676:      return &static_cast<const T*>(stru)->value;
        -: 1677:    }
    #####: 1678:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
        -: 1679:  }
        -: 1680:
    #####: 1681:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1682:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1683:  {
        -: 1684:    ACE_UNUSED_ARG(lhs);
        -: 1685:    ACE_UNUSED_ARG(field);
        -: 1686:    ACE_UNUSED_ARG(rhs);
        -: 1687:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1688:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1689:    if (std::strcmp(field, "value") == 0) {
    #####: 1690:      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1691:      return;
        -: 1692:    }
    #####: 1693:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
        -: 1694:  }
        -: 1695:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1696:
    #####: 1697:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1698:  {
        -: 1699:    ACE_UNUSED_ARG(lhs);
        -: 1700:    ACE_UNUSED_ARG(field);
        -: 1701:    ACE_UNUSED_ARG(rhs);
    #####: 1702:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::UserDataQosPolicy)");
        -: 1703:  }
        -: 1704:};
        -: 1705:
        -: 1706:template<>
    #####: 1707:const MetaStruct& getMetaStruct<DDS::UserDataQosPolicy>()
        -: 1708:{
    #####: 1709:  static MetaStructImpl<DDS::UserDataQosPolicy> msi;
    #####: 1710:  return msi;
        -: 1711:}
        -: 1712:
    #####: 1713:bool gen_skip_over(Serializer& ser, DDS::UserDataQosPolicy*)
        -: 1714:{
        -: 1715:  ACE_UNUSED_ARG(ser);
    #####: 1716:  MetaStructImpl<DDS::UserDataQosPolicy>().getValue(ser, "");
    #####: 1717:  return true;
        -: 1718:}
        -: 1719:
        -: 1720:}  }
        -: 1721:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1722:
        -: 1723:#endif
        -: 1724:
        -: 1725:/* End STRUCT: UserDataQosPolicy */
        -: 1726:
        -: 1727:
        -: 1728:/* Begin STRUCT: GroupDataQosPolicy */
        -: 1729:
        -: 1730:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1731:namespace OpenDDS { namespace DCPS {
        -: 1732:
        6: 1733:void gen_find_size(const DDS::GroupDataQosPolicy& stru, size_t& size, size_t& padding)
        -: 1734:{
        -: 1735:  ACE_UNUSED_ARG(stru);
        -: 1736:  ACE_UNUSED_ARG(size);
        -: 1737:  ACE_UNUSED_ARG(padding);
        6: 1738:  gen_find_size(stru.value, size, padding);
        6: 1739:}
        -: 1740:
        6: 1741:bool operator<<(Serializer& strm, const DDS::GroupDataQosPolicy& stru)
        -: 1742:{
        -: 1743:  ACE_UNUSED_ARG(strm);
        -: 1744:  ACE_UNUSED_ARG(stru);
        6: 1745:  return (strm << stru.value);
        -: 1746:}
        -: 1747:
    #####: 1748:bool operator>>(Serializer& strm, DDS::GroupDataQosPolicy& stru)
        -: 1749:{
        -: 1750:  ACE_UNUSED_ARG(strm);
        -: 1751:  ACE_UNUSED_ARG(stru);
    #####: 1752:  return (strm >> stru.value);
        -: 1753:}
        -: 1754:
        -: 1755:}  }
        -: 1756:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1757:
        -: 1758:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1759:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1760:namespace OpenDDS { namespace DCPS {
        -: 1761:
        -: 1762:template<>
    #####: 1763:struct MetaStructImpl<DDS::GroupDataQosPolicy> : MetaStruct {
        -: 1764:  typedef DDS::GroupDataQosPolicy T;
        -: 1765:
        -: 1766:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1767:  void* allocate() const { return new T; }
        -: 1768:
    #####: 1769:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1770:
    #####: 1771:  size_t numDcpsKeys() const { return 0; }
        -: 1772:
        -: 1773:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1774:
    #####: 1775:  bool isDcpsKey(const char* field) const
        -: 1776:  {
        -: 1777:    ACE_UNUSED_ARG(field);
    #####: 1778:    return false;
        -: 1779:  }
        -: 1780:
    #####: 1781:  Value getValue(const void* stru, const char* field) const
        -: 1782:  {
    #####: 1783:    const DDS::GroupDataQosPolicy& typed = *static_cast<const DDS::GroupDataQosPolicy*>(stru);
        -: 1784:    ACE_UNUSED_ARG(typed);
    #####: 1785:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
        -: 1786:  }
        -: 1787:
    #####: 1788:  Value getValue(Serializer& ser, const char* field) const
        -: 1789:  {
    #####: 1790:    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) {
    #####: 1791:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1792:    }
    #####: 1793:    if (!field[0]) {
    #####: 1794:      return 0;
        -: 1795:    }
    #####: 1796:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::GroupDataQosPolicy");
        -: 1797:  }
        -: 1798:
    #####: 1799:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1800:  {
        -: 1801:    ACE_UNUSED_ARG(next);
    #####: 1802:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
        -: 1803:  }
        -: 1804:
        -: 1805:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1806:  const char** getFieldNames() const
        -: 1807:  {
        -: 1808:    static const char* names[] = {"value", 0};
    #####: 1809:    return names;
        -: 1810:  }
        -: 1811:
    #####: 1812:  const void* getRawField(const void* stru, const char* field) const
        -: 1813:  {
    #####: 1814:    if (std::strcmp(field, "value") == 0) {
    #####: 1815:      return &static_cast<const T*>(stru)->value;
        -: 1816:    }
    #####: 1817:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
        -: 1818:  }
        -: 1819:
    #####: 1820:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1821:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1822:  {
        -: 1823:    ACE_UNUSED_ARG(lhs);
        -: 1824:    ACE_UNUSED_ARG(field);
        -: 1825:    ACE_UNUSED_ARG(rhs);
        -: 1826:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1827:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1828:    if (std::strcmp(field, "value") == 0) {
    #####: 1829:      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1830:      return;
        -: 1831:    }
    #####: 1832:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
        -: 1833:  }
        -: 1834:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1835:
    #####: 1836:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1837:  {
        -: 1838:    ACE_UNUSED_ARG(lhs);
        -: 1839:    ACE_UNUSED_ARG(field);
        -: 1840:    ACE_UNUSED_ARG(rhs);
    #####: 1841:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::GroupDataQosPolicy)");
        -: 1842:  }
        -: 1843:};
        -: 1844:
        -: 1845:template<>
    #####: 1846:const MetaStruct& getMetaStruct<DDS::GroupDataQosPolicy>()
        -: 1847:{
    #####: 1848:  static MetaStructImpl<DDS::GroupDataQosPolicy> msi;
    #####: 1849:  return msi;
        -: 1850:}
        -: 1851:
    #####: 1852:bool gen_skip_over(Serializer& ser, DDS::GroupDataQosPolicy*)
        -: 1853:{
        -: 1854:  ACE_UNUSED_ARG(ser);
    #####: 1855:  MetaStructImpl<DDS::GroupDataQosPolicy>().getValue(ser, "");
    #####: 1856:  return true;
        -: 1857:}
        -: 1858:
        -: 1859:}  }
        -: 1860:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1861:
        -: 1862:#endif
        -: 1863:
        -: 1864:/* End STRUCT: GroupDataQosPolicy */
        -: 1865:
        -: 1866:
        -: 1867:/* Begin STRUCT: TopicDataQosPolicy */
        -: 1868:
        -: 1869:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1870:namespace OpenDDS { namespace DCPS {
        -: 1871:
       12: 1872:void gen_find_size(const DDS::TopicDataQosPolicy& stru, size_t& size, size_t& padding)
        -: 1873:{
        -: 1874:  ACE_UNUSED_ARG(stru);
        -: 1875:  ACE_UNUSED_ARG(size);
        -: 1876:  ACE_UNUSED_ARG(padding);
       12: 1877:  gen_find_size(stru.value, size, padding);
       12: 1878:}
        -: 1879:
       12: 1880:bool operator<<(Serializer& strm, const DDS::TopicDataQosPolicy& stru)
        -: 1881:{
        -: 1882:  ACE_UNUSED_ARG(strm);
        -: 1883:  ACE_UNUSED_ARG(stru);
       12: 1884:  return (strm << stru.value);
        -: 1885:}
        -: 1886:
    #####: 1887:bool operator>>(Serializer& strm, DDS::TopicDataQosPolicy& stru)
        -: 1888:{
        -: 1889:  ACE_UNUSED_ARG(strm);
        -: 1890:  ACE_UNUSED_ARG(stru);
    #####: 1891:  return (strm >> stru.value);
        -: 1892:}
        -: 1893:
        -: 1894:}  }
        -: 1895:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1896:
        -: 1897:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1898:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1899:namespace OpenDDS { namespace DCPS {
        -: 1900:
        -: 1901:template<>
    #####: 1902:struct MetaStructImpl<DDS::TopicDataQosPolicy> : MetaStruct {
        -: 1903:  typedef DDS::TopicDataQosPolicy T;
        -: 1904:
        -: 1905:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1906:  void* allocate() const { return new T; }
        -: 1907:
    #####: 1908:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1909:
    #####: 1910:  size_t numDcpsKeys() const { return 0; }
        -: 1911:
        -: 1912:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1913:
    #####: 1914:  bool isDcpsKey(const char* field) const
        -: 1915:  {
        -: 1916:    ACE_UNUSED_ARG(field);
    #####: 1917:    return false;
        -: 1918:  }
        -: 1919:
    #####: 1920:  Value getValue(const void* stru, const char* field) const
        -: 1921:  {
    #####: 1922:    const DDS::TopicDataQosPolicy& typed = *static_cast<const DDS::TopicDataQosPolicy*>(stru);
        -: 1923:    ACE_UNUSED_ARG(typed);
    #####: 1924:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
        -: 1925:  }
        -: 1926:
    #####: 1927:  Value getValue(Serializer& ser, const char* field) const
        -: 1928:  {
    #####: 1929:    if (!gen_skip_over(ser, static_cast<DDS::OctetSeq*>(0))) {
    #####: 1930:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1931:    }
    #####: 1932:    if (!field[0]) {
    #####: 1933:      return 0;
        -: 1934:    }
    #####: 1935:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TopicDataQosPolicy");
        -: 1936:  }
        -: 1937:
    #####: 1938:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1939:  {
        -: 1940:    ACE_UNUSED_ARG(next);
    #####: 1941:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
        -: 1942:  }
        -: 1943:
        -: 1944:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1945:  const char** getFieldNames() const
        -: 1946:  {
        -: 1947:    static const char* names[] = {"value", 0};
    #####: 1948:    return names;
        -: 1949:  }
        -: 1950:
    #####: 1951:  const void* getRawField(const void* stru, const char* field) const
        -: 1952:  {
    #####: 1953:    if (std::strcmp(field, "value") == 0) {
    #####: 1954:      return &static_cast<const T*>(stru)->value;
        -: 1955:    }
    #####: 1956:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
        -: 1957:  }
        -: 1958:
    #####: 1959:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1960:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1961:  {
        -: 1962:    ACE_UNUSED_ARG(lhs);
        -: 1963:    ACE_UNUSED_ARG(field);
        -: 1964:    ACE_UNUSED_ARG(rhs);
        -: 1965:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1966:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1967:    if (std::strcmp(field, "value") == 0) {
    #####: 1968:      static_cast<T*>(lhs)->value = *static_cast<const DDS::OctetSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1969:      return;
        -: 1970:    }
    #####: 1971:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
        -: 1972:  }
        -: 1973:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1974:
    #####: 1975:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1976:  {
        -: 1977:    ACE_UNUSED_ARG(lhs);
        -: 1978:    ACE_UNUSED_ARG(field);
        -: 1979:    ACE_UNUSED_ARG(rhs);
    #####: 1980:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicDataQosPolicy)");
        -: 1981:  }
        -: 1982:};
        -: 1983:
        -: 1984:template<>
    #####: 1985:const MetaStruct& getMetaStruct<DDS::TopicDataQosPolicy>()
        -: 1986:{
    #####: 1987:  static MetaStructImpl<DDS::TopicDataQosPolicy> msi;
    #####: 1988:  return msi;
        -: 1989:}
        -: 1990:
    #####: 1991:bool gen_skip_over(Serializer& ser, DDS::TopicDataQosPolicy*)
        -: 1992:{
        -: 1993:  ACE_UNUSED_ARG(ser);
    #####: 1994:  MetaStructImpl<DDS::TopicDataQosPolicy>().getValue(ser, "");
    #####: 1995:  return true;
        -: 1996:}
        -: 1997:
        -: 1998:}  }
        -: 1999:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2000:
        -: 2001:#endif
        -: 2002:
        -: 2003:/* End STRUCT: TopicDataQosPolicy */
        -: 2004:
        -: 2005:
        -: 2006:/* Begin STRUCT: PartitionQosPolicy */
        -: 2007:
        -: 2008:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2009:namespace OpenDDS { namespace DCPS {
        -: 2010:
        6: 2011:void gen_find_size(const DDS::PartitionQosPolicy& stru, size_t& size, size_t& padding)
        -: 2012:{
        -: 2013:  ACE_UNUSED_ARG(stru);
        -: 2014:  ACE_UNUSED_ARG(size);
        -: 2015:  ACE_UNUSED_ARG(padding);
        6: 2016:  gen_find_size(stru.name, size, padding);
        6: 2017:}
        -: 2018:
        6: 2019:bool operator<<(Serializer& strm, const DDS::PartitionQosPolicy& stru)
        -: 2020:{
        -: 2021:  ACE_UNUSED_ARG(strm);
        -: 2022:  ACE_UNUSED_ARG(stru);
        6: 2023:  return (strm << stru.name);
        -: 2024:}
        -: 2025:
    #####: 2026:bool operator>>(Serializer& strm, DDS::PartitionQosPolicy& stru)
        -: 2027:{
        -: 2028:  ACE_UNUSED_ARG(strm);
        -: 2029:  ACE_UNUSED_ARG(stru);
    #####: 2030:  return (strm >> stru.name);
        -: 2031:}
        -: 2032:
        -: 2033:}  }
        -: 2034:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2035:
        -: 2036:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2037:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2038:namespace OpenDDS { namespace DCPS {
        -: 2039:
        -: 2040:template<>
    #####: 2041:struct MetaStructImpl<DDS::PartitionQosPolicy> : MetaStruct {
        -: 2042:  typedef DDS::PartitionQosPolicy T;
        -: 2043:
        -: 2044:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2045:  void* allocate() const { return new T; }
        -: 2046:
    #####: 2047:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2048:
    #####: 2049:  size_t numDcpsKeys() const { return 0; }
        -: 2050:
        -: 2051:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2052:
    #####: 2053:  bool isDcpsKey(const char* field) const
        -: 2054:  {
        -: 2055:    ACE_UNUSED_ARG(field);
    #####: 2056:    return false;
        -: 2057:  }
        -: 2058:
    #####: 2059:  Value getValue(const void* stru, const char* field) const
        -: 2060:  {
    #####: 2061:    const DDS::PartitionQosPolicy& typed = *static_cast<const DDS::PartitionQosPolicy*>(stru);
        -: 2062:    ACE_UNUSED_ARG(typed);
    #####: 2063:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
        -: 2064:  }
        -: 2065:
    #####: 2066:  Value getValue(Serializer& ser, const char* field) const
        -: 2067:  {
    #####: 2068:    if (!gen_skip_over(ser, static_cast<DDS::StringSeq*>(0))) {
    #####: 2069:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2070:    }
    #####: 2071:    if (!field[0]) {
    #####: 2072:      return 0;
        -: 2073:    }
    #####: 2074:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PartitionQosPolicy");
        -: 2075:  }
        -: 2076:
    #####: 2077:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2078:  {
        -: 2079:    ACE_UNUSED_ARG(next);
    #####: 2080:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
        -: 2081:  }
        -: 2082:
        -: 2083:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2084:  const char** getFieldNames() const
        -: 2085:  {
        -: 2086:    static const char* names[] = {"name", 0};
    #####: 2087:    return names;
        -: 2088:  }
        -: 2089:
    #####: 2090:  const void* getRawField(const void* stru, const char* field) const
        -: 2091:  {
    #####: 2092:    if (std::strcmp(field, "name") == 0) {
    #####: 2093:      return &static_cast<const T*>(stru)->name;
        -: 2094:    }
    #####: 2095:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
        -: 2096:  }
        -: 2097:
    #####: 2098:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2099:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2100:  {
        -: 2101:    ACE_UNUSED_ARG(lhs);
        -: 2102:    ACE_UNUSED_ARG(field);
        -: 2103:    ACE_UNUSED_ARG(rhs);
        -: 2104:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2105:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2106:    if (std::strcmp(field, "name") == 0) {
    #####: 2107:      static_cast<T*>(lhs)->name = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2108:      return;
        -: 2109:    }
    #####: 2110:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
        -: 2111:  }
        -: 2112:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2113:
    #####: 2114:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2115:  {
        -: 2116:    ACE_UNUSED_ARG(lhs);
        -: 2117:    ACE_UNUSED_ARG(field);
        -: 2118:    ACE_UNUSED_ARG(rhs);
    #####: 2119:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PartitionQosPolicy)");
        -: 2120:  }
        -: 2121:};
        -: 2122:
        -: 2123:template<>
    #####: 2124:const MetaStruct& getMetaStruct<DDS::PartitionQosPolicy>()
        -: 2125:{
    #####: 2126:  static MetaStructImpl<DDS::PartitionQosPolicy> msi;
    #####: 2127:  return msi;
        -: 2128:}
        -: 2129:
    #####: 2130:bool gen_skip_over(Serializer& ser, DDS::PartitionQosPolicy*)
        -: 2131:{
        -: 2132:  ACE_UNUSED_ARG(ser);
    #####: 2133:  MetaStructImpl<DDS::PartitionQosPolicy>().getValue(ser, "");
    #####: 2134:  return true;
        -: 2135:}
        -: 2136:
        -: 2137:}  }
        -: 2138:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2139:
        -: 2140:#endif
        -: 2141:
        -: 2142:/* End STRUCT: PartitionQosPolicy */
        -: 2143:
        -: 2144:
        -: 2145:/* Begin ENUM: HistoryQosPolicyKind */
        -: 2146:
        -: 2147:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2148:namespace OpenDDS { namespace DCPS {
        -: 2149:
       15: 2150:bool operator<<(Serializer& strm, const DDS::HistoryQosPolicyKind& enumval)
        -: 2151:{
        -: 2152:  ACE_UNUSED_ARG(strm);
        -: 2153:  ACE_UNUSED_ARG(enumval);
       15: 2154:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 2155:}
        -: 2156:
    #####: 2157:bool operator>>(Serializer& strm, DDS::HistoryQosPolicyKind& enumval)
        -: 2158:{
        -: 2159:  ACE_UNUSED_ARG(strm);
        -: 2160:  ACE_UNUSED_ARG(enumval);
    #####: 2161:  CORBA::ULong temp = 0;
    #####: 2162:  if (strm >> temp) {
    #####: 2163:    enumval = static_cast<DDS::HistoryQosPolicyKind>(temp);
    #####: 2164:    return true;
        -: 2165:  }
    #####: 2166:  return false;
        -: 2167:}
        -: 2168:
        -: 2169:}  }
        -: 2170:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2171:
        -: 2172:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2173:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2174:namespace OpenDDS { namespace DCPS {
        -: 2175:
        -: 2176:const char* gen_DDS_HistoryQosPolicyKind_names[] = {
        -: 2177:  "KEEP_LAST_HISTORY_QOS",
        -: 2178:  "KEEP_ALL_HISTORY_QOS"
        -: 2179:};
        -: 2180:const size_t gen_DDS_HistoryQosPolicyKind_names_size = 2;
        -: 2181:}  }
        -: 2182:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2183:
        -: 2184:#endif
        -: 2185:
        -: 2186:/* End ENUM: HistoryQosPolicyKind */
        -: 2187:
        -: 2188:
        -: 2189:/* Begin ENUM: DurabilityQosPolicyKind */
        -: 2190:
        -: 2191:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2192:namespace OpenDDS { namespace DCPS {
        -: 2193:
       12: 2194:bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicyKind& enumval)
        -: 2195:{
        -: 2196:  ACE_UNUSED_ARG(strm);
        -: 2197:  ACE_UNUSED_ARG(enumval);
       12: 2198:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 2199:}
        -: 2200:
    #####: 2201:bool operator>>(Serializer& strm, DDS::DurabilityQosPolicyKind& enumval)
        -: 2202:{
        -: 2203:  ACE_UNUSED_ARG(strm);
        -: 2204:  ACE_UNUSED_ARG(enumval);
    #####: 2205:  CORBA::ULong temp = 0;
    #####: 2206:  if (strm >> temp) {
    #####: 2207:    enumval = static_cast<DDS::DurabilityQosPolicyKind>(temp);
    #####: 2208:    return true;
        -: 2209:  }
    #####: 2210:  return false;
        -: 2211:}
        -: 2212:
        -: 2213:}  }
        -: 2214:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2215:
        -: 2216:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2217:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2218:namespace OpenDDS { namespace DCPS {
        -: 2219:
        -: 2220:const char* gen_DDS_DurabilityQosPolicyKind_names[] = {
        -: 2221:  "VOLATILE_DURABILITY_QOS",
        -: 2222:  "TRANSIENT_LOCAL_DURABILITY_QOS",
        -: 2223:  "TRANSIENT_DURABILITY_QOS",
        -: 2224:  "PERSISTENT_DURABILITY_QOS"
        -: 2225:};
        -: 2226:const size_t gen_DDS_DurabilityQosPolicyKind_names_size = 4;
        -: 2227:}  }
        -: 2228:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2229:
        -: 2230:#endif
        -: 2231:
        -: 2232:/* End ENUM: DurabilityQosPolicyKind */
        -: 2233:
        -: 2234:
        -: 2235:/* Begin STRUCT: DurabilityQosPolicy */
        -: 2236:
        -: 2237:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2238:namespace OpenDDS { namespace DCPS {
        -: 2239:
       12: 2240:void gen_find_size(const DDS::DurabilityQosPolicy& stru, size_t& size, size_t& padding)
        -: 2241:{
        -: 2242:  ACE_UNUSED_ARG(stru);
        -: 2243:  ACE_UNUSED_ARG(size);
        -: 2244:  ACE_UNUSED_ARG(padding);
       12: 2245:  find_size_ulong(size, padding);
       12: 2246:}
        -: 2247:
       12: 2248:bool operator<<(Serializer& strm, const DDS::DurabilityQosPolicy& stru)
        -: 2249:{
        -: 2250:  ACE_UNUSED_ARG(strm);
        -: 2251:  ACE_UNUSED_ARG(stru);
       12: 2252:  return (strm << stru.kind);
        -: 2253:}
        -: 2254:
    #####: 2255:bool operator>>(Serializer& strm, DDS::DurabilityQosPolicy& stru)
        -: 2256:{
        -: 2257:  ACE_UNUSED_ARG(strm);
        -: 2258:  ACE_UNUSED_ARG(stru);
    #####: 2259:  return (strm >> stru.kind);
        -: 2260:}
        -: 2261:
        -: 2262:}  }
        -: 2263:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2264:
        -: 2265:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2266:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2267:namespace OpenDDS { namespace DCPS {
        -: 2268:
        -: 2269:template<>
    #####: 2270:struct MetaStructImpl<DDS::DurabilityQosPolicy> : MetaStruct {
        -: 2271:  typedef DDS::DurabilityQosPolicy T;
        -: 2272:
        -: 2273:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2274:  void* allocate() const { return new T; }
        -: 2275:
    #####: 2276:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2277:
    #####: 2278:  size_t numDcpsKeys() const { return 0; }
        -: 2279:
        -: 2280:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2281:
    #####: 2282:  bool isDcpsKey(const char* field) const
        -: 2283:  {
        -: 2284:    ACE_UNUSED_ARG(field);
    #####: 2285:    return false;
        -: 2286:  }
        -: 2287:
    #####: 2288:  Value getValue(const void* stru, const char* field) const
        -: 2289:  {
    #####: 2290:    const DDS::DurabilityQosPolicy& typed = *static_cast<const DDS::DurabilityQosPolicy*>(stru);
    #####: 2291:    if (std::strcmp(field, "kind") == 0) {
    #####: 2292:      return gen_DDS_DurabilityQosPolicyKind_names[typed.kind];
        -: 2293:    }
        -: 2294:    ACE_UNUSED_ARG(typed);
    #####: 2295:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
        -: 2296:  }
        -: 2297:
    #####: 2298:  Value getValue(Serializer& ser, const char* field) const
        -: 2299:  {
    #####: 2300:    if (std::strcmp(field, "kind") == 0) {
        -: 2301:      ACE_CDR::ULong val;
    #####: 2302:      if (!(ser >> val)) {
    #####: 2303:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 2304:      }
    #####: 2305:      return val;
        -: 2306:    } else {
    #####: 2307:      if (!ser.skip(1, 4)) {
    #####: 2308:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 2309:      }
        -: 2310:    }
    #####: 2311:    if (!field[0]) {
    #####: 2312:      return 0;
        -: 2313:    }
    #####: 2314:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DurabilityQosPolicy");
        -: 2315:  }
        -: 2316:
    #####: 2317:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2318:  {
        -: 2319:    ACE_UNUSED_ARG(next);
    #####: 2320:    if (std::strcmp(field, "kind") == 0) {
    #####: 2321:      return make_field_cmp(&T::kind, next);
        -: 2322:    }
    #####: 2323:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
        -: 2324:  }
        -: 2325:
        -: 2326:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2327:  const char** getFieldNames() const
        -: 2328:  {
        -: 2329:    static const char* names[] = {"kind", 0};
    #####: 2330:    return names;
        -: 2331:  }
        -: 2332:
    #####: 2333:  const void* getRawField(const void* stru, const char* field) const
        -: 2334:  {
    #####: 2335:    if (std::strcmp(field, "kind") == 0) {
    #####: 2336:      return &static_cast<const T*>(stru)->kind;
        -: 2337:    }
    #####: 2338:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
        -: 2339:  }
        -: 2340:
    #####: 2341:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2342:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2343:  {
        -: 2344:    ACE_UNUSED_ARG(lhs);
        -: 2345:    ACE_UNUSED_ARG(field);
        -: 2346:    ACE_UNUSED_ARG(rhs);
        -: 2347:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2348:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2349:    if (std::strcmp(field, "kind") == 0) {
    #####: 2350:      static_cast<T*>(lhs)->kind = *static_cast<const DDS::DurabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2351:      return;
        -: 2352:    }
    #####: 2353:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
        -: 2354:  }
        -: 2355:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2356:
    #####: 2357:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2358:  {
        -: 2359:    ACE_UNUSED_ARG(lhs);
        -: 2360:    ACE_UNUSED_ARG(field);
        -: 2361:    ACE_UNUSED_ARG(rhs);
    #####: 2362:    if (std::strcmp(field, "kind") == 0) {
    #####: 2363:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 2364:    }
    #####: 2365:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityQosPolicy)");
        -: 2366:  }
        -: 2367:};
        -: 2368:
        -: 2369:template<>
    #####: 2370:const MetaStruct& getMetaStruct<DDS::DurabilityQosPolicy>()
        -: 2371:{
    #####: 2372:  static MetaStructImpl<DDS::DurabilityQosPolicy> msi;
    #####: 2373:  return msi;
        -: 2374:}
        -: 2375:
    #####: 2376:bool gen_skip_over(Serializer& ser, DDS::DurabilityQosPolicy*)
        -: 2377:{
        -: 2378:  ACE_UNUSED_ARG(ser);
    #####: 2379:  MetaStructImpl<DDS::DurabilityQosPolicy>().getValue(ser, "");
    #####: 2380:  return true;
        -: 2381:}
        -: 2382:
        -: 2383:}  }
        -: 2384:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2385:
        -: 2386:#endif
        -: 2387:
        -: 2388:/* End STRUCT: DurabilityQosPolicy */
        -: 2389:
        -: 2390:
        -: 2391:/* Begin STRUCT: DurabilityServiceQosPolicy */
        -: 2392:
        -: 2393:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2394:namespace OpenDDS { namespace DCPS {
        -: 2395:
        9: 2396:void gen_find_size(const DDS::DurabilityServiceQosPolicy& stru, size_t& size, size_t& padding)
        -: 2397:{
        -: 2398:  ACE_UNUSED_ARG(stru);
        -: 2399:  ACE_UNUSED_ARG(size);
        -: 2400:  ACE_UNUSED_ARG(padding);
        9: 2401:  gen_find_size(stru.service_cleanup_delay, size, padding);
        9: 2402:  find_size_ulong(size, padding);
        9: 2403:  if ((size + padding) % 4) {
    #####: 2404:    padding += 4 - ((size + padding) % 4);
        -: 2405:  }
        9: 2406:  size += gen_max_marshaled_size(stru.history_depth);
        9: 2407:  if ((size + padding) % 4) {
    #####: 2408:    padding += 4 - ((size + padding) % 4);
        -: 2409:  }
        9: 2410:  size += gen_max_marshaled_size(stru.max_samples);
        9: 2411:  if ((size + padding) % 4) {
    #####: 2412:    padding += 4 - ((size + padding) % 4);
        -: 2413:  }
        9: 2414:  size += gen_max_marshaled_size(stru.max_instances);
        9: 2415:  if ((size + padding) % 4) {
    #####: 2416:    padding += 4 - ((size + padding) % 4);
        -: 2417:  }
        9: 2418:  size += gen_max_marshaled_size(stru.max_samples_per_instance);
        9: 2419:}
        -: 2420:
        9: 2421:bool operator<<(Serializer& strm, const DDS::DurabilityServiceQosPolicy& stru)
        -: 2422:{
        -: 2423:  ACE_UNUSED_ARG(strm);
        -: 2424:  ACE_UNUSED_ARG(stru);
        9: 2425:  return (strm << stru.service_cleanup_delay)
        9: 2426:    && (strm << stru.history_kind)
        9: 2427:    && (strm << stru.history_depth)
        9: 2428:    && (strm << stru.max_samples)
        9: 2429:    && (strm << stru.max_instances)
       18: 2430:    && (strm << stru.max_samples_per_instance);
        -: 2431:}
        -: 2432:
    #####: 2433:bool operator>>(Serializer& strm, DDS::DurabilityServiceQosPolicy& stru)
        -: 2434:{
        -: 2435:  ACE_UNUSED_ARG(strm);
        -: 2436:  ACE_UNUSED_ARG(stru);
    #####: 2437:  return (strm >> stru.service_cleanup_delay)
    #####: 2438:    && (strm >> stru.history_kind)
    #####: 2439:    && (strm >> stru.history_depth)
    #####: 2440:    && (strm >> stru.max_samples)
    #####: 2441:    && (strm >> stru.max_instances)
    #####: 2442:    && (strm >> stru.max_samples_per_instance);
        -: 2443:}
        -: 2444:
        -: 2445:}  }
        -: 2446:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2447:
        -: 2448:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2449:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2450:namespace OpenDDS { namespace DCPS {
        -: 2451:
        -: 2452:template<>
    #####: 2453:struct MetaStructImpl<DDS::DurabilityServiceQosPolicy> : MetaStruct {
        -: 2454:  typedef DDS::DurabilityServiceQosPolicy T;
        -: 2455:
        -: 2456:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2457:  void* allocate() const { return new T; }
        -: 2458:
    #####: 2459:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2460:
    #####: 2461:  size_t numDcpsKeys() const { return 0; }
        -: 2462:
        -: 2463:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2464:
    #####: 2465:  bool isDcpsKey(const char* field) const
        -: 2466:  {
        -: 2467:    ACE_UNUSED_ARG(field);
    #####: 2468:    return false;
        -: 2469:  }
        -: 2470:
    #####: 2471:  Value getValue(const void* stru, const char* field) const
        -: 2472:  {
    #####: 2473:    const DDS::DurabilityServiceQosPolicy& typed = *static_cast<const DDS::DurabilityServiceQosPolicy*>(stru);
    #####: 2474:    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
    #####: 2475:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.service_cleanup_delay, field + 22);
        -: 2476:    }
    #####: 2477:    if (std::strcmp(field, "history_kind") == 0) {
    #####: 2478:      return gen_DDS_HistoryQosPolicyKind_names[typed.history_kind];
        -: 2479:    }
    #####: 2480:    if (std::strcmp(field, "history_depth") == 0) {
    #####: 2481:      return typed.history_depth;
        -: 2482:    }
    #####: 2483:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 2484:      return typed.max_samples;
        -: 2485:    }
    #####: 2486:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 2487:      return typed.max_instances;
        -: 2488:    }
    #####: 2489:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 2490:      return typed.max_samples_per_instance;
        -: 2491:    }
        -: 2492:    ACE_UNUSED_ARG(typed);
    #####: 2493:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
        -: 2494:  }
        -: 2495:
    #####: 2496:  Value getValue(Serializer& ser, const char* field) const
        -: 2497:  {
    #####: 2498:    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
    #####: 2499:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 22);
        -: 2500:    } else {
    #####: 2501:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 2502:        throw std::runtime_error("Field 'service_cleanup_delay' could not be skipped");
        -: 2503:      }
        -: 2504:    }
    #####: 2505:    if (std::strcmp(field, "history_kind") == 0) {
        -: 2506:      ACE_CDR::ULong val;
    #####: 2507:      if (!(ser >> val)) {
    #####: 2508:        throw std::runtime_error("Field 'history_kind' could not be deserialized");
        -: 2509:      }
    #####: 2510:      return val;
        -: 2511:    } else {
    #####: 2512:      if (!ser.skip(1, 4)) {
    #####: 2513:        throw std::runtime_error("Field 'history_kind' could not be skipped");
        -: 2514:      }
        -: 2515:    }
    #####: 2516:    if (std::strcmp(field, "history_depth") == 0) {
        -: 2517:      ACE_CDR::Long val;
    #####: 2518:      if (!(ser >> val)) {
    #####: 2519:        throw std::runtime_error("Field 'history_depth' could not be deserialized");
        -: 2520:      }
    #####: 2521:      return val;
        -: 2522:    } else {
    #####: 2523:      if (!ser.skip(1, 4)) {
    #####: 2524:        throw std::runtime_error("Field 'history_depth' could not be skipped");
        -: 2525:      }
        -: 2526:    }
    #####: 2527:    if (std::strcmp(field, "max_samples") == 0) {
        -: 2528:      ACE_CDR::Long val;
    #####: 2529:      if (!(ser >> val)) {
    #####: 2530:        throw std::runtime_error("Field 'max_samples' could not be deserialized");
        -: 2531:      }
    #####: 2532:      return val;
        -: 2533:    } else {
    #####: 2534:      if (!ser.skip(1, 4)) {
    #####: 2535:        throw std::runtime_error("Field 'max_samples' could not be skipped");
        -: 2536:      }
        -: 2537:    }
    #####: 2538:    if (std::strcmp(field, "max_instances") == 0) {
        -: 2539:      ACE_CDR::Long val;
    #####: 2540:      if (!(ser >> val)) {
    #####: 2541:        throw std::runtime_error("Field 'max_instances' could not be deserialized");
        -: 2542:      }
    #####: 2543:      return val;
        -: 2544:    } else {
    #####: 2545:      if (!ser.skip(1, 4)) {
    #####: 2546:        throw std::runtime_error("Field 'max_instances' could not be skipped");
        -: 2547:      }
        -: 2548:    }
    #####: 2549:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
        -: 2550:      ACE_CDR::Long val;
    #####: 2551:      if (!(ser >> val)) {
    #####: 2552:        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
        -: 2553:      }
    #####: 2554:      return val;
        -: 2555:    } else {
    #####: 2556:      if (!ser.skip(1, 4)) {
    #####: 2557:        throw std::runtime_error("Field 'max_samples_per_instance' could not be skipped");
        -: 2558:      }
        -: 2559:    }
    #####: 2560:    if (!field[0]) {
    #####: 2561:      return 0;
        -: 2562:    }
    #####: 2563:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DurabilityServiceQosPolicy");
        -: 2564:  }
        -: 2565:
    #####: 2566:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2567:  {
        -: 2568:    ACE_UNUSED_ARG(next);
    #####: 2569:    if (std::strncmp(field, "service_cleanup_delay.", 22) == 0) {
    #####: 2570:      return make_struct_cmp(&T::service_cleanup_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 22), next);
        -: 2571:    }
    #####: 2572:    if (std::strcmp(field, "history_kind") == 0) {
    #####: 2573:      return make_field_cmp(&T::history_kind, next);
        -: 2574:    }
    #####: 2575:    if (std::strcmp(field, "history_depth") == 0) {
    #####: 2576:      return make_field_cmp(&T::history_depth, next);
        -: 2577:    }
    #####: 2578:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 2579:      return make_field_cmp(&T::max_samples, next);
        -: 2580:    }
    #####: 2581:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 2582:      return make_field_cmp(&T::max_instances, next);
        -: 2583:    }
    #####: 2584:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 2585:      return make_field_cmp(&T::max_samples_per_instance, next);
        -: 2586:    }
    #####: 2587:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
        -: 2588:  }
        -: 2589:
        -: 2590:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2591:  const char** getFieldNames() const
        -: 2592:  {
        -: 2593:    static const char* names[] = {"service_cleanup_delay", "history_kind", "history_depth", "max_samples", "max_instances", "max_samples_per_instance", 0};
    #####: 2594:    return names;
        -: 2595:  }
        -: 2596:
    #####: 2597:  const void* getRawField(const void* stru, const char* field) const
        -: 2598:  {
    #####: 2599:    if (std::strcmp(field, "service_cleanup_delay") == 0) {
    #####: 2600:      return &static_cast<const T*>(stru)->service_cleanup_delay;
        -: 2601:    }
    #####: 2602:    if (std::strcmp(field, "history_kind") == 0) {
    #####: 2603:      return &static_cast<const T*>(stru)->history_kind;
        -: 2604:    }
    #####: 2605:    if (std::strcmp(field, "history_depth") == 0) {
    #####: 2606:      return &static_cast<const T*>(stru)->history_depth;
        -: 2607:    }
    #####: 2608:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 2609:      return &static_cast<const T*>(stru)->max_samples;
        -: 2610:    }
    #####: 2611:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 2612:      return &static_cast<const T*>(stru)->max_instances;
        -: 2613:    }
    #####: 2614:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 2615:      return &static_cast<const T*>(stru)->max_samples_per_instance;
        -: 2616:    }
    #####: 2617:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
        -: 2618:  }
        -: 2619:
    #####: 2620:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2621:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2622:  {
        -: 2623:    ACE_UNUSED_ARG(lhs);
        -: 2624:    ACE_UNUSED_ARG(field);
        -: 2625:    ACE_UNUSED_ARG(rhs);
        -: 2626:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2627:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2628:    if (std::strcmp(field, "service_cleanup_delay") == 0) {
    #####: 2629:      static_cast<T*>(lhs)->service_cleanup_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2630:      return;
        -: 2631:    }
    #####: 2632:    if (std::strcmp(field, "history_kind") == 0) {
    #####: 2633:      static_cast<T*>(lhs)->history_kind = *static_cast<const DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2634:      return;
        -: 2635:    }
    #####: 2636:    if (std::strcmp(field, "history_depth") == 0) {
    #####: 2637:      static_cast<T*>(lhs)->history_depth = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2638:      return;
        -: 2639:    }
    #####: 2640:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 2641:      static_cast<T*>(lhs)->max_samples = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2642:      return;
        -: 2643:    }
    #####: 2644:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 2645:      static_cast<T*>(lhs)->max_instances = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2646:      return;
        -: 2647:    }
    #####: 2648:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 2649:      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2650:      return;
        -: 2651:    }
    #####: 2652:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
        -: 2653:  }
        -: 2654:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2655:
    #####: 2656:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2657:  {
        -: 2658:    ACE_UNUSED_ARG(lhs);
        -: 2659:    ACE_UNUSED_ARG(field);
        -: 2660:    ACE_UNUSED_ARG(rhs);
    #####: 2661:    if (std::strcmp(field, "history_kind") == 0) {
    #####: 2662:      return static_cast<const T*>(lhs)->history_kind == static_cast<const T*>(rhs)->history_kind;
        -: 2663:    }
    #####: 2664:    if (std::strcmp(field, "history_depth") == 0) {
    #####: 2665:      return static_cast<const T*>(lhs)->history_depth == static_cast<const T*>(rhs)->history_depth;
        -: 2666:    }
    #####: 2667:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 2668:      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
        -: 2669:    }
    #####: 2670:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 2671:      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
        -: 2672:    }
    #####: 2673:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 2674:      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
        -: 2675:    }
    #####: 2676:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DurabilityServiceQosPolicy)");
        -: 2677:  }
        -: 2678:};
        -: 2679:
        -: 2680:template<>
    #####: 2681:const MetaStruct& getMetaStruct<DDS::DurabilityServiceQosPolicy>()
        -: 2682:{
    #####: 2683:  static MetaStructImpl<DDS::DurabilityServiceQosPolicy> msi;
    #####: 2684:  return msi;
        -: 2685:}
        -: 2686:
    #####: 2687:bool gen_skip_over(Serializer& ser, DDS::DurabilityServiceQosPolicy*)
        -: 2688:{
        -: 2689:  ACE_UNUSED_ARG(ser);
    #####: 2690:  MetaStructImpl<DDS::DurabilityServiceQosPolicy>().getValue(ser, "");
    #####: 2691:  return true;
        -: 2692:}
        -: 2693:
        -: 2694:}  }
        -: 2695:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2696:
        -: 2697:#endif
        -: 2698:
        -: 2699:/* End STRUCT: DurabilityServiceQosPolicy */
        -: 2700:
        -: 2701:
        -: 2702:/* Begin STRUCT: DeadlineQosPolicy */
        -: 2703:
        -: 2704:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2705:namespace OpenDDS { namespace DCPS {
        -: 2706:
       12: 2707:void gen_find_size(const DDS::DeadlineQosPolicy& stru, size_t& size, size_t& padding)
        -: 2708:{
        -: 2709:  ACE_UNUSED_ARG(stru);
        -: 2710:  ACE_UNUSED_ARG(size);
        -: 2711:  ACE_UNUSED_ARG(padding);
       12: 2712:  gen_find_size(stru.period, size, padding);
       12: 2713:}
        -: 2714:
       12: 2715:bool operator<<(Serializer& strm, const DDS::DeadlineQosPolicy& stru)
        -: 2716:{
        -: 2717:  ACE_UNUSED_ARG(strm);
        -: 2718:  ACE_UNUSED_ARG(stru);
       12: 2719:  return (strm << stru.period);
        -: 2720:}
        -: 2721:
    #####: 2722:bool operator>>(Serializer& strm, DDS::DeadlineQosPolicy& stru)
        -: 2723:{
        -: 2724:  ACE_UNUSED_ARG(strm);
        -: 2725:  ACE_UNUSED_ARG(stru);
    #####: 2726:  return (strm >> stru.period);
        -: 2727:}
        -: 2728:
        -: 2729:}  }
        -: 2730:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2731:
        -: 2732:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2733:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2734:namespace OpenDDS { namespace DCPS {
        -: 2735:
        -: 2736:template<>
    #####: 2737:struct MetaStructImpl<DDS::DeadlineQosPolicy> : MetaStruct {
        -: 2738:  typedef DDS::DeadlineQosPolicy T;
        -: 2739:
        -: 2740:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2741:  void* allocate() const { return new T; }
        -: 2742:
    #####: 2743:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2744:
    #####: 2745:  size_t numDcpsKeys() const { return 0; }
        -: 2746:
        -: 2747:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2748:
    #####: 2749:  bool isDcpsKey(const char* field) const
        -: 2750:  {
        -: 2751:    ACE_UNUSED_ARG(field);
    #####: 2752:    return false;
        -: 2753:  }
        -: 2754:
    #####: 2755:  Value getValue(const void* stru, const char* field) const
        -: 2756:  {
    #####: 2757:    const DDS::DeadlineQosPolicy& typed = *static_cast<const DDS::DeadlineQosPolicy*>(stru);
    #####: 2758:    if (std::strncmp(field, "period.", 7) == 0) {
    #####: 2759:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.period, field + 7);
        -: 2760:    }
        -: 2761:    ACE_UNUSED_ARG(typed);
    #####: 2762:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
        -: 2763:  }
        -: 2764:
    #####: 2765:  Value getValue(Serializer& ser, const char* field) const
        -: 2766:  {
    #####: 2767:    if (std::strncmp(field, "period.", 7) == 0) {
    #####: 2768:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 7);
        -: 2769:    } else {
    #####: 2770:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 2771:        throw std::runtime_error("Field 'period' could not be skipped");
        -: 2772:      }
        -: 2773:    }
    #####: 2774:    if (!field[0]) {
    #####: 2775:      return 0;
        -: 2776:    }
    #####: 2777:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DeadlineQosPolicy");
        -: 2778:  }
        -: 2779:
    #####: 2780:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2781:  {
        -: 2782:    ACE_UNUSED_ARG(next);
    #####: 2783:    if (std::strncmp(field, "period.", 7) == 0) {
    #####: 2784:      return make_struct_cmp(&T::period, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 7), next);
        -: 2785:    }
    #####: 2786:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
        -: 2787:  }
        -: 2788:
        -: 2789:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2790:  const char** getFieldNames() const
        -: 2791:  {
        -: 2792:    static const char* names[] = {"period", 0};
    #####: 2793:    return names;
        -: 2794:  }
        -: 2795:
    #####: 2796:  const void* getRawField(const void* stru, const char* field) const
        -: 2797:  {
    #####: 2798:    if (std::strcmp(field, "period") == 0) {
    #####: 2799:      return &static_cast<const T*>(stru)->period;
        -: 2800:    }
    #####: 2801:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
        -: 2802:  }
        -: 2803:
    #####: 2804:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2805:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2806:  {
        -: 2807:    ACE_UNUSED_ARG(lhs);
        -: 2808:    ACE_UNUSED_ARG(field);
        -: 2809:    ACE_UNUSED_ARG(rhs);
        -: 2810:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2811:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2812:    if (std::strcmp(field, "period") == 0) {
    #####: 2813:      static_cast<T*>(lhs)->period = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2814:      return;
        -: 2815:    }
    #####: 2816:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
        -: 2817:  }
        -: 2818:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2819:
    #####: 2820:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2821:  {
        -: 2822:    ACE_UNUSED_ARG(lhs);
        -: 2823:    ACE_UNUSED_ARG(field);
        -: 2824:    ACE_UNUSED_ARG(rhs);
    #####: 2825:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DeadlineQosPolicy)");
        -: 2826:  }
        -: 2827:};
        -: 2828:
        -: 2829:template<>
    #####: 2830:const MetaStruct& getMetaStruct<DDS::DeadlineQosPolicy>()
        -: 2831:{
    #####: 2832:  static MetaStructImpl<DDS::DeadlineQosPolicy> msi;
    #####: 2833:  return msi;
        -: 2834:}
        -: 2835:
    #####: 2836:bool gen_skip_over(Serializer& ser, DDS::DeadlineQosPolicy*)
        -: 2837:{
        -: 2838:  ACE_UNUSED_ARG(ser);
    #####: 2839:  MetaStructImpl<DDS::DeadlineQosPolicy>().getValue(ser, "");
    #####: 2840:  return true;
        -: 2841:}
        -: 2842:
        -: 2843:}  }
        -: 2844:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2845:
        -: 2846:#endif
        -: 2847:
        -: 2848:/* End STRUCT: DeadlineQosPolicy */
        -: 2849:
        -: 2850:
        -: 2851:/* Begin STRUCT: LatencyBudgetQosPolicy */
        -: 2852:
        -: 2853:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2854:namespace OpenDDS { namespace DCPS {
        -: 2855:
       12: 2856:void gen_find_size(const DDS::LatencyBudgetQosPolicy& stru, size_t& size, size_t& padding)
        -: 2857:{
        -: 2858:  ACE_UNUSED_ARG(stru);
        -: 2859:  ACE_UNUSED_ARG(size);
        -: 2860:  ACE_UNUSED_ARG(padding);
       12: 2861:  gen_find_size(stru.duration, size, padding);
       12: 2862:}
        -: 2863:
       12: 2864:bool operator<<(Serializer& strm, const DDS::LatencyBudgetQosPolicy& stru)
        -: 2865:{
        -: 2866:  ACE_UNUSED_ARG(strm);
        -: 2867:  ACE_UNUSED_ARG(stru);
       12: 2868:  return (strm << stru.duration);
        -: 2869:}
        -: 2870:
    #####: 2871:bool operator>>(Serializer& strm, DDS::LatencyBudgetQosPolicy& stru)
        -: 2872:{
        -: 2873:  ACE_UNUSED_ARG(strm);
        -: 2874:  ACE_UNUSED_ARG(stru);
    #####: 2875:  return (strm >> stru.duration);
        -: 2876:}
        -: 2877:
        -: 2878:}  }
        -: 2879:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2880:
        -: 2881:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2882:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2883:namespace OpenDDS { namespace DCPS {
        -: 2884:
        -: 2885:template<>
    #####: 2886:struct MetaStructImpl<DDS::LatencyBudgetQosPolicy> : MetaStruct {
        -: 2887:  typedef DDS::LatencyBudgetQosPolicy T;
        -: 2888:
        -: 2889:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2890:  void* allocate() const { return new T; }
        -: 2891:
    #####: 2892:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2893:
    #####: 2894:  size_t numDcpsKeys() const { return 0; }
        -: 2895:
        -: 2896:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2897:
    #####: 2898:  bool isDcpsKey(const char* field) const
        -: 2899:  {
        -: 2900:    ACE_UNUSED_ARG(field);
    #####: 2901:    return false;
        -: 2902:  }
        -: 2903:
    #####: 2904:  Value getValue(const void* stru, const char* field) const
        -: 2905:  {
    #####: 2906:    const DDS::LatencyBudgetQosPolicy& typed = *static_cast<const DDS::LatencyBudgetQosPolicy*>(stru);
    #####: 2907:    if (std::strncmp(field, "duration.", 9) == 0) {
    #####: 2908:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.duration, field + 9);
        -: 2909:    }
        -: 2910:    ACE_UNUSED_ARG(typed);
    #####: 2911:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
        -: 2912:  }
        -: 2913:
    #####: 2914:  Value getValue(Serializer& ser, const char* field) const
        -: 2915:  {
    #####: 2916:    if (std::strncmp(field, "duration.", 9) == 0) {
    #####: 2917:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 9);
        -: 2918:    } else {
    #####: 2919:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 2920:        throw std::runtime_error("Field 'duration' could not be skipped");
        -: 2921:      }
        -: 2922:    }
    #####: 2923:    if (!field[0]) {
    #####: 2924:      return 0;
        -: 2925:    }
    #####: 2926:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::LatencyBudgetQosPolicy");
        -: 2927:  }
        -: 2928:
    #####: 2929:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2930:  {
        -: 2931:    ACE_UNUSED_ARG(next);
    #####: 2932:    if (std::strncmp(field, "duration.", 9) == 0) {
    #####: 2933:      return make_struct_cmp(&T::duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 9), next);
        -: 2934:    }
    #####: 2935:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
        -: 2936:  }
        -: 2937:
        -: 2938:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2939:  const char** getFieldNames() const
        -: 2940:  {
        -: 2941:    static const char* names[] = {"duration", 0};
    #####: 2942:    return names;
        -: 2943:  }
        -: 2944:
    #####: 2945:  const void* getRawField(const void* stru, const char* field) const
        -: 2946:  {
    #####: 2947:    if (std::strcmp(field, "duration") == 0) {
    #####: 2948:      return &static_cast<const T*>(stru)->duration;
        -: 2949:    }
    #####: 2950:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
        -: 2951:  }
        -: 2952:
    #####: 2953:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2954:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2955:  {
        -: 2956:    ACE_UNUSED_ARG(lhs);
        -: 2957:    ACE_UNUSED_ARG(field);
        -: 2958:    ACE_UNUSED_ARG(rhs);
        -: 2959:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2960:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2961:    if (std::strcmp(field, "duration") == 0) {
    #####: 2962:      static_cast<T*>(lhs)->duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2963:      return;
        -: 2964:    }
    #####: 2965:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
        -: 2966:  }
        -: 2967:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2968:
    #####: 2969:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2970:  {
        -: 2971:    ACE_UNUSED_ARG(lhs);
        -: 2972:    ACE_UNUSED_ARG(field);
        -: 2973:    ACE_UNUSED_ARG(rhs);
    #####: 2974:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LatencyBudgetQosPolicy)");
        -: 2975:  }
        -: 2976:};
        -: 2977:
        -: 2978:template<>
    #####: 2979:const MetaStruct& getMetaStruct<DDS::LatencyBudgetQosPolicy>()
        -: 2980:{
    #####: 2981:  static MetaStructImpl<DDS::LatencyBudgetQosPolicy> msi;
    #####: 2982:  return msi;
        -: 2983:}
        -: 2984:
    #####: 2985:bool gen_skip_over(Serializer& ser, DDS::LatencyBudgetQosPolicy*)
        -: 2986:{
        -: 2987:  ACE_UNUSED_ARG(ser);
    #####: 2988:  MetaStructImpl<DDS::LatencyBudgetQosPolicy>().getValue(ser, "");
    #####: 2989:  return true;
        -: 2990:}
        -: 2991:
        -: 2992:}  }
        -: 2993:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2994:
        -: 2995:#endif
        -: 2996:
        -: 2997:/* End STRUCT: LatencyBudgetQosPolicy */
        -: 2998:
        -: 2999:
        -: 3000:/* Begin ENUM: LivelinessQosPolicyKind */
        -: 3001:
        -: 3002:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3003:namespace OpenDDS { namespace DCPS {
        -: 3004:
       12: 3005:bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicyKind& enumval)
        -: 3006:{
        -: 3007:  ACE_UNUSED_ARG(strm);
        -: 3008:  ACE_UNUSED_ARG(enumval);
       12: 3009:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 3010:}
        -: 3011:
    #####: 3012:bool operator>>(Serializer& strm, DDS::LivelinessQosPolicyKind& enumval)
        -: 3013:{
        -: 3014:  ACE_UNUSED_ARG(strm);
        -: 3015:  ACE_UNUSED_ARG(enumval);
    #####: 3016:  CORBA::ULong temp = 0;
    #####: 3017:  if (strm >> temp) {
    #####: 3018:    enumval = static_cast<DDS::LivelinessQosPolicyKind>(temp);
    #####: 3019:    return true;
        -: 3020:  }
    #####: 3021:  return false;
        -: 3022:}
        -: 3023:
        -: 3024:}  }
        -: 3025:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3026:
        -: 3027:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3028:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3029:namespace OpenDDS { namespace DCPS {
        -: 3030:
        -: 3031:const char* gen_DDS_LivelinessQosPolicyKind_names[] = {
        -: 3032:  "AUTOMATIC_LIVELINESS_QOS",
        -: 3033:  "MANUAL_BY_PARTICIPANT_LIVELINESS_QOS",
        -: 3034:  "MANUAL_BY_TOPIC_LIVELINESS_QOS"
        -: 3035:};
        -: 3036:const size_t gen_DDS_LivelinessQosPolicyKind_names_size = 3;
        -: 3037:}  }
        -: 3038:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3039:
        -: 3040:#endif
        -: 3041:
        -: 3042:/* End ENUM: LivelinessQosPolicyKind */
        -: 3043:
        -: 3044:
        -: 3045:/* Begin STRUCT: LivelinessQosPolicy */
        -: 3046:
        -: 3047:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3048:namespace OpenDDS { namespace DCPS {
        -: 3049:
       12: 3050:void gen_find_size(const DDS::LivelinessQosPolicy& stru, size_t& size, size_t& padding)
        -: 3051:{
        -: 3052:  ACE_UNUSED_ARG(stru);
        -: 3053:  ACE_UNUSED_ARG(size);
        -: 3054:  ACE_UNUSED_ARG(padding);
       12: 3055:  find_size_ulong(size, padding);
       12: 3056:  gen_find_size(stru.lease_duration, size, padding);
       12: 3057:}
        -: 3058:
       12: 3059:bool operator<<(Serializer& strm, const DDS::LivelinessQosPolicy& stru)
        -: 3060:{
        -: 3061:  ACE_UNUSED_ARG(strm);
        -: 3062:  ACE_UNUSED_ARG(stru);
       12: 3063:  return (strm << stru.kind)
       12: 3064:    && (strm << stru.lease_duration);
        -: 3065:}
        -: 3066:
    #####: 3067:bool operator>>(Serializer& strm, DDS::LivelinessQosPolicy& stru)
        -: 3068:{
        -: 3069:  ACE_UNUSED_ARG(strm);
        -: 3070:  ACE_UNUSED_ARG(stru);
    #####: 3071:  return (strm >> stru.kind)
    #####: 3072:    && (strm >> stru.lease_duration);
        -: 3073:}
        -: 3074:
        -: 3075:}  }
        -: 3076:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3077:
        -: 3078:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3079:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3080:namespace OpenDDS { namespace DCPS {
        -: 3081:
        -: 3082:template<>
    #####: 3083:struct MetaStructImpl<DDS::LivelinessQosPolicy> : MetaStruct {
        -: 3084:  typedef DDS::LivelinessQosPolicy T;
        -: 3085:
        -: 3086:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3087:  void* allocate() const { return new T; }
        -: 3088:
    #####: 3089:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3090:
    #####: 3091:  size_t numDcpsKeys() const { return 0; }
        -: 3092:
        -: 3093:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3094:
    #####: 3095:  bool isDcpsKey(const char* field) const
        -: 3096:  {
        -: 3097:    ACE_UNUSED_ARG(field);
    #####: 3098:    return false;
        -: 3099:  }
        -: 3100:
    #####: 3101:  Value getValue(const void* stru, const char* field) const
        -: 3102:  {
    #####: 3103:    const DDS::LivelinessQosPolicy& typed = *static_cast<const DDS::LivelinessQosPolicy*>(stru);
    #####: 3104:    if (std::strcmp(field, "kind") == 0) {
    #####: 3105:      return gen_DDS_LivelinessQosPolicyKind_names[typed.kind];
        -: 3106:    }
    #####: 3107:    if (std::strncmp(field, "lease_duration.", 15) == 0) {
    #####: 3108:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.lease_duration, field + 15);
        -: 3109:    }
        -: 3110:    ACE_UNUSED_ARG(typed);
    #####: 3111:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
        -: 3112:  }
        -: 3113:
    #####: 3114:  Value getValue(Serializer& ser, const char* field) const
        -: 3115:  {
    #####: 3116:    if (std::strcmp(field, "kind") == 0) {
        -: 3117:      ACE_CDR::ULong val;
    #####: 3118:      if (!(ser >> val)) {
    #####: 3119:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 3120:      }
    #####: 3121:      return val;
        -: 3122:    } else {
    #####: 3123:      if (!ser.skip(1, 4)) {
    #####: 3124:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 3125:      }
        -: 3126:    }
    #####: 3127:    if (std::strncmp(field, "lease_duration.", 15) == 0) {
    #####: 3128:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 15);
        -: 3129:    } else {
    #####: 3130:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 3131:        throw std::runtime_error("Field 'lease_duration' could not be skipped");
        -: 3132:      }
        -: 3133:    }
    #####: 3134:    if (!field[0]) {
    #####: 3135:      return 0;
        -: 3136:    }
    #####: 3137:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::LivelinessQosPolicy");
        -: 3138:  }
        -: 3139:
    #####: 3140:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3141:  {
        -: 3142:    ACE_UNUSED_ARG(next);
    #####: 3143:    if (std::strcmp(field, "kind") == 0) {
    #####: 3144:      return make_field_cmp(&T::kind, next);
        -: 3145:    }
    #####: 3146:    if (std::strncmp(field, "lease_duration.", 15) == 0) {
    #####: 3147:      return make_struct_cmp(&T::lease_duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 15), next);
        -: 3148:    }
    #####: 3149:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
        -: 3150:  }
        -: 3151:
        -: 3152:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3153:  const char** getFieldNames() const
        -: 3154:  {
        -: 3155:    static const char* names[] = {"kind", "lease_duration", 0};
    #####: 3156:    return names;
        -: 3157:  }
        -: 3158:
    #####: 3159:  const void* getRawField(const void* stru, const char* field) const
        -: 3160:  {
    #####: 3161:    if (std::strcmp(field, "kind") == 0) {
    #####: 3162:      return &static_cast<const T*>(stru)->kind;
        -: 3163:    }
    #####: 3164:    if (std::strcmp(field, "lease_duration") == 0) {
    #####: 3165:      return &static_cast<const T*>(stru)->lease_duration;
        -: 3166:    }
    #####: 3167:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
        -: 3168:  }
        -: 3169:
    #####: 3170:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3171:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3172:  {
        -: 3173:    ACE_UNUSED_ARG(lhs);
        -: 3174:    ACE_UNUSED_ARG(field);
        -: 3175:    ACE_UNUSED_ARG(rhs);
        -: 3176:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3177:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3178:    if (std::strcmp(field, "kind") == 0) {
    #####: 3179:      static_cast<T*>(lhs)->kind = *static_cast<const DDS::LivelinessQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3180:      return;
        -: 3181:    }
    #####: 3182:    if (std::strcmp(field, "lease_duration") == 0) {
    #####: 3183:      static_cast<T*>(lhs)->lease_duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3184:      return;
        -: 3185:    }
    #####: 3186:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
        -: 3187:  }
        -: 3188:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3189:
    #####: 3190:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3191:  {
        -: 3192:    ACE_UNUSED_ARG(lhs);
        -: 3193:    ACE_UNUSED_ARG(field);
        -: 3194:    ACE_UNUSED_ARG(rhs);
    #####: 3195:    if (std::strcmp(field, "kind") == 0) {
    #####: 3196:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 3197:    }
    #####: 3198:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LivelinessQosPolicy)");
        -: 3199:  }
        -: 3200:};
        -: 3201:
        -: 3202:template<>
    #####: 3203:const MetaStruct& getMetaStruct<DDS::LivelinessQosPolicy>()
        -: 3204:{
    #####: 3205:  static MetaStructImpl<DDS::LivelinessQosPolicy> msi;
    #####: 3206:  return msi;
        -: 3207:}
        -: 3208:
    #####: 3209:bool gen_skip_over(Serializer& ser, DDS::LivelinessQosPolicy*)
        -: 3210:{
        -: 3211:  ACE_UNUSED_ARG(ser);
    #####: 3212:  MetaStructImpl<DDS::LivelinessQosPolicy>().getValue(ser, "");
    #####: 3213:  return true;
        -: 3214:}
        -: 3215:
        -: 3216:}  }
        -: 3217:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3218:
        -: 3219:#endif
        -: 3220:
        -: 3221:/* End STRUCT: LivelinessQosPolicy */
        -: 3222:
        -: 3223:
        -: 3224:/* Begin ENUM: ReliabilityQosPolicyKind */
        -: 3225:
        -: 3226:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3227:namespace OpenDDS { namespace DCPS {
        -: 3228:
       12: 3229:bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicyKind& enumval)
        -: 3230:{
        -: 3231:  ACE_UNUSED_ARG(strm);
        -: 3232:  ACE_UNUSED_ARG(enumval);
       12: 3233:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 3234:}
        -: 3235:
    #####: 3236:bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicyKind& enumval)
        -: 3237:{
        -: 3238:  ACE_UNUSED_ARG(strm);
        -: 3239:  ACE_UNUSED_ARG(enumval);
    #####: 3240:  CORBA::ULong temp = 0;
    #####: 3241:  if (strm >> temp) {
    #####: 3242:    enumval = static_cast<DDS::ReliabilityQosPolicyKind>(temp);
    #####: 3243:    return true;
        -: 3244:  }
    #####: 3245:  return false;
        -: 3246:}
        -: 3247:
        -: 3248:}  }
        -: 3249:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3250:
        -: 3251:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3252:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3253:namespace OpenDDS { namespace DCPS {
        -: 3254:
        -: 3255:const char* gen_DDS_ReliabilityQosPolicyKind_names[] = {
        -: 3256:  "BEST_EFFORT_RELIABILITY_QOS",
        -: 3257:  "RELIABLE_RELIABILITY_QOS"
        -: 3258:};
        -: 3259:const size_t gen_DDS_ReliabilityQosPolicyKind_names_size = 2;
        -: 3260:}  }
        -: 3261:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3262:
        -: 3263:#endif
        -: 3264:
        -: 3265:/* End ENUM: ReliabilityQosPolicyKind */
        -: 3266:
        -: 3267:
        -: 3268:/* Begin STRUCT: ReliabilityQosPolicy */
        -: 3269:
        -: 3270:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3271:namespace OpenDDS { namespace DCPS {
        -: 3272:
       12: 3273:void gen_find_size(const DDS::ReliabilityQosPolicy& stru, size_t& size, size_t& padding)
        -: 3274:{
        -: 3275:  ACE_UNUSED_ARG(stru);
        -: 3276:  ACE_UNUSED_ARG(size);
        -: 3277:  ACE_UNUSED_ARG(padding);
       12: 3278:  find_size_ulong(size, padding);
       12: 3279:  gen_find_size(stru.max_blocking_time, size, padding);
       12: 3280:}
        -: 3281:
       12: 3282:bool operator<<(Serializer& strm, const DDS::ReliabilityQosPolicy& stru)
        -: 3283:{
        -: 3284:  ACE_UNUSED_ARG(strm);
        -: 3285:  ACE_UNUSED_ARG(stru);
       12: 3286:  return (strm << stru.kind)
       12: 3287:    && (strm << stru.max_blocking_time);
        -: 3288:}
        -: 3289:
    #####: 3290:bool operator>>(Serializer& strm, DDS::ReliabilityQosPolicy& stru)
        -: 3291:{
        -: 3292:  ACE_UNUSED_ARG(strm);
        -: 3293:  ACE_UNUSED_ARG(stru);
    #####: 3294:  return (strm >> stru.kind)
    #####: 3295:    && (strm >> stru.max_blocking_time);
        -: 3296:}
        -: 3297:
        -: 3298:}  }
        -: 3299:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3300:
        -: 3301:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3302:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3303:namespace OpenDDS { namespace DCPS {
        -: 3304:
        -: 3305:template<>
    #####: 3306:struct MetaStructImpl<DDS::ReliabilityQosPolicy> : MetaStruct {
        -: 3307:  typedef DDS::ReliabilityQosPolicy T;
        -: 3308:
        -: 3309:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3310:  void* allocate() const { return new T; }
        -: 3311:
    #####: 3312:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3313:
    #####: 3314:  size_t numDcpsKeys() const { return 0; }
        -: 3315:
        -: 3316:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3317:
    #####: 3318:  bool isDcpsKey(const char* field) const
        -: 3319:  {
        -: 3320:    ACE_UNUSED_ARG(field);
    #####: 3321:    return false;
        -: 3322:  }
        -: 3323:
    #####: 3324:  Value getValue(const void* stru, const char* field) const
        -: 3325:  {
    #####: 3326:    const DDS::ReliabilityQosPolicy& typed = *static_cast<const DDS::ReliabilityQosPolicy*>(stru);
    #####: 3327:    if (std::strcmp(field, "kind") == 0) {
    #####: 3328:      return gen_DDS_ReliabilityQosPolicyKind_names[typed.kind];
        -: 3329:    }
    #####: 3330:    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
    #####: 3331:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.max_blocking_time, field + 18);
        -: 3332:    }
        -: 3333:    ACE_UNUSED_ARG(typed);
    #####: 3334:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
        -: 3335:  }
        -: 3336:
    #####: 3337:  Value getValue(Serializer& ser, const char* field) const
        -: 3338:  {
    #####: 3339:    if (std::strcmp(field, "kind") == 0) {
        -: 3340:      ACE_CDR::ULong val;
    #####: 3341:      if (!(ser >> val)) {
    #####: 3342:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 3343:      }
    #####: 3344:      return val;
        -: 3345:    } else {
    #####: 3346:      if (!ser.skip(1, 4)) {
    #####: 3347:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 3348:      }
        -: 3349:    }
    #####: 3350:    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
    #####: 3351:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 18);
        -: 3352:    } else {
    #####: 3353:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 3354:        throw std::runtime_error("Field 'max_blocking_time' could not be skipped");
        -: 3355:      }
        -: 3356:    }
    #####: 3357:    if (!field[0]) {
    #####: 3358:      return 0;
        -: 3359:    }
    #####: 3360:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ReliabilityQosPolicy");
        -: 3361:  }
        -: 3362:
    #####: 3363:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3364:  {
        -: 3365:    ACE_UNUSED_ARG(next);
    #####: 3366:    if (std::strcmp(field, "kind") == 0) {
    #####: 3367:      return make_field_cmp(&T::kind, next);
        -: 3368:    }
    #####: 3369:    if (std::strncmp(field, "max_blocking_time.", 18) == 0) {
    #####: 3370:      return make_struct_cmp(&T::max_blocking_time, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 18), next);
        -: 3371:    }
    #####: 3372:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
        -: 3373:  }
        -: 3374:
        -: 3375:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3376:  const char** getFieldNames() const
        -: 3377:  {
        -: 3378:    static const char* names[] = {"kind", "max_blocking_time", 0};
    #####: 3379:    return names;
        -: 3380:  }
        -: 3381:
    #####: 3382:  const void* getRawField(const void* stru, const char* field) const
        -: 3383:  {
    #####: 3384:    if (std::strcmp(field, "kind") == 0) {
    #####: 3385:      return &static_cast<const T*>(stru)->kind;
        -: 3386:    }
    #####: 3387:    if (std::strcmp(field, "max_blocking_time") == 0) {
    #####: 3388:      return &static_cast<const T*>(stru)->max_blocking_time;
        -: 3389:    }
    #####: 3390:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
        -: 3391:  }
        -: 3392:
    #####: 3393:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3394:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3395:  {
        -: 3396:    ACE_UNUSED_ARG(lhs);
        -: 3397:    ACE_UNUSED_ARG(field);
        -: 3398:    ACE_UNUSED_ARG(rhs);
        -: 3399:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3400:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3401:    if (std::strcmp(field, "kind") == 0) {
    #####: 3402:      static_cast<T*>(lhs)->kind = *static_cast<const DDS::ReliabilityQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3403:      return;
        -: 3404:    }
    #####: 3405:    if (std::strcmp(field, "max_blocking_time") == 0) {
    #####: 3406:      static_cast<T*>(lhs)->max_blocking_time = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3407:      return;
        -: 3408:    }
    #####: 3409:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
        -: 3410:  }
        -: 3411:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3412:
    #####: 3413:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3414:  {
        -: 3415:    ACE_UNUSED_ARG(lhs);
        -: 3416:    ACE_UNUSED_ARG(field);
        -: 3417:    ACE_UNUSED_ARG(rhs);
    #####: 3418:    if (std::strcmp(field, "kind") == 0) {
    #####: 3419:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 3420:    }
    #####: 3421:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReliabilityQosPolicy)");
        -: 3422:  }
        -: 3423:};
        -: 3424:
        -: 3425:template<>
    #####: 3426:const MetaStruct& getMetaStruct<DDS::ReliabilityQosPolicy>()
        -: 3427:{
    #####: 3428:  static MetaStructImpl<DDS::ReliabilityQosPolicy> msi;
    #####: 3429:  return msi;
        -: 3430:}
        -: 3431:
    #####: 3432:bool gen_skip_over(Serializer& ser, DDS::ReliabilityQosPolicy*)
        -: 3433:{
        -: 3434:  ACE_UNUSED_ARG(ser);
    #####: 3435:  MetaStructImpl<DDS::ReliabilityQosPolicy>().getValue(ser, "");
    #####: 3436:  return true;
        -: 3437:}
        -: 3438:
        -: 3439:}  }
        -: 3440:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3441:
        -: 3442:#endif
        -: 3443:
        -: 3444:/* End STRUCT: ReliabilityQosPolicy */
        -: 3445:
        -: 3446:
        -: 3447:/* Begin ENUM: DestinationOrderQosPolicyKind */
        -: 3448:
        -: 3449:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3450:namespace OpenDDS { namespace DCPS {
        -: 3451:
       12: 3452:bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicyKind& enumval)
        -: 3453:{
        -: 3454:  ACE_UNUSED_ARG(strm);
        -: 3455:  ACE_UNUSED_ARG(enumval);
       12: 3456:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 3457:}
        -: 3458:
    #####: 3459:bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicyKind& enumval)
        -: 3460:{
        -: 3461:  ACE_UNUSED_ARG(strm);
        -: 3462:  ACE_UNUSED_ARG(enumval);
    #####: 3463:  CORBA::ULong temp = 0;
    #####: 3464:  if (strm >> temp) {
    #####: 3465:    enumval = static_cast<DDS::DestinationOrderQosPolicyKind>(temp);
    #####: 3466:    return true;
        -: 3467:  }
    #####: 3468:  return false;
        -: 3469:}
        -: 3470:
        -: 3471:}  }
        -: 3472:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3473:
        -: 3474:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3475:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3476:namespace OpenDDS { namespace DCPS {
        -: 3477:
        -: 3478:const char* gen_DDS_DestinationOrderQosPolicyKind_names[] = {
        -: 3479:  "BY_RECEPTION_TIMESTAMP_DESTINATIONORDER_QOS",
        -: 3480:  "BY_SOURCE_TIMESTAMP_DESTINATIONORDER_QOS"
        -: 3481:};
        -: 3482:const size_t gen_DDS_DestinationOrderQosPolicyKind_names_size = 2;
        -: 3483:}  }
        -: 3484:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3485:
        -: 3486:#endif
        -: 3487:
        -: 3488:/* End ENUM: DestinationOrderQosPolicyKind */
        -: 3489:
        -: 3490:
        -: 3491:/* Begin STRUCT: DestinationOrderQosPolicy */
        -: 3492:
        -: 3493:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3494:namespace OpenDDS { namespace DCPS {
        -: 3495:
       12: 3496:void gen_find_size(const DDS::DestinationOrderQosPolicy& stru, size_t& size, size_t& padding)
        -: 3497:{
        -: 3498:  ACE_UNUSED_ARG(stru);
        -: 3499:  ACE_UNUSED_ARG(size);
        -: 3500:  ACE_UNUSED_ARG(padding);
       12: 3501:  find_size_ulong(size, padding);
       12: 3502:}
        -: 3503:
       12: 3504:bool operator<<(Serializer& strm, const DDS::DestinationOrderQosPolicy& stru)
        -: 3505:{
        -: 3506:  ACE_UNUSED_ARG(strm);
        -: 3507:  ACE_UNUSED_ARG(stru);
       12: 3508:  return (strm << stru.kind);
        -: 3509:}
        -: 3510:
    #####: 3511:bool operator>>(Serializer& strm, DDS::DestinationOrderQosPolicy& stru)
        -: 3512:{
        -: 3513:  ACE_UNUSED_ARG(strm);
        -: 3514:  ACE_UNUSED_ARG(stru);
    #####: 3515:  return (strm >> stru.kind);
        -: 3516:}
        -: 3517:
        -: 3518:}  }
        -: 3519:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3520:
        -: 3521:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3522:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3523:namespace OpenDDS { namespace DCPS {
        -: 3524:
        -: 3525:template<>
    #####: 3526:struct MetaStructImpl<DDS::DestinationOrderQosPolicy> : MetaStruct {
        -: 3527:  typedef DDS::DestinationOrderQosPolicy T;
        -: 3528:
        -: 3529:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3530:  void* allocate() const { return new T; }
        -: 3531:
    #####: 3532:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3533:
    #####: 3534:  size_t numDcpsKeys() const { return 0; }
        -: 3535:
        -: 3536:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3537:
    #####: 3538:  bool isDcpsKey(const char* field) const
        -: 3539:  {
        -: 3540:    ACE_UNUSED_ARG(field);
    #####: 3541:    return false;
        -: 3542:  }
        -: 3543:
    #####: 3544:  Value getValue(const void* stru, const char* field) const
        -: 3545:  {
    #####: 3546:    const DDS::DestinationOrderQosPolicy& typed = *static_cast<const DDS::DestinationOrderQosPolicy*>(stru);
    #####: 3547:    if (std::strcmp(field, "kind") == 0) {
    #####: 3548:      return gen_DDS_DestinationOrderQosPolicyKind_names[typed.kind];
        -: 3549:    }
        -: 3550:    ACE_UNUSED_ARG(typed);
    #####: 3551:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
        -: 3552:  }
        -: 3553:
    #####: 3554:  Value getValue(Serializer& ser, const char* field) const
        -: 3555:  {
    #####: 3556:    if (std::strcmp(field, "kind") == 0) {
        -: 3557:      ACE_CDR::ULong val;
    #####: 3558:      if (!(ser >> val)) {
    #####: 3559:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 3560:      }
    #####: 3561:      return val;
        -: 3562:    } else {
    #####: 3563:      if (!ser.skip(1, 4)) {
    #####: 3564:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 3565:      }
        -: 3566:    }
    #####: 3567:    if (!field[0]) {
    #####: 3568:      return 0;
        -: 3569:    }
    #####: 3570:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DestinationOrderQosPolicy");
        -: 3571:  }
        -: 3572:
    #####: 3573:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3574:  {
        -: 3575:    ACE_UNUSED_ARG(next);
    #####: 3576:    if (std::strcmp(field, "kind") == 0) {
    #####: 3577:      return make_field_cmp(&T::kind, next);
        -: 3578:    }
    #####: 3579:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
        -: 3580:  }
        -: 3581:
        -: 3582:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3583:  const char** getFieldNames() const
        -: 3584:  {
        -: 3585:    static const char* names[] = {"kind", 0};
    #####: 3586:    return names;
        -: 3587:  }
        -: 3588:
    #####: 3589:  const void* getRawField(const void* stru, const char* field) const
        -: 3590:  {
    #####: 3591:    if (std::strcmp(field, "kind") == 0) {
    #####: 3592:      return &static_cast<const T*>(stru)->kind;
        -: 3593:    }
    #####: 3594:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
        -: 3595:  }
        -: 3596:
    #####: 3597:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3598:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3599:  {
        -: 3600:    ACE_UNUSED_ARG(lhs);
        -: 3601:    ACE_UNUSED_ARG(field);
        -: 3602:    ACE_UNUSED_ARG(rhs);
        -: 3603:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3604:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3605:    if (std::strcmp(field, "kind") == 0) {
    #####: 3606:      static_cast<T*>(lhs)->kind = *static_cast<const DDS::DestinationOrderQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3607:      return;
        -: 3608:    }
    #####: 3609:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
        -: 3610:  }
        -: 3611:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3612:
    #####: 3613:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3614:  {
        -: 3615:    ACE_UNUSED_ARG(lhs);
        -: 3616:    ACE_UNUSED_ARG(field);
        -: 3617:    ACE_UNUSED_ARG(rhs);
    #####: 3618:    if (std::strcmp(field, "kind") == 0) {
    #####: 3619:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 3620:    }
    #####: 3621:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DestinationOrderQosPolicy)");
        -: 3622:  }
        -: 3623:};
        -: 3624:
        -: 3625:template<>
    #####: 3626:const MetaStruct& getMetaStruct<DDS::DestinationOrderQosPolicy>()
        -: 3627:{
    #####: 3628:  static MetaStructImpl<DDS::DestinationOrderQosPolicy> msi;
    #####: 3629:  return msi;
        -: 3630:}
        -: 3631:
    #####: 3632:bool gen_skip_over(Serializer& ser, DDS::DestinationOrderQosPolicy*)
        -: 3633:{
        -: 3634:  ACE_UNUSED_ARG(ser);
    #####: 3635:  MetaStructImpl<DDS::DestinationOrderQosPolicy>().getValue(ser, "");
    #####: 3636:  return true;
        -: 3637:}
        -: 3638:
        -: 3639:}  }
        -: 3640:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3641:
        -: 3642:#endif
        -: 3643:
        -: 3644:/* End STRUCT: DestinationOrderQosPolicy */
        -: 3645:
        -: 3646:
        -: 3647:/* Begin STRUCT: HistoryQosPolicy */
        -: 3648:
        -: 3649:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3650:namespace OpenDDS { namespace DCPS {
        -: 3651:
        6: 3652:void gen_find_size(const DDS::HistoryQosPolicy& stru, size_t& size, size_t& padding)
        -: 3653:{
        -: 3654:  ACE_UNUSED_ARG(stru);
        -: 3655:  ACE_UNUSED_ARG(size);
        -: 3656:  ACE_UNUSED_ARG(padding);
        6: 3657:  find_size_ulong(size, padding);
        6: 3658:  if ((size + padding) % 4) {
    #####: 3659:    padding += 4 - ((size + padding) % 4);
        -: 3660:  }
        6: 3661:  size += gen_max_marshaled_size(stru.depth);
        6: 3662:}
        -: 3663:
        6: 3664:bool operator<<(Serializer& strm, const DDS::HistoryQosPolicy& stru)
        -: 3665:{
        -: 3666:  ACE_UNUSED_ARG(strm);
        -: 3667:  ACE_UNUSED_ARG(stru);
        6: 3668:  return (strm << stru.kind)
        6: 3669:    && (strm << stru.depth);
        -: 3670:}
        -: 3671:
    #####: 3672:bool operator>>(Serializer& strm, DDS::HistoryQosPolicy& stru)
        -: 3673:{
        -: 3674:  ACE_UNUSED_ARG(strm);
        -: 3675:  ACE_UNUSED_ARG(stru);
    #####: 3676:  return (strm >> stru.kind)
    #####: 3677:    && (strm >> stru.depth);
        -: 3678:}
        -: 3679:
        -: 3680:}  }
        -: 3681:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3682:
        -: 3683:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3684:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3685:namespace OpenDDS { namespace DCPS {
        -: 3686:
        -: 3687:template<>
    #####: 3688:struct MetaStructImpl<DDS::HistoryQosPolicy> : MetaStruct {
        -: 3689:  typedef DDS::HistoryQosPolicy T;
        -: 3690:
        -: 3691:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3692:  void* allocate() const { return new T; }
        -: 3693:
    #####: 3694:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3695:
    #####: 3696:  size_t numDcpsKeys() const { return 0; }
        -: 3697:
        -: 3698:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3699:
    #####: 3700:  bool isDcpsKey(const char* field) const
        -: 3701:  {
        -: 3702:    ACE_UNUSED_ARG(field);
    #####: 3703:    return false;
        -: 3704:  }
        -: 3705:
    #####: 3706:  Value getValue(const void* stru, const char* field) const
        -: 3707:  {
    #####: 3708:    const DDS::HistoryQosPolicy& typed = *static_cast<const DDS::HistoryQosPolicy*>(stru);
    #####: 3709:    if (std::strcmp(field, "kind") == 0) {
    #####: 3710:      return gen_DDS_HistoryQosPolicyKind_names[typed.kind];
        -: 3711:    }
    #####: 3712:    if (std::strcmp(field, "depth") == 0) {
    #####: 3713:      return typed.depth;
        -: 3714:    }
        -: 3715:    ACE_UNUSED_ARG(typed);
    #####: 3716:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
        -: 3717:  }
        -: 3718:
    #####: 3719:  Value getValue(Serializer& ser, const char* field) const
        -: 3720:  {
    #####: 3721:    if (std::strcmp(field, "kind") == 0) {
        -: 3722:      ACE_CDR::ULong val;
    #####: 3723:      if (!(ser >> val)) {
    #####: 3724:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 3725:      }
    #####: 3726:      return val;
        -: 3727:    } else {
    #####: 3728:      if (!ser.skip(1, 4)) {
    #####: 3729:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 3730:      }
        -: 3731:    }
    #####: 3732:    if (std::strcmp(field, "depth") == 0) {
        -: 3733:      ACE_CDR::Long val;
    #####: 3734:      if (!(ser >> val)) {
    #####: 3735:        throw std::runtime_error("Field 'depth' could not be deserialized");
        -: 3736:      }
    #####: 3737:      return val;
        -: 3738:    } else {
    #####: 3739:      if (!ser.skip(1, 4)) {
    #####: 3740:        throw std::runtime_error("Field 'depth' could not be skipped");
        -: 3741:      }
        -: 3742:    }
    #####: 3743:    if (!field[0]) {
    #####: 3744:      return 0;
        -: 3745:    }
    #####: 3746:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::HistoryQosPolicy");
        -: 3747:  }
        -: 3748:
    #####: 3749:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3750:  {
        -: 3751:    ACE_UNUSED_ARG(next);
    #####: 3752:    if (std::strcmp(field, "kind") == 0) {
    #####: 3753:      return make_field_cmp(&T::kind, next);
        -: 3754:    }
    #####: 3755:    if (std::strcmp(field, "depth") == 0) {
    #####: 3756:      return make_field_cmp(&T::depth, next);
        -: 3757:    }
    #####: 3758:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
        -: 3759:  }
        -: 3760:
        -: 3761:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3762:  const char** getFieldNames() const
        -: 3763:  {
        -: 3764:    static const char* names[] = {"kind", "depth", 0};
    #####: 3765:    return names;
        -: 3766:  }
        -: 3767:
    #####: 3768:  const void* getRawField(const void* stru, const char* field) const
        -: 3769:  {
    #####: 3770:    if (std::strcmp(field, "kind") == 0) {
    #####: 3771:      return &static_cast<const T*>(stru)->kind;
        -: 3772:    }
    #####: 3773:    if (std::strcmp(field, "depth") == 0) {
    #####: 3774:      return &static_cast<const T*>(stru)->depth;
        -: 3775:    }
    #####: 3776:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
        -: 3777:  }
        -: 3778:
    #####: 3779:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3780:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3781:  {
        -: 3782:    ACE_UNUSED_ARG(lhs);
        -: 3783:    ACE_UNUSED_ARG(field);
        -: 3784:    ACE_UNUSED_ARG(rhs);
        -: 3785:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3786:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3787:    if (std::strcmp(field, "kind") == 0) {
    #####: 3788:      static_cast<T*>(lhs)->kind = *static_cast<const DDS::HistoryQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3789:      return;
        -: 3790:    }
    #####: 3791:    if (std::strcmp(field, "depth") == 0) {
    #####: 3792:      static_cast<T*>(lhs)->depth = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3793:      return;
        -: 3794:    }
    #####: 3795:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
        -: 3796:  }
        -: 3797:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3798:
    #####: 3799:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3800:  {
        -: 3801:    ACE_UNUSED_ARG(lhs);
        -: 3802:    ACE_UNUSED_ARG(field);
        -: 3803:    ACE_UNUSED_ARG(rhs);
    #####: 3804:    if (std::strcmp(field, "kind") == 0) {
    #####: 3805:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 3806:    }
    #####: 3807:    if (std::strcmp(field, "depth") == 0) {
    #####: 3808:      return static_cast<const T*>(lhs)->depth == static_cast<const T*>(rhs)->depth;
        -: 3809:    }
    #####: 3810:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::HistoryQosPolicy)");
        -: 3811:  }
        -: 3812:};
        -: 3813:
        -: 3814:template<>
    #####: 3815:const MetaStruct& getMetaStruct<DDS::HistoryQosPolicy>()
        -: 3816:{
    #####: 3817:  static MetaStructImpl<DDS::HistoryQosPolicy> msi;
    #####: 3818:  return msi;
        -: 3819:}
        -: 3820:
    #####: 3821:bool gen_skip_over(Serializer& ser, DDS::HistoryQosPolicy*)
        -: 3822:{
        -: 3823:  ACE_UNUSED_ARG(ser);
    #####: 3824:  MetaStructImpl<DDS::HistoryQosPolicy>().getValue(ser, "");
    #####: 3825:  return true;
        -: 3826:}
        -: 3827:
        -: 3828:}  }
        -: 3829:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3830:
        -: 3831:#endif
        -: 3832:
        -: 3833:/* End STRUCT: HistoryQosPolicy */
        -: 3834:
        -: 3835:
        -: 3836:/* Begin STRUCT: ResourceLimitsQosPolicy */
        -: 3837:
        -: 3838:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3839:namespace OpenDDS { namespace DCPS {
        -: 3840:
        6: 3841:void gen_find_size(const DDS::ResourceLimitsQosPolicy& stru, size_t& size, size_t& padding)
        -: 3842:{
        -: 3843:  ACE_UNUSED_ARG(stru);
        -: 3844:  ACE_UNUSED_ARG(size);
        -: 3845:  ACE_UNUSED_ARG(padding);
        6: 3846:  if ((size + padding) % 4) {
    #####: 3847:    padding += 4 - ((size + padding) % 4);
        -: 3848:  }
        6: 3849:  size += gen_max_marshaled_size(stru.max_samples);
        6: 3850:  if ((size + padding) % 4) {
    #####: 3851:    padding += 4 - ((size + padding) % 4);
        -: 3852:  }
        6: 3853:  size += gen_max_marshaled_size(stru.max_instances);
        6: 3854:  if ((size + padding) % 4) {
    #####: 3855:    padding += 4 - ((size + padding) % 4);
        -: 3856:  }
        6: 3857:  size += gen_max_marshaled_size(stru.max_samples_per_instance);
        6: 3858:}
        -: 3859:
        6: 3860:bool operator<<(Serializer& strm, const DDS::ResourceLimitsQosPolicy& stru)
        -: 3861:{
        -: 3862:  ACE_UNUSED_ARG(strm);
        -: 3863:  ACE_UNUSED_ARG(stru);
        6: 3864:  return (strm << stru.max_samples)
        6: 3865:    && (strm << stru.max_instances)
       12: 3866:    && (strm << stru.max_samples_per_instance);
        -: 3867:}
        -: 3868:
    #####: 3869:bool operator>>(Serializer& strm, DDS::ResourceLimitsQosPolicy& stru)
        -: 3870:{
        -: 3871:  ACE_UNUSED_ARG(strm);
        -: 3872:  ACE_UNUSED_ARG(stru);
    #####: 3873:  return (strm >> stru.max_samples)
    #####: 3874:    && (strm >> stru.max_instances)
    #####: 3875:    && (strm >> stru.max_samples_per_instance);
        -: 3876:}
        -: 3877:
        -: 3878:}  }
        -: 3879:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3880:
        -: 3881:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3882:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3883:namespace OpenDDS { namespace DCPS {
        -: 3884:
        -: 3885:template<>
    #####: 3886:struct MetaStructImpl<DDS::ResourceLimitsQosPolicy> : MetaStruct {
        -: 3887:  typedef DDS::ResourceLimitsQosPolicy T;
        -: 3888:
        -: 3889:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3890:  void* allocate() const { return new T; }
        -: 3891:
    #####: 3892:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3893:
    #####: 3894:  size_t numDcpsKeys() const { return 0; }
        -: 3895:
        -: 3896:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3897:
    #####: 3898:  bool isDcpsKey(const char* field) const
        -: 3899:  {
        -: 3900:    ACE_UNUSED_ARG(field);
    #####: 3901:    return false;
        -: 3902:  }
        -: 3903:
    #####: 3904:  Value getValue(const void* stru, const char* field) const
        -: 3905:  {
    #####: 3906:    const DDS::ResourceLimitsQosPolicy& typed = *static_cast<const DDS::ResourceLimitsQosPolicy*>(stru);
    #####: 3907:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 3908:      return typed.max_samples;
        -: 3909:    }
    #####: 3910:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 3911:      return typed.max_instances;
        -: 3912:    }
    #####: 3913:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 3914:      return typed.max_samples_per_instance;
        -: 3915:    }
        -: 3916:    ACE_UNUSED_ARG(typed);
    #####: 3917:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
        -: 3918:  }
        -: 3919:
    #####: 3920:  Value getValue(Serializer& ser, const char* field) const
        -: 3921:  {
    #####: 3922:    if (std::strcmp(field, "max_samples") == 0) {
        -: 3923:      ACE_CDR::Long val;
    #####: 3924:      if (!(ser >> val)) {
    #####: 3925:        throw std::runtime_error("Field 'max_samples' could not be deserialized");
        -: 3926:      }
    #####: 3927:      return val;
        -: 3928:    } else {
    #####: 3929:      if (!ser.skip(1, 4)) {
    #####: 3930:        throw std::runtime_error("Field 'max_samples' could not be skipped");
        -: 3931:      }
        -: 3932:    }
    #####: 3933:    if (std::strcmp(field, "max_instances") == 0) {
        -: 3934:      ACE_CDR::Long val;
    #####: 3935:      if (!(ser >> val)) {
    #####: 3936:        throw std::runtime_error("Field 'max_instances' could not be deserialized");
        -: 3937:      }
    #####: 3938:      return val;
        -: 3939:    } else {
    #####: 3940:      if (!ser.skip(1, 4)) {
    #####: 3941:        throw std::runtime_error("Field 'max_instances' could not be skipped");
        -: 3942:      }
        -: 3943:    }
    #####: 3944:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
        -: 3945:      ACE_CDR::Long val;
    #####: 3946:      if (!(ser >> val)) {
    #####: 3947:        throw std::runtime_error("Field 'max_samples_per_instance' could not be deserialized");
        -: 3948:      }
    #####: 3949:      return val;
        -: 3950:    } else {
    #####: 3951:      if (!ser.skip(1, 4)) {
    #####: 3952:        throw std::runtime_error("Field 'max_samples_per_instance' could not be skipped");
        -: 3953:      }
        -: 3954:    }
    #####: 3955:    if (!field[0]) {
    #####: 3956:      return 0;
        -: 3957:    }
    #####: 3958:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ResourceLimitsQosPolicy");
        -: 3959:  }
        -: 3960:
    #####: 3961:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3962:  {
        -: 3963:    ACE_UNUSED_ARG(next);
    #####: 3964:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 3965:      return make_field_cmp(&T::max_samples, next);
        -: 3966:    }
    #####: 3967:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 3968:      return make_field_cmp(&T::max_instances, next);
        -: 3969:    }
    #####: 3970:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 3971:      return make_field_cmp(&T::max_samples_per_instance, next);
        -: 3972:    }
    #####: 3973:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
        -: 3974:  }
        -: 3975:
        -: 3976:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3977:  const char** getFieldNames() const
        -: 3978:  {
        -: 3979:    static const char* names[] = {"max_samples", "max_instances", "max_samples_per_instance", 0};
    #####: 3980:    return names;
        -: 3981:  }
        -: 3982:
    #####: 3983:  const void* getRawField(const void* stru, const char* field) const
        -: 3984:  {
    #####: 3985:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 3986:      return &static_cast<const T*>(stru)->max_samples;
        -: 3987:    }
    #####: 3988:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 3989:      return &static_cast<const T*>(stru)->max_instances;
        -: 3990:    }
    #####: 3991:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 3992:      return &static_cast<const T*>(stru)->max_samples_per_instance;
        -: 3993:    }
    #####: 3994:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
        -: 3995:  }
        -: 3996:
    #####: 3997:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3998:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3999:  {
        -: 4000:    ACE_UNUSED_ARG(lhs);
        -: 4001:    ACE_UNUSED_ARG(field);
        -: 4002:    ACE_UNUSED_ARG(rhs);
        -: 4003:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 4004:    ACE_UNUSED_ARG(rhsMeta);
    #####: 4005:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 4006:      static_cast<T*>(lhs)->max_samples = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4007:      return;
        -: 4008:    }
    #####: 4009:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 4010:      static_cast<T*>(lhs)->max_instances = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4011:      return;
        -: 4012:    }
    #####: 4013:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 4014:      static_cast<T*>(lhs)->max_samples_per_instance = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4015:      return;
        -: 4016:    }
    #####: 4017:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
        -: 4018:  }
        -: 4019:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4020:
    #####: 4021:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 4022:  {
        -: 4023:    ACE_UNUSED_ARG(lhs);
        -: 4024:    ACE_UNUSED_ARG(field);
        -: 4025:    ACE_UNUSED_ARG(rhs);
    #####: 4026:    if (std::strcmp(field, "max_samples") == 0) {
    #####: 4027:      return static_cast<const T*>(lhs)->max_samples == static_cast<const T*>(rhs)->max_samples;
        -: 4028:    }
    #####: 4029:    if (std::strcmp(field, "max_instances") == 0) {
    #####: 4030:      return static_cast<const T*>(lhs)->max_instances == static_cast<const T*>(rhs)->max_instances;
        -: 4031:    }
    #####: 4032:    if (std::strcmp(field, "max_samples_per_instance") == 0) {
    #####: 4033:      return static_cast<const T*>(lhs)->max_samples_per_instance == static_cast<const T*>(rhs)->max_samples_per_instance;
        -: 4034:    }
    #####: 4035:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ResourceLimitsQosPolicy)");
        -: 4036:  }
        -: 4037:};
        -: 4038:
        -: 4039:template<>
    #####: 4040:const MetaStruct& getMetaStruct<DDS::ResourceLimitsQosPolicy>()
        -: 4041:{
    #####: 4042:  static MetaStructImpl<DDS::ResourceLimitsQosPolicy> msi;
    #####: 4043:  return msi;
        -: 4044:}
        -: 4045:
    #####: 4046:bool gen_skip_over(Serializer& ser, DDS::ResourceLimitsQosPolicy*)
        -: 4047:{
        -: 4048:  ACE_UNUSED_ARG(ser);
    #####: 4049:  MetaStructImpl<DDS::ResourceLimitsQosPolicy>().getValue(ser, "");
    #####: 4050:  return true;
        -: 4051:}
        -: 4052:
        -: 4053:}  }
        -: 4054:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4055:
        -: 4056:#endif
        -: 4057:
        -: 4058:/* End STRUCT: ResourceLimitsQosPolicy */
        -: 4059:
        -: 4060:
        -: 4061:/* Begin STRUCT: TransportPriorityQosPolicy */
        -: 4062:
        -: 4063:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4064:namespace OpenDDS { namespace DCPS {
        -: 4065:
        6: 4066:void gen_find_size(const DDS::TransportPriorityQosPolicy& stru, size_t& size, size_t& padding)
        -: 4067:{
        -: 4068:  ACE_UNUSED_ARG(stru);
        -: 4069:  ACE_UNUSED_ARG(size);
        -: 4070:  ACE_UNUSED_ARG(padding);
        6: 4071:  if ((size + padding) % 4) {
    #####: 4072:    padding += 4 - ((size + padding) % 4);
        -: 4073:  }
        6: 4074:  size += gen_max_marshaled_size(stru.value);
        6: 4075:}
        -: 4076:
        6: 4077:bool operator<<(Serializer& strm, const DDS::TransportPriorityQosPolicy& stru)
        -: 4078:{
        -: 4079:  ACE_UNUSED_ARG(strm);
        -: 4080:  ACE_UNUSED_ARG(stru);
        6: 4081:  return (strm << stru.value);
        -: 4082:}
        -: 4083:
    #####: 4084:bool operator>>(Serializer& strm, DDS::TransportPriorityQosPolicy& stru)
        -: 4085:{
        -: 4086:  ACE_UNUSED_ARG(strm);
        -: 4087:  ACE_UNUSED_ARG(stru);
    #####: 4088:  return (strm >> stru.value);
        -: 4089:}
        -: 4090:
        -: 4091:}  }
        -: 4092:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4093:
        -: 4094:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4095:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4096:namespace OpenDDS { namespace DCPS {
        -: 4097:
        -: 4098:template<>
    #####: 4099:struct MetaStructImpl<DDS::TransportPriorityQosPolicy> : MetaStruct {
        -: 4100:  typedef DDS::TransportPriorityQosPolicy T;
        -: 4101:
        -: 4102:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4103:  void* allocate() const { return new T; }
        -: 4104:
    #####: 4105:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 4106:
    #####: 4107:  size_t numDcpsKeys() const { return 0; }
        -: 4108:
        -: 4109:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4110:
    #####: 4111:  bool isDcpsKey(const char* field) const
        -: 4112:  {
        -: 4113:    ACE_UNUSED_ARG(field);
    #####: 4114:    return false;
        -: 4115:  }
        -: 4116:
    #####: 4117:  Value getValue(const void* stru, const char* field) const
        -: 4118:  {
    #####: 4119:    const DDS::TransportPriorityQosPolicy& typed = *static_cast<const DDS::TransportPriorityQosPolicy*>(stru);
    #####: 4120:    if (std::strcmp(field, "value") == 0) {
    #####: 4121:      return typed.value;
        -: 4122:    }
        -: 4123:    ACE_UNUSED_ARG(typed);
    #####: 4124:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
        -: 4125:  }
        -: 4126:
    #####: 4127:  Value getValue(Serializer& ser, const char* field) const
        -: 4128:  {
    #####: 4129:    if (std::strcmp(field, "value") == 0) {
        -: 4130:      ACE_CDR::Long val;
    #####: 4131:      if (!(ser >> val)) {
    #####: 4132:        throw std::runtime_error("Field 'value' could not be deserialized");
        -: 4133:      }
    #####: 4134:      return val;
        -: 4135:    } else {
    #####: 4136:      if (!ser.skip(1, 4)) {
    #####: 4137:        throw std::runtime_error("Field 'value' could not be skipped");
        -: 4138:      }
        -: 4139:    }
    #####: 4140:    if (!field[0]) {
    #####: 4141:      return 0;
        -: 4142:    }
    #####: 4143:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TransportPriorityQosPolicy");
        -: 4144:  }
        -: 4145:
    #####: 4146:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 4147:  {
        -: 4148:    ACE_UNUSED_ARG(next);
    #####: 4149:    if (std::strcmp(field, "value") == 0) {
    #####: 4150:      return make_field_cmp(&T::value, next);
        -: 4151:    }
    #####: 4152:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
        -: 4153:  }
        -: 4154:
        -: 4155:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4156:  const char** getFieldNames() const
        -: 4157:  {
        -: 4158:    static const char* names[] = {"value", 0};
    #####: 4159:    return names;
        -: 4160:  }
        -: 4161:
    #####: 4162:  const void* getRawField(const void* stru, const char* field) const
        -: 4163:  {
    #####: 4164:    if (std::strcmp(field, "value") == 0) {
    #####: 4165:      return &static_cast<const T*>(stru)->value;
        -: 4166:    }
    #####: 4167:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
        -: 4168:  }
        -: 4169:
    #####: 4170:  void assign(void* lhs, const char* field, const void* rhs,
        -: 4171:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 4172:  {
        -: 4173:    ACE_UNUSED_ARG(lhs);
        -: 4174:    ACE_UNUSED_ARG(field);
        -: 4175:    ACE_UNUSED_ARG(rhs);
        -: 4176:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 4177:    ACE_UNUSED_ARG(rhsMeta);
    #####: 4178:    if (std::strcmp(field, "value") == 0) {
    #####: 4179:      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4180:      return;
        -: 4181:    }
    #####: 4182:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
        -: 4183:  }
        -: 4184:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4185:
    #####: 4186:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 4187:  {
        -: 4188:    ACE_UNUSED_ARG(lhs);
        -: 4189:    ACE_UNUSED_ARG(field);
        -: 4190:    ACE_UNUSED_ARG(rhs);
    #####: 4191:    if (std::strcmp(field, "value") == 0) {
    #####: 4192:      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
        -: 4193:    }
    #####: 4194:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TransportPriorityQosPolicy)");
        -: 4195:  }
        -: 4196:};
        -: 4197:
        -: 4198:template<>
    #####: 4199:const MetaStruct& getMetaStruct<DDS::TransportPriorityQosPolicy>()
        -: 4200:{
    #####: 4201:  static MetaStructImpl<DDS::TransportPriorityQosPolicy> msi;
    #####: 4202:  return msi;
        -: 4203:}
        -: 4204:
    #####: 4205:bool gen_skip_over(Serializer& ser, DDS::TransportPriorityQosPolicy*)
        -: 4206:{
        -: 4207:  ACE_UNUSED_ARG(ser);
    #####: 4208:  MetaStructImpl<DDS::TransportPriorityQosPolicy>().getValue(ser, "");
    #####: 4209:  return true;
        -: 4210:}
        -: 4211:
        -: 4212:}  }
        -: 4213:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4214:
        -: 4215:#endif
        -: 4216:
        -: 4217:/* End STRUCT: TransportPriorityQosPolicy */
        -: 4218:
        -: 4219:
        -: 4220:/* Begin STRUCT: LifespanQosPolicy */
        -: 4221:
        -: 4222:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4223:namespace OpenDDS { namespace DCPS {
        -: 4224:
        9: 4225:void gen_find_size(const DDS::LifespanQosPolicy& stru, size_t& size, size_t& padding)
        -: 4226:{
        -: 4227:  ACE_UNUSED_ARG(stru);
        -: 4228:  ACE_UNUSED_ARG(size);
        -: 4229:  ACE_UNUSED_ARG(padding);
        9: 4230:  gen_find_size(stru.duration, size, padding);
        9: 4231:}
        -: 4232:
        9: 4233:bool operator<<(Serializer& strm, const DDS::LifespanQosPolicy& stru)
        -: 4234:{
        -: 4235:  ACE_UNUSED_ARG(strm);
        -: 4236:  ACE_UNUSED_ARG(stru);
        9: 4237:  return (strm << stru.duration);
        -: 4238:}
        -: 4239:
    #####: 4240:bool operator>>(Serializer& strm, DDS::LifespanQosPolicy& stru)
        -: 4241:{
        -: 4242:  ACE_UNUSED_ARG(strm);
        -: 4243:  ACE_UNUSED_ARG(stru);
    #####: 4244:  return (strm >> stru.duration);
        -: 4245:}
        -: 4246:
        -: 4247:}  }
        -: 4248:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4249:
        -: 4250:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4251:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4252:namespace OpenDDS { namespace DCPS {
        -: 4253:
        -: 4254:template<>
    #####: 4255:struct MetaStructImpl<DDS::LifespanQosPolicy> : MetaStruct {
        -: 4256:  typedef DDS::LifespanQosPolicy T;
        -: 4257:
        -: 4258:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4259:  void* allocate() const { return new T; }
        -: 4260:
    #####: 4261:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 4262:
    #####: 4263:  size_t numDcpsKeys() const { return 0; }
        -: 4264:
        -: 4265:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4266:
    #####: 4267:  bool isDcpsKey(const char* field) const
        -: 4268:  {
        -: 4269:    ACE_UNUSED_ARG(field);
    #####: 4270:    return false;
        -: 4271:  }
        -: 4272:
    #####: 4273:  Value getValue(const void* stru, const char* field) const
        -: 4274:  {
    #####: 4275:    const DDS::LifespanQosPolicy& typed = *static_cast<const DDS::LifespanQosPolicy*>(stru);
    #####: 4276:    if (std::strncmp(field, "duration.", 9) == 0) {
    #####: 4277:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.duration, field + 9);
        -: 4278:    }
        -: 4279:    ACE_UNUSED_ARG(typed);
    #####: 4280:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
        -: 4281:  }
        -: 4282:
    #####: 4283:  Value getValue(Serializer& ser, const char* field) const
        -: 4284:  {
    #####: 4285:    if (std::strncmp(field, "duration.", 9) == 0) {
    #####: 4286:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 9);
        -: 4287:    } else {
    #####: 4288:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 4289:        throw std::runtime_error("Field 'duration' could not be skipped");
        -: 4290:      }
        -: 4291:    }
    #####: 4292:    if (!field[0]) {
    #####: 4293:      return 0;
        -: 4294:    }
    #####: 4295:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::LifespanQosPolicy");
        -: 4296:  }
        -: 4297:
    #####: 4298:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 4299:  {
        -: 4300:    ACE_UNUSED_ARG(next);
    #####: 4301:    if (std::strncmp(field, "duration.", 9) == 0) {
    #####: 4302:      return make_struct_cmp(&T::duration, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 9), next);
        -: 4303:    }
    #####: 4304:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
        -: 4305:  }
        -: 4306:
        -: 4307:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4308:  const char** getFieldNames() const
        -: 4309:  {
        -: 4310:    static const char* names[] = {"duration", 0};
    #####: 4311:    return names;
        -: 4312:  }
        -: 4313:
    #####: 4314:  const void* getRawField(const void* stru, const char* field) const
        -: 4315:  {
    #####: 4316:    if (std::strcmp(field, "duration") == 0) {
    #####: 4317:      return &static_cast<const T*>(stru)->duration;
        -: 4318:    }
    #####: 4319:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
        -: 4320:  }
        -: 4321:
    #####: 4322:  void assign(void* lhs, const char* field, const void* rhs,
        -: 4323:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 4324:  {
        -: 4325:    ACE_UNUSED_ARG(lhs);
        -: 4326:    ACE_UNUSED_ARG(field);
        -: 4327:    ACE_UNUSED_ARG(rhs);
        -: 4328:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 4329:    ACE_UNUSED_ARG(rhsMeta);
    #####: 4330:    if (std::strcmp(field, "duration") == 0) {
    #####: 4331:      static_cast<T*>(lhs)->duration = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4332:      return;
        -: 4333:    }
    #####: 4334:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
        -: 4335:  }
        -: 4336:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4337:
    #####: 4338:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 4339:  {
        -: 4340:    ACE_UNUSED_ARG(lhs);
        -: 4341:    ACE_UNUSED_ARG(field);
        -: 4342:    ACE_UNUSED_ARG(rhs);
    #####: 4343:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::LifespanQosPolicy)");
        -: 4344:  }
        -: 4345:};
        -: 4346:
        -: 4347:template<>
    #####: 4348:const MetaStruct& getMetaStruct<DDS::LifespanQosPolicy>()
        -: 4349:{
    #####: 4350:  static MetaStructImpl<DDS::LifespanQosPolicy> msi;
    #####: 4351:  return msi;
        -: 4352:}
        -: 4353:
    #####: 4354:bool gen_skip_over(Serializer& ser, DDS::LifespanQosPolicy*)
        -: 4355:{
        -: 4356:  ACE_UNUSED_ARG(ser);
    #####: 4357:  MetaStructImpl<DDS::LifespanQosPolicy>().getValue(ser, "");
    #####: 4358:  return true;
        -: 4359:}
        -: 4360:
        -: 4361:}  }
        -: 4362:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4363:
        -: 4364:#endif
        -: 4365:
        -: 4366:/* End STRUCT: LifespanQosPolicy */
        -: 4367:
        -: 4368:
        -: 4369:/* Begin ENUM: OwnershipQosPolicyKind */
        -: 4370:
        -: 4371:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4372:namespace OpenDDS { namespace DCPS {
        -: 4373:
       12: 4374:bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicyKind& enumval)
        -: 4375:{
        -: 4376:  ACE_UNUSED_ARG(strm);
        -: 4377:  ACE_UNUSED_ARG(enumval);
       12: 4378:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 4379:}
        -: 4380:
    #####: 4381:bool operator>>(Serializer& strm, DDS::OwnershipQosPolicyKind& enumval)
        -: 4382:{
        -: 4383:  ACE_UNUSED_ARG(strm);
        -: 4384:  ACE_UNUSED_ARG(enumval);
    #####: 4385:  CORBA::ULong temp = 0;
    #####: 4386:  if (strm >> temp) {
    #####: 4387:    enumval = static_cast<DDS::OwnershipQosPolicyKind>(temp);
    #####: 4388:    return true;
        -: 4389:  }
    #####: 4390:  return false;
        -: 4391:}
        -: 4392:
        -: 4393:}  }
        -: 4394:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4395:
        -: 4396:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4397:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4398:namespace OpenDDS { namespace DCPS {
        -: 4399:
        -: 4400:const char* gen_DDS_OwnershipQosPolicyKind_names[] = {
        -: 4401:  "SHARED_OWNERSHIP_QOS",
        -: 4402:  "EXCLUSIVE_OWNERSHIP_QOS"
        -: 4403:};
        -: 4404:const size_t gen_DDS_OwnershipQosPolicyKind_names_size = 2;
        -: 4405:}  }
        -: 4406:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4407:
        -: 4408:#endif
        -: 4409:
        -: 4410:/* End ENUM: OwnershipQosPolicyKind */
        -: 4411:
        -: 4412:
        -: 4413:/* Begin STRUCT: OwnershipQosPolicy */
        -: 4414:
        -: 4415:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4416:namespace OpenDDS { namespace DCPS {
        -: 4417:
       12: 4418:void gen_find_size(const DDS::OwnershipQosPolicy& stru, size_t& size, size_t& padding)
        -: 4419:{
        -: 4420:  ACE_UNUSED_ARG(stru);
        -: 4421:  ACE_UNUSED_ARG(size);
        -: 4422:  ACE_UNUSED_ARG(padding);
       12: 4423:  find_size_ulong(size, padding);
       12: 4424:}
        -: 4425:
       12: 4426:bool operator<<(Serializer& strm, const DDS::OwnershipQosPolicy& stru)
        -: 4427:{
        -: 4428:  ACE_UNUSED_ARG(strm);
        -: 4429:  ACE_UNUSED_ARG(stru);
       12: 4430:  return (strm << stru.kind);
        -: 4431:}
        -: 4432:
    #####: 4433:bool operator>>(Serializer& strm, DDS::OwnershipQosPolicy& stru)
        -: 4434:{
        -: 4435:  ACE_UNUSED_ARG(strm);
        -: 4436:  ACE_UNUSED_ARG(stru);
    #####: 4437:  return (strm >> stru.kind);
        -: 4438:}
        -: 4439:
        -: 4440:}  }
        -: 4441:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4442:
        -: 4443:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4444:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4445:namespace OpenDDS { namespace DCPS {
        -: 4446:
        -: 4447:template<>
    #####: 4448:struct MetaStructImpl<DDS::OwnershipQosPolicy> : MetaStruct {
        -: 4449:  typedef DDS::OwnershipQosPolicy T;
        -: 4450:
        -: 4451:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4452:  void* allocate() const { return new T; }
        -: 4453:
    #####: 4454:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 4455:
    #####: 4456:  size_t numDcpsKeys() const { return 0; }
        -: 4457:
        -: 4458:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4459:
    #####: 4460:  bool isDcpsKey(const char* field) const
        -: 4461:  {
        -: 4462:    ACE_UNUSED_ARG(field);
    #####: 4463:    return false;
        -: 4464:  }
        -: 4465:
    #####: 4466:  Value getValue(const void* stru, const char* field) const
        -: 4467:  {
    #####: 4468:    const DDS::OwnershipQosPolicy& typed = *static_cast<const DDS::OwnershipQosPolicy*>(stru);
    #####: 4469:    if (std::strcmp(field, "kind") == 0) {
    #####: 4470:      return gen_DDS_OwnershipQosPolicyKind_names[typed.kind];
        -: 4471:    }
        -: 4472:    ACE_UNUSED_ARG(typed);
    #####: 4473:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
        -: 4474:  }
        -: 4475:
    #####: 4476:  Value getValue(Serializer& ser, const char* field) const
        -: 4477:  {
    #####: 4478:    if (std::strcmp(field, "kind") == 0) {
        -: 4479:      ACE_CDR::ULong val;
    #####: 4480:      if (!(ser >> val)) {
    #####: 4481:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 4482:      }
    #####: 4483:      return val;
        -: 4484:    } else {
    #####: 4485:      if (!ser.skip(1, 4)) {
    #####: 4486:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 4487:      }
        -: 4488:    }
    #####: 4489:    if (!field[0]) {
    #####: 4490:      return 0;
        -: 4491:    }
    #####: 4492:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::OwnershipQosPolicy");
        -: 4493:  }
        -: 4494:
    #####: 4495:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 4496:  {
        -: 4497:    ACE_UNUSED_ARG(next);
    #####: 4498:    if (std::strcmp(field, "kind") == 0) {
    #####: 4499:      return make_field_cmp(&T::kind, next);
        -: 4500:    }
    #####: 4501:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
        -: 4502:  }
        -: 4503:
        -: 4504:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4505:  const char** getFieldNames() const
        -: 4506:  {
        -: 4507:    static const char* names[] = {"kind", 0};
    #####: 4508:    return names;
        -: 4509:  }
        -: 4510:
    #####: 4511:  const void* getRawField(const void* stru, const char* field) const
        -: 4512:  {
    #####: 4513:    if (std::strcmp(field, "kind") == 0) {
    #####: 4514:      return &static_cast<const T*>(stru)->kind;
        -: 4515:    }
    #####: 4516:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
        -: 4517:  }
        -: 4518:
    #####: 4519:  void assign(void* lhs, const char* field, const void* rhs,
        -: 4520:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 4521:  {
        -: 4522:    ACE_UNUSED_ARG(lhs);
        -: 4523:    ACE_UNUSED_ARG(field);
        -: 4524:    ACE_UNUSED_ARG(rhs);
        -: 4525:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 4526:    ACE_UNUSED_ARG(rhsMeta);
    #####: 4527:    if (std::strcmp(field, "kind") == 0) {
    #####: 4528:      static_cast<T*>(lhs)->kind = *static_cast<const DDS::OwnershipQosPolicyKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4529:      return;
        -: 4530:    }
    #####: 4531:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
        -: 4532:  }
        -: 4533:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4534:
    #####: 4535:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 4536:  {
        -: 4537:    ACE_UNUSED_ARG(lhs);
        -: 4538:    ACE_UNUSED_ARG(field);
        -: 4539:    ACE_UNUSED_ARG(rhs);
    #####: 4540:    if (std::strcmp(field, "kind") == 0) {
    #####: 4541:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 4542:    }
    #####: 4543:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipQosPolicy)");
        -: 4544:  }
        -: 4545:};
        -: 4546:
        -: 4547:template<>
    #####: 4548:const MetaStruct& getMetaStruct<DDS::OwnershipQosPolicy>()
        -: 4549:{
    #####: 4550:  static MetaStructImpl<DDS::OwnershipQosPolicy> msi;
    #####: 4551:  return msi;
        -: 4552:}
        -: 4553:
    #####: 4554:bool gen_skip_over(Serializer& ser, DDS::OwnershipQosPolicy*)
        -: 4555:{
        -: 4556:  ACE_UNUSED_ARG(ser);
    #####: 4557:  MetaStructImpl<DDS::OwnershipQosPolicy>().getValue(ser, "");
    #####: 4558:  return true;
        -: 4559:}
        -: 4560:
        -: 4561:}  }
        -: 4562:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4563:
        -: 4564:#endif
        -: 4565:
        -: 4566:/* End STRUCT: OwnershipQosPolicy */
        -: 4567:
        -: 4568:
        -: 4569:/* Begin STRUCT: OwnershipStrengthQosPolicy */
        -: 4570:
        -: 4571:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4572:namespace OpenDDS { namespace DCPS {
        -: 4573:
        3: 4574:void gen_find_size(const DDS::OwnershipStrengthQosPolicy& stru, size_t& size, size_t& padding)
        -: 4575:{
        -: 4576:  ACE_UNUSED_ARG(stru);
        -: 4577:  ACE_UNUSED_ARG(size);
        -: 4578:  ACE_UNUSED_ARG(padding);
        3: 4579:  if ((size + padding) % 4) {
    #####: 4580:    padding += 4 - ((size + padding) % 4);
        -: 4581:  }
        3: 4582:  size += gen_max_marshaled_size(stru.value);
        3: 4583:}
        -: 4584:
        3: 4585:bool operator<<(Serializer& strm, const DDS::OwnershipStrengthQosPolicy& stru)
        -: 4586:{
        -: 4587:  ACE_UNUSED_ARG(strm);
        -: 4588:  ACE_UNUSED_ARG(stru);
        3: 4589:  return (strm << stru.value);
        -: 4590:}
        -: 4591:
    #####: 4592:bool operator>>(Serializer& strm, DDS::OwnershipStrengthQosPolicy& stru)
        -: 4593:{
        -: 4594:  ACE_UNUSED_ARG(strm);
        -: 4595:  ACE_UNUSED_ARG(stru);
    #####: 4596:  return (strm >> stru.value);
        -: 4597:}
        -: 4598:
        -: 4599:}  }
        -: 4600:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4601:
        -: 4602:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4603:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4604:namespace OpenDDS { namespace DCPS {
        -: 4605:
        -: 4606:template<>
    #####: 4607:struct MetaStructImpl<DDS::OwnershipStrengthQosPolicy> : MetaStruct {
        -: 4608:  typedef DDS::OwnershipStrengthQosPolicy T;
        -: 4609:
        -: 4610:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4611:  void* allocate() const { return new T; }
        -: 4612:
    #####: 4613:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 4614:
    #####: 4615:  size_t numDcpsKeys() const { return 0; }
        -: 4616:
        -: 4617:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4618:
    #####: 4619:  bool isDcpsKey(const char* field) const
        -: 4620:  {
        -: 4621:    ACE_UNUSED_ARG(field);
    #####: 4622:    return false;
        -: 4623:  }
        -: 4624:
    #####: 4625:  Value getValue(const void* stru, const char* field) const
        -: 4626:  {
    #####: 4627:    const DDS::OwnershipStrengthQosPolicy& typed = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(stru);
    #####: 4628:    if (std::strcmp(field, "value") == 0) {
    #####: 4629:      return typed.value;
        -: 4630:    }
        -: 4631:    ACE_UNUSED_ARG(typed);
    #####: 4632:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
        -: 4633:  }
        -: 4634:
    #####: 4635:  Value getValue(Serializer& ser, const char* field) const
        -: 4636:  {
    #####: 4637:    if (std::strcmp(field, "value") == 0) {
        -: 4638:      ACE_CDR::Long val;
    #####: 4639:      if (!(ser >> val)) {
    #####: 4640:        throw std::runtime_error("Field 'value' could not be deserialized");
        -: 4641:      }
    #####: 4642:      return val;
        -: 4643:    } else {
    #####: 4644:      if (!ser.skip(1, 4)) {
    #####: 4645:        throw std::runtime_error("Field 'value' could not be skipped");
        -: 4646:      }
        -: 4647:    }
    #####: 4648:    if (!field[0]) {
    #####: 4649:      return 0;
        -: 4650:    }
    #####: 4651:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::OwnershipStrengthQosPolicy");
        -: 4652:  }
        -: 4653:
    #####: 4654:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 4655:  {
        -: 4656:    ACE_UNUSED_ARG(next);
    #####: 4657:    if (std::strcmp(field, "value") == 0) {
    #####: 4658:      return make_field_cmp(&T::value, next);
        -: 4659:    }
    #####: 4660:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
        -: 4661:  }
        -: 4662:
        -: 4663:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4664:  const char** getFieldNames() const
        -: 4665:  {
        -: 4666:    static const char* names[] = {"value", 0};
    #####: 4667:    return names;
        -: 4668:  }
        -: 4669:
    #####: 4670:  const void* getRawField(const void* stru, const char* field) const
        -: 4671:  {
    #####: 4672:    if (std::strcmp(field, "value") == 0) {
    #####: 4673:      return &static_cast<const T*>(stru)->value;
        -: 4674:    }
    #####: 4675:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
        -: 4676:  }
        -: 4677:
    #####: 4678:  void assign(void* lhs, const char* field, const void* rhs,
        -: 4679:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 4680:  {
        -: 4681:    ACE_UNUSED_ARG(lhs);
        -: 4682:    ACE_UNUSED_ARG(field);
        -: 4683:    ACE_UNUSED_ARG(rhs);
        -: 4684:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 4685:    ACE_UNUSED_ARG(rhsMeta);
    #####: 4686:    if (std::strcmp(field, "value") == 0) {
    #####: 4687:      static_cast<T*>(lhs)->value = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4688:      return;
        -: 4689:    }
    #####: 4690:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
        -: 4691:  }
        -: 4692:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4693:
    #####: 4694:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 4695:  {
        -: 4696:    ACE_UNUSED_ARG(lhs);
        -: 4697:    ACE_UNUSED_ARG(field);
        -: 4698:    ACE_UNUSED_ARG(rhs);
    #####: 4699:    if (std::strcmp(field, "value") == 0) {
    #####: 4700:      return static_cast<const T*>(lhs)->value == static_cast<const T*>(rhs)->value;
        -: 4701:    }
    #####: 4702:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::OwnershipStrengthQosPolicy)");
        -: 4703:  }
        -: 4704:};
        -: 4705:
        -: 4706:template<>
    #####: 4707:const MetaStruct& getMetaStruct<DDS::OwnershipStrengthQosPolicy>()
        -: 4708:{
    #####: 4709:  static MetaStructImpl<DDS::OwnershipStrengthQosPolicy> msi;
    #####: 4710:  return msi;
        -: 4711:}
        -: 4712:
    #####: 4713:bool gen_skip_over(Serializer& ser, DDS::OwnershipStrengthQosPolicy*)
        -: 4714:{
        -: 4715:  ACE_UNUSED_ARG(ser);
    #####: 4716:  MetaStructImpl<DDS::OwnershipStrengthQosPolicy>().getValue(ser, "");
    #####: 4717:  return true;
        -: 4718:}
        -: 4719:
        -: 4720:}  }
        -: 4721:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4722:
        -: 4723:#endif
        -: 4724:
        -: 4725:/* End STRUCT: OwnershipStrengthQosPolicy */
        -: 4726:
        -: 4727:
        -: 4728:/* Begin ENUM: PresentationQosPolicyAccessScopeKind */
        -: 4729:
        -: 4730:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4731:namespace OpenDDS { namespace DCPS {
        -: 4732:
        6: 4733:bool operator<<(Serializer& strm, const DDS::PresentationQosPolicyAccessScopeKind& enumval)
        -: 4734:{
        -: 4735:  ACE_UNUSED_ARG(strm);
        -: 4736:  ACE_UNUSED_ARG(enumval);
        6: 4737:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 4738:}
        -: 4739:
    #####: 4740:bool operator>>(Serializer& strm, DDS::PresentationQosPolicyAccessScopeKind& enumval)
        -: 4741:{
        -: 4742:  ACE_UNUSED_ARG(strm);
        -: 4743:  ACE_UNUSED_ARG(enumval);
    #####: 4744:  CORBA::ULong temp = 0;
    #####: 4745:  if (strm >> temp) {
    #####: 4746:    enumval = static_cast<DDS::PresentationQosPolicyAccessScopeKind>(temp);
    #####: 4747:    return true;
        -: 4748:  }
    #####: 4749:  return false;
        -: 4750:}
        -: 4751:
        -: 4752:}  }
        -: 4753:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4754:
        -: 4755:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4756:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4757:namespace OpenDDS { namespace DCPS {
        -: 4758:
        -: 4759:const char* gen_DDS_PresentationQosPolicyAccessScopeKind_names[] = {
        -: 4760:  "INSTANCE_PRESENTATION_QOS",
        -: 4761:  "TOPIC_PRESENTATION_QOS",
        -: 4762:  "GROUP_PRESENTATION_QOS"
        -: 4763:};
        -: 4764:const size_t gen_DDS_PresentationQosPolicyAccessScopeKind_names_size = 3;
        -: 4765:}  }
        -: 4766:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4767:
        -: 4768:#endif
        -: 4769:
        -: 4770:/* End ENUM: PresentationQosPolicyAccessScopeKind */
        -: 4771:
        -: 4772:
        -: 4773:/* Begin STRUCT: PresentationQosPolicy */
        -: 4774:
        -: 4775:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4776:namespace OpenDDS { namespace DCPS {
        -: 4777:
        6: 4778:void gen_find_size(const DDS::PresentationQosPolicy& stru, size_t& size, size_t& padding)
        -: 4779:{
        -: 4780:  ACE_UNUSED_ARG(stru);
        -: 4781:  ACE_UNUSED_ARG(size);
        -: 4782:  ACE_UNUSED_ARG(padding);
        6: 4783:  find_size_ulong(size, padding);
        6: 4784:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.coherent_access));
        6: 4785:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.ordered_access));
        6: 4786:}
        -: 4787:
        6: 4788:bool operator<<(Serializer& strm, const DDS::PresentationQosPolicy& stru)
        -: 4789:{
        -: 4790:  ACE_UNUSED_ARG(strm);
        -: 4791:  ACE_UNUSED_ARG(stru);
        6: 4792:  return (strm << stru.access_scope)
       12: 4793:    && (strm << ACE_OutputCDR::from_boolean(stru.coherent_access))
       18: 4794:    && (strm << ACE_OutputCDR::from_boolean(stru.ordered_access));
        -: 4795:}
        -: 4796:
    #####: 4797:bool operator>>(Serializer& strm, DDS::PresentationQosPolicy& stru)
        -: 4798:{
        -: 4799:  ACE_UNUSED_ARG(strm);
        -: 4800:  ACE_UNUSED_ARG(stru);
    #####: 4801:  return (strm >> stru.access_scope)
    #####: 4802:    && (strm >> ACE_InputCDR::to_boolean(stru.coherent_access))
    #####: 4803:    && (strm >> ACE_InputCDR::to_boolean(stru.ordered_access));
        -: 4804:}
        -: 4805:
        -: 4806:}  }
        -: 4807:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4808:
        -: 4809:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 4810:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4811:namespace OpenDDS { namespace DCPS {
        -: 4812:
        -: 4813:template<>
    #####: 4814:struct MetaStructImpl<DDS::PresentationQosPolicy> : MetaStruct {
        -: 4815:  typedef DDS::PresentationQosPolicy T;
        -: 4816:
        -: 4817:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4818:  void* allocate() const { return new T; }
        -: 4819:
    #####: 4820:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 4821:
    #####: 4822:  size_t numDcpsKeys() const { return 0; }
        -: 4823:
        -: 4824:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4825:
    #####: 4826:  bool isDcpsKey(const char* field) const
        -: 4827:  {
        -: 4828:    ACE_UNUSED_ARG(field);
    #####: 4829:    return false;
        -: 4830:  }
        -: 4831:
    #####: 4832:  Value getValue(const void* stru, const char* field) const
        -: 4833:  {
    #####: 4834:    const DDS::PresentationQosPolicy& typed = *static_cast<const DDS::PresentationQosPolicy*>(stru);
    #####: 4835:    if (std::strcmp(field, "access_scope") == 0) {
    #####: 4836:      return gen_DDS_PresentationQosPolicyAccessScopeKind_names[typed.access_scope];
        -: 4837:    }
    #####: 4838:    if (std::strcmp(field, "coherent_access") == 0) {
    #####: 4839:      return typed.coherent_access;
        -: 4840:    }
    #####: 4841:    if (std::strcmp(field, "ordered_access") == 0) {
    #####: 4842:      return typed.ordered_access;
        -: 4843:    }
        -: 4844:    ACE_UNUSED_ARG(typed);
    #####: 4845:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
        -: 4846:  }
        -: 4847:
    #####: 4848:  Value getValue(Serializer& ser, const char* field) const
        -: 4849:  {
    #####: 4850:    if (std::strcmp(field, "access_scope") == 0) {
        -: 4851:      ACE_CDR::ULong val;
    #####: 4852:      if (!(ser >> val)) {
    #####: 4853:        throw std::runtime_error("Field 'access_scope' could not be deserialized");
        -: 4854:      }
    #####: 4855:      return val;
        -: 4856:    } else {
    #####: 4857:      if (!ser.skip(1, 4)) {
    #####: 4858:        throw std::runtime_error("Field 'access_scope' could not be skipped");
        -: 4859:      }
        -: 4860:    }
    #####: 4861:    if (std::strcmp(field, "coherent_access") == 0) {
        -: 4862:      ACE_CDR::Boolean val;
    #####: 4863:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 4864:        throw std::runtime_error("Field 'coherent_access' could not be deserialized");
        -: 4865:      }
    #####: 4866:      return val;
        -: 4867:    } else {
    #####: 4868:      if (!ser.skip(1, 1)) {
    #####: 4869:        throw std::runtime_error("Field 'coherent_access' could not be skipped");
        -: 4870:      }
        -: 4871:    }
    #####: 4872:    if (std::strcmp(field, "ordered_access") == 0) {
        -: 4873:      ACE_CDR::Boolean val;
    #####: 4874:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 4875:        throw std::runtime_error("Field 'ordered_access' could not be deserialized");
        -: 4876:      }
    #####: 4877:      return val;
        -: 4878:    } else {
    #####: 4879:      if (!ser.skip(1, 1)) {
    #####: 4880:        throw std::runtime_error("Field 'ordered_access' could not be skipped");
        -: 4881:      }
        -: 4882:    }
    #####: 4883:    if (!field[0]) {
    #####: 4884:      return 0;
        -: 4885:    }
    #####: 4886:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PresentationQosPolicy");
        -: 4887:  }
        -: 4888:
    #####: 4889:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 4890:  {
        -: 4891:    ACE_UNUSED_ARG(next);
    #####: 4892:    if (std::strcmp(field, "access_scope") == 0) {
    #####: 4893:      return make_field_cmp(&T::access_scope, next);
        -: 4894:    }
    #####: 4895:    if (std::strcmp(field, "coherent_access") == 0) {
    #####: 4896:      return make_field_cmp(&T::coherent_access, next);
        -: 4897:    }
    #####: 4898:    if (std::strcmp(field, "ordered_access") == 0) {
    #####: 4899:      return make_field_cmp(&T::ordered_access, next);
        -: 4900:    }
    #####: 4901:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
        -: 4902:  }
        -: 4903:
        -: 4904:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 4905:  const char** getFieldNames() const
        -: 4906:  {
        -: 4907:    static const char* names[] = {"access_scope", "coherent_access", "ordered_access", 0};
    #####: 4908:    return names;
        -: 4909:  }
        -: 4910:
    #####: 4911:  const void* getRawField(const void* stru, const char* field) const
        -: 4912:  {
    #####: 4913:    if (std::strcmp(field, "access_scope") == 0) {
    #####: 4914:      return &static_cast<const T*>(stru)->access_scope;
        -: 4915:    }
    #####: 4916:    if (std::strcmp(field, "coherent_access") == 0) {
    #####: 4917:      return &static_cast<const T*>(stru)->coherent_access;
        -: 4918:    }
    #####: 4919:    if (std::strcmp(field, "ordered_access") == 0) {
    #####: 4920:      return &static_cast<const T*>(stru)->ordered_access;
        -: 4921:    }
    #####: 4922:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
        -: 4923:  }
        -: 4924:
    #####: 4925:  void assign(void* lhs, const char* field, const void* rhs,
        -: 4926:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 4927:  {
        -: 4928:    ACE_UNUSED_ARG(lhs);
        -: 4929:    ACE_UNUSED_ARG(field);
        -: 4930:    ACE_UNUSED_ARG(rhs);
        -: 4931:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 4932:    ACE_UNUSED_ARG(rhsMeta);
    #####: 4933:    if (std::strcmp(field, "access_scope") == 0) {
    #####: 4934:      static_cast<T*>(lhs)->access_scope = *static_cast<const DDS::PresentationQosPolicyAccessScopeKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4935:      return;
        -: 4936:    }
    #####: 4937:    if (std::strcmp(field, "coherent_access") == 0) {
    #####: 4938:      static_cast<T*>(lhs)->coherent_access = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4939:      return;
        -: 4940:    }
    #####: 4941:    if (std::strcmp(field, "ordered_access") == 0) {
    #####: 4942:      static_cast<T*>(lhs)->ordered_access = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 4943:      return;
        -: 4944:    }
    #####: 4945:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
        -: 4946:  }
        -: 4947:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 4948:
    #####: 4949:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 4950:  {
        -: 4951:    ACE_UNUSED_ARG(lhs);
        -: 4952:    ACE_UNUSED_ARG(field);
        -: 4953:    ACE_UNUSED_ARG(rhs);
    #####: 4954:    if (std::strcmp(field, "access_scope") == 0) {
    #####: 4955:      return static_cast<const T*>(lhs)->access_scope == static_cast<const T*>(rhs)->access_scope;
        -: 4956:    }
    #####: 4957:    if (std::strcmp(field, "coherent_access") == 0) {
    #####: 4958:      return static_cast<const T*>(lhs)->coherent_access == static_cast<const T*>(rhs)->coherent_access;
        -: 4959:    }
    #####: 4960:    if (std::strcmp(field, "ordered_access") == 0) {
    #####: 4961:      return static_cast<const T*>(lhs)->ordered_access == static_cast<const T*>(rhs)->ordered_access;
        -: 4962:    }
    #####: 4963:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PresentationQosPolicy)");
        -: 4964:  }
        -: 4965:};
        -: 4966:
        -: 4967:template<>
    #####: 4968:const MetaStruct& getMetaStruct<DDS::PresentationQosPolicy>()
        -: 4969:{
    #####: 4970:  static MetaStructImpl<DDS::PresentationQosPolicy> msi;
    #####: 4971:  return msi;
        -: 4972:}
        -: 4973:
    #####: 4974:bool gen_skip_over(Serializer& ser, DDS::PresentationQosPolicy*)
        -: 4975:{
        -: 4976:  ACE_UNUSED_ARG(ser);
    #####: 4977:  MetaStructImpl<DDS::PresentationQosPolicy>().getValue(ser, "");
    #####: 4978:  return true;
        -: 4979:}
        -: 4980:
        -: 4981:}  }
        -: 4982:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 4983:
        -: 4984:#endif
        -: 4985:
        -: 4986:/* End STRUCT: PresentationQosPolicy */
        -: 4987:
        -: 4988:
        -: 4989:/* Begin STRUCT: TimeBasedFilterQosPolicy */
        -: 4990:
        -: 4991:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 4992:namespace OpenDDS { namespace DCPS {
        -: 4993:
        3: 4994:void gen_find_size(const DDS::TimeBasedFilterQosPolicy& stru, size_t& size, size_t& padding)
        -: 4995:{
        -: 4996:  ACE_UNUSED_ARG(stru);
        -: 4997:  ACE_UNUSED_ARG(size);
        -: 4998:  ACE_UNUSED_ARG(padding);
        3: 4999:  gen_find_size(stru.minimum_separation, size, padding);
        3: 5000:}
        -: 5001:
        3: 5002:bool operator<<(Serializer& strm, const DDS::TimeBasedFilterQosPolicy& stru)
        -: 5003:{
        -: 5004:  ACE_UNUSED_ARG(strm);
        -: 5005:  ACE_UNUSED_ARG(stru);
        3: 5006:  return (strm << stru.minimum_separation);
        -: 5007:}
        -: 5008:
    #####: 5009:bool operator>>(Serializer& strm, DDS::TimeBasedFilterQosPolicy& stru)
        -: 5010:{
        -: 5011:  ACE_UNUSED_ARG(strm);
        -: 5012:  ACE_UNUSED_ARG(stru);
    #####: 5013:  return (strm >> stru.minimum_separation);
        -: 5014:}
        -: 5015:
        -: 5016:}  }
        -: 5017:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5018:
        -: 5019:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 5020:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5021:namespace OpenDDS { namespace DCPS {
        -: 5022:
        -: 5023:template<>
    #####: 5024:struct MetaStructImpl<DDS::TimeBasedFilterQosPolicy> : MetaStruct {
        -: 5025:  typedef DDS::TimeBasedFilterQosPolicy T;
        -: 5026:
        -: 5027:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5028:  void* allocate() const { return new T; }
        -: 5029:
    #####: 5030:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 5031:
    #####: 5032:  size_t numDcpsKeys() const { return 0; }
        -: 5033:
        -: 5034:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5035:
    #####: 5036:  bool isDcpsKey(const char* field) const
        -: 5037:  {
        -: 5038:    ACE_UNUSED_ARG(field);
    #####: 5039:    return false;
        -: 5040:  }
        -: 5041:
    #####: 5042:  Value getValue(const void* stru, const char* field) const
        -: 5043:  {
    #####: 5044:    const DDS::TimeBasedFilterQosPolicy& typed = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(stru);
    #####: 5045:    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
    #####: 5046:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.minimum_separation, field + 19);
        -: 5047:    }
        -: 5048:    ACE_UNUSED_ARG(typed);
    #####: 5049:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
        -: 5050:  }
        -: 5051:
    #####: 5052:  Value getValue(Serializer& ser, const char* field) const
        -: 5053:  {
    #####: 5054:    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
    #####: 5055:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 19);
        -: 5056:    } else {
    #####: 5057:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 5058:        throw std::runtime_error("Field 'minimum_separation' could not be skipped");
        -: 5059:      }
        -: 5060:    }
    #####: 5061:    if (!field[0]) {
    #####: 5062:      return 0;
        -: 5063:    }
    #####: 5064:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TimeBasedFilterQosPolicy");
        -: 5065:  }
        -: 5066:
    #####: 5067:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 5068:  {
        -: 5069:    ACE_UNUSED_ARG(next);
    #####: 5070:    if (std::strncmp(field, "minimum_separation.", 19) == 0) {
    #####: 5071:      return make_struct_cmp(&T::minimum_separation, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 19), next);
        -: 5072:    }
    #####: 5073:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
        -: 5074:  }
        -: 5075:
        -: 5076:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5077:  const char** getFieldNames() const
        -: 5078:  {
        -: 5079:    static const char* names[] = {"minimum_separation", 0};
    #####: 5080:    return names;
        -: 5081:  }
        -: 5082:
    #####: 5083:  const void* getRawField(const void* stru, const char* field) const
        -: 5084:  {
    #####: 5085:    if (std::strcmp(field, "minimum_separation") == 0) {
    #####: 5086:      return &static_cast<const T*>(stru)->minimum_separation;
        -: 5087:    }
    #####: 5088:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
        -: 5089:  }
        -: 5090:
    #####: 5091:  void assign(void* lhs, const char* field, const void* rhs,
        -: 5092:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 5093:  {
        -: 5094:    ACE_UNUSED_ARG(lhs);
        -: 5095:    ACE_UNUSED_ARG(field);
        -: 5096:    ACE_UNUSED_ARG(rhs);
        -: 5097:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 5098:    ACE_UNUSED_ARG(rhsMeta);
    #####: 5099:    if (std::strcmp(field, "minimum_separation") == 0) {
    #####: 5100:      static_cast<T*>(lhs)->minimum_separation = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5101:      return;
        -: 5102:    }
    #####: 5103:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
        -: 5104:  }
        -: 5105:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5106:
    #####: 5107:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 5108:  {
        -: 5109:    ACE_UNUSED_ARG(lhs);
        -: 5110:    ACE_UNUSED_ARG(field);
        -: 5111:    ACE_UNUSED_ARG(rhs);
    #####: 5112:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TimeBasedFilterQosPolicy)");
        -: 5113:  }
        -: 5114:};
        -: 5115:
        -: 5116:template<>
    #####: 5117:const MetaStruct& getMetaStruct<DDS::TimeBasedFilterQosPolicy>()
        -: 5118:{
    #####: 5119:  static MetaStructImpl<DDS::TimeBasedFilterQosPolicy> msi;
    #####: 5120:  return msi;
        -: 5121:}
        -: 5122:
    #####: 5123:bool gen_skip_over(Serializer& ser, DDS::TimeBasedFilterQosPolicy*)
        -: 5124:{
        -: 5125:  ACE_UNUSED_ARG(ser);
    #####: 5126:  MetaStructImpl<DDS::TimeBasedFilterQosPolicy>().getValue(ser, "");
    #####: 5127:  return true;
        -: 5128:}
        -: 5129:
        -: 5130:}  }
        -: 5131:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5132:
        -: 5133:#endif
        -: 5134:
        -: 5135:/* End STRUCT: TimeBasedFilterQosPolicy */
        -: 5136:
        -: 5137:
        -: 5138:/* Begin STRUCT: TopicQos */
        -: 5139:
        -: 5140:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5141:namespace OpenDDS { namespace DCPS {
        -: 5142:
    #####: 5143:void gen_find_size(const DDS::TopicQos& stru, size_t& size, size_t& padding)
        -: 5144:{
        -: 5145:  ACE_UNUSED_ARG(stru);
        -: 5146:  ACE_UNUSED_ARG(size);
        -: 5147:  ACE_UNUSED_ARG(padding);
    #####: 5148:  gen_find_size(stru.topic_data, size, padding);
    #####: 5149:  gen_find_size(stru.durability, size, padding);
    #####: 5150:  gen_find_size(stru.durability_service, size, padding);
    #####: 5151:  gen_find_size(stru.deadline, size, padding);
    #####: 5152:  gen_find_size(stru.latency_budget, size, padding);
    #####: 5153:  gen_find_size(stru.liveliness, size, padding);
    #####: 5154:  gen_find_size(stru.reliability, size, padding);
    #####: 5155:  gen_find_size(stru.destination_order, size, padding);
    #####: 5156:  gen_find_size(stru.history, size, padding);
    #####: 5157:  gen_find_size(stru.resource_limits, size, padding);
    #####: 5158:  gen_find_size(stru.transport_priority, size, padding);
    #####: 5159:  gen_find_size(stru.lifespan, size, padding);
    #####: 5160:  gen_find_size(stru.ownership, size, padding);
    #####: 5161:}
        -: 5162:
    #####: 5163:bool operator<<(Serializer& strm, const DDS::TopicQos& stru)
        -: 5164:{
        -: 5165:  ACE_UNUSED_ARG(strm);
        -: 5166:  ACE_UNUSED_ARG(stru);
    #####: 5167:  return (strm << stru.topic_data)
    #####: 5168:    && (strm << stru.durability)
    #####: 5169:    && (strm << stru.durability_service)
    #####: 5170:    && (strm << stru.deadline)
    #####: 5171:    && (strm << stru.latency_budget)
    #####: 5172:    && (strm << stru.liveliness)
    #####: 5173:    && (strm << stru.reliability)
    #####: 5174:    && (strm << stru.destination_order)
    #####: 5175:    && (strm << stru.history)
    #####: 5176:    && (strm << stru.resource_limits)
    #####: 5177:    && (strm << stru.transport_priority)
    #####: 5178:    && (strm << stru.lifespan)
    #####: 5179:    && (strm << stru.ownership);
        -: 5180:}
        -: 5181:
    #####: 5182:bool operator>>(Serializer& strm, DDS::TopicQos& stru)
        -: 5183:{
        -: 5184:  ACE_UNUSED_ARG(strm);
        -: 5185:  ACE_UNUSED_ARG(stru);
    #####: 5186:  return (strm >> stru.topic_data)
    #####: 5187:    && (strm >> stru.durability)
    #####: 5188:    && (strm >> stru.durability_service)
    #####: 5189:    && (strm >> stru.deadline)
    #####: 5190:    && (strm >> stru.latency_budget)
    #####: 5191:    && (strm >> stru.liveliness)
    #####: 5192:    && (strm >> stru.reliability)
    #####: 5193:    && (strm >> stru.destination_order)
    #####: 5194:    && (strm >> stru.history)
    #####: 5195:    && (strm >> stru.resource_limits)
    #####: 5196:    && (strm >> stru.transport_priority)
    #####: 5197:    && (strm >> stru.lifespan)
    #####: 5198:    && (strm >> stru.ownership);
        -: 5199:}
        -: 5200:
        -: 5201:}  }
        -: 5202:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5203:
        -: 5204:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 5205:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5206:namespace OpenDDS { namespace DCPS {
        -: 5207:
        -: 5208:template<>
    #####: 5209:struct MetaStructImpl<DDS::TopicQos> : MetaStruct {
        -: 5210:  typedef DDS::TopicQos T;
        -: 5211:
        -: 5212:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5213:  void* allocate() const { return new T; }
        -: 5214:
    #####: 5215:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 5216:
    #####: 5217:  size_t numDcpsKeys() const { return 0; }
        -: 5218:
        -: 5219:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5220:
    #####: 5221:  bool isDcpsKey(const char* field) const
        -: 5222:  {
        -: 5223:    ACE_UNUSED_ARG(field);
    #####: 5224:    return false;
        -: 5225:  }
        -: 5226:
    #####: 5227:  Value getValue(const void* stru, const char* field) const
        -: 5228:  {
    #####: 5229:    const DDS::TopicQos& typed = *static_cast<const DDS::TopicQos*>(stru);
    #####: 5230:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 5231:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
        -: 5232:    }
    #####: 5233:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 5234:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
        -: 5235:    }
    #####: 5236:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 5237:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
        -: 5238:    }
    #####: 5239:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 5240:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
        -: 5241:    }
    #####: 5242:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 5243:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
        -: 5244:    }
    #####: 5245:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 5246:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
        -: 5247:    }
    #####: 5248:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 5249:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
        -: 5250:    }
    #####: 5251:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 5252:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
        -: 5253:    }
    #####: 5254:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 5255:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
        -: 5256:    }
    #####: 5257:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 5258:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
        -: 5259:    }
    #####: 5260:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 5261:      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
        -: 5262:    }
    #####: 5263:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 5264:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
        -: 5265:    }
    #####: 5266:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 5267:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
        -: 5268:    }
        -: 5269:    ACE_UNUSED_ARG(typed);
    #####: 5270:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
        -: 5271:  }
        -: 5272:
    #####: 5273:  Value getValue(Serializer& ser, const char* field) const
        -: 5274:  {
    #####: 5275:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 5276:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
        -: 5277:    } else {
    #####: 5278:      if (!gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0))) {
    #####: 5279:        throw std::runtime_error("Field 'topic_data' could not be skipped");
        -: 5280:      }
        -: 5281:    }
    #####: 5282:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 5283:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
        -: 5284:    } else {
    #####: 5285:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) {
    #####: 5286:        throw std::runtime_error("Field 'durability' could not be skipped");
        -: 5287:      }
        -: 5288:    }
    #####: 5289:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 5290:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
        -: 5291:    } else {
    #####: 5292:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0))) {
    #####: 5293:        throw std::runtime_error("Field 'durability_service' could not be skipped");
        -: 5294:      }
        -: 5295:    }
    #####: 5296:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 5297:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
        -: 5298:    } else {
    #####: 5299:      if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) {
    #####: 5300:        throw std::runtime_error("Field 'deadline' could not be skipped");
        -: 5301:      }
        -: 5302:    }
    #####: 5303:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 5304:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
        -: 5305:    } else {
    #####: 5306:      if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) {
    #####: 5307:        throw std::runtime_error("Field 'latency_budget' could not be skipped");
        -: 5308:      }
        -: 5309:    }
    #####: 5310:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 5311:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
        -: 5312:    } else {
    #####: 5313:      if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) {
    #####: 5314:        throw std::runtime_error("Field 'liveliness' could not be skipped");
        -: 5315:      }
        -: 5316:    }
    #####: 5317:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 5318:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
        -: 5319:    } else {
    #####: 5320:      if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) {
    #####: 5321:        throw std::runtime_error("Field 'reliability' could not be skipped");
        -: 5322:      }
        -: 5323:    }
    #####: 5324:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 5325:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
        -: 5326:    } else {
    #####: 5327:      if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) {
    #####: 5328:        throw std::runtime_error("Field 'destination_order' could not be skipped");
        -: 5329:      }
        -: 5330:    }
    #####: 5331:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 5332:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
        -: 5333:    } else {
    #####: 5334:      if (!gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0))) {
    #####: 5335:        throw std::runtime_error("Field 'history' could not be skipped");
        -: 5336:      }
        -: 5337:    }
    #####: 5338:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 5339:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
        -: 5340:    } else {
    #####: 5341:      if (!gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0))) {
    #####: 5342:        throw std::runtime_error("Field 'resource_limits' could not be skipped");
        -: 5343:      }
        -: 5344:    }
    #####: 5345:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 5346:      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
        -: 5347:    } else {
    #####: 5348:      if (!gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0))) {
    #####: 5349:        throw std::runtime_error("Field 'transport_priority' could not be skipped");
        -: 5350:      }
        -: 5351:    }
    #####: 5352:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 5353:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
        -: 5354:    } else {
    #####: 5355:      if (!gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0))) {
    #####: 5356:        throw std::runtime_error("Field 'lifespan' could not be skipped");
        -: 5357:      }
        -: 5358:    }
    #####: 5359:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 5360:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
        -: 5361:    } else {
    #####: 5362:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) {
    #####: 5363:        throw std::runtime_error("Field 'ownership' could not be skipped");
        -: 5364:      }
        -: 5365:    }
    #####: 5366:    if (!field[0]) {
    #####: 5367:      return 0;
        -: 5368:    }
    #####: 5369:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TopicQos");
        -: 5370:  }
        -: 5371:
    #####: 5372:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 5373:  {
        -: 5374:    ACE_UNUSED_ARG(next);
    #####: 5375:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 5376:      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 5377:    }
    #####: 5378:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 5379:      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
        -: 5380:    }
    #####: 5381:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 5382:      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
        -: 5383:    }
    #####: 5384:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 5385:      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
        -: 5386:    }
    #####: 5387:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 5388:      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
        -: 5389:    }
    #####: 5390:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 5391:      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
        -: 5392:    }
    #####: 5393:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 5394:      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
        -: 5395:    }
    #####: 5396:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 5397:      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
        -: 5398:    }
    #####: 5399:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 5400:      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
        -: 5401:    }
    #####: 5402:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 5403:      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
        -: 5404:    }
    #####: 5405:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 5406:      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
        -: 5407:    }
    #####: 5408:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 5409:      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
        -: 5410:    }
    #####: 5411:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 5412:      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
        -: 5413:    }
    #####: 5414:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
        -: 5415:  }
        -: 5416:
        -: 5417:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5418:  const char** getFieldNames() const
        -: 5419:  {
        -: 5420:    static const char* names[] = {"topic_data", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "ownership", 0};
    #####: 5421:    return names;
        -: 5422:  }
        -: 5423:
    #####: 5424:  const void* getRawField(const void* stru, const char* field) const
        -: 5425:  {
    #####: 5426:    if (std::strcmp(field, "topic_data") == 0) {
    #####: 5427:      return &static_cast<const T*>(stru)->topic_data;
        -: 5428:    }
    #####: 5429:    if (std::strcmp(field, "durability") == 0) {
    #####: 5430:      return &static_cast<const T*>(stru)->durability;
        -: 5431:    }
    #####: 5432:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 5433:      return &static_cast<const T*>(stru)->durability_service;
        -: 5434:    }
    #####: 5435:    if (std::strcmp(field, "deadline") == 0) {
    #####: 5436:      return &static_cast<const T*>(stru)->deadline;
        -: 5437:    }
    #####: 5438:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 5439:      return &static_cast<const T*>(stru)->latency_budget;
        -: 5440:    }
    #####: 5441:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 5442:      return &static_cast<const T*>(stru)->liveliness;
        -: 5443:    }
    #####: 5444:    if (std::strcmp(field, "reliability") == 0) {
    #####: 5445:      return &static_cast<const T*>(stru)->reliability;
        -: 5446:    }
    #####: 5447:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 5448:      return &static_cast<const T*>(stru)->destination_order;
        -: 5449:    }
    #####: 5450:    if (std::strcmp(field, "history") == 0) {
    #####: 5451:      return &static_cast<const T*>(stru)->history;
        -: 5452:    }
    #####: 5453:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 5454:      return &static_cast<const T*>(stru)->resource_limits;
        -: 5455:    }
    #####: 5456:    if (std::strcmp(field, "transport_priority") == 0) {
    #####: 5457:      return &static_cast<const T*>(stru)->transport_priority;
        -: 5458:    }
    #####: 5459:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 5460:      return &static_cast<const T*>(stru)->lifespan;
        -: 5461:    }
    #####: 5462:    if (std::strcmp(field, "ownership") == 0) {
    #####: 5463:      return &static_cast<const T*>(stru)->ownership;
        -: 5464:    }
    #####: 5465:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
        -: 5466:  }
        -: 5467:
    #####: 5468:  void assign(void* lhs, const char* field, const void* rhs,
        -: 5469:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 5470:  {
        -: 5471:    ACE_UNUSED_ARG(lhs);
        -: 5472:    ACE_UNUSED_ARG(field);
        -: 5473:    ACE_UNUSED_ARG(rhs);
        -: 5474:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 5475:    ACE_UNUSED_ARG(rhsMeta);
    #####: 5476:    if (std::strcmp(field, "topic_data") == 0) {
    #####: 5477:      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5478:      return;
        -: 5479:    }
    #####: 5480:    if (std::strcmp(field, "durability") == 0) {
    #####: 5481:      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5482:      return;
        -: 5483:    }
    #####: 5484:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 5485:      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5486:      return;
        -: 5487:    }
    #####: 5488:    if (std::strcmp(field, "deadline") == 0) {
    #####: 5489:      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5490:      return;
        -: 5491:    }
    #####: 5492:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 5493:      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5494:      return;
        -: 5495:    }
    #####: 5496:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 5497:      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5498:      return;
        -: 5499:    }
    #####: 5500:    if (std::strcmp(field, "reliability") == 0) {
    #####: 5501:      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5502:      return;
        -: 5503:    }
    #####: 5504:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 5505:      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5506:      return;
        -: 5507:    }
    #####: 5508:    if (std::strcmp(field, "history") == 0) {
    #####: 5509:      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5510:      return;
        -: 5511:    }
    #####: 5512:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 5513:      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5514:      return;
        -: 5515:    }
    #####: 5516:    if (std::strcmp(field, "transport_priority") == 0) {
    #####: 5517:      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5518:      return;
        -: 5519:    }
    #####: 5520:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 5521:      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5522:      return;
        -: 5523:    }
    #####: 5524:    if (std::strcmp(field, "ownership") == 0) {
    #####: 5525:      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5526:      return;
        -: 5527:    }
    #####: 5528:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
        -: 5529:  }
        -: 5530:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5531:
    #####: 5532:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 5533:  {
        -: 5534:    ACE_UNUSED_ARG(lhs);
        -: 5535:    ACE_UNUSED_ARG(field);
        -: 5536:    ACE_UNUSED_ARG(rhs);
    #####: 5537:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicQos)");
        -: 5538:  }
        -: 5539:};
        -: 5540:
        -: 5541:template<>
    #####: 5542:const MetaStruct& getMetaStruct<DDS::TopicQos>()
        -: 5543:{
    #####: 5544:  static MetaStructImpl<DDS::TopicQos> msi;
    #####: 5545:  return msi;
        -: 5546:}
        -: 5547:
    #####: 5548:bool gen_skip_over(Serializer& ser, DDS::TopicQos*)
        -: 5549:{
        -: 5550:  ACE_UNUSED_ARG(ser);
    #####: 5551:  MetaStructImpl<DDS::TopicQos>().getValue(ser, "");
    #####: 5552:  return true;
        -: 5553:}
        -: 5554:
        -: 5555:}  }
        -: 5556:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5557:
        -: 5558:#endif
        -: 5559:
        -: 5560:/* End STRUCT: TopicQos */
        -: 5561:
        -: 5562:
        -: 5563:/* Begin STRUCT: WriterDataLifecycleQosPolicy */
        -: 5564:
        -: 5565:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5566:namespace OpenDDS { namespace DCPS {
        -: 5567:
    #####: 5568:void gen_find_size(const DDS::WriterDataLifecycleQosPolicy& stru, size_t& size, size_t& padding)
        -: 5569:{
        -: 5570:  ACE_UNUSED_ARG(stru);
        -: 5571:  ACE_UNUSED_ARG(size);
        -: 5572:  ACE_UNUSED_ARG(padding);
    #####: 5573:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
    #####: 5574:}
        -: 5575:
    #####: 5576:bool operator<<(Serializer& strm, const DDS::WriterDataLifecycleQosPolicy& stru)
        -: 5577:{
        -: 5578:  ACE_UNUSED_ARG(strm);
        -: 5579:  ACE_UNUSED_ARG(stru);
    #####: 5580:  return (strm << ACE_OutputCDR::from_boolean(stru.autodispose_unregistered_instances));
        -: 5581:}
        -: 5582:
    #####: 5583:bool operator>>(Serializer& strm, DDS::WriterDataLifecycleQosPolicy& stru)
        -: 5584:{
        -: 5585:  ACE_UNUSED_ARG(strm);
        -: 5586:  ACE_UNUSED_ARG(stru);
    #####: 5587:  return (strm >> ACE_InputCDR::to_boolean(stru.autodispose_unregistered_instances));
        -: 5588:}
        -: 5589:
        -: 5590:}  }
        -: 5591:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5592:
        -: 5593:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 5594:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5595:namespace OpenDDS { namespace DCPS {
        -: 5596:
        -: 5597:template<>
    #####: 5598:struct MetaStructImpl<DDS::WriterDataLifecycleQosPolicy> : MetaStruct {
        -: 5599:  typedef DDS::WriterDataLifecycleQosPolicy T;
        -: 5600:
        -: 5601:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5602:  void* allocate() const { return new T; }
        -: 5603:
    #####: 5604:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 5605:
    #####: 5606:  size_t numDcpsKeys() const { return 0; }
        -: 5607:
        -: 5608:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5609:
    #####: 5610:  bool isDcpsKey(const char* field) const
        -: 5611:  {
        -: 5612:    ACE_UNUSED_ARG(field);
    #####: 5613:    return false;
        -: 5614:  }
        -: 5615:
    #####: 5616:  Value getValue(const void* stru, const char* field) const
        -: 5617:  {
    #####: 5618:    const DDS::WriterDataLifecycleQosPolicy& typed = *static_cast<const DDS::WriterDataLifecycleQosPolicy*>(stru);
    #####: 5619:    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
    #####: 5620:      return typed.autodispose_unregistered_instances;
        -: 5621:    }
        -: 5622:    ACE_UNUSED_ARG(typed);
    #####: 5623:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
        -: 5624:  }
        -: 5625:
    #####: 5626:  Value getValue(Serializer& ser, const char* field) const
        -: 5627:  {
    #####: 5628:    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
        -: 5629:      ACE_CDR::Boolean val;
    #####: 5630:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 5631:        throw std::runtime_error("Field 'autodispose_unregistered_instances' could not be deserialized");
        -: 5632:      }
    #####: 5633:      return val;
        -: 5634:    } else {
    #####: 5635:      if (!ser.skip(1, 1)) {
    #####: 5636:        throw std::runtime_error("Field 'autodispose_unregistered_instances' could not be skipped");
        -: 5637:      }
        -: 5638:    }
    #####: 5639:    if (!field[0]) {
    #####: 5640:      return 0;
        -: 5641:    }
    #####: 5642:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::WriterDataLifecycleQosPolicy");
        -: 5643:  }
        -: 5644:
    #####: 5645:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 5646:  {
        -: 5647:    ACE_UNUSED_ARG(next);
    #####: 5648:    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
    #####: 5649:      return make_field_cmp(&T::autodispose_unregistered_instances, next);
        -: 5650:    }
    #####: 5651:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
        -: 5652:  }
        -: 5653:
        -: 5654:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5655:  const char** getFieldNames() const
        -: 5656:  {
        -: 5657:    static const char* names[] = {"autodispose_unregistered_instances", 0};
    #####: 5658:    return names;
        -: 5659:  }
        -: 5660:
    #####: 5661:  const void* getRawField(const void* stru, const char* field) const
        -: 5662:  {
    #####: 5663:    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
    #####: 5664:      return &static_cast<const T*>(stru)->autodispose_unregistered_instances;
        -: 5665:    }
    #####: 5666:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
        -: 5667:  }
        -: 5668:
    #####: 5669:  void assign(void* lhs, const char* field, const void* rhs,
        -: 5670:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 5671:  {
        -: 5672:    ACE_UNUSED_ARG(lhs);
        -: 5673:    ACE_UNUSED_ARG(field);
        -: 5674:    ACE_UNUSED_ARG(rhs);
        -: 5675:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 5676:    ACE_UNUSED_ARG(rhsMeta);
    #####: 5677:    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
    #####: 5678:      static_cast<T*>(lhs)->autodispose_unregistered_instances = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 5679:      return;
        -: 5680:    }
    #####: 5681:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
        -: 5682:  }
        -: 5683:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5684:
    #####: 5685:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 5686:  {
        -: 5687:    ACE_UNUSED_ARG(lhs);
        -: 5688:    ACE_UNUSED_ARG(field);
        -: 5689:    ACE_UNUSED_ARG(rhs);
    #####: 5690:    if (std::strcmp(field, "autodispose_unregistered_instances") == 0) {
    #####: 5691:      return static_cast<const T*>(lhs)->autodispose_unregistered_instances == static_cast<const T*>(rhs)->autodispose_unregistered_instances;
        -: 5692:    }
    #####: 5693:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::WriterDataLifecycleQosPolicy)");
        -: 5694:  }
        -: 5695:};
        -: 5696:
        -: 5697:template<>
    #####: 5698:const MetaStruct& getMetaStruct<DDS::WriterDataLifecycleQosPolicy>()
        -: 5699:{
    #####: 5700:  static MetaStructImpl<DDS::WriterDataLifecycleQosPolicy> msi;
    #####: 5701:  return msi;
        -: 5702:}
        -: 5703:
    #####: 5704:bool gen_skip_over(Serializer& ser, DDS::WriterDataLifecycleQosPolicy*)
        -: 5705:{
        -: 5706:  ACE_UNUSED_ARG(ser);
    #####: 5707:  MetaStructImpl<DDS::WriterDataLifecycleQosPolicy>().getValue(ser, "");
    #####: 5708:  return true;
        -: 5709:}
        -: 5710:
        -: 5711:}  }
        -: 5712:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5713:
        -: 5714:#endif
        -: 5715:
        -: 5716:/* End STRUCT: WriterDataLifecycleQosPolicy */
        -: 5717:
        -: 5718:
        -: 5719:/* Begin STRUCT: DataWriterQos */
        -: 5720:
        -: 5721:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5722:namespace OpenDDS { namespace DCPS {
        -: 5723:
    #####: 5724:void gen_find_size(const DDS::DataWriterQos& stru, size_t& size, size_t& padding)
        -: 5725:{
        -: 5726:  ACE_UNUSED_ARG(stru);
        -: 5727:  ACE_UNUSED_ARG(size);
        -: 5728:  ACE_UNUSED_ARG(padding);
    #####: 5729:  gen_find_size(stru.durability, size, padding);
    #####: 5730:  gen_find_size(stru.durability_service, size, padding);
    #####: 5731:  gen_find_size(stru.deadline, size, padding);
    #####: 5732:  gen_find_size(stru.latency_budget, size, padding);
    #####: 5733:  gen_find_size(stru.liveliness, size, padding);
    #####: 5734:  gen_find_size(stru.reliability, size, padding);
    #####: 5735:  gen_find_size(stru.destination_order, size, padding);
    #####: 5736:  gen_find_size(stru.history, size, padding);
    #####: 5737:  gen_find_size(stru.resource_limits, size, padding);
    #####: 5738:  gen_find_size(stru.transport_priority, size, padding);
    #####: 5739:  gen_find_size(stru.lifespan, size, padding);
    #####: 5740:  gen_find_size(stru.user_data, size, padding);
    #####: 5741:  gen_find_size(stru.ownership, size, padding);
    #####: 5742:  gen_find_size(stru.ownership_strength, size, padding);
    #####: 5743:  gen_find_size(stru.writer_data_lifecycle, size, padding);
    #####: 5744:}
        -: 5745:
    #####: 5746:bool operator<<(Serializer& strm, const DDS::DataWriterQos& stru)
        -: 5747:{
        -: 5748:  ACE_UNUSED_ARG(strm);
        -: 5749:  ACE_UNUSED_ARG(stru);
    #####: 5750:  return (strm << stru.durability)
    #####: 5751:    && (strm << stru.durability_service)
    #####: 5752:    && (strm << stru.deadline)
    #####: 5753:    && (strm << stru.latency_budget)
    #####: 5754:    && (strm << stru.liveliness)
    #####: 5755:    && (strm << stru.reliability)
    #####: 5756:    && (strm << stru.destination_order)
    #####: 5757:    && (strm << stru.history)
    #####: 5758:    && (strm << stru.resource_limits)
    #####: 5759:    && (strm << stru.transport_priority)
    #####: 5760:    && (strm << stru.lifespan)
    #####: 5761:    && (strm << stru.user_data)
    #####: 5762:    && (strm << stru.ownership)
    #####: 5763:    && (strm << stru.ownership_strength)
    #####: 5764:    && (strm << stru.writer_data_lifecycle);
        -: 5765:}
        -: 5766:
    #####: 5767:bool operator>>(Serializer& strm, DDS::DataWriterQos& stru)
        -: 5768:{
        -: 5769:  ACE_UNUSED_ARG(strm);
        -: 5770:  ACE_UNUSED_ARG(stru);
    #####: 5771:  return (strm >> stru.durability)
    #####: 5772:    && (strm >> stru.durability_service)
    #####: 5773:    && (strm >> stru.deadline)
    #####: 5774:    && (strm >> stru.latency_budget)
    #####: 5775:    && (strm >> stru.liveliness)
    #####: 5776:    && (strm >> stru.reliability)
    #####: 5777:    && (strm >> stru.destination_order)
    #####: 5778:    && (strm >> stru.history)
    #####: 5779:    && (strm >> stru.resource_limits)
    #####: 5780:    && (strm >> stru.transport_priority)
    #####: 5781:    && (strm >> stru.lifespan)
    #####: 5782:    && (strm >> stru.user_data)
    #####: 5783:    && (strm >> stru.ownership)
    #####: 5784:    && (strm >> stru.ownership_strength)
    #####: 5785:    && (strm >> stru.writer_data_lifecycle);
        -: 5786:}
        -: 5787:
        -: 5788:}  }
        -: 5789:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 5790:
        -: 5791:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 5792:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 5793:namespace OpenDDS { namespace DCPS {
        -: 5794:
        -: 5795:template<>
    #####: 5796:struct MetaStructImpl<DDS::DataWriterQos> : MetaStruct {
        -: 5797:  typedef DDS::DataWriterQos T;
        -: 5798:
        -: 5799:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 5800:  void* allocate() const { return new T; }
        -: 5801:
    #####: 5802:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 5803:
    #####: 5804:  size_t numDcpsKeys() const { return 0; }
        -: 5805:
        -: 5806:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 5807:
    #####: 5808:  bool isDcpsKey(const char* field) const
        -: 5809:  {
        -: 5810:    ACE_UNUSED_ARG(field);
    #####: 5811:    return false;
        -: 5812:  }
        -: 5813:
    #####: 5814:  Value getValue(const void* stru, const char* field) const
        -: 5815:  {
    #####: 5816:    const DDS::DataWriterQos& typed = *static_cast<const DDS::DataWriterQos*>(stru);
    #####: 5817:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 5818:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
        -: 5819:    }
    #####: 5820:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 5821:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
        -: 5822:    }
    #####: 5823:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 5824:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
        -: 5825:    }
    #####: 5826:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 5827:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
        -: 5828:    }
    #####: 5829:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 5830:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
        -: 5831:    }
    #####: 5832:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 5833:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
        -: 5834:    }
    #####: 5835:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 5836:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
        -: 5837:    }
    #####: 5838:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 5839:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
        -: 5840:    }
    #####: 5841:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 5842:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
        -: 5843:    }
    #####: 5844:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 5845:      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
        -: 5846:    }
    #####: 5847:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 5848:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
        -: 5849:    }
    #####: 5850:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 5851:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
        -: 5852:    }
    #####: 5853:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 5854:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
        -: 5855:    }
    #####: 5856:    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
    #####: 5857:      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
        -: 5858:    }
    #####: 5859:    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
    #####: 5860:      return getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().getValue(&typed.writer_data_lifecycle, field + 22);
        -: 5861:    }
        -: 5862:    ACE_UNUSED_ARG(typed);
    #####: 5863:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
        -: 5864:  }
        -: 5865:
    #####: 5866:  Value getValue(Serializer& ser, const char* field) const
        -: 5867:  {
    #####: 5868:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 5869:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
        -: 5870:    } else {
    #####: 5871:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) {
    #####: 5872:        throw std::runtime_error("Field 'durability' could not be skipped");
        -: 5873:      }
        -: 5874:    }
    #####: 5875:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 5876:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
        -: 5877:    } else {
    #####: 5878:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0))) {
    #####: 5879:        throw std::runtime_error("Field 'durability_service' could not be skipped");
        -: 5880:      }
        -: 5881:    }
    #####: 5882:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 5883:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
        -: 5884:    } else {
    #####: 5885:      if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) {
    #####: 5886:        throw std::runtime_error("Field 'deadline' could not be skipped");
        -: 5887:      }
        -: 5888:    }
    #####: 5889:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 5890:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
        -: 5891:    } else {
    #####: 5892:      if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) {
    #####: 5893:        throw std::runtime_error("Field 'latency_budget' could not be skipped");
        -: 5894:      }
        -: 5895:    }
    #####: 5896:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 5897:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
        -: 5898:    } else {
    #####: 5899:      if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) {
    #####: 5900:        throw std::runtime_error("Field 'liveliness' could not be skipped");
        -: 5901:      }
        -: 5902:    }
    #####: 5903:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 5904:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
        -: 5905:    } else {
    #####: 5906:      if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) {
    #####: 5907:        throw std::runtime_error("Field 'reliability' could not be skipped");
        -: 5908:      }
        -: 5909:    }
    #####: 5910:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 5911:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
        -: 5912:    } else {
    #####: 5913:      if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) {
    #####: 5914:        throw std::runtime_error("Field 'destination_order' could not be skipped");
        -: 5915:      }
        -: 5916:    }
    #####: 5917:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 5918:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
        -: 5919:    } else {
    #####: 5920:      if (!gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0))) {
    #####: 5921:        throw std::runtime_error("Field 'history' could not be skipped");
        -: 5922:      }
        -: 5923:    }
    #####: 5924:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 5925:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
        -: 5926:    } else {
    #####: 5927:      if (!gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0))) {
    #####: 5928:        throw std::runtime_error("Field 'resource_limits' could not be skipped");
        -: 5929:      }
        -: 5930:    }
    #####: 5931:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 5932:      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
        -: 5933:    } else {
    #####: 5934:      if (!gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0))) {
    #####: 5935:        throw std::runtime_error("Field 'transport_priority' could not be skipped");
        -: 5936:      }
        -: 5937:    }
    #####: 5938:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 5939:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
        -: 5940:    } else {
    #####: 5941:      if (!gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0))) {
    #####: 5942:        throw std::runtime_error("Field 'lifespan' could not be skipped");
        -: 5943:      }
        -: 5944:    }
    #####: 5945:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 5946:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
        -: 5947:    } else {
    #####: 5948:      if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) {
    #####: 5949:        throw std::runtime_error("Field 'user_data' could not be skipped");
        -: 5950:      }
        -: 5951:    }
    #####: 5952:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 5953:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
        -: 5954:    } else {
    #####: 5955:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) {
    #####: 5956:        throw std::runtime_error("Field 'ownership' could not be skipped");
        -: 5957:      }
        -: 5958:    }
    #####: 5959:    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
    #####: 5960:      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(ser, field + 19);
        -: 5961:    } else {
    #####: 5962:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0))) {
    #####: 5963:        throw std::runtime_error("Field 'ownership_strength' could not be skipped");
        -: 5964:      }
        -: 5965:    }
    #####: 5966:    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
    #####: 5967:      return getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().getValue(ser, field + 22);
        -: 5968:    } else {
    #####: 5969:      if (!gen_skip_over(ser, static_cast<DDS::WriterDataLifecycleQosPolicy*>(0))) {
    #####: 5970:        throw std::runtime_error("Field 'writer_data_lifecycle' could not be skipped");
        -: 5971:      }
        -: 5972:    }
    #####: 5973:    if (!field[0]) {
    #####: 5974:      return 0;
        -: 5975:    }
    #####: 5976:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DataWriterQos");
        -: 5977:  }
        -: 5978:
    #####: 5979:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 5980:  {
        -: 5981:    ACE_UNUSED_ARG(next);
    #####: 5982:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 5983:      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
        -: 5984:    }
    #####: 5985:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 5986:      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
        -: 5987:    }
    #####: 5988:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 5989:      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
        -: 5990:    }
    #####: 5991:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 5992:      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
        -: 5993:    }
    #####: 5994:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 5995:      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
        -: 5996:    }
    #####: 5997:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 5998:      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
        -: 5999:    }
    #####: 6000:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 6001:      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
        -: 6002:    }
    #####: 6003:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 6004:      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
        -: 6005:    }
    #####: 6006:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 6007:      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
        -: 6008:    }
    #####: 6009:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 6010:      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
        -: 6011:    }
    #####: 6012:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 6013:      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
        -: 6014:    }
    #####: 6015:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 6016:      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
        -: 6017:    }
    #####: 6018:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 6019:      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
        -: 6020:    }
    #####: 6021:    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
    #####: 6022:      return make_struct_cmp(&T::ownership_strength, getMetaStruct<DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19), next);
        -: 6023:    }
    #####: 6024:    if (std::strncmp(field, "writer_data_lifecycle.", 22) == 0) {
    #####: 6025:      return make_struct_cmp(&T::writer_data_lifecycle, getMetaStruct<DDS::WriterDataLifecycleQosPolicy>().create_qc_comparator(field + 22), next);
        -: 6026:    }
    #####: 6027:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
        -: 6028:  }
        -: 6029:
        -: 6030:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6031:  const char** getFieldNames() const
        -: 6032:  {
        -: 6033:    static const char* names[] = {"durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "transport_priority", "lifespan", "user_data", "ownership", "ownership_strength", "writer_data_lifecycle", 0};
    #####: 6034:    return names;
        -: 6035:  }
        -: 6036:
    #####: 6037:  const void* getRawField(const void* stru, const char* field) const
        -: 6038:  {
    #####: 6039:    if (std::strcmp(field, "durability") == 0) {
    #####: 6040:      return &static_cast<const T*>(stru)->durability;
        -: 6041:    }
    #####: 6042:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 6043:      return &static_cast<const T*>(stru)->durability_service;
        -: 6044:    }
    #####: 6045:    if (std::strcmp(field, "deadline") == 0) {
    #####: 6046:      return &static_cast<const T*>(stru)->deadline;
        -: 6047:    }
    #####: 6048:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 6049:      return &static_cast<const T*>(stru)->latency_budget;
        -: 6050:    }
    #####: 6051:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 6052:      return &static_cast<const T*>(stru)->liveliness;
        -: 6053:    }
    #####: 6054:    if (std::strcmp(field, "reliability") == 0) {
    #####: 6055:      return &static_cast<const T*>(stru)->reliability;
        -: 6056:    }
    #####: 6057:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 6058:      return &static_cast<const T*>(stru)->destination_order;
        -: 6059:    }
    #####: 6060:    if (std::strcmp(field, "history") == 0) {
    #####: 6061:      return &static_cast<const T*>(stru)->history;
        -: 6062:    }
    #####: 6063:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 6064:      return &static_cast<const T*>(stru)->resource_limits;
        -: 6065:    }
    #####: 6066:    if (std::strcmp(field, "transport_priority") == 0) {
    #####: 6067:      return &static_cast<const T*>(stru)->transport_priority;
        -: 6068:    }
    #####: 6069:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 6070:      return &static_cast<const T*>(stru)->lifespan;
        -: 6071:    }
    #####: 6072:    if (std::strcmp(field, "user_data") == 0) {
    #####: 6073:      return &static_cast<const T*>(stru)->user_data;
        -: 6074:    }
    #####: 6075:    if (std::strcmp(field, "ownership") == 0) {
    #####: 6076:      return &static_cast<const T*>(stru)->ownership;
        -: 6077:    }
    #####: 6078:    if (std::strcmp(field, "ownership_strength") == 0) {
    #####: 6079:      return &static_cast<const T*>(stru)->ownership_strength;
        -: 6080:    }
    #####: 6081:    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
    #####: 6082:      return &static_cast<const T*>(stru)->writer_data_lifecycle;
        -: 6083:    }
    #####: 6084:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
        -: 6085:  }
        -: 6086:
    #####: 6087:  void assign(void* lhs, const char* field, const void* rhs,
        -: 6088:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 6089:  {
        -: 6090:    ACE_UNUSED_ARG(lhs);
        -: 6091:    ACE_UNUSED_ARG(field);
        -: 6092:    ACE_UNUSED_ARG(rhs);
        -: 6093:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 6094:    ACE_UNUSED_ARG(rhsMeta);
    #####: 6095:    if (std::strcmp(field, "durability") == 0) {
    #####: 6096:      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6097:      return;
        -: 6098:    }
    #####: 6099:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 6100:      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6101:      return;
        -: 6102:    }
    #####: 6103:    if (std::strcmp(field, "deadline") == 0) {
    #####: 6104:      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6105:      return;
        -: 6106:    }
    #####: 6107:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 6108:      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6109:      return;
        -: 6110:    }
    #####: 6111:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 6112:      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6113:      return;
        -: 6114:    }
    #####: 6115:    if (std::strcmp(field, "reliability") == 0) {
    #####: 6116:      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6117:      return;
        -: 6118:    }
    #####: 6119:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 6120:      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6121:      return;
        -: 6122:    }
    #####: 6123:    if (std::strcmp(field, "history") == 0) {
    #####: 6124:      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6125:      return;
        -: 6126:    }
    #####: 6127:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 6128:      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6129:      return;
        -: 6130:    }
    #####: 6131:    if (std::strcmp(field, "transport_priority") == 0) {
    #####: 6132:      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6133:      return;
        -: 6134:    }
    #####: 6135:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 6136:      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6137:      return;
        -: 6138:    }
    #####: 6139:    if (std::strcmp(field, "user_data") == 0) {
    #####: 6140:      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6141:      return;
        -: 6142:    }
    #####: 6143:    if (std::strcmp(field, "ownership") == 0) {
    #####: 6144:      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6145:      return;
        -: 6146:    }
    #####: 6147:    if (std::strcmp(field, "ownership_strength") == 0) {
    #####: 6148:      static_cast<T*>(lhs)->ownership_strength = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6149:      return;
        -: 6150:    }
    #####: 6151:    if (std::strcmp(field, "writer_data_lifecycle") == 0) {
    #####: 6152:      static_cast<T*>(lhs)->writer_data_lifecycle = *static_cast<const DDS::WriterDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6153:      return;
        -: 6154:    }
    #####: 6155:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
        -: 6156:  }
        -: 6157:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6158:
    #####: 6159:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 6160:  {
        -: 6161:    ACE_UNUSED_ARG(lhs);
        -: 6162:    ACE_UNUSED_ARG(field);
        -: 6163:    ACE_UNUSED_ARG(rhs);
    #####: 6164:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataWriterQos)");
        -: 6165:  }
        -: 6166:};
        -: 6167:
        -: 6168:template<>
    #####: 6169:const MetaStruct& getMetaStruct<DDS::DataWriterQos>()
        -: 6170:{
    #####: 6171:  static MetaStructImpl<DDS::DataWriterQos> msi;
    #####: 6172:  return msi;
        -: 6173:}
        -: 6174:
    #####: 6175:bool gen_skip_over(Serializer& ser, DDS::DataWriterQos*)
        -: 6176:{
        -: 6177:  ACE_UNUSED_ARG(ser);
    #####: 6178:  MetaStructImpl<DDS::DataWriterQos>().getValue(ser, "");
    #####: 6179:  return true;
        -: 6180:}
        -: 6181:
        -: 6182:}  }
        -: 6183:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6184:
        -: 6185:#endif
        -: 6186:
        -: 6187:/* End STRUCT: DataWriterQos */
        -: 6188:
        -: 6189:
        -: 6190:/* Begin STRUCT: EntityFactoryQosPolicy */
        -: 6191:
        -: 6192:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6193:namespace OpenDDS { namespace DCPS {
        -: 6194:
    #####: 6195:void gen_find_size(const DDS::EntityFactoryQosPolicy& stru, size_t& size, size_t& padding)
        -: 6196:{
        -: 6197:  ACE_UNUSED_ARG(stru);
        -: 6198:  ACE_UNUSED_ARG(size);
        -: 6199:  ACE_UNUSED_ARG(padding);
    #####: 6200:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
    #####: 6201:}
        -: 6202:
    #####: 6203:bool operator<<(Serializer& strm, const DDS::EntityFactoryQosPolicy& stru)
        -: 6204:{
        -: 6205:  ACE_UNUSED_ARG(strm);
        -: 6206:  ACE_UNUSED_ARG(stru);
    #####: 6207:  return (strm << ACE_OutputCDR::from_boolean(stru.autoenable_created_entities));
        -: 6208:}
        -: 6209:
    #####: 6210:bool operator>>(Serializer& strm, DDS::EntityFactoryQosPolicy& stru)
        -: 6211:{
        -: 6212:  ACE_UNUSED_ARG(strm);
        -: 6213:  ACE_UNUSED_ARG(stru);
    #####: 6214:  return (strm >> ACE_InputCDR::to_boolean(stru.autoenable_created_entities));
        -: 6215:}
        -: 6216:
        -: 6217:}  }
        -: 6218:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6219:
        -: 6220:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 6221:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6222:namespace OpenDDS { namespace DCPS {
        -: 6223:
        -: 6224:template<>
    #####: 6225:struct MetaStructImpl<DDS::EntityFactoryQosPolicy> : MetaStruct {
        -: 6226:  typedef DDS::EntityFactoryQosPolicy T;
        -: 6227:
        -: 6228:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6229:  void* allocate() const { return new T; }
        -: 6230:
    #####: 6231:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 6232:
    #####: 6233:  size_t numDcpsKeys() const { return 0; }
        -: 6234:
        -: 6235:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6236:
    #####: 6237:  bool isDcpsKey(const char* field) const
        -: 6238:  {
        -: 6239:    ACE_UNUSED_ARG(field);
    #####: 6240:    return false;
        -: 6241:  }
        -: 6242:
    #####: 6243:  Value getValue(const void* stru, const char* field) const
        -: 6244:  {
    #####: 6245:    const DDS::EntityFactoryQosPolicy& typed = *static_cast<const DDS::EntityFactoryQosPolicy*>(stru);
    #####: 6246:    if (std::strcmp(field, "autoenable_created_entities") == 0) {
    #####: 6247:      return typed.autoenable_created_entities;
        -: 6248:    }
        -: 6249:    ACE_UNUSED_ARG(typed);
    #####: 6250:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
        -: 6251:  }
        -: 6252:
    #####: 6253:  Value getValue(Serializer& ser, const char* field) const
        -: 6254:  {
    #####: 6255:    if (std::strcmp(field, "autoenable_created_entities") == 0) {
        -: 6256:      ACE_CDR::Boolean val;
    #####: 6257:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 6258:        throw std::runtime_error("Field 'autoenable_created_entities' could not be deserialized");
        -: 6259:      }
    #####: 6260:      return val;
        -: 6261:    } else {
    #####: 6262:      if (!ser.skip(1, 1)) {
    #####: 6263:        throw std::runtime_error("Field 'autoenable_created_entities' could not be skipped");
        -: 6264:      }
        -: 6265:    }
    #####: 6266:    if (!field[0]) {
    #####: 6267:      return 0;
        -: 6268:    }
    #####: 6269:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::EntityFactoryQosPolicy");
        -: 6270:  }
        -: 6271:
    #####: 6272:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 6273:  {
        -: 6274:    ACE_UNUSED_ARG(next);
    #####: 6275:    if (std::strcmp(field, "autoenable_created_entities") == 0) {
    #####: 6276:      return make_field_cmp(&T::autoenable_created_entities, next);
        -: 6277:    }
    #####: 6278:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
        -: 6279:  }
        -: 6280:
        -: 6281:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6282:  const char** getFieldNames() const
        -: 6283:  {
        -: 6284:    static const char* names[] = {"autoenable_created_entities", 0};
    #####: 6285:    return names;
        -: 6286:  }
        -: 6287:
    #####: 6288:  const void* getRawField(const void* stru, const char* field) const
        -: 6289:  {
    #####: 6290:    if (std::strcmp(field, "autoenable_created_entities") == 0) {
    #####: 6291:      return &static_cast<const T*>(stru)->autoenable_created_entities;
        -: 6292:    }
    #####: 6293:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
        -: 6294:  }
        -: 6295:
    #####: 6296:  void assign(void* lhs, const char* field, const void* rhs,
        -: 6297:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 6298:  {
        -: 6299:    ACE_UNUSED_ARG(lhs);
        -: 6300:    ACE_UNUSED_ARG(field);
        -: 6301:    ACE_UNUSED_ARG(rhs);
        -: 6302:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 6303:    ACE_UNUSED_ARG(rhsMeta);
    #####: 6304:    if (std::strcmp(field, "autoenable_created_entities") == 0) {
    #####: 6305:      static_cast<T*>(lhs)->autoenable_created_entities = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6306:      return;
        -: 6307:    }
    #####: 6308:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
        -: 6309:  }
        -: 6310:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6311:
    #####: 6312:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 6313:  {
        -: 6314:    ACE_UNUSED_ARG(lhs);
        -: 6315:    ACE_UNUSED_ARG(field);
        -: 6316:    ACE_UNUSED_ARG(rhs);
    #####: 6317:    if (std::strcmp(field, "autoenable_created_entities") == 0) {
    #####: 6318:      return static_cast<const T*>(lhs)->autoenable_created_entities == static_cast<const T*>(rhs)->autoenable_created_entities;
        -: 6319:    }
    #####: 6320:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::EntityFactoryQosPolicy)");
        -: 6321:  }
        -: 6322:};
        -: 6323:
        -: 6324:template<>
    #####: 6325:const MetaStruct& getMetaStruct<DDS::EntityFactoryQosPolicy>()
        -: 6326:{
    #####: 6327:  static MetaStructImpl<DDS::EntityFactoryQosPolicy> msi;
    #####: 6328:  return msi;
        -: 6329:}
        -: 6330:
    #####: 6331:bool gen_skip_over(Serializer& ser, DDS::EntityFactoryQosPolicy*)
        -: 6332:{
        -: 6333:  ACE_UNUSED_ARG(ser);
    #####: 6334:  MetaStructImpl<DDS::EntityFactoryQosPolicy>().getValue(ser, "");
    #####: 6335:  return true;
        -: 6336:}
        -: 6337:
        -: 6338:}  }
        -: 6339:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6340:
        -: 6341:#endif
        -: 6342:
        -: 6343:/* End STRUCT: EntityFactoryQosPolicy */
        -: 6344:
        -: 6345:
        -: 6346:/* Begin STRUCT: PublisherQos */
        -: 6347:
        -: 6348:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6349:namespace OpenDDS { namespace DCPS {
        -: 6350:
    #####: 6351:void gen_find_size(const DDS::PublisherQos& stru, size_t& size, size_t& padding)
        -: 6352:{
        -: 6353:  ACE_UNUSED_ARG(stru);
        -: 6354:  ACE_UNUSED_ARG(size);
        -: 6355:  ACE_UNUSED_ARG(padding);
    #####: 6356:  gen_find_size(stru.presentation, size, padding);
    #####: 6357:  gen_find_size(stru.partition, size, padding);
    #####: 6358:  gen_find_size(stru.group_data, size, padding);
    #####: 6359:  gen_find_size(stru.entity_factory, size, padding);
    #####: 6360:}
        -: 6361:
    #####: 6362:bool operator<<(Serializer& strm, const DDS::PublisherQos& stru)
        -: 6363:{
        -: 6364:  ACE_UNUSED_ARG(strm);
        -: 6365:  ACE_UNUSED_ARG(stru);
    #####: 6366:  return (strm << stru.presentation)
    #####: 6367:    && (strm << stru.partition)
    #####: 6368:    && (strm << stru.group_data)
    #####: 6369:    && (strm << stru.entity_factory);
        -: 6370:}
        -: 6371:
    #####: 6372:bool operator>>(Serializer& strm, DDS::PublisherQos& stru)
        -: 6373:{
        -: 6374:  ACE_UNUSED_ARG(strm);
        -: 6375:  ACE_UNUSED_ARG(stru);
    #####: 6376:  return (strm >> stru.presentation)
    #####: 6377:    && (strm >> stru.partition)
    #####: 6378:    && (strm >> stru.group_data)
    #####: 6379:    && (strm >> stru.entity_factory);
        -: 6380:}
        -: 6381:
        -: 6382:}  }
        -: 6383:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6384:
        -: 6385:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 6386:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6387:namespace OpenDDS { namespace DCPS {
        -: 6388:
        -: 6389:template<>
    #####: 6390:struct MetaStructImpl<DDS::PublisherQos> : MetaStruct {
        -: 6391:  typedef DDS::PublisherQos T;
        -: 6392:
        -: 6393:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6394:  void* allocate() const { return new T; }
        -: 6395:
    #####: 6396:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 6397:
    #####: 6398:  size_t numDcpsKeys() const { return 0; }
        -: 6399:
        -: 6400:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6401:
    #####: 6402:  bool isDcpsKey(const char* field) const
        -: 6403:  {
        -: 6404:    ACE_UNUSED_ARG(field);
    #####: 6405:    return false;
        -: 6406:  }
        -: 6407:
    #####: 6408:  Value getValue(const void* stru, const char* field) const
        -: 6409:  {
    #####: 6410:    const DDS::PublisherQos& typed = *static_cast<const DDS::PublisherQos*>(stru);
    #####: 6411:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 6412:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
        -: 6413:    }
    #####: 6414:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 6415:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
        -: 6416:    }
    #####: 6417:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 6418:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
        -: 6419:    }
    #####: 6420:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 6421:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
        -: 6422:    }
        -: 6423:    ACE_UNUSED_ARG(typed);
    #####: 6424:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
        -: 6425:  }
        -: 6426:
    #####: 6427:  Value getValue(Serializer& ser, const char* field) const
        -: 6428:  {
    #####: 6429:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 6430:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
        -: 6431:    } else {
    #####: 6432:      if (!gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0))) {
    #####: 6433:        throw std::runtime_error("Field 'presentation' could not be skipped");
        -: 6434:      }
        -: 6435:    }
    #####: 6436:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 6437:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
        -: 6438:    } else {
    #####: 6439:      if (!gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0))) {
    #####: 6440:        throw std::runtime_error("Field 'partition' could not be skipped");
        -: 6441:      }
        -: 6442:    }
    #####: 6443:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 6444:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
        -: 6445:    } else {
    #####: 6446:      if (!gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0))) {
    #####: 6447:        throw std::runtime_error("Field 'group_data' could not be skipped");
        -: 6448:      }
        -: 6449:    }
    #####: 6450:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 6451:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
        -: 6452:    } else {
    #####: 6453:      if (!gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0))) {
    #####: 6454:        throw std::runtime_error("Field 'entity_factory' could not be skipped");
        -: 6455:      }
        -: 6456:    }
    #####: 6457:    if (!field[0]) {
    #####: 6458:      return 0;
        -: 6459:    }
    #####: 6460:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PublisherQos");
        -: 6461:  }
        -: 6462:
    #####: 6463:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 6464:  {
        -: 6465:    ACE_UNUSED_ARG(next);
    #####: 6466:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 6467:      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
        -: 6468:    }
    #####: 6469:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 6470:      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
        -: 6471:    }
    #####: 6472:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 6473:      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 6474:    }
    #####: 6475:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 6476:      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
        -: 6477:    }
    #####: 6478:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
        -: 6479:  }
        -: 6480:
        -: 6481:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6482:  const char** getFieldNames() const
        -: 6483:  {
        -: 6484:    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    #####: 6485:    return names;
        -: 6486:  }
        -: 6487:
    #####: 6488:  const void* getRawField(const void* stru, const char* field) const
        -: 6489:  {
    #####: 6490:    if (std::strcmp(field, "presentation") == 0) {
    #####: 6491:      return &static_cast<const T*>(stru)->presentation;
        -: 6492:    }
    #####: 6493:    if (std::strcmp(field, "partition") == 0) {
    #####: 6494:      return &static_cast<const T*>(stru)->partition;
        -: 6495:    }
    #####: 6496:    if (std::strcmp(field, "group_data") == 0) {
    #####: 6497:      return &static_cast<const T*>(stru)->group_data;
        -: 6498:    }
    #####: 6499:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 6500:      return &static_cast<const T*>(stru)->entity_factory;
        -: 6501:    }
    #####: 6502:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
        -: 6503:  }
        -: 6504:
    #####: 6505:  void assign(void* lhs, const char* field, const void* rhs,
        -: 6506:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 6507:  {
        -: 6508:    ACE_UNUSED_ARG(lhs);
        -: 6509:    ACE_UNUSED_ARG(field);
        -: 6510:    ACE_UNUSED_ARG(rhs);
        -: 6511:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 6512:    ACE_UNUSED_ARG(rhsMeta);
    #####: 6513:    if (std::strcmp(field, "presentation") == 0) {
    #####: 6514:      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6515:      return;
        -: 6516:    }
    #####: 6517:    if (std::strcmp(field, "partition") == 0) {
    #####: 6518:      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6519:      return;
        -: 6520:    }
    #####: 6521:    if (std::strcmp(field, "group_data") == 0) {
    #####: 6522:      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6523:      return;
        -: 6524:    }
    #####: 6525:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 6526:      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6527:      return;
        -: 6528:    }
    #####: 6529:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
        -: 6530:  }
        -: 6531:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6532:
    #####: 6533:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 6534:  {
        -: 6535:    ACE_UNUSED_ARG(lhs);
        -: 6536:    ACE_UNUSED_ARG(field);
        -: 6537:    ACE_UNUSED_ARG(rhs);
    #####: 6538:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublisherQos)");
        -: 6539:  }
        -: 6540:};
        -: 6541:
        -: 6542:template<>
    #####: 6543:const MetaStruct& getMetaStruct<DDS::PublisherQos>()
        -: 6544:{
    #####: 6545:  static MetaStructImpl<DDS::PublisherQos> msi;
    #####: 6546:  return msi;
        -: 6547:}
        -: 6548:
    #####: 6549:bool gen_skip_over(Serializer& ser, DDS::PublisherQos*)
        -: 6550:{
        -: 6551:  ACE_UNUSED_ARG(ser);
    #####: 6552:  MetaStructImpl<DDS::PublisherQos>().getValue(ser, "");
    #####: 6553:  return true;
        -: 6554:}
        -: 6555:
        -: 6556:}  }
        -: 6557:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6558:
        -: 6559:#endif
        -: 6560:
        -: 6561:/* End STRUCT: PublisherQos */
        -: 6562:
        -: 6563:
        -: 6564:/* Begin STRUCT: ReaderDataLifecycleQosPolicy */
        -: 6565:
        -: 6566:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6567:namespace OpenDDS { namespace DCPS {
        -: 6568:
    #####: 6569:void gen_find_size(const DDS::ReaderDataLifecycleQosPolicy& stru, size_t& size, size_t& padding)
        -: 6570:{
        -: 6571:  ACE_UNUSED_ARG(stru);
        -: 6572:  ACE_UNUSED_ARG(size);
        -: 6573:  ACE_UNUSED_ARG(padding);
    #####: 6574:  gen_find_size(stru.autopurge_nowriter_samples_delay, size, padding);
    #####: 6575:  gen_find_size(stru.autopurge_disposed_samples_delay, size, padding);
    #####: 6576:}
        -: 6577:
    #####: 6578:bool operator<<(Serializer& strm, const DDS::ReaderDataLifecycleQosPolicy& stru)
        -: 6579:{
        -: 6580:  ACE_UNUSED_ARG(strm);
        -: 6581:  ACE_UNUSED_ARG(stru);
    #####: 6582:  return (strm << stru.autopurge_nowriter_samples_delay)
    #####: 6583:    && (strm << stru.autopurge_disposed_samples_delay);
        -: 6584:}
        -: 6585:
    #####: 6586:bool operator>>(Serializer& strm, DDS::ReaderDataLifecycleQosPolicy& stru)
        -: 6587:{
        -: 6588:  ACE_UNUSED_ARG(strm);
        -: 6589:  ACE_UNUSED_ARG(stru);
    #####: 6590:  return (strm >> stru.autopurge_nowriter_samples_delay)
    #####: 6591:    && (strm >> stru.autopurge_disposed_samples_delay);
        -: 6592:}
        -: 6593:
        -: 6594:}  }
        -: 6595:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6596:
        -: 6597:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 6598:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6599:namespace OpenDDS { namespace DCPS {
        -: 6600:
        -: 6601:template<>
    #####: 6602:struct MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy> : MetaStruct {
        -: 6603:  typedef DDS::ReaderDataLifecycleQosPolicy T;
        -: 6604:
        -: 6605:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6606:  void* allocate() const { return new T; }
        -: 6607:
    #####: 6608:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 6609:
    #####: 6610:  size_t numDcpsKeys() const { return 0; }
        -: 6611:
        -: 6612:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6613:
    #####: 6614:  bool isDcpsKey(const char* field) const
        -: 6615:  {
        -: 6616:    ACE_UNUSED_ARG(field);
    #####: 6617:    return false;
        -: 6618:  }
        -: 6619:
    #####: 6620:  Value getValue(const void* stru, const char* field) const
        -: 6621:  {
    #####: 6622:    const DDS::ReaderDataLifecycleQosPolicy& typed = *static_cast<const DDS::ReaderDataLifecycleQosPolicy*>(stru);
    #####: 6623:    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
    #####: 6624:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.autopurge_nowriter_samples_delay, field + 33);
        -: 6625:    }
    #####: 6626:    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
    #####: 6627:      return getMetaStruct<DDS::Duration_t>().getValue(&typed.autopurge_disposed_samples_delay, field + 33);
        -: 6628:    }
        -: 6629:    ACE_UNUSED_ARG(typed);
    #####: 6630:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
        -: 6631:  }
        -: 6632:
    #####: 6633:  Value getValue(Serializer& ser, const char* field) const
        -: 6634:  {
    #####: 6635:    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
    #####: 6636:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 33);
        -: 6637:    } else {
    #####: 6638:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 6639:        throw std::runtime_error("Field 'autopurge_nowriter_samples_delay' could not be skipped");
        -: 6640:      }
        -: 6641:    }
    #####: 6642:    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
    #####: 6643:      return getMetaStruct<DDS::Duration_t>().getValue(ser, field + 33);
        -: 6644:    } else {
    #####: 6645:      if (!gen_skip_over(ser, static_cast<DDS::Duration_t*>(0))) {
    #####: 6646:        throw std::runtime_error("Field 'autopurge_disposed_samples_delay' could not be skipped");
        -: 6647:      }
        -: 6648:    }
    #####: 6649:    if (!field[0]) {
    #####: 6650:      return 0;
        -: 6651:    }
    #####: 6652:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ReaderDataLifecycleQosPolicy");
        -: 6653:  }
        -: 6654:
    #####: 6655:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 6656:  {
        -: 6657:    ACE_UNUSED_ARG(next);
    #####: 6658:    if (std::strncmp(field, "autopurge_nowriter_samples_delay.", 33) == 0) {
    #####: 6659:      return make_struct_cmp(&T::autopurge_nowriter_samples_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 33), next);
        -: 6660:    }
    #####: 6661:    if (std::strncmp(field, "autopurge_disposed_samples_delay.", 33) == 0) {
    #####: 6662:      return make_struct_cmp(&T::autopurge_disposed_samples_delay, getMetaStruct<DDS::Duration_t>().create_qc_comparator(field + 33), next);
        -: 6663:    }
    #####: 6664:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
        -: 6665:  }
        -: 6666:
        -: 6667:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6668:  const char** getFieldNames() const
        -: 6669:  {
        -: 6670:    static const char* names[] = {"autopurge_nowriter_samples_delay", "autopurge_disposed_samples_delay", 0};
    #####: 6671:    return names;
        -: 6672:  }
        -: 6673:
    #####: 6674:  const void* getRawField(const void* stru, const char* field) const
        -: 6675:  {
    #####: 6676:    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
    #####: 6677:      return &static_cast<const T*>(stru)->autopurge_nowriter_samples_delay;
        -: 6678:    }
    #####: 6679:    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
    #####: 6680:      return &static_cast<const T*>(stru)->autopurge_disposed_samples_delay;
        -: 6681:    }
    #####: 6682:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
        -: 6683:  }
        -: 6684:
    #####: 6685:  void assign(void* lhs, const char* field, const void* rhs,
        -: 6686:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 6687:  {
        -: 6688:    ACE_UNUSED_ARG(lhs);
        -: 6689:    ACE_UNUSED_ARG(field);
        -: 6690:    ACE_UNUSED_ARG(rhs);
        -: 6691:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 6692:    ACE_UNUSED_ARG(rhsMeta);
    #####: 6693:    if (std::strcmp(field, "autopurge_nowriter_samples_delay") == 0) {
    #####: 6694:      static_cast<T*>(lhs)->autopurge_nowriter_samples_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6695:      return;
        -: 6696:    }
    #####: 6697:    if (std::strcmp(field, "autopurge_disposed_samples_delay") == 0) {
    #####: 6698:      static_cast<T*>(lhs)->autopurge_disposed_samples_delay = *static_cast<const DDS::Duration_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 6699:      return;
        -: 6700:    }
    #####: 6701:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
        -: 6702:  }
        -: 6703:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6704:
    #####: 6705:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 6706:  {
        -: 6707:    ACE_UNUSED_ARG(lhs);
        -: 6708:    ACE_UNUSED_ARG(field);
        -: 6709:    ACE_UNUSED_ARG(rhs);
    #####: 6710:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ReaderDataLifecycleQosPolicy)");
        -: 6711:  }
        -: 6712:};
        -: 6713:
        -: 6714:template<>
    #####: 6715:const MetaStruct& getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>()
        -: 6716:{
    #####: 6717:  static MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy> msi;
    #####: 6718:  return msi;
        -: 6719:}
        -: 6720:
    #####: 6721:bool gen_skip_over(Serializer& ser, DDS::ReaderDataLifecycleQosPolicy*)
        -: 6722:{
        -: 6723:  ACE_UNUSED_ARG(ser);
    #####: 6724:  MetaStructImpl<DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, "");
    #####: 6725:  return true;
        -: 6726:}
        -: 6727:
        -: 6728:}  }
        -: 6729:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6730:
        -: 6731:#endif
        -: 6732:
        -: 6733:/* End STRUCT: ReaderDataLifecycleQosPolicy */
        -: 6734:
        -: 6735:
        -: 6736:/* Begin STRUCT: DataReaderQos */
        -: 6737:
        -: 6738:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6739:namespace OpenDDS { namespace DCPS {
        -: 6740:
    #####: 6741:void gen_find_size(const DDS::DataReaderQos& stru, size_t& size, size_t& padding)
        -: 6742:{
        -: 6743:  ACE_UNUSED_ARG(stru);
        -: 6744:  ACE_UNUSED_ARG(size);
        -: 6745:  ACE_UNUSED_ARG(padding);
    #####: 6746:  gen_find_size(stru.durability, size, padding);
    #####: 6747:  gen_find_size(stru.deadline, size, padding);
    #####: 6748:  gen_find_size(stru.latency_budget, size, padding);
    #####: 6749:  gen_find_size(stru.liveliness, size, padding);
    #####: 6750:  gen_find_size(stru.reliability, size, padding);
    #####: 6751:  gen_find_size(stru.destination_order, size, padding);
    #####: 6752:  gen_find_size(stru.history, size, padding);
    #####: 6753:  gen_find_size(stru.resource_limits, size, padding);
    #####: 6754:  gen_find_size(stru.user_data, size, padding);
    #####: 6755:  gen_find_size(stru.ownership, size, padding);
    #####: 6756:  gen_find_size(stru.time_based_filter, size, padding);
    #####: 6757:  gen_find_size(stru.reader_data_lifecycle, size, padding);
    #####: 6758:}
        -: 6759:
    #####: 6760:bool operator<<(Serializer& strm, const DDS::DataReaderQos& stru)
        -: 6761:{
        -: 6762:  ACE_UNUSED_ARG(strm);
        -: 6763:  ACE_UNUSED_ARG(stru);
    #####: 6764:  return (strm << stru.durability)
    #####: 6765:    && (strm << stru.deadline)
    #####: 6766:    && (strm << stru.latency_budget)
    #####: 6767:    && (strm << stru.liveliness)
    #####: 6768:    && (strm << stru.reliability)
    #####: 6769:    && (strm << stru.destination_order)
    #####: 6770:    && (strm << stru.history)
    #####: 6771:    && (strm << stru.resource_limits)
    #####: 6772:    && (strm << stru.user_data)
    #####: 6773:    && (strm << stru.ownership)
    #####: 6774:    && (strm << stru.time_based_filter)
    #####: 6775:    && (strm << stru.reader_data_lifecycle);
        -: 6776:}
        -: 6777:
    #####: 6778:bool operator>>(Serializer& strm, DDS::DataReaderQos& stru)
        -: 6779:{
        -: 6780:  ACE_UNUSED_ARG(strm);
        -: 6781:  ACE_UNUSED_ARG(stru);
    #####: 6782:  return (strm >> stru.durability)
    #####: 6783:    && (strm >> stru.deadline)
    #####: 6784:    && (strm >> stru.latency_budget)
    #####: 6785:    && (strm >> stru.liveliness)
    #####: 6786:    && (strm >> stru.reliability)
    #####: 6787:    && (strm >> stru.destination_order)
    #####: 6788:    && (strm >> stru.history)
    #####: 6789:    && (strm >> stru.resource_limits)
    #####: 6790:    && (strm >> stru.user_data)
    #####: 6791:    && (strm >> stru.ownership)
    #####: 6792:    && (strm >> stru.time_based_filter)
    #####: 6793:    && (strm >> stru.reader_data_lifecycle);
        -: 6794:}
        -: 6795:
        -: 6796:}  }
        -: 6797:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 6798:
        -: 6799:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 6800:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 6801:namespace OpenDDS { namespace DCPS {
        -: 6802:
        -: 6803:template<>
    #####: 6804:struct MetaStructImpl<DDS::DataReaderQos> : MetaStruct {
        -: 6805:  typedef DDS::DataReaderQos T;
        -: 6806:
        -: 6807:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 6808:  void* allocate() const { return new T; }
        -: 6809:
    #####: 6810:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 6811:
    #####: 6812:  size_t numDcpsKeys() const { return 0; }
        -: 6813:
        -: 6814:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 6815:
    #####: 6816:  bool isDcpsKey(const char* field) const
        -: 6817:  {
        -: 6818:    ACE_UNUSED_ARG(field);
    #####: 6819:    return false;
        -: 6820:  }
        -: 6821:
    #####: 6822:  Value getValue(const void* stru, const char* field) const
        -: 6823:  {
    #####: 6824:    const DDS::DataReaderQos& typed = *static_cast<const DDS::DataReaderQos*>(stru);
    #####: 6825:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 6826:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
        -: 6827:    }
    #####: 6828:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 6829:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
        -: 6830:    }
    #####: 6831:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 6832:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
        -: 6833:    }
    #####: 6834:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 6835:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
        -: 6836:    }
    #####: 6837:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 6838:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
        -: 6839:    }
    #####: 6840:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 6841:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
        -: 6842:    }
    #####: 6843:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 6844:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
        -: 6845:    }
    #####: 6846:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 6847:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
        -: 6848:    }
    #####: 6849:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 6850:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
        -: 6851:    }
    #####: 6852:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 6853:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
        -: 6854:    }
    #####: 6855:    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
    #####: 6856:      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
        -: 6857:    }
    #####: 6858:    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
    #####: 6859:      return getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().getValue(&typed.reader_data_lifecycle, field + 22);
        -: 6860:    }
        -: 6861:    ACE_UNUSED_ARG(typed);
    #####: 6862:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
        -: 6863:  }
        -: 6864:
    #####: 6865:  Value getValue(Serializer& ser, const char* field) const
        -: 6866:  {
    #####: 6867:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 6868:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
        -: 6869:    } else {
    #####: 6870:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) {
    #####: 6871:        throw std::runtime_error("Field 'durability' could not be skipped");
        -: 6872:      }
        -: 6873:    }
    #####: 6874:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 6875:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
        -: 6876:    } else {
    #####: 6877:      if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) {
    #####: 6878:        throw std::runtime_error("Field 'deadline' could not be skipped");
        -: 6879:      }
        -: 6880:    }
    #####: 6881:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 6882:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
        -: 6883:    } else {
    #####: 6884:      if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) {
    #####: 6885:        throw std::runtime_error("Field 'latency_budget' could not be skipped");
        -: 6886:      }
        -: 6887:    }
    #####: 6888:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 6889:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
        -: 6890:    } else {
    #####: 6891:      if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) {
    #####: 6892:        throw std::runtime_error("Field 'liveliness' could not be skipped");
        -: 6893:      }
        -: 6894:    }
    #####: 6895:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 6896:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
        -: 6897:    } else {
    #####: 6898:      if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) {
    #####: 6899:        throw std::runtime_error("Field 'reliability' could not be skipped");
        -: 6900:      }
        -: 6901:    }
    #####: 6902:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 6903:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
        -: 6904:    } else {
    #####: 6905:      if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) {
    #####: 6906:        throw std::runtime_error("Field 'destination_order' could not be skipped");
        -: 6907:      }
        -: 6908:    }
    #####: 6909:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 6910:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
        -: 6911:    } else {
    #####: 6912:      if (!gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0))) {
    #####: 6913:        throw std::runtime_error("Field 'history' could not be skipped");
        -: 6914:      }
        -: 6915:    }
    #####: 6916:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 6917:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
        -: 6918:    } else {
    #####: 6919:      if (!gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0))) {
    #####: 6920:        throw std::runtime_error("Field 'resource_limits' could not be skipped");
        -: 6921:      }
        -: 6922:    }
    #####: 6923:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 6924:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
        -: 6925:    } else {
    #####: 6926:      if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) {
    #####: 6927:        throw std::runtime_error("Field 'user_data' could not be skipped");
        -: 6928:      }
        -: 6929:    }
    #####: 6930:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 6931:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
        -: 6932:    } else {
    #####: 6933:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) {
    #####: 6934:        throw std::runtime_error("Field 'ownership' could not be skipped");
        -: 6935:      }
        -: 6936:    }
    #####: 6937:    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
    #####: 6938:      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(ser, field + 18);
        -: 6939:    } else {
    #####: 6940:      if (!gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0))) {
    #####: 6941:        throw std::runtime_error("Field 'time_based_filter' could not be skipped");
        -: 6942:      }
        -: 6943:    }
    #####: 6944:    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
    #####: 6945:      return getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().getValue(ser, field + 22);
        -: 6946:    } else {
    #####: 6947:      if (!gen_skip_over(ser, static_cast<DDS::ReaderDataLifecycleQosPolicy*>(0))) {
    #####: 6948:        throw std::runtime_error("Field 'reader_data_lifecycle' could not be skipped");
        -: 6949:      }
        -: 6950:    }
    #####: 6951:    if (!field[0]) {
    #####: 6952:      return 0;
        -: 6953:    }
    #####: 6954:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DataReaderQos");
        -: 6955:  }
        -: 6956:
    #####: 6957:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 6958:  {
        -: 6959:    ACE_UNUSED_ARG(next);
    #####: 6960:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 6961:      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
        -: 6962:    }
    #####: 6963:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 6964:      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
        -: 6965:    }
    #####: 6966:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 6967:      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
        -: 6968:    }
    #####: 6969:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 6970:      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
        -: 6971:    }
    #####: 6972:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 6973:      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
        -: 6974:    }
    #####: 6975:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 6976:      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
        -: 6977:    }
    #####: 6978:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 6979:      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
        -: 6980:    }
    #####: 6981:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 6982:      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
        -: 6983:    }
    #####: 6984:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 6985:      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
        -: 6986:    }
    #####: 6987:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 6988:      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
        -: 6989:    }
    #####: 6990:    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
    #####: 6991:      return make_struct_cmp(&T::time_based_filter, getMetaStruct<DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18), next);
        -: 6992:    }
    #####: 6993:    if (std::strncmp(field, "reader_data_lifecycle.", 22) == 0) {
    #####: 6994:      return make_struct_cmp(&T::reader_data_lifecycle, getMetaStruct<DDS::ReaderDataLifecycleQosPolicy>().create_qc_comparator(field + 22), next);
        -: 6995:    }
    #####: 6996:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
        -: 6997:  }
        -: 6998:
        -: 6999:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7000:  const char** getFieldNames() const
        -: 7001:  {
        -: 7002:    static const char* names[] = {"durability", "deadline", "latency_budget", "liveliness", "reliability", "destination_order", "history", "resource_limits", "user_data", "ownership", "time_based_filter", "reader_data_lifecycle", 0};
    #####: 7003:    return names;
        -: 7004:  }
        -: 7005:
    #####: 7006:  const void* getRawField(const void* stru, const char* field) const
        -: 7007:  {
    #####: 7008:    if (std::strcmp(field, "durability") == 0) {
    #####: 7009:      return &static_cast<const T*>(stru)->durability;
        -: 7010:    }
    #####: 7011:    if (std::strcmp(field, "deadline") == 0) {
    #####: 7012:      return &static_cast<const T*>(stru)->deadline;
        -: 7013:    }
    #####: 7014:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 7015:      return &static_cast<const T*>(stru)->latency_budget;
        -: 7016:    }
    #####: 7017:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 7018:      return &static_cast<const T*>(stru)->liveliness;
        -: 7019:    }
    #####: 7020:    if (std::strcmp(field, "reliability") == 0) {
    #####: 7021:      return &static_cast<const T*>(stru)->reliability;
        -: 7022:    }
    #####: 7023:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 7024:      return &static_cast<const T*>(stru)->destination_order;
        -: 7025:    }
    #####: 7026:    if (std::strcmp(field, "history") == 0) {
    #####: 7027:      return &static_cast<const T*>(stru)->history;
        -: 7028:    }
    #####: 7029:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 7030:      return &static_cast<const T*>(stru)->resource_limits;
        -: 7031:    }
    #####: 7032:    if (std::strcmp(field, "user_data") == 0) {
    #####: 7033:      return &static_cast<const T*>(stru)->user_data;
        -: 7034:    }
    #####: 7035:    if (std::strcmp(field, "ownership") == 0) {
    #####: 7036:      return &static_cast<const T*>(stru)->ownership;
        -: 7037:    }
    #####: 7038:    if (std::strcmp(field, "time_based_filter") == 0) {
    #####: 7039:      return &static_cast<const T*>(stru)->time_based_filter;
        -: 7040:    }
    #####: 7041:    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
    #####: 7042:      return &static_cast<const T*>(stru)->reader_data_lifecycle;
        -: 7043:    }
    #####: 7044:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
        -: 7045:  }
        -: 7046:
    #####: 7047:  void assign(void* lhs, const char* field, const void* rhs,
        -: 7048:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 7049:  {
        -: 7050:    ACE_UNUSED_ARG(lhs);
        -: 7051:    ACE_UNUSED_ARG(field);
        -: 7052:    ACE_UNUSED_ARG(rhs);
        -: 7053:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 7054:    ACE_UNUSED_ARG(rhsMeta);
    #####: 7055:    if (std::strcmp(field, "durability") == 0) {
    #####: 7056:      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7057:      return;
        -: 7058:    }
    #####: 7059:    if (std::strcmp(field, "deadline") == 0) {
    #####: 7060:      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7061:      return;
        -: 7062:    }
    #####: 7063:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 7064:      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7065:      return;
        -: 7066:    }
    #####: 7067:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 7068:      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7069:      return;
        -: 7070:    }
    #####: 7071:    if (std::strcmp(field, "reliability") == 0) {
    #####: 7072:      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7073:      return;
        -: 7074:    }
    #####: 7075:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 7076:      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7077:      return;
        -: 7078:    }
    #####: 7079:    if (std::strcmp(field, "history") == 0) {
    #####: 7080:      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7081:      return;
        -: 7082:    }
    #####: 7083:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 7084:      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7085:      return;
        -: 7086:    }
    #####: 7087:    if (std::strcmp(field, "user_data") == 0) {
    #####: 7088:      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7089:      return;
        -: 7090:    }
    #####: 7091:    if (std::strcmp(field, "ownership") == 0) {
    #####: 7092:      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7093:      return;
        -: 7094:    }
    #####: 7095:    if (std::strcmp(field, "time_based_filter") == 0) {
    #####: 7096:      static_cast<T*>(lhs)->time_based_filter = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7097:      return;
        -: 7098:    }
    #####: 7099:    if (std::strcmp(field, "reader_data_lifecycle") == 0) {
    #####: 7100:      static_cast<T*>(lhs)->reader_data_lifecycle = *static_cast<const DDS::ReaderDataLifecycleQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7101:      return;
        -: 7102:    }
    #####: 7103:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
        -: 7104:  }
        -: 7105:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7106:
    #####: 7107:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 7108:  {
        -: 7109:    ACE_UNUSED_ARG(lhs);
        -: 7110:    ACE_UNUSED_ARG(field);
        -: 7111:    ACE_UNUSED_ARG(rhs);
    #####: 7112:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DataReaderQos)");
        -: 7113:  }
        -: 7114:};
        -: 7115:
        -: 7116:template<>
    #####: 7117:const MetaStruct& getMetaStruct<DDS::DataReaderQos>()
        -: 7118:{
    #####: 7119:  static MetaStructImpl<DDS::DataReaderQos> msi;
    #####: 7120:  return msi;
        -: 7121:}
        -: 7122:
    #####: 7123:bool gen_skip_over(Serializer& ser, DDS::DataReaderQos*)
        -: 7124:{
        -: 7125:  ACE_UNUSED_ARG(ser);
    #####: 7126:  MetaStructImpl<DDS::DataReaderQos>().getValue(ser, "");
    #####: 7127:  return true;
        -: 7128:}
        -: 7129:
        -: 7130:}  }
        -: 7131:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7132:
        -: 7133:#endif
        -: 7134:
        -: 7135:/* End STRUCT: DataReaderQos */
        -: 7136:
        -: 7137:
        -: 7138:/* Begin STRUCT: SubscriberQos */
        -: 7139:
        -: 7140:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7141:namespace OpenDDS { namespace DCPS {
        -: 7142:
    #####: 7143:void gen_find_size(const DDS::SubscriberQos& stru, size_t& size, size_t& padding)
        -: 7144:{
        -: 7145:  ACE_UNUSED_ARG(stru);
        -: 7146:  ACE_UNUSED_ARG(size);
        -: 7147:  ACE_UNUSED_ARG(padding);
    #####: 7148:  gen_find_size(stru.presentation, size, padding);
    #####: 7149:  gen_find_size(stru.partition, size, padding);
    #####: 7150:  gen_find_size(stru.group_data, size, padding);
    #####: 7151:  gen_find_size(stru.entity_factory, size, padding);
    #####: 7152:}
        -: 7153:
    #####: 7154:bool operator<<(Serializer& strm, const DDS::SubscriberQos& stru)
        -: 7155:{
        -: 7156:  ACE_UNUSED_ARG(strm);
        -: 7157:  ACE_UNUSED_ARG(stru);
    #####: 7158:  return (strm << stru.presentation)
    #####: 7159:    && (strm << stru.partition)
    #####: 7160:    && (strm << stru.group_data)
    #####: 7161:    && (strm << stru.entity_factory);
        -: 7162:}
        -: 7163:
    #####: 7164:bool operator>>(Serializer& strm, DDS::SubscriberQos& stru)
        -: 7165:{
        -: 7166:  ACE_UNUSED_ARG(strm);
        -: 7167:  ACE_UNUSED_ARG(stru);
    #####: 7168:  return (strm >> stru.presentation)
    #####: 7169:    && (strm >> stru.partition)
    #####: 7170:    && (strm >> stru.group_data)
    #####: 7171:    && (strm >> stru.entity_factory);
        -: 7172:}
        -: 7173:
        -: 7174:}  }
        -: 7175:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7176:
        -: 7177:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 7178:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7179:namespace OpenDDS { namespace DCPS {
        -: 7180:
        -: 7181:template<>
    #####: 7182:struct MetaStructImpl<DDS::SubscriberQos> : MetaStruct {
        -: 7183:  typedef DDS::SubscriberQos T;
        -: 7184:
        -: 7185:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7186:  void* allocate() const { return new T; }
        -: 7187:
    #####: 7188:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 7189:
    #####: 7190:  size_t numDcpsKeys() const { return 0; }
        -: 7191:
        -: 7192:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7193:
    #####: 7194:  bool isDcpsKey(const char* field) const
        -: 7195:  {
        -: 7196:    ACE_UNUSED_ARG(field);
    #####: 7197:    return false;
        -: 7198:  }
        -: 7199:
    #####: 7200:  Value getValue(const void* stru, const char* field) const
        -: 7201:  {
    #####: 7202:    const DDS::SubscriberQos& typed = *static_cast<const DDS::SubscriberQos*>(stru);
    #####: 7203:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 7204:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
        -: 7205:    }
    #####: 7206:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 7207:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
        -: 7208:    }
    #####: 7209:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 7210:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
        -: 7211:    }
    #####: 7212:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7213:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
        -: 7214:    }
        -: 7215:    ACE_UNUSED_ARG(typed);
    #####: 7216:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
        -: 7217:  }
        -: 7218:
    #####: 7219:  Value getValue(Serializer& ser, const char* field) const
        -: 7220:  {
    #####: 7221:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 7222:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
        -: 7223:    } else {
    #####: 7224:      if (!gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0))) {
    #####: 7225:        throw std::runtime_error("Field 'presentation' could not be skipped");
        -: 7226:      }
        -: 7227:    }
    #####: 7228:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 7229:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
        -: 7230:    } else {
    #####: 7231:      if (!gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0))) {
    #####: 7232:        throw std::runtime_error("Field 'partition' could not be skipped");
        -: 7233:      }
        -: 7234:    }
    #####: 7235:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 7236:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
        -: 7237:    } else {
    #####: 7238:      if (!gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0))) {
    #####: 7239:        throw std::runtime_error("Field 'group_data' could not be skipped");
        -: 7240:      }
        -: 7241:    }
    #####: 7242:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7243:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
        -: 7244:    } else {
    #####: 7245:      if (!gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0))) {
    #####: 7246:        throw std::runtime_error("Field 'entity_factory' could not be skipped");
        -: 7247:      }
        -: 7248:    }
    #####: 7249:    if (!field[0]) {
    #####: 7250:      return 0;
        -: 7251:    }
    #####: 7252:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::SubscriberQos");
        -: 7253:  }
        -: 7254:
    #####: 7255:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 7256:  {
        -: 7257:    ACE_UNUSED_ARG(next);
    #####: 7258:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 7259:      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
        -: 7260:    }
    #####: 7261:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 7262:      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
        -: 7263:    }
    #####: 7264:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 7265:      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 7266:    }
    #####: 7267:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7268:      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
        -: 7269:    }
    #####: 7270:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
        -: 7271:  }
        -: 7272:
        -: 7273:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7274:  const char** getFieldNames() const
        -: 7275:  {
        -: 7276:    static const char* names[] = {"presentation", "partition", "group_data", "entity_factory", 0};
    #####: 7277:    return names;
        -: 7278:  }
        -: 7279:
    #####: 7280:  const void* getRawField(const void* stru, const char* field) const
        -: 7281:  {
    #####: 7282:    if (std::strcmp(field, "presentation") == 0) {
    #####: 7283:      return &static_cast<const T*>(stru)->presentation;
        -: 7284:    }
    #####: 7285:    if (std::strcmp(field, "partition") == 0) {
    #####: 7286:      return &static_cast<const T*>(stru)->partition;
        -: 7287:    }
    #####: 7288:    if (std::strcmp(field, "group_data") == 0) {
    #####: 7289:      return &static_cast<const T*>(stru)->group_data;
        -: 7290:    }
    #####: 7291:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 7292:      return &static_cast<const T*>(stru)->entity_factory;
        -: 7293:    }
    #####: 7294:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
        -: 7295:  }
        -: 7296:
    #####: 7297:  void assign(void* lhs, const char* field, const void* rhs,
        -: 7298:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 7299:  {
        -: 7300:    ACE_UNUSED_ARG(lhs);
        -: 7301:    ACE_UNUSED_ARG(field);
        -: 7302:    ACE_UNUSED_ARG(rhs);
        -: 7303:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 7304:    ACE_UNUSED_ARG(rhsMeta);
    #####: 7305:    if (std::strcmp(field, "presentation") == 0) {
    #####: 7306:      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7307:      return;
        -: 7308:    }
    #####: 7309:    if (std::strcmp(field, "partition") == 0) {
    #####: 7310:      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7311:      return;
        -: 7312:    }
    #####: 7313:    if (std::strcmp(field, "group_data") == 0) {
    #####: 7314:      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7315:      return;
        -: 7316:    }
    #####: 7317:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 7318:      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7319:      return;
        -: 7320:    }
    #####: 7321:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
        -: 7322:  }
        -: 7323:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7324:
    #####: 7325:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 7326:  {
        -: 7327:    ACE_UNUSED_ARG(lhs);
        -: 7328:    ACE_UNUSED_ARG(field);
        -: 7329:    ACE_UNUSED_ARG(rhs);
    #####: 7330:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriberQos)");
        -: 7331:  }
        -: 7332:};
        -: 7333:
        -: 7334:template<>
    #####: 7335:const MetaStruct& getMetaStruct<DDS::SubscriberQos>()
        -: 7336:{
    #####: 7337:  static MetaStructImpl<DDS::SubscriberQos> msi;
    #####: 7338:  return msi;
        -: 7339:}
        -: 7340:
    #####: 7341:bool gen_skip_over(Serializer& ser, DDS::SubscriberQos*)
        -: 7342:{
        -: 7343:  ACE_UNUSED_ARG(ser);
    #####: 7344:  MetaStructImpl<DDS::SubscriberQos>().getValue(ser, "");
    #####: 7345:  return true;
        -: 7346:}
        -: 7347:
        -: 7348:}  }
        -: 7349:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7350:
        -: 7351:#endif
        -: 7352:
        -: 7353:/* End STRUCT: SubscriberQos */
        -: 7354:
        -: 7355:
        -: 7356:/* Begin STRUCT: DomainParticipantFactoryQos */
        -: 7357:
        -: 7358:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7359:namespace OpenDDS { namespace DCPS {
        -: 7360:
    #####: 7361:void gen_find_size(const DDS::DomainParticipantFactoryQos& stru, size_t& size, size_t& padding)
        -: 7362:{
        -: 7363:  ACE_UNUSED_ARG(stru);
        -: 7364:  ACE_UNUSED_ARG(size);
        -: 7365:  ACE_UNUSED_ARG(padding);
    #####: 7366:  gen_find_size(stru.entity_factory, size, padding);
    #####: 7367:}
        -: 7368:
    #####: 7369:bool operator<<(Serializer& strm, const DDS::DomainParticipantFactoryQos& stru)
        -: 7370:{
        -: 7371:  ACE_UNUSED_ARG(strm);
        -: 7372:  ACE_UNUSED_ARG(stru);
    #####: 7373:  return (strm << stru.entity_factory);
        -: 7374:}
        -: 7375:
    #####: 7376:bool operator>>(Serializer& strm, DDS::DomainParticipantFactoryQos& stru)
        -: 7377:{
        -: 7378:  ACE_UNUSED_ARG(strm);
        -: 7379:  ACE_UNUSED_ARG(stru);
    #####: 7380:  return (strm >> stru.entity_factory);
        -: 7381:}
        -: 7382:
        -: 7383:}  }
        -: 7384:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7385:
        -: 7386:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 7387:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7388:namespace OpenDDS { namespace DCPS {
        -: 7389:
        -: 7390:template<>
    #####: 7391:struct MetaStructImpl<DDS::DomainParticipantFactoryQos> : MetaStruct {
        -: 7392:  typedef DDS::DomainParticipantFactoryQos T;
        -: 7393:
        -: 7394:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7395:  void* allocate() const { return new T; }
        -: 7396:
    #####: 7397:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 7398:
    #####: 7399:  size_t numDcpsKeys() const { return 0; }
        -: 7400:
        -: 7401:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7402:
    #####: 7403:  bool isDcpsKey(const char* field) const
        -: 7404:  {
        -: 7405:    ACE_UNUSED_ARG(field);
    #####: 7406:    return false;
        -: 7407:  }
        -: 7408:
    #####: 7409:  Value getValue(const void* stru, const char* field) const
        -: 7410:  {
    #####: 7411:    const DDS::DomainParticipantFactoryQos& typed = *static_cast<const DDS::DomainParticipantFactoryQos*>(stru);
    #####: 7412:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7413:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
        -: 7414:    }
        -: 7415:    ACE_UNUSED_ARG(typed);
    #####: 7416:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
        -: 7417:  }
        -: 7418:
    #####: 7419:  Value getValue(Serializer& ser, const char* field) const
        -: 7420:  {
    #####: 7421:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7422:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
        -: 7423:    } else {
    #####: 7424:      if (!gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0))) {
    #####: 7425:        throw std::runtime_error("Field 'entity_factory' could not be skipped");
        -: 7426:      }
        -: 7427:    }
    #####: 7428:    if (!field[0]) {
    #####: 7429:      return 0;
        -: 7430:    }
    #####: 7431:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DomainParticipantFactoryQos");
        -: 7432:  }
        -: 7433:
    #####: 7434:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 7435:  {
        -: 7436:    ACE_UNUSED_ARG(next);
    #####: 7437:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7438:      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
        -: 7439:    }
    #####: 7440:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
        -: 7441:  }
        -: 7442:
        -: 7443:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7444:  const char** getFieldNames() const
        -: 7445:  {
        -: 7446:    static const char* names[] = {"entity_factory", 0};
    #####: 7447:    return names;
        -: 7448:  }
        -: 7449:
    #####: 7450:  const void* getRawField(const void* stru, const char* field) const
        -: 7451:  {
    #####: 7452:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 7453:      return &static_cast<const T*>(stru)->entity_factory;
        -: 7454:    }
    #####: 7455:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
        -: 7456:  }
        -: 7457:
    #####: 7458:  void assign(void* lhs, const char* field, const void* rhs,
        -: 7459:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 7460:  {
        -: 7461:    ACE_UNUSED_ARG(lhs);
        -: 7462:    ACE_UNUSED_ARG(field);
        -: 7463:    ACE_UNUSED_ARG(rhs);
        -: 7464:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 7465:    ACE_UNUSED_ARG(rhsMeta);
    #####: 7466:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 7467:      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7468:      return;
        -: 7469:    }
    #####: 7470:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
        -: 7471:  }
        -: 7472:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7473:
    #####: 7474:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 7475:  {
        -: 7476:    ACE_UNUSED_ARG(lhs);
        -: 7477:    ACE_UNUSED_ARG(field);
        -: 7478:    ACE_UNUSED_ARG(rhs);
    #####: 7479:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantFactoryQos)");
        -: 7480:  }
        -: 7481:};
        -: 7482:
        -: 7483:template<>
    #####: 7484:const MetaStruct& getMetaStruct<DDS::DomainParticipantFactoryQos>()
        -: 7485:{
    #####: 7486:  static MetaStructImpl<DDS::DomainParticipantFactoryQos> msi;
    #####: 7487:  return msi;
        -: 7488:}
        -: 7489:
    #####: 7490:bool gen_skip_over(Serializer& ser, DDS::DomainParticipantFactoryQos*)
        -: 7491:{
        -: 7492:  ACE_UNUSED_ARG(ser);
    #####: 7493:  MetaStructImpl<DDS::DomainParticipantFactoryQos>().getValue(ser, "");
    #####: 7494:  return true;
        -: 7495:}
        -: 7496:
        -: 7497:}  }
        -: 7498:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7499:
        -: 7500:#endif
        -: 7501:
        -: 7502:/* End STRUCT: DomainParticipantFactoryQos */
        -: 7503:
        -: 7504:
        -: 7505:/* Begin STRUCT: DomainParticipantQos */
        -: 7506:
        -: 7507:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7508:namespace OpenDDS { namespace DCPS {
        -: 7509:
    #####: 7510:void gen_find_size(const DDS::DomainParticipantQos& stru, size_t& size, size_t& padding)
        -: 7511:{
        -: 7512:  ACE_UNUSED_ARG(stru);
        -: 7513:  ACE_UNUSED_ARG(size);
        -: 7514:  ACE_UNUSED_ARG(padding);
    #####: 7515:  gen_find_size(stru.user_data, size, padding);
    #####: 7516:  gen_find_size(stru.entity_factory, size, padding);
    #####: 7517:  gen_find_size(stru.property, size, padding);
    #####: 7518:}
        -: 7519:
    #####: 7520:bool operator<<(Serializer& strm, const DDS::DomainParticipantQos& stru)
        -: 7521:{
        -: 7522:  ACE_UNUSED_ARG(strm);
        -: 7523:  ACE_UNUSED_ARG(stru);
    #####: 7524:  return (strm << stru.user_data)
    #####: 7525:    && (strm << stru.entity_factory)
    #####: 7526:    && (strm << stru.property);
        -: 7527:}
        -: 7528:
    #####: 7529:bool operator>>(Serializer& strm, DDS::DomainParticipantQos& stru)
        -: 7530:{
        -: 7531:  ACE_UNUSED_ARG(strm);
        -: 7532:  ACE_UNUSED_ARG(stru);
    #####: 7533:  return (strm >> stru.user_data)
    #####: 7534:    && (strm >> stru.entity_factory)
    #####: 7535:    && (strm >> stru.property);
        -: 7536:}
        -: 7537:
        -: 7538:}  }
        -: 7539:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7540:
        -: 7541:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 7542:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7543:namespace OpenDDS { namespace DCPS {
        -: 7544:
        -: 7545:template<>
    #####: 7546:struct MetaStructImpl<DDS::DomainParticipantQos> : MetaStruct {
        -: 7547:  typedef DDS::DomainParticipantQos T;
        -: 7548:
        -: 7549:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7550:  void* allocate() const { return new T; }
        -: 7551:
    #####: 7552:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 7553:
    #####: 7554:  size_t numDcpsKeys() const { return 0; }
        -: 7555:
        -: 7556:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7557:
    #####: 7558:  bool isDcpsKey(const char* field) const
        -: 7559:  {
        -: 7560:    ACE_UNUSED_ARG(field);
    #####: 7561:    return false;
        -: 7562:  }
        -: 7563:
    #####: 7564:  Value getValue(const void* stru, const char* field) const
        -: 7565:  {
    #####: 7566:    const DDS::DomainParticipantQos& typed = *static_cast<const DDS::DomainParticipantQos*>(stru);
    #####: 7567:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 7568:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
        -: 7569:    }
    #####: 7570:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7571:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(&typed.entity_factory, field + 15);
        -: 7572:    }
    #####: 7573:    if (std::strncmp(field, "property.", 9) == 0) {
    #####: 7574:      return getMetaStruct<DDS::PropertyQosPolicy>().getValue(&typed.property, field + 9);
        -: 7575:    }
        -: 7576:    ACE_UNUSED_ARG(typed);
    #####: 7577:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
        -: 7578:  }
        -: 7579:
    #####: 7580:  Value getValue(Serializer& ser, const char* field) const
        -: 7581:  {
    #####: 7582:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 7583:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
        -: 7584:    } else {
    #####: 7585:      if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) {
    #####: 7586:        throw std::runtime_error("Field 'user_data' could not be skipped");
        -: 7587:      }
        -: 7588:    }
    #####: 7589:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7590:      return getMetaStruct<DDS::EntityFactoryQosPolicy>().getValue(ser, field + 15);
        -: 7591:    } else {
    #####: 7592:      if (!gen_skip_over(ser, static_cast<DDS::EntityFactoryQosPolicy*>(0))) {
    #####: 7593:        throw std::runtime_error("Field 'entity_factory' could not be skipped");
        -: 7594:      }
        -: 7595:    }
    #####: 7596:    if (std::strncmp(field, "property.", 9) == 0) {
    #####: 7597:      return getMetaStruct<DDS::PropertyQosPolicy>().getValue(ser, field + 9);
        -: 7598:    } else {
    #####: 7599:      if (!gen_skip_over(ser, static_cast<DDS::PropertyQosPolicy*>(0))) {
    #####: 7600:        throw std::runtime_error("Field 'property' could not be skipped");
        -: 7601:      }
        -: 7602:    }
    #####: 7603:    if (!field[0]) {
    #####: 7604:      return 0;
        -: 7605:    }
    #####: 7606:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::DomainParticipantQos");
        -: 7607:  }
        -: 7608:
    #####: 7609:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 7610:  {
        -: 7611:    ACE_UNUSED_ARG(next);
    #####: 7612:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 7613:      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
        -: 7614:    }
    #####: 7615:    if (std::strncmp(field, "entity_factory.", 15) == 0) {
    #####: 7616:      return make_struct_cmp(&T::entity_factory, getMetaStruct<DDS::EntityFactoryQosPolicy>().create_qc_comparator(field + 15), next);
        -: 7617:    }
    #####: 7618:    if (std::strncmp(field, "property.", 9) == 0) {
    #####: 7619:      return make_struct_cmp(&T::property, getMetaStruct<DDS::PropertyQosPolicy>().create_qc_comparator(field + 9), next);
        -: 7620:    }
    #####: 7621:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
        -: 7622:  }
        -: 7623:
        -: 7624:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7625:  const char** getFieldNames() const
        -: 7626:  {
        -: 7627:    static const char* names[] = {"user_data", "entity_factory", "property", 0};
    #####: 7628:    return names;
        -: 7629:  }
        -: 7630:
    #####: 7631:  const void* getRawField(const void* stru, const char* field) const
        -: 7632:  {
    #####: 7633:    if (std::strcmp(field, "user_data") == 0) {
    #####: 7634:      return &static_cast<const T*>(stru)->user_data;
        -: 7635:    }
    #####: 7636:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 7637:      return &static_cast<const T*>(stru)->entity_factory;
        -: 7638:    }
    #####: 7639:    if (std::strcmp(field, "property") == 0) {
    #####: 7640:      return &static_cast<const T*>(stru)->property;
        -: 7641:    }
    #####: 7642:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
        -: 7643:  }
        -: 7644:
    #####: 7645:  void assign(void* lhs, const char* field, const void* rhs,
        -: 7646:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 7647:  {
        -: 7648:    ACE_UNUSED_ARG(lhs);
        -: 7649:    ACE_UNUSED_ARG(field);
        -: 7650:    ACE_UNUSED_ARG(rhs);
        -: 7651:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 7652:    ACE_UNUSED_ARG(rhsMeta);
    #####: 7653:    if (std::strcmp(field, "user_data") == 0) {
    #####: 7654:      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7655:      return;
        -: 7656:    }
    #####: 7657:    if (std::strcmp(field, "entity_factory") == 0) {
    #####: 7658:      static_cast<T*>(lhs)->entity_factory = *static_cast<const DDS::EntityFactoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7659:      return;
        -: 7660:    }
    #####: 7661:    if (std::strcmp(field, "property") == 0) {
    #####: 7662:      static_cast<T*>(lhs)->property = *static_cast<const DDS::PropertyQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7663:      return;
        -: 7664:    }
    #####: 7665:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
        -: 7666:  }
        -: 7667:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7668:
    #####: 7669:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 7670:  {
        -: 7671:    ACE_UNUSED_ARG(lhs);
        -: 7672:    ACE_UNUSED_ARG(field);
        -: 7673:    ACE_UNUSED_ARG(rhs);
    #####: 7674:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::DomainParticipantQos)");
        -: 7675:  }
        -: 7676:};
        -: 7677:
        -: 7678:template<>
    #####: 7679:const MetaStruct& getMetaStruct<DDS::DomainParticipantQos>()
        -: 7680:{
    #####: 7681:  static MetaStructImpl<DDS::DomainParticipantQos> msi;
    #####: 7682:  return msi;
        -: 7683:}
        -: 7684:
    #####: 7685:bool gen_skip_over(Serializer& ser, DDS::DomainParticipantQos*)
        -: 7686:{
        -: 7687:  ACE_UNUSED_ARG(ser);
    #####: 7688:  MetaStructImpl<DDS::DomainParticipantQos>().getValue(ser, "");
    #####: 7689:  return true;
        -: 7690:}
        -: 7691:
        -: 7692:}  }
        -: 7693:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7694:
        -: 7695:#endif
        -: 7696:
        -: 7697:/* End STRUCT: DomainParticipantQos */
        -: 7698:
        -: 7699:
        -: 7700:/* Begin STRUCT: BuiltinTopicKey_t */
        -: 7701:
        -: 7702:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7703:namespace OpenDDS { namespace DCPS {
        -: 7704:
       24: 7705:void gen_find_size(const DDS::BuiltinTopicKey_t& stru, size_t& size, size_t& padding)
        -: 7706:{
        -: 7707:  ACE_UNUSED_ARG(stru);
        -: 7708:  ACE_UNUSED_ARG(size);
        -: 7709:  ACE_UNUSED_ARG(padding);
       48: 7710:  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
       24: 7711:  gen_find_size(stru_value, size, padding);
       24: 7712:}
        -: 7713:
       24: 7714:bool operator<<(Serializer& strm, const DDS::BuiltinTopicKey_t& stru)
        -: 7715:{
        -: 7716:  ACE_UNUSED_ARG(strm);
        -: 7717:  ACE_UNUSED_ARG(stru);
       48: 7718:  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
       48: 7719:  return (strm << stru_value);
        -: 7720:}
        -: 7721:
    #####: 7722:bool operator>>(Serializer& strm, DDS::BuiltinTopicKey_t& stru)
        -: 7723:{
        -: 7724:  ACE_UNUSED_ARG(strm);
        -: 7725:  ACE_UNUSED_ARG(stru);
    #####: 7726:  DDS::BuiltinTopicKeyValue_forany stru_value(const_cast<DDS::BuiltinTopicKeyValue_slice*>(stru.value));
    #####: 7727:  return (strm >> stru_value);
        -: 7728:}
        -: 7729:
        -: 7730:}  }
        -: 7731:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7732:
        -: 7733:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 7734:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7735:namespace OpenDDS { namespace DCPS {
        -: 7736:
        -: 7737:template<>
    #####: 7738:struct MetaStructImpl<DDS::BuiltinTopicKey_t> : MetaStruct {
        -: 7739:  typedef DDS::BuiltinTopicKey_t T;
        -: 7740:
        -: 7741:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7742:  void* allocate() const { return new T; }
        -: 7743:
    #####: 7744:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 7745:
    #####: 7746:  size_t numDcpsKeys() const { return 0; }
        -: 7747:
        -: 7748:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7749:
    #####: 7750:  bool isDcpsKey(const char* field) const
        -: 7751:  {
        -: 7752:    ACE_UNUSED_ARG(field);
    #####: 7753:    return false;
        -: 7754:  }
        -: 7755:
    #####: 7756:  Value getValue(const void* stru, const char* field) const
        -: 7757:  {
    #####: 7758:    const DDS::BuiltinTopicKey_t& typed = *static_cast<const DDS::BuiltinTopicKey_t*>(stru);
        -: 7759:    ACE_UNUSED_ARG(typed);
    #####: 7760:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
        -: 7761:  }
        -: 7762:
    #####: 7763:  Value getValue(Serializer& ser, const char* field) const
        -: 7764:  {
    #####: 7765:    if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKeyValue_forany*>(0))) {
    #####: 7766:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 7767:    }
    #####: 7768:    if (!field[0]) {
    #####: 7769:      return 0;
        -: 7770:    }
    #####: 7771:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::BuiltinTopicKey_t");
        -: 7772:  }
        -: 7773:
    #####: 7774:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 7775:  {
        -: 7776:    ACE_UNUSED_ARG(next);
    #####: 7777:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
        -: 7778:  }
        -: 7779:
        -: 7780:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7781:  const char** getFieldNames() const
        -: 7782:  {
        -: 7783:    static const char* names[] = {"value", 0};
    #####: 7784:    return names;
        -: 7785:  }
        -: 7786:
    #####: 7787:  const void* getRawField(const void* stru, const char* field) const
        -: 7788:  {
    #####: 7789:    if (std::strcmp(field, "value") == 0) {
    #####: 7790:      return &static_cast<const T*>(stru)->value;
        -: 7791:    }
    #####: 7792:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
        -: 7793:  }
        -: 7794:
    #####: 7795:  void assign(void* lhs, const char* field, const void* rhs,
        -: 7796:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 7797:  {
        -: 7798:    ACE_UNUSED_ARG(lhs);
        -: 7799:    ACE_UNUSED_ARG(field);
        -: 7800:    ACE_UNUSED_ARG(rhs);
        -: 7801:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 7802:    ACE_UNUSED_ARG(rhsMeta);
    #####: 7803:    if (std::strcmp(field, "value") == 0) {
    #####: 7804:      DDS::BuiltinTopicKeyValue* lhsArr = &static_cast<T*>(lhs)->value;
    #####: 7805:      const DDS::BuiltinTopicKeyValue* rhsArr = static_cast<const DDS::BuiltinTopicKeyValue*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 7806:      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    #####: 7807:        (*lhsArr)[i0] = (*rhsArr)[i0];
        -: 7808:      }
    #####: 7809:      return;
        -: 7810:    }
    #####: 7811:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
        -: 7812:  }
        -: 7813:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 7814:
    #####: 7815:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 7816:  {
        -: 7817:    ACE_UNUSED_ARG(lhs);
        -: 7818:    ACE_UNUSED_ARG(field);
        -: 7819:    ACE_UNUSED_ARG(rhs);
    #####: 7820:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::BuiltinTopicKey_t)");
        -: 7821:  }
        -: 7822:};
        -: 7823:
        -: 7824:template<>
    #####: 7825:const MetaStruct& getMetaStruct<DDS::BuiltinTopicKey_t>()
        -: 7826:{
    #####: 7827:  static MetaStructImpl<DDS::BuiltinTopicKey_t> msi;
    #####: 7828:  return msi;
        -: 7829:}
        -: 7830:
    #####: 7831:bool gen_skip_over(Serializer& ser, DDS::BuiltinTopicKey_t*)
        -: 7832:{
        -: 7833:  ACE_UNUSED_ARG(ser);
    #####: 7834:  MetaStructImpl<DDS::BuiltinTopicKey_t>().getValue(ser, "");
    #####: 7835:  return true;
        -: 7836:}
        -: 7837:
        -: 7838:}  }
        -: 7839:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7840:
        -: 7841:#endif
        -: 7842:
        -: 7843:/* End STRUCT: BuiltinTopicKey_t */
        -: 7844:
        -: 7845:
        -: 7846:/* Begin STRUCT: ParticipantBuiltinTopicData */
        -: 7847:
        -: 7848:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7849:namespace OpenDDS { namespace DCPS {
        -: 7850:
        6: 7851:void gen_find_size(const DDS::ParticipantBuiltinTopicData& stru, size_t& size, size_t& padding)
        -: 7852:{
        -: 7853:  ACE_UNUSED_ARG(stru);
        -: 7854:  ACE_UNUSED_ARG(size);
        -: 7855:  ACE_UNUSED_ARG(padding);
        6: 7856:  gen_find_size(stru.key, size, padding);
        6: 7857:  gen_find_size(stru.user_data, size, padding);
        6: 7858:}
        -: 7859:
        6: 7860:bool operator<<(Serializer& strm, const DDS::ParticipantBuiltinTopicData& stru)
        -: 7861:{
        -: 7862:  ACE_UNUSED_ARG(strm);
        -: 7863:  ACE_UNUSED_ARG(stru);
        6: 7864:  return (strm << stru.key)
        6: 7865:    && (strm << stru.user_data);
        -: 7866:}
        -: 7867:
    #####: 7868:bool operator>>(Serializer& strm, DDS::ParticipantBuiltinTopicData& stru)
        -: 7869:{
        -: 7870:  ACE_UNUSED_ARG(strm);
        -: 7871:  ACE_UNUSED_ARG(stru);
    #####: 7872:  return (strm >> stru.key)
    #####: 7873:    && (strm >> stru.user_data);
        -: 7874:}
        -: 7875:
    #####: 7876:size_t gen_max_marshaled_size(const DDS::ParticipantBuiltinTopicData& stru, bool align)
        -: 7877:{
        -: 7878:  ACE_UNUSED_ARG(stru);
        -: 7879:  ACE_UNUSED_ARG(align);
    #####: 7880:  return 0;
        -: 7881:}
        -: 7882:
        3: 7883:size_t gen_max_marshaled_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, bool align)
        -: 7884:{
        -: 7885:  ACE_UNUSED_ARG(stru);
        -: 7886:  ACE_UNUSED_ARG(align);
        3: 7887:  return 12;
        -: 7888:}
        -: 7889:
    #####: 7890:void gen_find_size(KeyOnly<const DDS::ParticipantBuiltinTopicData> stru, size_t& size, size_t& padding)
        -: 7891:{
        -: 7892:  ACE_UNUSED_ARG(stru);
        -: 7893:  ACE_UNUSED_ARG(size);
        -: 7894:  ACE_UNUSED_ARG(padding);
    #####: 7895:  if ((size + padding) % 4) {
    #####: 7896:    padding += 4 - ((size + padding) % 4);
        -: 7897:  }
    #####: 7898:  size += gen_max_marshaled_size(stru.t.key.value[0]);
    #####: 7899:  if ((size + padding) % 4) {
    #####: 7900:    padding += 4 - ((size + padding) % 4);
        -: 7901:  }
    #####: 7902:  size += gen_max_marshaled_size(stru.t.key.value[1]);
    #####: 7903:  if ((size + padding) % 4) {
    #####: 7904:    padding += 4 - ((size + padding) % 4);
        -: 7905:  }
    #####: 7906:  size += gen_max_marshaled_size(stru.t.key.value[2]);
    #####: 7907:}
        -: 7908:
        6: 7909:bool operator<<(Serializer& strm, KeyOnly<const DDS::ParticipantBuiltinTopicData> stru)
        -: 7910:{
        -: 7911:  ACE_UNUSED_ARG(strm);
        -: 7912:  ACE_UNUSED_ARG(stru);
        6: 7913:  return (strm << stru.t.key.value[0])
        6: 7914:    && (strm << stru.t.key.value[1])
       12: 7915:    && (strm << stru.t.key.value[2]);
        -: 7916:}
        -: 7917:
    #####: 7918:bool operator>>(Serializer& strm, KeyOnly<DDS::ParticipantBuiltinTopicData> stru)
        -: 7919:{
        -: 7920:  ACE_UNUSED_ARG(strm);
        -: 7921:  ACE_UNUSED_ARG(stru);
    #####: 7922:  return (strm >> stru.t.key.value[0])
    #####: 7923:    && (strm >> stru.t.key.value[1])
    #####: 7924:    && (strm >> stru.t.key.value[2]);
        -: 7925:}
        -: 7926:
        -: 7927:}  }
        -: 7928:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7929:
        -: 7930:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7931:namespace DDS {
        3: 7932:::DDS::DataWriter_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_datawriter()
        -: 7933:{
        -: 7934:  typedef OpenDDS::DCPS::DataWriterImpl_T<ParticipantBuiltinTopicData> DataWriterImplType;
        3: 7935:  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
        3: 7936:  ACE_NEW_NORETURN(writer_impl,
        -: 7937:                   DataWriterImplType());
        3: 7938:  return writer_impl;
        -: 7939:}
        -: 7940:
    #####: 7941:::DDS::DataReader_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_datareader()
        -: 7942:{
        -: 7943:  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantBuiltinTopicData> DataReaderImplType;
    #####: 7944:  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
    #####: 7945:  ACE_NEW_NORETURN(reader_impl,
        -: 7946:                   DataReaderImplType());
    #####: 7947:  return reader_impl;
        -: 7948:}
        -: 7949:
        -: 7950:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7951:::DDS::DataReader_ptr ParticipantBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
        -: 7952:{
        -: 7953:  typedef OpenDDS::DCPS::DataReaderImpl_T<ParticipantBuiltinTopicData> DataReaderImplType;
        -: 7954:  typedef OpenDDS::DCPS::MultiTopicDataReader_T<ParticipantBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
    #####: 7955:  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
    #####: 7956:  ACE_NEW_NORETURN(multitopic_reader_impl,
        -: 7957:                   MultiTopicDataReaderImplType());
    #####: 7958:  return multitopic_reader_impl;
        -: 7959:}
        -: 7960:#endif /* !OPENDDS_NO_MULTI_TOPIC */
        -: 7961:
        -: 7962:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
    #####: 7963:const OpenDDS::DCPS::MetaStruct& ParticipantBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
        -: 7964:{
    #####: 7965:  return OpenDDS::DCPS::getMetaStruct<ParticipantBuiltinTopicData>();
        -: 7966:}
        -: 7967:#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
        -: 7968:
        3: 7969:bool ParticipantBuiltinTopicDataTypeSupportImpl::has_dcps_key()
        -: 7970:{
        3: 7971:  return TraitsType::gen_has_key ();
        -: 7972:}
        -: 7973:
    #####: 7974:const char* ParticipantBuiltinTopicDataTypeSupportImpl::default_type_name() const
        -: 7975:{
    #####: 7976:  return TraitsType::type_name();
        -: 7977:}
        -: 7978:
    #####: 7979:ParticipantBuiltinTopicDataTypeSupport::_ptr_type ParticipantBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
        -: 7980:{
    #####: 7981:  return TypeSupportType::_narrow(obj);
        -: 7982:}
        -: 7983:}
        -: 7984:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 7985:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 7986:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 7987:namespace OpenDDS { namespace DCPS {
        -: 7988:
        -: 7989:template<>
    #####: 7990:struct MetaStructImpl<DDS::ParticipantBuiltinTopicData> : MetaStruct {
        -: 7991:  typedef DDS::ParticipantBuiltinTopicData T;
        -: 7992:
        -: 7993:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 7994:  void* allocate() const { return new T; }
        -: 7995:
    #####: 7996:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 7997:
    #####: 7998:  size_t numDcpsKeys() const { return 3; }
        -: 7999:
        -: 8000:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 8001:
    #####: 8002:  bool isDcpsKey(const char* field) const
        -: 8003:  {
    #####: 8004:    if (!ACE_OS::strcmp(field, "key.value[0]")) {
    #####: 8005:      return true;
        -: 8006:    }
    #####: 8007:    if (!ACE_OS::strcmp(field, "key.value[1]")) {
    #####: 8008:      return true;
        -: 8009:    }
    #####: 8010:    if (!ACE_OS::strcmp(field, "key.value[2]")) {
    #####: 8011:      return true;
        -: 8012:    }
    #####: 8013:    return false;
        -: 8014:  }
        -: 8015:
    #####: 8016:  Value getValue(const void* stru, const char* field) const
        -: 8017:  {
    #####: 8018:    const DDS::ParticipantBuiltinTopicData& typed = *static_cast<const DDS::ParticipantBuiltinTopicData*>(stru);
    #####: 8019:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 8020:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
        -: 8021:    }
    #####: 8022:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 8023:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
        -: 8024:    }
        -: 8025:    ACE_UNUSED_ARG(typed);
    #####: 8026:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
        -: 8027:  }
        -: 8028:
    #####: 8029:  Value getValue(Serializer& ser, const char* field) const
        -: 8030:  {
    #####: 8031:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 8032:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
        -: 8033:    } else {
    #####: 8034:      if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0))) {
    #####: 8035:        throw std::runtime_error("Field 'key' could not be skipped");
        -: 8036:      }
        -: 8037:    }
    #####: 8038:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 8039:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
        -: 8040:    } else {
    #####: 8041:      if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) {
    #####: 8042:        throw std::runtime_error("Field 'user_data' could not be skipped");
        -: 8043:      }
        -: 8044:    }
    #####: 8045:    if (!field[0]) {
    #####: 8046:      return 0;
        -: 8047:    }
    #####: 8048:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::ParticipantBuiltinTopicData");
        -: 8049:  }
        -: 8050:
    #####: 8051:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 8052:  {
        -: 8053:    ACE_UNUSED_ARG(next);
    #####: 8054:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 8055:      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
        -: 8056:    }
    #####: 8057:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 8058:      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
        -: 8059:    }
    #####: 8060:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
        -: 8061:  }
        -: 8062:
        -: 8063:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 8064:  const char** getFieldNames() const
        -: 8065:  {
        -: 8066:    static const char* names[] = {"key", "user_data", 0};
    #####: 8067:    return names;
        -: 8068:  }
        -: 8069:
    #####: 8070:  const void* getRawField(const void* stru, const char* field) const
        -: 8071:  {
    #####: 8072:    if (std::strcmp(field, "key") == 0) {
    #####: 8073:      return &static_cast<const T*>(stru)->key;
        -: 8074:    }
    #####: 8075:    if (std::strcmp(field, "user_data") == 0) {
    #####: 8076:      return &static_cast<const T*>(stru)->user_data;
        -: 8077:    }
    #####: 8078:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
        -: 8079:  }
        -: 8080:
    #####: 8081:  void assign(void* lhs, const char* field, const void* rhs,
        -: 8082:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 8083:  {
        -: 8084:    ACE_UNUSED_ARG(lhs);
        -: 8085:    ACE_UNUSED_ARG(field);
        -: 8086:    ACE_UNUSED_ARG(rhs);
        -: 8087:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 8088:    ACE_UNUSED_ARG(rhsMeta);
    #####: 8089:    if (std::strcmp(field, "key") == 0) {
    #####: 8090:      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8091:      return;
        -: 8092:    }
    #####: 8093:    if (std::strcmp(field, "user_data") == 0) {
    #####: 8094:      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8095:      return;
        -: 8096:    }
    #####: 8097:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
        -: 8098:  }
        -: 8099:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 8100:
    #####: 8101:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 8102:  {
        -: 8103:    ACE_UNUSED_ARG(lhs);
        -: 8104:    ACE_UNUSED_ARG(field);
        -: 8105:    ACE_UNUSED_ARG(rhs);
    #####: 8106:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::ParticipantBuiltinTopicData)");
        -: 8107:  }
        -: 8108:};
        -: 8109:
        -: 8110:template<>
    #####: 8111:const MetaStruct& getMetaStruct<DDS::ParticipantBuiltinTopicData>()
        -: 8112:{
    #####: 8113:  static MetaStructImpl<DDS::ParticipantBuiltinTopicData> msi;
    #####: 8114:  return msi;
        -: 8115:}
        -: 8116:
    #####: 8117:bool gen_skip_over(Serializer& ser, DDS::ParticipantBuiltinTopicData*)
        -: 8118:{
        -: 8119:  ACE_UNUSED_ARG(ser);
    #####: 8120:  MetaStructImpl<DDS::ParticipantBuiltinTopicData>().getValue(ser, "");
    #####: 8121:  return true;
        -: 8122:}
        -: 8123:
        -: 8124:}  }
        -: 8125:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 8126:
        -: 8127:#endif
        -: 8128:
        -: 8129:/* End STRUCT: ParticipantBuiltinTopicData */
        -: 8130:
        -: 8131:
        -: 8132:/* Begin STRUCT: PublicationBuiltinTopicData */
        -: 8133:
        -: 8134:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 8135:namespace OpenDDS { namespace DCPS {
        -: 8136:
        3: 8137:void gen_find_size(const DDS::PublicationBuiltinTopicData& stru, size_t& size, size_t& padding)
        -: 8138:{
        -: 8139:  ACE_UNUSED_ARG(stru);
        -: 8140:  ACE_UNUSED_ARG(size);
        -: 8141:  ACE_UNUSED_ARG(padding);
        3: 8142:  gen_find_size(stru.key, size, padding);
        3: 8143:  gen_find_size(stru.participant_key, size, padding);
        3: 8144:  find_size_ulong(size, padding);
        3: 8145:  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
        3: 8146:  find_size_ulong(size, padding);
        3: 8147:  size += ACE_OS::strlen(stru.type_name.in()) + 1;
        3: 8148:  gen_find_size(stru.durability, size, padding);
        3: 8149:  gen_find_size(stru.durability_service, size, padding);
        3: 8150:  gen_find_size(stru.deadline, size, padding);
        3: 8151:  gen_find_size(stru.latency_budget, size, padding);
        3: 8152:  gen_find_size(stru.liveliness, size, padding);
        3: 8153:  gen_find_size(stru.reliability, size, padding);
        3: 8154:  gen_find_size(stru.lifespan, size, padding);
        3: 8155:  gen_find_size(stru.user_data, size, padding);
        3: 8156:  gen_find_size(stru.ownership, size, padding);
        3: 8157:  gen_find_size(stru.ownership_strength, size, padding);
        3: 8158:  gen_find_size(stru.destination_order, size, padding);
        3: 8159:  gen_find_size(stru.presentation, size, padding);
        3: 8160:  gen_find_size(stru.partition, size, padding);
        3: 8161:  gen_find_size(stru.topic_data, size, padding);
        3: 8162:  gen_find_size(stru.group_data, size, padding);
        3: 8163:}
        -: 8164:
        3: 8165:bool operator<<(Serializer& strm, const DDS::PublicationBuiltinTopicData& stru)
        -: 8166:{
        -: 8167:  ACE_UNUSED_ARG(strm);
        -: 8168:  ACE_UNUSED_ARG(stru);
        3: 8169:  return (strm << stru.key)
        3: 8170:    && (strm << stru.participant_key)
        3: 8171:    && (strm << stru.topic_name.in())
        3: 8172:    && (strm << stru.type_name.in())
        3: 8173:    && (strm << stru.durability)
        3: 8174:    && (strm << stru.durability_service)
        3: 8175:    && (strm << stru.deadline)
        3: 8176:    && (strm << stru.latency_budget)
        3: 8177:    && (strm << stru.liveliness)
        3: 8178:    && (strm << stru.reliability)
        3: 8179:    && (strm << stru.lifespan)
        3: 8180:    && (strm << stru.user_data)
        3: 8181:    && (strm << stru.ownership)
        3: 8182:    && (strm << stru.ownership_strength)
        3: 8183:    && (strm << stru.destination_order)
        3: 8184:    && (strm << stru.presentation)
        3: 8185:    && (strm << stru.partition)
        3: 8186:    && (strm << stru.topic_data)
        6: 8187:    && (strm << stru.group_data);
        -: 8188:}
        -: 8189:
    #####: 8190:bool operator>>(Serializer& strm, DDS::PublicationBuiltinTopicData& stru)
        -: 8191:{
        -: 8192:  ACE_UNUSED_ARG(strm);
        -: 8193:  ACE_UNUSED_ARG(stru);
    #####: 8194:  return (strm >> stru.key)
    #####: 8195:    && (strm >> stru.participant_key)
    #####: 8196:    && (strm >> stru.topic_name.out())
    #####: 8197:    && (strm >> stru.type_name.out())
    #####: 8198:    && (strm >> stru.durability)
    #####: 8199:    && (strm >> stru.durability_service)
    #####: 8200:    && (strm >> stru.deadline)
    #####: 8201:    && (strm >> stru.latency_budget)
    #####: 8202:    && (strm >> stru.liveliness)
    #####: 8203:    && (strm >> stru.reliability)
    #####: 8204:    && (strm >> stru.lifespan)
    #####: 8205:    && (strm >> stru.user_data)
    #####: 8206:    && (strm >> stru.ownership)
    #####: 8207:    && (strm >> stru.ownership_strength)
    #####: 8208:    && (strm >> stru.destination_order)
    #####: 8209:    && (strm >> stru.presentation)
    #####: 8210:    && (strm >> stru.partition)
    #####: 8211:    && (strm >> stru.topic_data)
    #####: 8212:    && (strm >> stru.group_data);
        -: 8213:}
        -: 8214:
    #####: 8215:size_t gen_max_marshaled_size(const DDS::PublicationBuiltinTopicData& stru, bool align)
        -: 8216:{
        -: 8217:  ACE_UNUSED_ARG(stru);
        -: 8218:  ACE_UNUSED_ARG(align);
    #####: 8219:  return 0;
        -: 8220:}
        -: 8221:
        3: 8222:size_t gen_max_marshaled_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, bool align)
        -: 8223:{
        -: 8224:  ACE_UNUSED_ARG(stru);
        -: 8225:  ACE_UNUSED_ARG(align);
        3: 8226:  return 12;
        -: 8227:}
        -: 8228:
    #####: 8229:void gen_find_size(KeyOnly<const DDS::PublicationBuiltinTopicData> stru, size_t& size, size_t& padding)
        -: 8230:{
        -: 8231:  ACE_UNUSED_ARG(stru);
        -: 8232:  ACE_UNUSED_ARG(size);
        -: 8233:  ACE_UNUSED_ARG(padding);
    #####: 8234:  if ((size + padding) % 4) {
    #####: 8235:    padding += 4 - ((size + padding) % 4);
        -: 8236:  }
    #####: 8237:  size += gen_max_marshaled_size(stru.t.key.value[0]);
    #####: 8238:  if ((size + padding) % 4) {
    #####: 8239:    padding += 4 - ((size + padding) % 4);
        -: 8240:  }
    #####: 8241:  size += gen_max_marshaled_size(stru.t.key.value[1]);
    #####: 8242:  if ((size + padding) % 4) {
    #####: 8243:    padding += 4 - ((size + padding) % 4);
        -: 8244:  }
    #####: 8245:  size += gen_max_marshaled_size(stru.t.key.value[2]);
    #####: 8246:}
        -: 8247:
        3: 8248:bool operator<<(Serializer& strm, KeyOnly<const DDS::PublicationBuiltinTopicData> stru)
        -: 8249:{
        -: 8250:  ACE_UNUSED_ARG(strm);
        -: 8251:  ACE_UNUSED_ARG(stru);
        3: 8252:  return (strm << stru.t.key.value[0])
        3: 8253:    && (strm << stru.t.key.value[1])
        6: 8254:    && (strm << stru.t.key.value[2]);
        -: 8255:}
        -: 8256:
    #####: 8257:bool operator>>(Serializer& strm, KeyOnly<DDS::PublicationBuiltinTopicData> stru)
        -: 8258:{
        -: 8259:  ACE_UNUSED_ARG(strm);
        -: 8260:  ACE_UNUSED_ARG(stru);
    #####: 8261:  return (strm >> stru.t.key.value[0])
    #####: 8262:    && (strm >> stru.t.key.value[1])
    #####: 8263:    && (strm >> stru.t.key.value[2]);
        -: 8264:}
        -: 8265:
        -: 8266:}  }
        -: 8267:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 8268:
        -: 8269:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 8270:namespace DDS {
        3: 8271:::DDS::DataWriter_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_datawriter()
        -: 8272:{
        -: 8273:  typedef OpenDDS::DCPS::DataWriterImpl_T<PublicationBuiltinTopicData> DataWriterImplType;
        3: 8274:  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
        3: 8275:  ACE_NEW_NORETURN(writer_impl,
        -: 8276:                   DataWriterImplType());
        3: 8277:  return writer_impl;
        -: 8278:}
        -: 8279:
    #####: 8280:::DDS::DataReader_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_datareader()
        -: 8281:{
        -: 8282:  typedef OpenDDS::DCPS::DataReaderImpl_T<PublicationBuiltinTopicData> DataReaderImplType;
    #####: 8283:  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
    #####: 8284:  ACE_NEW_NORETURN(reader_impl,
        -: 8285:                   DataReaderImplType());
    #####: 8286:  return reader_impl;
        -: 8287:}
        -: 8288:
        -: 8289:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 8290:::DDS::DataReader_ptr PublicationBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
        -: 8291:{
        -: 8292:  typedef OpenDDS::DCPS::DataReaderImpl_T<PublicationBuiltinTopicData> DataReaderImplType;
        -: 8293:  typedef OpenDDS::DCPS::MultiTopicDataReader_T<PublicationBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
    #####: 8294:  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
    #####: 8295:  ACE_NEW_NORETURN(multitopic_reader_impl,
        -: 8296:                   MultiTopicDataReaderImplType());
    #####: 8297:  return multitopic_reader_impl;
        -: 8298:}
        -: 8299:#endif /* !OPENDDS_NO_MULTI_TOPIC */
        -: 8300:
        -: 8301:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
    #####: 8302:const OpenDDS::DCPS::MetaStruct& PublicationBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
        -: 8303:{
    #####: 8304:  return OpenDDS::DCPS::getMetaStruct<PublicationBuiltinTopicData>();
        -: 8305:}
        -: 8306:#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
        -: 8307:
        3: 8308:bool PublicationBuiltinTopicDataTypeSupportImpl::has_dcps_key()
        -: 8309:{
        3: 8310:  return TraitsType::gen_has_key ();
        -: 8311:}
        -: 8312:
    #####: 8313:const char* PublicationBuiltinTopicDataTypeSupportImpl::default_type_name() const
        -: 8314:{
    #####: 8315:  return TraitsType::type_name();
        -: 8316:}
        -: 8317:
    #####: 8318:PublicationBuiltinTopicDataTypeSupport::_ptr_type PublicationBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
        -: 8319:{
    #####: 8320:  return TypeSupportType::_narrow(obj);
        -: 8321:}
        -: 8322:}
        -: 8323:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 8324:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 8325:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 8326:namespace OpenDDS { namespace DCPS {
        -: 8327:
        -: 8328:template<>
    #####: 8329:struct MetaStructImpl<DDS::PublicationBuiltinTopicData> : MetaStruct {
        -: 8330:  typedef DDS::PublicationBuiltinTopicData T;
        -: 8331:
        -: 8332:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 8333:  void* allocate() const { return new T; }
        -: 8334:
    #####: 8335:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 8336:
    #####: 8337:  size_t numDcpsKeys() const { return 3; }
        -: 8338:
        -: 8339:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 8340:
    #####: 8341:  bool isDcpsKey(const char* field) const
        -: 8342:  {
    #####: 8343:    if (!ACE_OS::strcmp(field, "key.value[0]")) {
    #####: 8344:      return true;
        -: 8345:    }
    #####: 8346:    if (!ACE_OS::strcmp(field, "key.value[1]")) {
    #####: 8347:      return true;
        -: 8348:    }
    #####: 8349:    if (!ACE_OS::strcmp(field, "key.value[2]")) {
    #####: 8350:      return true;
        -: 8351:    }
    #####: 8352:    return false;
        -: 8353:  }
        -: 8354:
    #####: 8355:  Value getValue(const void* stru, const char* field) const
        -: 8356:  {
    #####: 8357:    const DDS::PublicationBuiltinTopicData& typed = *static_cast<const DDS::PublicationBuiltinTopicData*>(stru);
    #####: 8358:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 8359:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
        -: 8360:    }
    #####: 8361:    if (std::strncmp(field, "participant_key.", 16) == 0) {
    #####: 8362:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
        -: 8363:    }
    #####: 8364:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 8365:      return typed.topic_name.in();
        -: 8366:    }
    #####: 8367:    if (std::strcmp(field, "type_name") == 0) {
    #####: 8368:      return typed.type_name.in();
        -: 8369:    }
    #####: 8370:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 8371:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
        -: 8372:    }
    #####: 8373:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 8374:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
        -: 8375:    }
    #####: 8376:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 8377:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
        -: 8378:    }
    #####: 8379:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 8380:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
        -: 8381:    }
    #####: 8382:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 8383:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
        -: 8384:    }
    #####: 8385:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 8386:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
        -: 8387:    }
    #####: 8388:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 8389:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
        -: 8390:    }
    #####: 8391:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 8392:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
        -: 8393:    }
    #####: 8394:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 8395:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
        -: 8396:    }
    #####: 8397:    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
    #####: 8398:      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(&typed.ownership_strength, field + 19);
        -: 8399:    }
    #####: 8400:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 8401:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
        -: 8402:    }
    #####: 8403:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 8404:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
        -: 8405:    }
    #####: 8406:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 8407:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
        -: 8408:    }
    #####: 8409:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 8410:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
        -: 8411:    }
    #####: 8412:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 8413:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
        -: 8414:    }
        -: 8415:    ACE_UNUSED_ARG(typed);
    #####: 8416:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
        -: 8417:  }
        -: 8418:
    #####: 8419:  Value getValue(Serializer& ser, const char* field) const
        -: 8420:  {
    #####: 8421:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 8422:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
        -: 8423:    } else {
    #####: 8424:      if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0))) {
    #####: 8425:        throw std::runtime_error("Field 'key' could not be skipped");
        -: 8426:      }
        -: 8427:    }
    #####: 8428:    if (std::strncmp(field, "participant_key.", 16) == 0) {
    #####: 8429:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 16);
        -: 8430:    } else {
    #####: 8431:      if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0))) {
    #####: 8432:        throw std::runtime_error("Field 'participant_key' could not be skipped");
        -: 8433:      }
        -: 8434:    }
    #####: 8435:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 8436:      TAO::String_Manager val;
    #####: 8437:      if (!(ser >> val.out())) {
    #####: 8438:        throw std::runtime_error("Field 'topic_name' could not be deserialized");
        -: 8439:      }
    #####: 8440:      return val;
        -: 8441:    } else {
        -: 8442:      ACE_CDR::ULong len;
    #####: 8443:      if (!(ser >> len)) {
    #####: 8444:        throw std::runtime_error("String 'topic_name' length could not be deserialized");
        -: 8445:      }
    #####: 8446:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 8447:        throw std::runtime_error("String 'topic_name' contents could not be skipped");
        -: 8448:      }
        -: 8449:    }
    #####: 8450:    if (std::strcmp(field, "type_name") == 0) {
    #####: 8451:      TAO::String_Manager val;
    #####: 8452:      if (!(ser >> val.out())) {
    #####: 8453:        throw std::runtime_error("Field 'type_name' could not be deserialized");
        -: 8454:      }
    #####: 8455:      return val;
        -: 8456:    } else {
        -: 8457:      ACE_CDR::ULong len;
    #####: 8458:      if (!(ser >> len)) {
    #####: 8459:        throw std::runtime_error("String 'type_name' length could not be deserialized");
        -: 8460:      }
    #####: 8461:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 8462:        throw std::runtime_error("String 'type_name' contents could not be skipped");
        -: 8463:      }
        -: 8464:    }
    #####: 8465:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 8466:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
        -: 8467:    } else {
    #####: 8468:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) {
    #####: 8469:        throw std::runtime_error("Field 'durability' could not be skipped");
        -: 8470:      }
        -: 8471:    }
    #####: 8472:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 8473:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
        -: 8474:    } else {
    #####: 8475:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0))) {
    #####: 8476:        throw std::runtime_error("Field 'durability_service' could not be skipped");
        -: 8477:      }
        -: 8478:    }
    #####: 8479:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 8480:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
        -: 8481:    } else {
    #####: 8482:      if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) {
    #####: 8483:        throw std::runtime_error("Field 'deadline' could not be skipped");
        -: 8484:      }
        -: 8485:    }
    #####: 8486:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 8487:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
        -: 8488:    } else {
    #####: 8489:      if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) {
    #####: 8490:        throw std::runtime_error("Field 'latency_budget' could not be skipped");
        -: 8491:      }
        -: 8492:    }
    #####: 8493:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 8494:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
        -: 8495:    } else {
    #####: 8496:      if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) {
    #####: 8497:        throw std::runtime_error("Field 'liveliness' could not be skipped");
        -: 8498:      }
        -: 8499:    }
    #####: 8500:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 8501:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
        -: 8502:    } else {
    #####: 8503:      if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) {
    #####: 8504:        throw std::runtime_error("Field 'reliability' could not be skipped");
        -: 8505:      }
        -: 8506:    }
    #####: 8507:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 8508:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
        -: 8509:    } else {
    #####: 8510:      if (!gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0))) {
    #####: 8511:        throw std::runtime_error("Field 'lifespan' could not be skipped");
        -: 8512:      }
        -: 8513:    }
    #####: 8514:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 8515:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
        -: 8516:    } else {
    #####: 8517:      if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) {
    #####: 8518:        throw std::runtime_error("Field 'user_data' could not be skipped");
        -: 8519:      }
        -: 8520:    }
    #####: 8521:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 8522:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
        -: 8523:    } else {
    #####: 8524:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) {
    #####: 8525:        throw std::runtime_error("Field 'ownership' could not be skipped");
        -: 8526:      }
        -: 8527:    }
    #####: 8528:    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
    #####: 8529:      return getMetaStruct<DDS::OwnershipStrengthQosPolicy>().getValue(ser, field + 19);
        -: 8530:    } else {
    #####: 8531:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipStrengthQosPolicy*>(0))) {
    #####: 8532:        throw std::runtime_error("Field 'ownership_strength' could not be skipped");
        -: 8533:      }
        -: 8534:    }
    #####: 8535:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 8536:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
        -: 8537:    } else {
    #####: 8538:      if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) {
    #####: 8539:        throw std::runtime_error("Field 'destination_order' could not be skipped");
        -: 8540:      }
        -: 8541:    }
    #####: 8542:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 8543:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
        -: 8544:    } else {
    #####: 8545:      if (!gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0))) {
    #####: 8546:        throw std::runtime_error("Field 'presentation' could not be skipped");
        -: 8547:      }
        -: 8548:    }
    #####: 8549:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 8550:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
        -: 8551:    } else {
    #####: 8552:      if (!gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0))) {
    #####: 8553:        throw std::runtime_error("Field 'partition' could not be skipped");
        -: 8554:      }
        -: 8555:    }
    #####: 8556:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 8557:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
        -: 8558:    } else {
    #####: 8559:      if (!gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0))) {
    #####: 8560:        throw std::runtime_error("Field 'topic_data' could not be skipped");
        -: 8561:      }
        -: 8562:    }
    #####: 8563:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 8564:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
        -: 8565:    } else {
    #####: 8566:      if (!gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0))) {
    #####: 8567:        throw std::runtime_error("Field 'group_data' could not be skipped");
        -: 8568:      }
        -: 8569:    }
    #####: 8570:    if (!field[0]) {
    #####: 8571:      return 0;
        -: 8572:    }
    #####: 8573:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::PublicationBuiltinTopicData");
        -: 8574:  }
        -: 8575:
    #####: 8576:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 8577:  {
        -: 8578:    ACE_UNUSED_ARG(next);
    #####: 8579:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 8580:      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
        -: 8581:    }
    #####: 8582:    if (std::strncmp(field, "participant_key.", 16) == 0) {
    #####: 8583:      return make_struct_cmp(&T::participant_key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16), next);
        -: 8584:    }
    #####: 8585:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 8586:      return make_field_cmp(&T::topic_name, next);
        -: 8587:    }
    #####: 8588:    if (std::strcmp(field, "type_name") == 0) {
    #####: 8589:      return make_field_cmp(&T::type_name, next);
        -: 8590:    }
    #####: 8591:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 8592:      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
        -: 8593:    }
    #####: 8594:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 8595:      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
        -: 8596:    }
    #####: 8597:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 8598:      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
        -: 8599:    }
    #####: 8600:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 8601:      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
        -: 8602:    }
    #####: 8603:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 8604:      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
        -: 8605:    }
    #####: 8606:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 8607:      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
        -: 8608:    }
    #####: 8609:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 8610:      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
        -: 8611:    }
    #####: 8612:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 8613:      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
        -: 8614:    }
    #####: 8615:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 8616:      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
        -: 8617:    }
    #####: 8618:    if (std::strncmp(field, "ownership_strength.", 19) == 0) {
    #####: 8619:      return make_struct_cmp(&T::ownership_strength, getMetaStruct<DDS::OwnershipStrengthQosPolicy>().create_qc_comparator(field + 19), next);
        -: 8620:    }
    #####: 8621:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 8622:      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
        -: 8623:    }
    #####: 8624:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 8625:      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
        -: 8626:    }
    #####: 8627:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 8628:      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
        -: 8629:    }
    #####: 8630:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 8631:      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 8632:    }
    #####: 8633:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 8634:      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 8635:    }
    #####: 8636:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
        -: 8637:  }
        -: 8638:
        -: 8639:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 8640:  const char** getFieldNames() const
        -: 8641:  {
        -: 8642:    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "lifespan", "user_data", "ownership", "ownership_strength", "destination_order", "presentation", "partition", "topic_data", "group_data", 0};
    #####: 8643:    return names;
        -: 8644:  }
        -: 8645:
    #####: 8646:  const void* getRawField(const void* stru, const char* field) const
        -: 8647:  {
    #####: 8648:    if (std::strcmp(field, "key") == 0) {
    #####: 8649:      return &static_cast<const T*>(stru)->key;
        -: 8650:    }
    #####: 8651:    if (std::strcmp(field, "participant_key") == 0) {
    #####: 8652:      return &static_cast<const T*>(stru)->participant_key;
        -: 8653:    }
    #####: 8654:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 8655:      return &static_cast<const T*>(stru)->topic_name;
        -: 8656:    }
    #####: 8657:    if (std::strcmp(field, "type_name") == 0) {
    #####: 8658:      return &static_cast<const T*>(stru)->type_name;
        -: 8659:    }
    #####: 8660:    if (std::strcmp(field, "durability") == 0) {
    #####: 8661:      return &static_cast<const T*>(stru)->durability;
        -: 8662:    }
    #####: 8663:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 8664:      return &static_cast<const T*>(stru)->durability_service;
        -: 8665:    }
    #####: 8666:    if (std::strcmp(field, "deadline") == 0) {
    #####: 8667:      return &static_cast<const T*>(stru)->deadline;
        -: 8668:    }
    #####: 8669:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 8670:      return &static_cast<const T*>(stru)->latency_budget;
        -: 8671:    }
    #####: 8672:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 8673:      return &static_cast<const T*>(stru)->liveliness;
        -: 8674:    }
    #####: 8675:    if (std::strcmp(field, "reliability") == 0) {
    #####: 8676:      return &static_cast<const T*>(stru)->reliability;
        -: 8677:    }
    #####: 8678:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 8679:      return &static_cast<const T*>(stru)->lifespan;
        -: 8680:    }
    #####: 8681:    if (std::strcmp(field, "user_data") == 0) {
    #####: 8682:      return &static_cast<const T*>(stru)->user_data;
        -: 8683:    }
    #####: 8684:    if (std::strcmp(field, "ownership") == 0) {
    #####: 8685:      return &static_cast<const T*>(stru)->ownership;
        -: 8686:    }
    #####: 8687:    if (std::strcmp(field, "ownership_strength") == 0) {
    #####: 8688:      return &static_cast<const T*>(stru)->ownership_strength;
        -: 8689:    }
    #####: 8690:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 8691:      return &static_cast<const T*>(stru)->destination_order;
        -: 8692:    }
    #####: 8693:    if (std::strcmp(field, "presentation") == 0) {
    #####: 8694:      return &static_cast<const T*>(stru)->presentation;
        -: 8695:    }
    #####: 8696:    if (std::strcmp(field, "partition") == 0) {
    #####: 8697:      return &static_cast<const T*>(stru)->partition;
        -: 8698:    }
    #####: 8699:    if (std::strcmp(field, "topic_data") == 0) {
    #####: 8700:      return &static_cast<const T*>(stru)->topic_data;
        -: 8701:    }
    #####: 8702:    if (std::strcmp(field, "group_data") == 0) {
    #####: 8703:      return &static_cast<const T*>(stru)->group_data;
        -: 8704:    }
    #####: 8705:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
        -: 8706:  }
        -: 8707:
    #####: 8708:  void assign(void* lhs, const char* field, const void* rhs,
        -: 8709:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 8710:  {
        -: 8711:    ACE_UNUSED_ARG(lhs);
        -: 8712:    ACE_UNUSED_ARG(field);
        -: 8713:    ACE_UNUSED_ARG(rhs);
        -: 8714:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 8715:    ACE_UNUSED_ARG(rhsMeta);
    #####: 8716:    if (std::strcmp(field, "key") == 0) {
    #####: 8717:      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8718:      return;
        -: 8719:    }
    #####: 8720:    if (std::strcmp(field, "participant_key") == 0) {
    #####: 8721:      static_cast<T*>(lhs)->participant_key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8722:      return;
        -: 8723:    }
    #####: 8724:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 8725:      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8726:      return;
        -: 8727:    }
    #####: 8728:    if (std::strcmp(field, "type_name") == 0) {
    #####: 8729:      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8730:      return;
        -: 8731:    }
    #####: 8732:    if (std::strcmp(field, "durability") == 0) {
    #####: 8733:      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8734:      return;
        -: 8735:    }
    #####: 8736:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 8737:      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8738:      return;
        -: 8739:    }
    #####: 8740:    if (std::strcmp(field, "deadline") == 0) {
    #####: 8741:      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8742:      return;
        -: 8743:    }
    #####: 8744:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 8745:      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8746:      return;
        -: 8747:    }
    #####: 8748:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 8749:      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8750:      return;
        -: 8751:    }
    #####: 8752:    if (std::strcmp(field, "reliability") == 0) {
    #####: 8753:      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8754:      return;
        -: 8755:    }
    #####: 8756:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 8757:      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8758:      return;
        -: 8759:    }
    #####: 8760:    if (std::strcmp(field, "user_data") == 0) {
    #####: 8761:      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8762:      return;
        -: 8763:    }
    #####: 8764:    if (std::strcmp(field, "ownership") == 0) {
    #####: 8765:      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8766:      return;
        -: 8767:    }
    #####: 8768:    if (std::strcmp(field, "ownership_strength") == 0) {
    #####: 8769:      static_cast<T*>(lhs)->ownership_strength = *static_cast<const DDS::OwnershipStrengthQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8770:      return;
        -: 8771:    }
    #####: 8772:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 8773:      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8774:      return;
        -: 8775:    }
    #####: 8776:    if (std::strcmp(field, "presentation") == 0) {
    #####: 8777:      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8778:      return;
        -: 8779:    }
    #####: 8780:    if (std::strcmp(field, "partition") == 0) {
    #####: 8781:      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8782:      return;
        -: 8783:    }
    #####: 8784:    if (std::strcmp(field, "topic_data") == 0) {
    #####: 8785:      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8786:      return;
        -: 8787:    }
    #####: 8788:    if (std::strcmp(field, "group_data") == 0) {
    #####: 8789:      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 8790:      return;
        -: 8791:    }
    #####: 8792:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
        -: 8793:  }
        -: 8794:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 8795:
    #####: 8796:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 8797:  {
        -: 8798:    ACE_UNUSED_ARG(lhs);
        -: 8799:    ACE_UNUSED_ARG(field);
        -: 8800:    ACE_UNUSED_ARG(rhs);
    #####: 8801:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 8802:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
        -: 8803:    }
    #####: 8804:    if (std::strcmp(field, "type_name") == 0) {
    #####: 8805:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
        -: 8806:    }
    #####: 8807:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::PublicationBuiltinTopicData)");
        -: 8808:  }
        -: 8809:};
        -: 8810:
        -: 8811:template<>
    #####: 8812:const MetaStruct& getMetaStruct<DDS::PublicationBuiltinTopicData>()
        -: 8813:{
    #####: 8814:  static MetaStructImpl<DDS::PublicationBuiltinTopicData> msi;
    #####: 8815:  return msi;
        -: 8816:}
        -: 8817:
    #####: 8818:bool gen_skip_over(Serializer& ser, DDS::PublicationBuiltinTopicData*)
        -: 8819:{
        -: 8820:  ACE_UNUSED_ARG(ser);
    #####: 8821:  MetaStructImpl<DDS::PublicationBuiltinTopicData>().getValue(ser, "");
    #####: 8822:  return true;
        -: 8823:}
        -: 8824:
        -: 8825:}  }
        -: 8826:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 8827:
        -: 8828:#endif
        -: 8829:
        -: 8830:/* End STRUCT: PublicationBuiltinTopicData */
        -: 8831:
        -: 8832:
        -: 8833:/* Begin STRUCT: SubscriptionBuiltinTopicData */
        -: 8834:
        -: 8835:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 8836:namespace OpenDDS { namespace DCPS {
        -: 8837:
        3: 8838:void gen_find_size(const DDS::SubscriptionBuiltinTopicData& stru, size_t& size, size_t& padding)
        -: 8839:{
        -: 8840:  ACE_UNUSED_ARG(stru);
        -: 8841:  ACE_UNUSED_ARG(size);
        -: 8842:  ACE_UNUSED_ARG(padding);
        3: 8843:  gen_find_size(stru.key, size, padding);
        3: 8844:  gen_find_size(stru.participant_key, size, padding);
        3: 8845:  find_size_ulong(size, padding);
        3: 8846:  size += ACE_OS::strlen(stru.topic_name.in()) + 1;
        3: 8847:  find_size_ulong(size, padding);
        3: 8848:  size += ACE_OS::strlen(stru.type_name.in()) + 1;
        3: 8849:  gen_find_size(stru.durability, size, padding);
        3: 8850:  gen_find_size(stru.deadline, size, padding);
        3: 8851:  gen_find_size(stru.latency_budget, size, padding);
        3: 8852:  gen_find_size(stru.liveliness, size, padding);
        3: 8853:  gen_find_size(stru.reliability, size, padding);
        3: 8854:  gen_find_size(stru.ownership, size, padding);
        3: 8855:  gen_find_size(stru.destination_order, size, padding);
        3: 8856:  gen_find_size(stru.user_data, size, padding);
        3: 8857:  gen_find_size(stru.time_based_filter, size, padding);
        3: 8858:  gen_find_size(stru.presentation, size, padding);
        3: 8859:  gen_find_size(stru.partition, size, padding);
        3: 8860:  gen_find_size(stru.topic_data, size, padding);
        3: 8861:  gen_find_size(stru.group_data, size, padding);
        3: 8862:}
        -: 8863:
        3: 8864:bool operator<<(Serializer& strm, const DDS::SubscriptionBuiltinTopicData& stru)
        -: 8865:{
        -: 8866:  ACE_UNUSED_ARG(strm);
        -: 8867:  ACE_UNUSED_ARG(stru);
        3: 8868:  return (strm << stru.key)
        3: 8869:    && (strm << stru.participant_key)
        3: 8870:    && (strm << stru.topic_name.in())
        3: 8871:    && (strm << stru.type_name.in())
        3: 8872:    && (strm << stru.durability)
        3: 8873:    && (strm << stru.deadline)
        3: 8874:    && (strm << stru.latency_budget)
        3: 8875:    && (strm << stru.liveliness)
        3: 8876:    && (strm << stru.reliability)
        3: 8877:    && (strm << stru.ownership)
        3: 8878:    && (strm << stru.destination_order)
        3: 8879:    && (strm << stru.user_data)
        3: 8880:    && (strm << stru.time_based_filter)
        3: 8881:    && (strm << stru.presentation)
        3: 8882:    && (strm << stru.partition)
        3: 8883:    && (strm << stru.topic_data)
        6: 8884:    && (strm << stru.group_data);
        -: 8885:}
        -: 8886:
    #####: 8887:bool operator>>(Serializer& strm, DDS::SubscriptionBuiltinTopicData& stru)
        -: 8888:{
        -: 8889:  ACE_UNUSED_ARG(strm);
        -: 8890:  ACE_UNUSED_ARG(stru);
    #####: 8891:  return (strm >> stru.key)
    #####: 8892:    && (strm >> stru.participant_key)
    #####: 8893:    && (strm >> stru.topic_name.out())
    #####: 8894:    && (strm >> stru.type_name.out())
    #####: 8895:    && (strm >> stru.durability)
    #####: 8896:    && (strm >> stru.deadline)
    #####: 8897:    && (strm >> stru.latency_budget)
    #####: 8898:    && (strm >> stru.liveliness)
    #####: 8899:    && (strm >> stru.reliability)
    #####: 8900:    && (strm >> stru.ownership)
    #####: 8901:    && (strm >> stru.destination_order)
    #####: 8902:    && (strm >> stru.user_data)
    #####: 8903:    && (strm >> stru.time_based_filter)
    #####: 8904:    && (strm >> stru.presentation)
    #####: 8905:    && (strm >> stru.partition)
    #####: 8906:    && (strm >> stru.topic_data)
    #####: 8907:    && (strm >> stru.group_data);
        -: 8908:}
        -: 8909:
    #####: 8910:size_t gen_max_marshaled_size(const DDS::SubscriptionBuiltinTopicData& stru, bool align)
        -: 8911:{
        -: 8912:  ACE_UNUSED_ARG(stru);
        -: 8913:  ACE_UNUSED_ARG(align);
    #####: 8914:  return 0;
        -: 8915:}
        -: 8916:
        3: 8917:size_t gen_max_marshaled_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, bool align)
        -: 8918:{
        -: 8919:  ACE_UNUSED_ARG(stru);
        -: 8920:  ACE_UNUSED_ARG(align);
        3: 8921:  return 12;
        -: 8922:}
        -: 8923:
    #####: 8924:void gen_find_size(KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru, size_t& size, size_t& padding)
        -: 8925:{
        -: 8926:  ACE_UNUSED_ARG(stru);
        -: 8927:  ACE_UNUSED_ARG(size);
        -: 8928:  ACE_UNUSED_ARG(padding);
    #####: 8929:  if ((size + padding) % 4) {
    #####: 8930:    padding += 4 - ((size + padding) % 4);
        -: 8931:  }
    #####: 8932:  size += gen_max_marshaled_size(stru.t.key.value[0]);
    #####: 8933:  if ((size + padding) % 4) {
    #####: 8934:    padding += 4 - ((size + padding) % 4);
        -: 8935:  }
    #####: 8936:  size += gen_max_marshaled_size(stru.t.key.value[1]);
    #####: 8937:  if ((size + padding) % 4) {
    #####: 8938:    padding += 4 - ((size + padding) % 4);
        -: 8939:  }
    #####: 8940:  size += gen_max_marshaled_size(stru.t.key.value[2]);
    #####: 8941:}
        -: 8942:
        3: 8943:bool operator<<(Serializer& strm, KeyOnly<const DDS::SubscriptionBuiltinTopicData> stru)
        -: 8944:{
        -: 8945:  ACE_UNUSED_ARG(strm);
        -: 8946:  ACE_UNUSED_ARG(stru);
        3: 8947:  return (strm << stru.t.key.value[0])
        3: 8948:    && (strm << stru.t.key.value[1])
        6: 8949:    && (strm << stru.t.key.value[2]);
        -: 8950:}
        -: 8951:
    #####: 8952:bool operator>>(Serializer& strm, KeyOnly<DDS::SubscriptionBuiltinTopicData> stru)
        -: 8953:{
        -: 8954:  ACE_UNUSED_ARG(strm);
        -: 8955:  ACE_UNUSED_ARG(stru);
    #####: 8956:  return (strm >> stru.t.key.value[0])
    #####: 8957:    && (strm >> stru.t.key.value[1])
    #####: 8958:    && (strm >> stru.t.key.value[2]);
        -: 8959:}
        -: 8960:
        -: 8961:}  }
        -: 8962:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 8963:
        -: 8964:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 8965:namespace DDS {
        3: 8966:::DDS::DataWriter_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_datawriter()
        -: 8967:{
        -: 8968:  typedef OpenDDS::DCPS::DataWriterImpl_T<SubscriptionBuiltinTopicData> DataWriterImplType;
        3: 8969:  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
        3: 8970:  ACE_NEW_NORETURN(writer_impl,
        -: 8971:                   DataWriterImplType());
        3: 8972:  return writer_impl;
        -: 8973:}
        -: 8974:
    #####: 8975:::DDS::DataReader_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_datareader()
        -: 8976:{
        -: 8977:  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriptionBuiltinTopicData> DataReaderImplType;
    #####: 8978:  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
    #####: 8979:  ACE_NEW_NORETURN(reader_impl,
        -: 8980:                   DataReaderImplType());
    #####: 8981:  return reader_impl;
        -: 8982:}
        -: 8983:
        -: 8984:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 8985:::DDS::DataReader_ptr SubscriptionBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
        -: 8986:{
        -: 8987:  typedef OpenDDS::DCPS::DataReaderImpl_T<SubscriptionBuiltinTopicData> DataReaderImplType;
        -: 8988:  typedef OpenDDS::DCPS::MultiTopicDataReader_T<SubscriptionBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
    #####: 8989:  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
    #####: 8990:  ACE_NEW_NORETURN(multitopic_reader_impl,
        -: 8991:                   MultiTopicDataReaderImplType());
    #####: 8992:  return multitopic_reader_impl;
        -: 8993:}
        -: 8994:#endif /* !OPENDDS_NO_MULTI_TOPIC */
        -: 8995:
        -: 8996:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
    #####: 8997:const OpenDDS::DCPS::MetaStruct& SubscriptionBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
        -: 8998:{
    #####: 8999:  return OpenDDS::DCPS::getMetaStruct<SubscriptionBuiltinTopicData>();
        -: 9000:}
        -: 9001:#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
        -: 9002:
        3: 9003:bool SubscriptionBuiltinTopicDataTypeSupportImpl::has_dcps_key()
        -: 9004:{
        3: 9005:  return TraitsType::gen_has_key ();
        -: 9006:}
        -: 9007:
    #####: 9008:const char* SubscriptionBuiltinTopicDataTypeSupportImpl::default_type_name() const
        -: 9009:{
    #####: 9010:  return TraitsType::type_name();
        -: 9011:}
        -: 9012:
    #####: 9013:SubscriptionBuiltinTopicDataTypeSupport::_ptr_type SubscriptionBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
        -: 9014:{
    #####: 9015:  return TypeSupportType::_narrow(obj);
        -: 9016:}
        -: 9017:}
        -: 9018:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 9019:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 9020:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 9021:namespace OpenDDS { namespace DCPS {
        -: 9022:
        -: 9023:template<>
    #####: 9024:struct MetaStructImpl<DDS::SubscriptionBuiltinTopicData> : MetaStruct {
        -: 9025:  typedef DDS::SubscriptionBuiltinTopicData T;
        -: 9026:
        -: 9027:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 9028:  void* allocate() const { return new T; }
        -: 9029:
    #####: 9030:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 9031:
    #####: 9032:  size_t numDcpsKeys() const { return 3; }
        -: 9033:
        -: 9034:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 9035:
    #####: 9036:  bool isDcpsKey(const char* field) const
        -: 9037:  {
    #####: 9038:    if (!ACE_OS::strcmp(field, "key.value[0]")) {
    #####: 9039:      return true;
        -: 9040:    }
    #####: 9041:    if (!ACE_OS::strcmp(field, "key.value[1]")) {
    #####: 9042:      return true;
        -: 9043:    }
    #####: 9044:    if (!ACE_OS::strcmp(field, "key.value[2]")) {
    #####: 9045:      return true;
        -: 9046:    }
    #####: 9047:    return false;
        -: 9048:  }
        -: 9049:
    #####: 9050:  Value getValue(const void* stru, const char* field) const
        -: 9051:  {
    #####: 9052:    const DDS::SubscriptionBuiltinTopicData& typed = *static_cast<const DDS::SubscriptionBuiltinTopicData*>(stru);
    #####: 9053:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 9054:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
        -: 9055:    }
    #####: 9056:    if (std::strncmp(field, "participant_key.", 16) == 0) {
    #####: 9057:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.participant_key, field + 16);
        -: 9058:    }
    #####: 9059:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 9060:      return typed.topic_name.in();
        -: 9061:    }
    #####: 9062:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9063:      return typed.type_name.in();
        -: 9064:    }
    #####: 9065:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 9066:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
        -: 9067:    }
    #####: 9068:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 9069:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
        -: 9070:    }
    #####: 9071:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 9072:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
        -: 9073:    }
    #####: 9074:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 9075:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
        -: 9076:    }
    #####: 9077:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 9078:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
        -: 9079:    }
    #####: 9080:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 9081:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
        -: 9082:    }
    #####: 9083:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 9084:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
        -: 9085:    }
    #####: 9086:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 9087:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(&typed.user_data, field + 10);
        -: 9088:    }
    #####: 9089:    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
    #####: 9090:      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(&typed.time_based_filter, field + 18);
        -: 9091:    }
    #####: 9092:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 9093:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(&typed.presentation, field + 13);
        -: 9094:    }
    #####: 9095:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 9096:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(&typed.partition, field + 10);
        -: 9097:    }
    #####: 9098:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 9099:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
        -: 9100:    }
    #####: 9101:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 9102:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(&typed.group_data, field + 11);
        -: 9103:    }
        -: 9104:    ACE_UNUSED_ARG(typed);
    #####: 9105:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
        -: 9106:  }
        -: 9107:
    #####: 9108:  Value getValue(Serializer& ser, const char* field) const
        -: 9109:  {
    #####: 9110:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 9111:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
        -: 9112:    } else {
    #####: 9113:      if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0))) {
    #####: 9114:        throw std::runtime_error("Field 'key' could not be skipped");
        -: 9115:      }
        -: 9116:    }
    #####: 9117:    if (std::strncmp(field, "participant_key.", 16) == 0) {
    #####: 9118:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 16);
        -: 9119:    } else {
    #####: 9120:      if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0))) {
    #####: 9121:        throw std::runtime_error("Field 'participant_key' could not be skipped");
        -: 9122:      }
        -: 9123:    }
    #####: 9124:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 9125:      TAO::String_Manager val;
    #####: 9126:      if (!(ser >> val.out())) {
    #####: 9127:        throw std::runtime_error("Field 'topic_name' could not be deserialized");
        -: 9128:      }
    #####: 9129:      return val;
        -: 9130:    } else {
        -: 9131:      ACE_CDR::ULong len;
    #####: 9132:      if (!(ser >> len)) {
    #####: 9133:        throw std::runtime_error("String 'topic_name' length could not be deserialized");
        -: 9134:      }
    #####: 9135:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 9136:        throw std::runtime_error("String 'topic_name' contents could not be skipped");
        -: 9137:      }
        -: 9138:    }
    #####: 9139:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9140:      TAO::String_Manager val;
    #####: 9141:      if (!(ser >> val.out())) {
    #####: 9142:        throw std::runtime_error("Field 'type_name' could not be deserialized");
        -: 9143:      }
    #####: 9144:      return val;
        -: 9145:    } else {
        -: 9146:      ACE_CDR::ULong len;
    #####: 9147:      if (!(ser >> len)) {
    #####: 9148:        throw std::runtime_error("String 'type_name' length could not be deserialized");
        -: 9149:      }
    #####: 9150:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 9151:        throw std::runtime_error("String 'type_name' contents could not be skipped");
        -: 9152:      }
        -: 9153:    }
    #####: 9154:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 9155:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
        -: 9156:    } else {
    #####: 9157:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) {
    #####: 9158:        throw std::runtime_error("Field 'durability' could not be skipped");
        -: 9159:      }
        -: 9160:    }
    #####: 9161:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 9162:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
        -: 9163:    } else {
    #####: 9164:      if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) {
    #####: 9165:        throw std::runtime_error("Field 'deadline' could not be skipped");
        -: 9166:      }
        -: 9167:    }
    #####: 9168:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 9169:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
        -: 9170:    } else {
    #####: 9171:      if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) {
    #####: 9172:        throw std::runtime_error("Field 'latency_budget' could not be skipped");
        -: 9173:      }
        -: 9174:    }
    #####: 9175:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 9176:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
        -: 9177:    } else {
    #####: 9178:      if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) {
    #####: 9179:        throw std::runtime_error("Field 'liveliness' could not be skipped");
        -: 9180:      }
        -: 9181:    }
    #####: 9182:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 9183:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
        -: 9184:    } else {
    #####: 9185:      if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) {
    #####: 9186:        throw std::runtime_error("Field 'reliability' could not be skipped");
        -: 9187:      }
        -: 9188:    }
    #####: 9189:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 9190:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
        -: 9191:    } else {
    #####: 9192:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) {
    #####: 9193:        throw std::runtime_error("Field 'ownership' could not be skipped");
        -: 9194:      }
        -: 9195:    }
    #####: 9196:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 9197:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
        -: 9198:    } else {
    #####: 9199:      if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) {
    #####: 9200:        throw std::runtime_error("Field 'destination_order' could not be skipped");
        -: 9201:      }
        -: 9202:    }
    #####: 9203:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 9204:      return getMetaStruct<DDS::UserDataQosPolicy>().getValue(ser, field + 10);
        -: 9205:    } else {
    #####: 9206:      if (!gen_skip_over(ser, static_cast<DDS::UserDataQosPolicy*>(0))) {
    #####: 9207:        throw std::runtime_error("Field 'user_data' could not be skipped");
        -: 9208:      }
        -: 9209:    }
    #####: 9210:    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
    #####: 9211:      return getMetaStruct<DDS::TimeBasedFilterQosPolicy>().getValue(ser, field + 18);
        -: 9212:    } else {
    #####: 9213:      if (!gen_skip_over(ser, static_cast<DDS::TimeBasedFilterQosPolicy*>(0))) {
    #####: 9214:        throw std::runtime_error("Field 'time_based_filter' could not be skipped");
        -: 9215:      }
        -: 9216:    }
    #####: 9217:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 9218:      return getMetaStruct<DDS::PresentationQosPolicy>().getValue(ser, field + 13);
        -: 9219:    } else {
    #####: 9220:      if (!gen_skip_over(ser, static_cast<DDS::PresentationQosPolicy*>(0))) {
    #####: 9221:        throw std::runtime_error("Field 'presentation' could not be skipped");
        -: 9222:      }
        -: 9223:    }
    #####: 9224:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 9225:      return getMetaStruct<DDS::PartitionQosPolicy>().getValue(ser, field + 10);
        -: 9226:    } else {
    #####: 9227:      if (!gen_skip_over(ser, static_cast<DDS::PartitionQosPolicy*>(0))) {
    #####: 9228:        throw std::runtime_error("Field 'partition' could not be skipped");
        -: 9229:      }
        -: 9230:    }
    #####: 9231:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 9232:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
        -: 9233:    } else {
    #####: 9234:      if (!gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0))) {
    #####: 9235:        throw std::runtime_error("Field 'topic_data' could not be skipped");
        -: 9236:      }
        -: 9237:    }
    #####: 9238:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 9239:      return getMetaStruct<DDS::GroupDataQosPolicy>().getValue(ser, field + 11);
        -: 9240:    } else {
    #####: 9241:      if (!gen_skip_over(ser, static_cast<DDS::GroupDataQosPolicy*>(0))) {
    #####: 9242:        throw std::runtime_error("Field 'group_data' could not be skipped");
        -: 9243:      }
        -: 9244:    }
    #####: 9245:    if (!field[0]) {
    #####: 9246:      return 0;
        -: 9247:    }
    #####: 9248:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::SubscriptionBuiltinTopicData");
        -: 9249:  }
        -: 9250:
    #####: 9251:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 9252:  {
        -: 9253:    ACE_UNUSED_ARG(next);
    #####: 9254:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 9255:      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
        -: 9256:    }
    #####: 9257:    if (std::strncmp(field, "participant_key.", 16) == 0) {
    #####: 9258:      return make_struct_cmp(&T::participant_key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 16), next);
        -: 9259:    }
    #####: 9260:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 9261:      return make_field_cmp(&T::topic_name, next);
        -: 9262:    }
    #####: 9263:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9264:      return make_field_cmp(&T::type_name, next);
        -: 9265:    }
    #####: 9266:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 9267:      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9268:    }
    #####: 9269:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 9270:      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
        -: 9271:    }
    #####: 9272:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 9273:      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
        -: 9274:    }
    #####: 9275:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 9276:      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9277:    }
    #####: 9278:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 9279:      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
        -: 9280:    }
    #####: 9281:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 9282:      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
        -: 9283:    }
    #####: 9284:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 9285:      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
        -: 9286:    }
    #####: 9287:    if (std::strncmp(field, "user_data.", 10) == 0) {
    #####: 9288:      return make_struct_cmp(&T::user_data, getMetaStruct<DDS::UserDataQosPolicy>().create_qc_comparator(field + 10), next);
        -: 9289:    }
    #####: 9290:    if (std::strncmp(field, "time_based_filter.", 18) == 0) {
    #####: 9291:      return make_struct_cmp(&T::time_based_filter, getMetaStruct<DDS::TimeBasedFilterQosPolicy>().create_qc_comparator(field + 18), next);
        -: 9292:    }
    #####: 9293:    if (std::strncmp(field, "presentation.", 13) == 0) {
    #####: 9294:      return make_struct_cmp(&T::presentation, getMetaStruct<DDS::PresentationQosPolicy>().create_qc_comparator(field + 13), next);
        -: 9295:    }
    #####: 9296:    if (std::strncmp(field, "partition.", 10) == 0) {
    #####: 9297:      return make_struct_cmp(&T::partition, getMetaStruct<DDS::PartitionQosPolicy>().create_qc_comparator(field + 10), next);
        -: 9298:    }
    #####: 9299:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 9300:      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9301:    }
    #####: 9302:    if (std::strncmp(field, "group_data.", 11) == 0) {
    #####: 9303:      return make_struct_cmp(&T::group_data, getMetaStruct<DDS::GroupDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9304:    }
    #####: 9305:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
        -: 9306:  }
        -: 9307:
        -: 9308:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 9309:  const char** getFieldNames() const
        -: 9310:  {
        -: 9311:    static const char* names[] = {"key", "participant_key", "topic_name", "type_name", "durability", "deadline", "latency_budget", "liveliness", "reliability", "ownership", "destination_order", "user_data", "time_based_filter", "presentation", "partition", "topic_data", "group_data", 0};
    #####: 9312:    return names;
        -: 9313:  }
        -: 9314:
    #####: 9315:  const void* getRawField(const void* stru, const char* field) const
        -: 9316:  {
    #####: 9317:    if (std::strcmp(field, "key") == 0) {
    #####: 9318:      return &static_cast<const T*>(stru)->key;
        -: 9319:    }
    #####: 9320:    if (std::strcmp(field, "participant_key") == 0) {
    #####: 9321:      return &static_cast<const T*>(stru)->participant_key;
        -: 9322:    }
    #####: 9323:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 9324:      return &static_cast<const T*>(stru)->topic_name;
        -: 9325:    }
    #####: 9326:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9327:      return &static_cast<const T*>(stru)->type_name;
        -: 9328:    }
    #####: 9329:    if (std::strcmp(field, "durability") == 0) {
    #####: 9330:      return &static_cast<const T*>(stru)->durability;
        -: 9331:    }
    #####: 9332:    if (std::strcmp(field, "deadline") == 0) {
    #####: 9333:      return &static_cast<const T*>(stru)->deadline;
        -: 9334:    }
    #####: 9335:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 9336:      return &static_cast<const T*>(stru)->latency_budget;
        -: 9337:    }
    #####: 9338:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 9339:      return &static_cast<const T*>(stru)->liveliness;
        -: 9340:    }
    #####: 9341:    if (std::strcmp(field, "reliability") == 0) {
    #####: 9342:      return &static_cast<const T*>(stru)->reliability;
        -: 9343:    }
    #####: 9344:    if (std::strcmp(field, "ownership") == 0) {
    #####: 9345:      return &static_cast<const T*>(stru)->ownership;
        -: 9346:    }
    #####: 9347:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 9348:      return &static_cast<const T*>(stru)->destination_order;
        -: 9349:    }
    #####: 9350:    if (std::strcmp(field, "user_data") == 0) {
    #####: 9351:      return &static_cast<const T*>(stru)->user_data;
        -: 9352:    }
    #####: 9353:    if (std::strcmp(field, "time_based_filter") == 0) {
    #####: 9354:      return &static_cast<const T*>(stru)->time_based_filter;
        -: 9355:    }
    #####: 9356:    if (std::strcmp(field, "presentation") == 0) {
    #####: 9357:      return &static_cast<const T*>(stru)->presentation;
        -: 9358:    }
    #####: 9359:    if (std::strcmp(field, "partition") == 0) {
    #####: 9360:      return &static_cast<const T*>(stru)->partition;
        -: 9361:    }
    #####: 9362:    if (std::strcmp(field, "topic_data") == 0) {
    #####: 9363:      return &static_cast<const T*>(stru)->topic_data;
        -: 9364:    }
    #####: 9365:    if (std::strcmp(field, "group_data") == 0) {
    #####: 9366:      return &static_cast<const T*>(stru)->group_data;
        -: 9367:    }
    #####: 9368:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
        -: 9369:  }
        -: 9370:
    #####: 9371:  void assign(void* lhs, const char* field, const void* rhs,
        -: 9372:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 9373:  {
        -: 9374:    ACE_UNUSED_ARG(lhs);
        -: 9375:    ACE_UNUSED_ARG(field);
        -: 9376:    ACE_UNUSED_ARG(rhs);
        -: 9377:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 9378:    ACE_UNUSED_ARG(rhsMeta);
    #####: 9379:    if (std::strcmp(field, "key") == 0) {
    #####: 9380:      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9381:      return;
        -: 9382:    }
    #####: 9383:    if (std::strcmp(field, "participant_key") == 0) {
    #####: 9384:      static_cast<T*>(lhs)->participant_key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9385:      return;
        -: 9386:    }
    #####: 9387:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 9388:      static_cast<T*>(lhs)->topic_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9389:      return;
        -: 9390:    }
    #####: 9391:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9392:      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9393:      return;
        -: 9394:    }
    #####: 9395:    if (std::strcmp(field, "durability") == 0) {
    #####: 9396:      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9397:      return;
        -: 9398:    }
    #####: 9399:    if (std::strcmp(field, "deadline") == 0) {
    #####: 9400:      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9401:      return;
        -: 9402:    }
    #####: 9403:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 9404:      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9405:      return;
        -: 9406:    }
    #####: 9407:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 9408:      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9409:      return;
        -: 9410:    }
    #####: 9411:    if (std::strcmp(field, "reliability") == 0) {
    #####: 9412:      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9413:      return;
        -: 9414:    }
    #####: 9415:    if (std::strcmp(field, "ownership") == 0) {
    #####: 9416:      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9417:      return;
        -: 9418:    }
    #####: 9419:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 9420:      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9421:      return;
        -: 9422:    }
    #####: 9423:    if (std::strcmp(field, "user_data") == 0) {
    #####: 9424:      static_cast<T*>(lhs)->user_data = *static_cast<const DDS::UserDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9425:      return;
        -: 9426:    }
    #####: 9427:    if (std::strcmp(field, "time_based_filter") == 0) {
    #####: 9428:      static_cast<T*>(lhs)->time_based_filter = *static_cast<const DDS::TimeBasedFilterQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9429:      return;
        -: 9430:    }
    #####: 9431:    if (std::strcmp(field, "presentation") == 0) {
    #####: 9432:      static_cast<T*>(lhs)->presentation = *static_cast<const DDS::PresentationQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9433:      return;
        -: 9434:    }
    #####: 9435:    if (std::strcmp(field, "partition") == 0) {
    #####: 9436:      static_cast<T*>(lhs)->partition = *static_cast<const DDS::PartitionQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9437:      return;
        -: 9438:    }
    #####: 9439:    if (std::strcmp(field, "topic_data") == 0) {
    #####: 9440:      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9441:      return;
        -: 9442:    }
    #####: 9443:    if (std::strcmp(field, "group_data") == 0) {
    #####: 9444:      static_cast<T*>(lhs)->group_data = *static_cast<const DDS::GroupDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 9445:      return;
        -: 9446:    }
    #####: 9447:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
        -: 9448:  }
        -: 9449:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 9450:
    #####: 9451:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 9452:  {
        -: 9453:    ACE_UNUSED_ARG(lhs);
        -: 9454:    ACE_UNUSED_ARG(field);
        -: 9455:    ACE_UNUSED_ARG(rhs);
    #####: 9456:    if (std::strcmp(field, "topic_name") == 0) {
    #####: 9457:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->topic_name.in(), static_cast<const T*>(rhs)->topic_name.in());
        -: 9458:    }
    #####: 9459:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9460:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
        -: 9461:    }
    #####: 9462:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SubscriptionBuiltinTopicData)");
        -: 9463:  }
        -: 9464:};
        -: 9465:
        -: 9466:template<>
    #####: 9467:const MetaStruct& getMetaStruct<DDS::SubscriptionBuiltinTopicData>()
        -: 9468:{
    #####: 9469:  static MetaStructImpl<DDS::SubscriptionBuiltinTopicData> msi;
    #####: 9470:  return msi;
        -: 9471:}
        -: 9472:
    #####: 9473:bool gen_skip_over(Serializer& ser, DDS::SubscriptionBuiltinTopicData*)
        -: 9474:{
        -: 9475:  ACE_UNUSED_ARG(ser);
    #####: 9476:  MetaStructImpl<DDS::SubscriptionBuiltinTopicData>().getValue(ser, "");
    #####: 9477:  return true;
        -: 9478:}
        -: 9479:
        -: 9480:}  }
        -: 9481:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 9482:
        -: 9483:#endif
        -: 9484:
        -: 9485:/* End STRUCT: SubscriptionBuiltinTopicData */
        -: 9486:
        -: 9487:
        -: 9488:/* Begin STRUCT: TopicBuiltinTopicData */
        -: 9489:
        -: 9490:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 9491:namespace OpenDDS { namespace DCPS {
        -: 9492:
        6: 9493:void gen_find_size(const DDS::TopicBuiltinTopicData& stru, size_t& size, size_t& padding)
        -: 9494:{
        -: 9495:  ACE_UNUSED_ARG(stru);
        -: 9496:  ACE_UNUSED_ARG(size);
        -: 9497:  ACE_UNUSED_ARG(padding);
        6: 9498:  gen_find_size(stru.key, size, padding);
        6: 9499:  find_size_ulong(size, padding);
        6: 9500:  size += ACE_OS::strlen(stru.name.in()) + 1;
        6: 9501:  find_size_ulong(size, padding);
        6: 9502:  size += ACE_OS::strlen(stru.type_name.in()) + 1;
        6: 9503:  gen_find_size(stru.durability, size, padding);
        6: 9504:  gen_find_size(stru.durability_service, size, padding);
        6: 9505:  gen_find_size(stru.deadline, size, padding);
        6: 9506:  gen_find_size(stru.latency_budget, size, padding);
        6: 9507:  gen_find_size(stru.liveliness, size, padding);
        6: 9508:  gen_find_size(stru.reliability, size, padding);
        6: 9509:  gen_find_size(stru.transport_priority, size, padding);
        6: 9510:  gen_find_size(stru.lifespan, size, padding);
        6: 9511:  gen_find_size(stru.destination_order, size, padding);
        6: 9512:  gen_find_size(stru.history, size, padding);
        6: 9513:  gen_find_size(stru.resource_limits, size, padding);
        6: 9514:  gen_find_size(stru.ownership, size, padding);
        6: 9515:  gen_find_size(stru.topic_data, size, padding);
        6: 9516:}
        -: 9517:
        6: 9518:bool operator<<(Serializer& strm, const DDS::TopicBuiltinTopicData& stru)
        -: 9519:{
        -: 9520:  ACE_UNUSED_ARG(strm);
        -: 9521:  ACE_UNUSED_ARG(stru);
        6: 9522:  return (strm << stru.key)
        6: 9523:    && (strm << stru.name.in())
        6: 9524:    && (strm << stru.type_name.in())
        6: 9525:    && (strm << stru.durability)
        6: 9526:    && (strm << stru.durability_service)
        6: 9527:    && (strm << stru.deadline)
        6: 9528:    && (strm << stru.latency_budget)
        6: 9529:    && (strm << stru.liveliness)
        6: 9530:    && (strm << stru.reliability)
        6: 9531:    && (strm << stru.transport_priority)
        6: 9532:    && (strm << stru.lifespan)
        6: 9533:    && (strm << stru.destination_order)
        6: 9534:    && (strm << stru.history)
        6: 9535:    && (strm << stru.resource_limits)
        6: 9536:    && (strm << stru.ownership)
       12: 9537:    && (strm << stru.topic_data);
        -: 9538:}
        -: 9539:
    #####: 9540:bool operator>>(Serializer& strm, DDS::TopicBuiltinTopicData& stru)
        -: 9541:{
        -: 9542:  ACE_UNUSED_ARG(strm);
        -: 9543:  ACE_UNUSED_ARG(stru);
    #####: 9544:  return (strm >> stru.key)
    #####: 9545:    && (strm >> stru.name.out())
    #####: 9546:    && (strm >> stru.type_name.out())
    #####: 9547:    && (strm >> stru.durability)
    #####: 9548:    && (strm >> stru.durability_service)
    #####: 9549:    && (strm >> stru.deadline)
    #####: 9550:    && (strm >> stru.latency_budget)
    #####: 9551:    && (strm >> stru.liveliness)
    #####: 9552:    && (strm >> stru.reliability)
    #####: 9553:    && (strm >> stru.transport_priority)
    #####: 9554:    && (strm >> stru.lifespan)
    #####: 9555:    && (strm >> stru.destination_order)
    #####: 9556:    && (strm >> stru.history)
    #####: 9557:    && (strm >> stru.resource_limits)
    #####: 9558:    && (strm >> stru.ownership)
    #####: 9559:    && (strm >> stru.topic_data);
        -: 9560:}
        -: 9561:
    #####: 9562:size_t gen_max_marshaled_size(const DDS::TopicBuiltinTopicData& stru, bool align)
        -: 9563:{
        -: 9564:  ACE_UNUSED_ARG(stru);
        -: 9565:  ACE_UNUSED_ARG(align);
    #####: 9566:  return 0;
        -: 9567:}
        -: 9568:
        3: 9569:size_t gen_max_marshaled_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, bool align)
        -: 9570:{
        -: 9571:  ACE_UNUSED_ARG(stru);
        -: 9572:  ACE_UNUSED_ARG(align);
        3: 9573:  return 12;
        -: 9574:}
        -: 9575:
    #####: 9576:void gen_find_size(KeyOnly<const DDS::TopicBuiltinTopicData> stru, size_t& size, size_t& padding)
        -: 9577:{
        -: 9578:  ACE_UNUSED_ARG(stru);
        -: 9579:  ACE_UNUSED_ARG(size);
        -: 9580:  ACE_UNUSED_ARG(padding);
    #####: 9581:  if ((size + padding) % 4) {
    #####: 9582:    padding += 4 - ((size + padding) % 4);
        -: 9583:  }
    #####: 9584:  size += gen_max_marshaled_size(stru.t.key.value[0]);
    #####: 9585:  if ((size + padding) % 4) {
    #####: 9586:    padding += 4 - ((size + padding) % 4);
        -: 9587:  }
    #####: 9588:  size += gen_max_marshaled_size(stru.t.key.value[1]);
    #####: 9589:  if ((size + padding) % 4) {
    #####: 9590:    padding += 4 - ((size + padding) % 4);
        -: 9591:  }
    #####: 9592:  size += gen_max_marshaled_size(stru.t.key.value[2]);
    #####: 9593:}
        -: 9594:
        6: 9595:bool operator<<(Serializer& strm, KeyOnly<const DDS::TopicBuiltinTopicData> stru)
        -: 9596:{
        -: 9597:  ACE_UNUSED_ARG(strm);
        -: 9598:  ACE_UNUSED_ARG(stru);
        6: 9599:  return (strm << stru.t.key.value[0])
        6: 9600:    && (strm << stru.t.key.value[1])
       12: 9601:    && (strm << stru.t.key.value[2]);
        -: 9602:}
        -: 9603:
    #####: 9604:bool operator>>(Serializer& strm, KeyOnly<DDS::TopicBuiltinTopicData> stru)
        -: 9605:{
        -: 9606:  ACE_UNUSED_ARG(strm);
        -: 9607:  ACE_UNUSED_ARG(stru);
    #####: 9608:  return (strm >> stru.t.key.value[0])
    #####: 9609:    && (strm >> stru.t.key.value[1])
    #####: 9610:    && (strm >> stru.t.key.value[2]);
        -: 9611:}
        -: 9612:
        -: 9613:}  }
        -: 9614:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 9615:
        -: 9616:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 9617:namespace DDS {
        3: 9618:::DDS::DataWriter_ptr TopicBuiltinTopicDataTypeSupportImpl::create_datawriter()
        -: 9619:{
        -: 9620:  typedef OpenDDS::DCPS::DataWriterImpl_T<TopicBuiltinTopicData> DataWriterImplType;
        3: 9621:  ::DDS::DataWriter_ptr writer_impl = ::DDS::DataWriter::_nil();
        3: 9622:  ACE_NEW_NORETURN(writer_impl,
        -: 9623:                   DataWriterImplType());
        3: 9624:  return writer_impl;
        -: 9625:}
        -: 9626:
    #####: 9627:::DDS::DataReader_ptr TopicBuiltinTopicDataTypeSupportImpl::create_datareader()
        -: 9628:{
        -: 9629:  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicBuiltinTopicData> DataReaderImplType;
    #####: 9630:  ::DDS::DataReader_ptr reader_impl = ::DDS::DataReader::_nil();
    #####: 9631:  ACE_NEW_NORETURN(reader_impl,
        -: 9632:                   DataReaderImplType());
    #####: 9633:  return reader_impl;
        -: 9634:}
        -: 9635:
        -: 9636:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 9637:::DDS::DataReader_ptr TopicBuiltinTopicDataTypeSupportImpl::create_multitopic_datareader()
        -: 9638:{
        -: 9639:  typedef OpenDDS::DCPS::DataReaderImpl_T<TopicBuiltinTopicData> DataReaderImplType;
        -: 9640:  typedef OpenDDS::DCPS::MultiTopicDataReader_T<TopicBuiltinTopicData, DataReaderImplType> MultiTopicDataReaderImplType;
    #####: 9641:  ::DDS::DataReader_ptr multitopic_reader_impl = ::DDS::DataReader::_nil();
    #####: 9642:  ACE_NEW_NORETURN(multitopic_reader_impl,
        -: 9643:                   MultiTopicDataReaderImplType());
    #####: 9644:  return multitopic_reader_impl;
        -: 9645:}
        -: 9646:#endif /* !OPENDDS_NO_MULTI_TOPIC */
        -: 9647:
        -: 9648:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
    #####: 9649:const OpenDDS::DCPS::MetaStruct& TopicBuiltinTopicDataTypeSupportImpl::getMetaStructForType()
        -: 9650:{
    #####: 9651:  return OpenDDS::DCPS::getMetaStruct<TopicBuiltinTopicData>();
        -: 9652:}
        -: 9653:#endif /* !OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE */
        -: 9654:
        3: 9655:bool TopicBuiltinTopicDataTypeSupportImpl::has_dcps_key()
        -: 9656:{
        3: 9657:  return TraitsType::gen_has_key ();
        -: 9658:}
        -: 9659:
    #####: 9660:const char* TopicBuiltinTopicDataTypeSupportImpl::default_type_name() const
        -: 9661:{
    #####: 9662:  return TraitsType::type_name();
        -: 9663:}
        -: 9664:
    #####: 9665:TopicBuiltinTopicDataTypeSupport::_ptr_type TopicBuiltinTopicDataTypeSupportImpl::_narrow(CORBA::Object_ptr obj)
        -: 9666:{
    #####: 9667:  return TypeSupportType::_narrow(obj);
        -: 9668:}
        -: 9669:}
        -: 9670:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 9671:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 9672:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 9673:namespace OpenDDS { namespace DCPS {
        -: 9674:
        -: 9675:template<>
    #####: 9676:struct MetaStructImpl<DDS::TopicBuiltinTopicData> : MetaStruct {
        -: 9677:  typedef DDS::TopicBuiltinTopicData T;
        -: 9678:
        -: 9679:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 9680:  void* allocate() const { return new T; }
        -: 9681:
    #####: 9682:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 9683:
    #####: 9684:  size_t numDcpsKeys() const { return 3; }
        -: 9685:
        -: 9686:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 9687:
    #####: 9688:  bool isDcpsKey(const char* field) const
        -: 9689:  {
    #####: 9690:    if (!ACE_OS::strcmp(field, "key.value[0]")) {
    #####: 9691:      return true;
        -: 9692:    }
    #####: 9693:    if (!ACE_OS::strcmp(field, "key.value[1]")) {
    #####: 9694:      return true;
        -: 9695:    }
    #####: 9696:    if (!ACE_OS::strcmp(field, "key.value[2]")) {
    #####: 9697:      return true;
        -: 9698:    }
    #####: 9699:    return false;
        -: 9700:  }
        -: 9701:
    #####: 9702:  Value getValue(const void* stru, const char* field) const
        -: 9703:  {
    #####: 9704:    const DDS::TopicBuiltinTopicData& typed = *static_cast<const DDS::TopicBuiltinTopicData*>(stru);
    #####: 9705:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 9706:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(&typed.key, field + 4);
        -: 9707:    }
    #####: 9708:    if (std::strcmp(field, "name") == 0) {
    #####: 9709:      return typed.name.in();
        -: 9710:    }
    #####: 9711:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9712:      return typed.type_name.in();
        -: 9713:    }
    #####: 9714:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 9715:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(&typed.durability, field + 11);
        -: 9716:    }
    #####: 9717:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 9718:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(&typed.durability_service, field + 19);
        -: 9719:    }
    #####: 9720:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 9721:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(&typed.deadline, field + 9);
        -: 9722:    }
    #####: 9723:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 9724:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(&typed.latency_budget, field + 15);
        -: 9725:    }
    #####: 9726:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 9727:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(&typed.liveliness, field + 11);
        -: 9728:    }
    #####: 9729:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 9730:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(&typed.reliability, field + 12);
        -: 9731:    }
    #####: 9732:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 9733:      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(&typed.transport_priority, field + 19);
        -: 9734:    }
    #####: 9735:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 9736:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(&typed.lifespan, field + 9);
        -: 9737:    }
    #####: 9738:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 9739:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(&typed.destination_order, field + 18);
        -: 9740:    }
    #####: 9741:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 9742:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(&typed.history, field + 8);
        -: 9743:    }
    #####: 9744:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 9745:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(&typed.resource_limits, field + 16);
        -: 9746:    }
    #####: 9747:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 9748:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(&typed.ownership, field + 10);
        -: 9749:    }
    #####: 9750:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 9751:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(&typed.topic_data, field + 11);
        -: 9752:    }
        -: 9753:    ACE_UNUSED_ARG(typed);
    #####: 9754:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
        -: 9755:  }
        -: 9756:
    #####: 9757:  Value getValue(Serializer& ser, const char* field) const
        -: 9758:  {
    #####: 9759:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 9760:      return getMetaStruct<DDS::BuiltinTopicKey_t>().getValue(ser, field + 4);
        -: 9761:    } else {
    #####: 9762:      if (!gen_skip_over(ser, static_cast<DDS::BuiltinTopicKey_t*>(0))) {
    #####: 9763:        throw std::runtime_error("Field 'key' could not be skipped");
        -: 9764:      }
        -: 9765:    }
    #####: 9766:    if (std::strcmp(field, "name") == 0) {
    #####: 9767:      TAO::String_Manager val;
    #####: 9768:      if (!(ser >> val.out())) {
    #####: 9769:        throw std::runtime_error("Field 'name' could not be deserialized");
        -: 9770:      }
    #####: 9771:      return val;
        -: 9772:    } else {
        -: 9773:      ACE_CDR::ULong len;
    #####: 9774:      if (!(ser >> len)) {
    #####: 9775:        throw std::runtime_error("String 'name' length could not be deserialized");
        -: 9776:      }
    #####: 9777:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 9778:        throw std::runtime_error("String 'name' contents could not be skipped");
        -: 9779:      }
        -: 9780:    }
    #####: 9781:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9782:      TAO::String_Manager val;
    #####: 9783:      if (!(ser >> val.out())) {
    #####: 9784:        throw std::runtime_error("Field 'type_name' could not be deserialized");
        -: 9785:      }
    #####: 9786:      return val;
        -: 9787:    } else {
        -: 9788:      ACE_CDR::ULong len;
    #####: 9789:      if (!(ser >> len)) {
    #####: 9790:        throw std::runtime_error("String 'type_name' length could not be deserialized");
        -: 9791:      }
    #####: 9792:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 9793:        throw std::runtime_error("String 'type_name' contents could not be skipped");
        -: 9794:      }
        -: 9795:    }
    #####: 9796:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 9797:      return getMetaStruct<DDS::DurabilityQosPolicy>().getValue(ser, field + 11);
        -: 9798:    } else {
    #####: 9799:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityQosPolicy*>(0))) {
    #####: 9800:        throw std::runtime_error("Field 'durability' could not be skipped");
        -: 9801:      }
        -: 9802:    }
    #####: 9803:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 9804:      return getMetaStruct<DDS::DurabilityServiceQosPolicy>().getValue(ser, field + 19);
        -: 9805:    } else {
    #####: 9806:      if (!gen_skip_over(ser, static_cast<DDS::DurabilityServiceQosPolicy*>(0))) {
    #####: 9807:        throw std::runtime_error("Field 'durability_service' could not be skipped");
        -: 9808:      }
        -: 9809:    }
    #####: 9810:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 9811:      return getMetaStruct<DDS::DeadlineQosPolicy>().getValue(ser, field + 9);
        -: 9812:    } else {
    #####: 9813:      if (!gen_skip_over(ser, static_cast<DDS::DeadlineQosPolicy*>(0))) {
    #####: 9814:        throw std::runtime_error("Field 'deadline' could not be skipped");
        -: 9815:      }
        -: 9816:    }
    #####: 9817:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 9818:      return getMetaStruct<DDS::LatencyBudgetQosPolicy>().getValue(ser, field + 15);
        -: 9819:    } else {
    #####: 9820:      if (!gen_skip_over(ser, static_cast<DDS::LatencyBudgetQosPolicy*>(0))) {
    #####: 9821:        throw std::runtime_error("Field 'latency_budget' could not be skipped");
        -: 9822:      }
        -: 9823:    }
    #####: 9824:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 9825:      return getMetaStruct<DDS::LivelinessQosPolicy>().getValue(ser, field + 11);
        -: 9826:    } else {
    #####: 9827:      if (!gen_skip_over(ser, static_cast<DDS::LivelinessQosPolicy*>(0))) {
    #####: 9828:        throw std::runtime_error("Field 'liveliness' could not be skipped");
        -: 9829:      }
        -: 9830:    }
    #####: 9831:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 9832:      return getMetaStruct<DDS::ReliabilityQosPolicy>().getValue(ser, field + 12);
        -: 9833:    } else {
    #####: 9834:      if (!gen_skip_over(ser, static_cast<DDS::ReliabilityQosPolicy*>(0))) {
    #####: 9835:        throw std::runtime_error("Field 'reliability' could not be skipped");
        -: 9836:      }
        -: 9837:    }
    #####: 9838:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 9839:      return getMetaStruct<DDS::TransportPriorityQosPolicy>().getValue(ser, field + 19);
        -: 9840:    } else {
    #####: 9841:      if (!gen_skip_over(ser, static_cast<DDS::TransportPriorityQosPolicy*>(0))) {
    #####: 9842:        throw std::runtime_error("Field 'transport_priority' could not be skipped");
        -: 9843:      }
        -: 9844:    }
    #####: 9845:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 9846:      return getMetaStruct<DDS::LifespanQosPolicy>().getValue(ser, field + 9);
        -: 9847:    } else {
    #####: 9848:      if (!gen_skip_over(ser, static_cast<DDS::LifespanQosPolicy*>(0))) {
    #####: 9849:        throw std::runtime_error("Field 'lifespan' could not be skipped");
        -: 9850:      }
        -: 9851:    }
    #####: 9852:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 9853:      return getMetaStruct<DDS::DestinationOrderQosPolicy>().getValue(ser, field + 18);
        -: 9854:    } else {
    #####: 9855:      if (!gen_skip_over(ser, static_cast<DDS::DestinationOrderQosPolicy*>(0))) {
    #####: 9856:        throw std::runtime_error("Field 'destination_order' could not be skipped");
        -: 9857:      }
        -: 9858:    }
    #####: 9859:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 9860:      return getMetaStruct<DDS::HistoryQosPolicy>().getValue(ser, field + 8);
        -: 9861:    } else {
    #####: 9862:      if (!gen_skip_over(ser, static_cast<DDS::HistoryQosPolicy*>(0))) {
    #####: 9863:        throw std::runtime_error("Field 'history' could not be skipped");
        -: 9864:      }
        -: 9865:    }
    #####: 9866:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 9867:      return getMetaStruct<DDS::ResourceLimitsQosPolicy>().getValue(ser, field + 16);
        -: 9868:    } else {
    #####: 9869:      if (!gen_skip_over(ser, static_cast<DDS::ResourceLimitsQosPolicy*>(0))) {
    #####: 9870:        throw std::runtime_error("Field 'resource_limits' could not be skipped");
        -: 9871:      }
        -: 9872:    }
    #####: 9873:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 9874:      return getMetaStruct<DDS::OwnershipQosPolicy>().getValue(ser, field + 10);
        -: 9875:    } else {
    #####: 9876:      if (!gen_skip_over(ser, static_cast<DDS::OwnershipQosPolicy*>(0))) {
    #####: 9877:        throw std::runtime_error("Field 'ownership' could not be skipped");
        -: 9878:      }
        -: 9879:    }
    #####: 9880:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 9881:      return getMetaStruct<DDS::TopicDataQosPolicy>().getValue(ser, field + 11);
        -: 9882:    } else {
    #####: 9883:      if (!gen_skip_over(ser, static_cast<DDS::TopicDataQosPolicy*>(0))) {
    #####: 9884:        throw std::runtime_error("Field 'topic_data' could not be skipped");
        -: 9885:      }
        -: 9886:    }
    #####: 9887:    if (!field[0]) {
    #####: 9888:      return 0;
        -: 9889:    }
    #####: 9890:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::TopicBuiltinTopicData");
        -: 9891:  }
        -: 9892:
    #####: 9893:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 9894:  {
        -: 9895:    ACE_UNUSED_ARG(next);
    #####: 9896:    if (std::strncmp(field, "key.", 4) == 0) {
    #####: 9897:      return make_struct_cmp(&T::key, getMetaStruct<DDS::BuiltinTopicKey_t>().create_qc_comparator(field + 4), next);
        -: 9898:    }
    #####: 9899:    if (std::strcmp(field, "name") == 0) {
    #####: 9900:      return make_field_cmp(&T::name, next);
        -: 9901:    }
    #####: 9902:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9903:      return make_field_cmp(&T::type_name, next);
        -: 9904:    }
    #####: 9905:    if (std::strncmp(field, "durability.", 11) == 0) {
    #####: 9906:      return make_struct_cmp(&T::durability, getMetaStruct<DDS::DurabilityQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9907:    }
    #####: 9908:    if (std::strncmp(field, "durability_service.", 19) == 0) {
    #####: 9909:      return make_struct_cmp(&T::durability_service, getMetaStruct<DDS::DurabilityServiceQosPolicy>().create_qc_comparator(field + 19), next);
        -: 9910:    }
    #####: 9911:    if (std::strncmp(field, "deadline.", 9) == 0) {
    #####: 9912:      return make_struct_cmp(&T::deadline, getMetaStruct<DDS::DeadlineQosPolicy>().create_qc_comparator(field + 9), next);
        -: 9913:    }
    #####: 9914:    if (std::strncmp(field, "latency_budget.", 15) == 0) {
    #####: 9915:      return make_struct_cmp(&T::latency_budget, getMetaStruct<DDS::LatencyBudgetQosPolicy>().create_qc_comparator(field + 15), next);
        -: 9916:    }
    #####: 9917:    if (std::strncmp(field, "liveliness.", 11) == 0) {
    #####: 9918:      return make_struct_cmp(&T::liveliness, getMetaStruct<DDS::LivelinessQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9919:    }
    #####: 9920:    if (std::strncmp(field, "reliability.", 12) == 0) {
    #####: 9921:      return make_struct_cmp(&T::reliability, getMetaStruct<DDS::ReliabilityQosPolicy>().create_qc_comparator(field + 12), next);
        -: 9922:    }
    #####: 9923:    if (std::strncmp(field, "transport_priority.", 19) == 0) {
    #####: 9924:      return make_struct_cmp(&T::transport_priority, getMetaStruct<DDS::TransportPriorityQosPolicy>().create_qc_comparator(field + 19), next);
        -: 9925:    }
    #####: 9926:    if (std::strncmp(field, "lifespan.", 9) == 0) {
    #####: 9927:      return make_struct_cmp(&T::lifespan, getMetaStruct<DDS::LifespanQosPolicy>().create_qc_comparator(field + 9), next);
        -: 9928:    }
    #####: 9929:    if (std::strncmp(field, "destination_order.", 18) == 0) {
    #####: 9930:      return make_struct_cmp(&T::destination_order, getMetaStruct<DDS::DestinationOrderQosPolicy>().create_qc_comparator(field + 18), next);
        -: 9931:    }
    #####: 9932:    if (std::strncmp(field, "history.", 8) == 0) {
    #####: 9933:      return make_struct_cmp(&T::history, getMetaStruct<DDS::HistoryQosPolicy>().create_qc_comparator(field + 8), next);
        -: 9934:    }
    #####: 9935:    if (std::strncmp(field, "resource_limits.", 16) == 0) {
    #####: 9936:      return make_struct_cmp(&T::resource_limits, getMetaStruct<DDS::ResourceLimitsQosPolicy>().create_qc_comparator(field + 16), next);
        -: 9937:    }
    #####: 9938:    if (std::strncmp(field, "ownership.", 10) == 0) {
    #####: 9939:      return make_struct_cmp(&T::ownership, getMetaStruct<DDS::OwnershipQosPolicy>().create_qc_comparator(field + 10), next);
        -: 9940:    }
    #####: 9941:    if (std::strncmp(field, "topic_data.", 11) == 0) {
    #####: 9942:      return make_struct_cmp(&T::topic_data, getMetaStruct<DDS::TopicDataQosPolicy>().create_qc_comparator(field + 11), next);
        -: 9943:    }
    #####: 9944:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
        -: 9945:  }
        -: 9946:
        -: 9947:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 9948:  const char** getFieldNames() const
        -: 9949:  {
        -: 9950:    static const char* names[] = {"key", "name", "type_name", "durability", "durability_service", "deadline", "latency_budget", "liveliness", "reliability", "transport_priority", "lifespan", "destination_order", "history", "resource_limits", "ownership", "topic_data", 0};
    #####: 9951:    return names;
        -: 9952:  }
        -: 9953:
    #####: 9954:  const void* getRawField(const void* stru, const char* field) const
        -: 9955:  {
    #####: 9956:    if (std::strcmp(field, "key") == 0) {
    #####: 9957:      return &static_cast<const T*>(stru)->key;
        -: 9958:    }
    #####: 9959:    if (std::strcmp(field, "name") == 0) {
    #####: 9960:      return &static_cast<const T*>(stru)->name;
        -: 9961:    }
    #####: 9962:    if (std::strcmp(field, "type_name") == 0) {
    #####: 9963:      return &static_cast<const T*>(stru)->type_name;
        -: 9964:    }
    #####: 9965:    if (std::strcmp(field, "durability") == 0) {
    #####: 9966:      return &static_cast<const T*>(stru)->durability;
        -: 9967:    }
    #####: 9968:    if (std::strcmp(field, "durability_service") == 0) {
    #####: 9969:      return &static_cast<const T*>(stru)->durability_service;
        -: 9970:    }
    #####: 9971:    if (std::strcmp(field, "deadline") == 0) {
    #####: 9972:      return &static_cast<const T*>(stru)->deadline;
        -: 9973:    }
    #####: 9974:    if (std::strcmp(field, "latency_budget") == 0) {
    #####: 9975:      return &static_cast<const T*>(stru)->latency_budget;
        -: 9976:    }
    #####: 9977:    if (std::strcmp(field, "liveliness") == 0) {
    #####: 9978:      return &static_cast<const T*>(stru)->liveliness;
        -: 9979:    }
    #####: 9980:    if (std::strcmp(field, "reliability") == 0) {
    #####: 9981:      return &static_cast<const T*>(stru)->reliability;
        -: 9982:    }
    #####: 9983:    if (std::strcmp(field, "transport_priority") == 0) {
    #####: 9984:      return &static_cast<const T*>(stru)->transport_priority;
        -: 9985:    }
    #####: 9986:    if (std::strcmp(field, "lifespan") == 0) {
    #####: 9987:      return &static_cast<const T*>(stru)->lifespan;
        -: 9988:    }
    #####: 9989:    if (std::strcmp(field, "destination_order") == 0) {
    #####: 9990:      return &static_cast<const T*>(stru)->destination_order;
        -: 9991:    }
    #####: 9992:    if (std::strcmp(field, "history") == 0) {
    #####: 9993:      return &static_cast<const T*>(stru)->history;
        -: 9994:    }
    #####: 9995:    if (std::strcmp(field, "resource_limits") == 0) {
    #####: 9996:      return &static_cast<const T*>(stru)->resource_limits;
        -: 9997:    }
    #####: 9998:    if (std::strcmp(field, "ownership") == 0) {
    #####: 9999:      return &static_cast<const T*>(stru)->ownership;
        -:10000:    }
    #####:10001:    if (std::strcmp(field, "topic_data") == 0) {
    #####:10002:      return &static_cast<const T*>(stru)->topic_data;
        -:10003:    }
    #####:10004:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
        -:10005:  }
        -:10006:
    #####:10007:  void assign(void* lhs, const char* field, const void* rhs,
        -:10008:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:10009:  {
        -:10010:    ACE_UNUSED_ARG(lhs);
        -:10011:    ACE_UNUSED_ARG(field);
        -:10012:    ACE_UNUSED_ARG(rhs);
        -:10013:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:10014:    ACE_UNUSED_ARG(rhsMeta);
    #####:10015:    if (std::strcmp(field, "key") == 0) {
    #####:10016:      static_cast<T*>(lhs)->key = *static_cast<const DDS::BuiltinTopicKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10017:      return;
        -:10018:    }
    #####:10019:    if (std::strcmp(field, "name") == 0) {
    #####:10020:      static_cast<T*>(lhs)->name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10021:      return;
        -:10022:    }
    #####:10023:    if (std::strcmp(field, "type_name") == 0) {
    #####:10024:      static_cast<T*>(lhs)->type_name = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10025:      return;
        -:10026:    }
    #####:10027:    if (std::strcmp(field, "durability") == 0) {
    #####:10028:      static_cast<T*>(lhs)->durability = *static_cast<const DDS::DurabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10029:      return;
        -:10030:    }
    #####:10031:    if (std::strcmp(field, "durability_service") == 0) {
    #####:10032:      static_cast<T*>(lhs)->durability_service = *static_cast<const DDS::DurabilityServiceQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10033:      return;
        -:10034:    }
    #####:10035:    if (std::strcmp(field, "deadline") == 0) {
    #####:10036:      static_cast<T*>(lhs)->deadline = *static_cast<const DDS::DeadlineQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10037:      return;
        -:10038:    }
    #####:10039:    if (std::strcmp(field, "latency_budget") == 0) {
    #####:10040:      static_cast<T*>(lhs)->latency_budget = *static_cast<const DDS::LatencyBudgetQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10041:      return;
        -:10042:    }
    #####:10043:    if (std::strcmp(field, "liveliness") == 0) {
    #####:10044:      static_cast<T*>(lhs)->liveliness = *static_cast<const DDS::LivelinessQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10045:      return;
        -:10046:    }
    #####:10047:    if (std::strcmp(field, "reliability") == 0) {
    #####:10048:      static_cast<T*>(lhs)->reliability = *static_cast<const DDS::ReliabilityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10049:      return;
        -:10050:    }
    #####:10051:    if (std::strcmp(field, "transport_priority") == 0) {
    #####:10052:      static_cast<T*>(lhs)->transport_priority = *static_cast<const DDS::TransportPriorityQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10053:      return;
        -:10054:    }
    #####:10055:    if (std::strcmp(field, "lifespan") == 0) {
    #####:10056:      static_cast<T*>(lhs)->lifespan = *static_cast<const DDS::LifespanQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10057:      return;
        -:10058:    }
    #####:10059:    if (std::strcmp(field, "destination_order") == 0) {
    #####:10060:      static_cast<T*>(lhs)->destination_order = *static_cast<const DDS::DestinationOrderQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10061:      return;
        -:10062:    }
    #####:10063:    if (std::strcmp(field, "history") == 0) {
    #####:10064:      static_cast<T*>(lhs)->history = *static_cast<const DDS::HistoryQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10065:      return;
        -:10066:    }
    #####:10067:    if (std::strcmp(field, "resource_limits") == 0) {
    #####:10068:      static_cast<T*>(lhs)->resource_limits = *static_cast<const DDS::ResourceLimitsQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10069:      return;
        -:10070:    }
    #####:10071:    if (std::strcmp(field, "ownership") == 0) {
    #####:10072:      static_cast<T*>(lhs)->ownership = *static_cast<const DDS::OwnershipQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10073:      return;
        -:10074:    }
    #####:10075:    if (std::strcmp(field, "topic_data") == 0) {
    #####:10076:      static_cast<T*>(lhs)->topic_data = *static_cast<const DDS::TopicDataQosPolicy*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10077:      return;
        -:10078:    }
    #####:10079:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
        -:10080:  }
        -:10081:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:10082:
    #####:10083:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:10084:  {
        -:10085:    ACE_UNUSED_ARG(lhs);
        -:10086:    ACE_UNUSED_ARG(field);
        -:10087:    ACE_UNUSED_ARG(rhs);
    #####:10088:    if (std::strcmp(field, "name") == 0) {
    #####:10089:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->name.in(), static_cast<const T*>(rhs)->name.in());
        -:10090:    }
    #####:10091:    if (std::strcmp(field, "type_name") == 0) {
    #####:10092:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->type_name.in(), static_cast<const T*>(rhs)->type_name.in());
        -:10093:    }
    #####:10094:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::TopicBuiltinTopicData)");
        -:10095:  }
        -:10096:};
        -:10097:
        -:10098:template<>
    #####:10099:const MetaStruct& getMetaStruct<DDS::TopicBuiltinTopicData>()
        -:10100:{
    #####:10101:  static MetaStructImpl<DDS::TopicBuiltinTopicData> msi;
    #####:10102:  return msi;
        -:10103:}
        -:10104:
    #####:10105:bool gen_skip_over(Serializer& ser, DDS::TopicBuiltinTopicData*)
        -:10106:{
        -:10107:  ACE_UNUSED_ARG(ser);
    #####:10108:  MetaStructImpl<DDS::TopicBuiltinTopicData>().getValue(ser, "");
    #####:10109:  return true;
        -:10110:}
        -:10111:
        -:10112:}  }
        -:10113:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:10114:
        -:10115:#endif
        -:10116:
        -:10117:/* End STRUCT: TopicBuiltinTopicData */
        -:10118:
        -:10119:
        -:10120:/* Begin TYPEDEF: SampleStateKind */
        -:10121:
        -:10122:
        -:10123:/* End TYPEDEF: SampleStateKind */
        -:10124:
        -:10125:
        -:10126:/* Begin CONST: READ_SAMPLE_STATE */
        -:10127:
        -:10128:
        -:10129:/* End CONST: READ_SAMPLE_STATE */
        -:10130:
        -:10131:
        -:10132:/* Begin CONST: NOT_READ_SAMPLE_STATE */
        -:10133:
        -:10134:
        -:10135:/* End CONST: NOT_READ_SAMPLE_STATE */
        -:10136:
        -:10137:
        -:10138:/* Begin TYPEDEF: SampleStateMask */
        -:10139:
        -:10140:
        -:10141:/* End TYPEDEF: SampleStateMask */
        -:10142:
        -:10143:
        -:10144:/* Begin CONST: ANY_SAMPLE_STATE */
        -:10145:
        -:10146:
        -:10147:/* End CONST: ANY_SAMPLE_STATE */
        -:10148:
        -:10149:
        -:10150:/* Begin TYPEDEF: ViewStateKind */
        -:10151:
        -:10152:
        -:10153:/* End TYPEDEF: ViewStateKind */
        -:10154:
        -:10155:
        -:10156:/* Begin CONST: NEW_VIEW_STATE */
        -:10157:
        -:10158:
        -:10159:/* End CONST: NEW_VIEW_STATE */
        -:10160:
        -:10161:
        -:10162:/* Begin CONST: NOT_NEW_VIEW_STATE */
        -:10163:
        -:10164:
        -:10165:/* End CONST: NOT_NEW_VIEW_STATE */
        -:10166:
        -:10167:
        -:10168:/* Begin TYPEDEF: ViewStateMask */
        -:10169:
        -:10170:
        -:10171:/* End TYPEDEF: ViewStateMask */
        -:10172:
        -:10173:
        -:10174:/* Begin CONST: ANY_VIEW_STATE */
        -:10175:
        -:10176:
        -:10177:/* End CONST: ANY_VIEW_STATE */
        -:10178:
        -:10179:
        -:10180:/* Begin TYPEDEF: InstanceStateKind */
        -:10181:
        -:10182:
        -:10183:/* End TYPEDEF: InstanceStateKind */
        -:10184:
        -:10185:
        -:10186:/* Begin CONST: ALIVE_INSTANCE_STATE */
        -:10187:
        -:10188:
        -:10189:/* End CONST: ALIVE_INSTANCE_STATE */
        -:10190:
        -:10191:
        -:10192:/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */
        -:10193:
        -:10194:
        -:10195:/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */
        -:10196:
        -:10197:
        -:10198:/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */
        -:10199:
        -:10200:
        -:10201:/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */
        -:10202:
        -:10203:
        -:10204:/* Begin TYPEDEF: InstanceStateMask */
        -:10205:
        -:10206:
        -:10207:/* End TYPEDEF: InstanceStateMask */
        -:10208:
        -:10209:
        -:10210:/* Begin CONST: ANY_INSTANCE_STATE */
        -:10211:
        -:10212:
        -:10213:/* End CONST: ANY_INSTANCE_STATE */
        -:10214:
        -:10215:
        -:10216:/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */
        -:10217:
        -:10218:
        -:10219:/* End CONST: NOT_ALIVE_INSTANCE_STATE */
        -:10220:
        -:10221:
        -:10222:/* Begin STRUCT: Time_t */
        -:10223:
        -:10224:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:10225:namespace OpenDDS { namespace DCPS {
        -:10226:
    #####:10227:void gen_find_size(const DDS::Time_t& stru, size_t& size, size_t& padding)
        -:10228:{
        -:10229:  ACE_UNUSED_ARG(stru);
        -:10230:  ACE_UNUSED_ARG(size);
        -:10231:  ACE_UNUSED_ARG(padding);
    #####:10232:  if ((size + padding) % 4) {
    #####:10233:    padding += 4 - ((size + padding) % 4);
        -:10234:  }
    #####:10235:  size += gen_max_marshaled_size(stru.sec);
    #####:10236:  if ((size + padding) % 4) {
    #####:10237:    padding += 4 - ((size + padding) % 4);
        -:10238:  }
    #####:10239:  size += gen_max_marshaled_size(stru.nanosec);
    #####:10240:}
        -:10241:
    #####:10242:bool operator<<(Serializer& strm, const DDS::Time_t& stru)
        -:10243:{
        -:10244:  ACE_UNUSED_ARG(strm);
        -:10245:  ACE_UNUSED_ARG(stru);
    #####:10246:  return (strm << stru.sec)
    #####:10247:    && (strm << stru.nanosec);
        -:10248:}
        -:10249:
    #####:10250:bool operator>>(Serializer& strm, DDS::Time_t& stru)
        -:10251:{
        -:10252:  ACE_UNUSED_ARG(strm);
        -:10253:  ACE_UNUSED_ARG(stru);
    #####:10254:  return (strm >> stru.sec)
    #####:10255:    && (strm >> stru.nanosec);
        -:10256:}
        -:10257:
        -:10258:}  }
        -:10259:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:10260:
        -:10261:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:10262:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:10263:namespace OpenDDS { namespace DCPS {
        -:10264:
        -:10265:template<>
    #####:10266:struct MetaStructImpl<DDS::Time_t> : MetaStruct {
        -:10267:  typedef DDS::Time_t T;
        -:10268:
        -:10269:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:10270:  void* allocate() const { return new T; }
        -:10271:
    #####:10272:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:10273:
    #####:10274:  size_t numDcpsKeys() const { return 0; }
        -:10275:
        -:10276:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:10277:
    #####:10278:  bool isDcpsKey(const char* field) const
        -:10279:  {
        -:10280:    ACE_UNUSED_ARG(field);
    #####:10281:    return false;
        -:10282:  }
        -:10283:
    #####:10284:  Value getValue(const void* stru, const char* field) const
        -:10285:  {
    #####:10286:    const DDS::Time_t& typed = *static_cast<const DDS::Time_t*>(stru);
    #####:10287:    if (std::strcmp(field, "sec") == 0) {
    #####:10288:      return typed.sec;
        -:10289:    }
    #####:10290:    if (std::strcmp(field, "nanosec") == 0) {
    #####:10291:      return typed.nanosec;
        -:10292:    }
        -:10293:    ACE_UNUSED_ARG(typed);
    #####:10294:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
        -:10295:  }
        -:10296:
    #####:10297:  Value getValue(Serializer& ser, const char* field) const
        -:10298:  {
    #####:10299:    if (std::strcmp(field, "sec") == 0) {
        -:10300:      ACE_CDR::Long val;
    #####:10301:      if (!(ser >> val)) {
    #####:10302:        throw std::runtime_error("Field 'sec' could not be deserialized");
        -:10303:      }
    #####:10304:      return val;
        -:10305:    } else {
    #####:10306:      if (!ser.skip(1, 4)) {
    #####:10307:        throw std::runtime_error("Field 'sec' could not be skipped");
        -:10308:      }
        -:10309:    }
    #####:10310:    if (std::strcmp(field, "nanosec") == 0) {
        -:10311:      ACE_CDR::ULong val;
    #####:10312:      if (!(ser >> val)) {
    #####:10313:        throw std::runtime_error("Field 'nanosec' could not be deserialized");
        -:10314:      }
    #####:10315:      return val;
        -:10316:    } else {
    #####:10317:      if (!ser.skip(1, 4)) {
    #####:10318:        throw std::runtime_error("Field 'nanosec' could not be skipped");
        -:10319:      }
        -:10320:    }
    #####:10321:    if (!field[0]) {
    #####:10322:      return 0;
        -:10323:    }
    #####:10324:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::Time_t");
        -:10325:  }
        -:10326:
    #####:10327:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:10328:  {
        -:10329:    ACE_UNUSED_ARG(next);
    #####:10330:    if (std::strcmp(field, "sec") == 0) {
    #####:10331:      return make_field_cmp(&T::sec, next);
        -:10332:    }
    #####:10333:    if (std::strcmp(field, "nanosec") == 0) {
    #####:10334:      return make_field_cmp(&T::nanosec, next);
        -:10335:    }
    #####:10336:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
        -:10337:  }
        -:10338:
        -:10339:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:10340:  const char** getFieldNames() const
        -:10341:  {
        -:10342:    static const char* names[] = {"sec", "nanosec", 0};
    #####:10343:    return names;
        -:10344:  }
        -:10345:
    #####:10346:  const void* getRawField(const void* stru, const char* field) const
        -:10347:  {
    #####:10348:    if (std::strcmp(field, "sec") == 0) {
    #####:10349:      return &static_cast<const T*>(stru)->sec;
        -:10350:    }
    #####:10351:    if (std::strcmp(field, "nanosec") == 0) {
    #####:10352:      return &static_cast<const T*>(stru)->nanosec;
        -:10353:    }
    #####:10354:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
        -:10355:  }
        -:10356:
    #####:10357:  void assign(void* lhs, const char* field, const void* rhs,
        -:10358:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:10359:  {
        -:10360:    ACE_UNUSED_ARG(lhs);
        -:10361:    ACE_UNUSED_ARG(field);
        -:10362:    ACE_UNUSED_ARG(rhs);
        -:10363:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:10364:    ACE_UNUSED_ARG(rhsMeta);
    #####:10365:    if (std::strcmp(field, "sec") == 0) {
    #####:10366:      static_cast<T*>(lhs)->sec = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10367:      return;
        -:10368:    }
    #####:10369:    if (std::strcmp(field, "nanosec") == 0) {
    #####:10370:      static_cast<T*>(lhs)->nanosec = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10371:      return;
        -:10372:    }
    #####:10373:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
        -:10374:  }
        -:10375:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:10376:
    #####:10377:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:10378:  {
        -:10379:    ACE_UNUSED_ARG(lhs);
        -:10380:    ACE_UNUSED_ARG(field);
        -:10381:    ACE_UNUSED_ARG(rhs);
    #####:10382:    if (std::strcmp(field, "sec") == 0) {
    #####:10383:      return static_cast<const T*>(lhs)->sec == static_cast<const T*>(rhs)->sec;
        -:10384:    }
    #####:10385:    if (std::strcmp(field, "nanosec") == 0) {
    #####:10386:      return static_cast<const T*>(lhs)->nanosec == static_cast<const T*>(rhs)->nanosec;
        -:10387:    }
    #####:10388:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::Time_t)");
        -:10389:  }
        -:10390:};
        -:10391:
        -:10392:template<>
    #####:10393:const MetaStruct& getMetaStruct<DDS::Time_t>()
        -:10394:{
    #####:10395:  static MetaStructImpl<DDS::Time_t> msi;
    #####:10396:  return msi;
        -:10397:}
        -:10398:
    #####:10399:bool gen_skip_over(Serializer& ser, DDS::Time_t*)
        -:10400:{
        -:10401:  ACE_UNUSED_ARG(ser);
    #####:10402:  MetaStructImpl<DDS::Time_t>().getValue(ser, "");
    #####:10403:  return true;
        -:10404:}
        -:10405:
        -:10406:}  }
        -:10407:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:10408:
        -:10409:#endif
        -:10410:
        -:10411:/* End STRUCT: Time_t */
        -:10412:
        -:10413:
        -:10414:/* Begin CONST: TIME_INVALID_SEC */
        -:10415:
        -:10416:
        -:10417:/* End CONST: TIME_INVALID_SEC */
        -:10418:
        -:10419:
        -:10420:/* Begin CONST: TIME_INVALID_NSEC */
        -:10421:
        -:10422:
        -:10423:/* End CONST: TIME_INVALID_NSEC */
        -:10424:
        -:10425:
        -:10426:/* Begin STRUCT: SampleInfo */
        -:10427:
        -:10428:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:10429:namespace OpenDDS { namespace DCPS {
        -:10430:
    #####:10431:void gen_find_size(const DDS::SampleInfo& stru, size_t& size, size_t& padding)
        -:10432:{
        -:10433:  ACE_UNUSED_ARG(stru);
        -:10434:  ACE_UNUSED_ARG(size);
        -:10435:  ACE_UNUSED_ARG(padding);
    #####:10436:  if ((size + padding) % 4) {
    #####:10437:    padding += 4 - ((size + padding) % 4);
        -:10438:  }
    #####:10439:  size += gen_max_marshaled_size(stru.sample_state);
    #####:10440:  if ((size + padding) % 4) {
    #####:10441:    padding += 4 - ((size + padding) % 4);
        -:10442:  }
    #####:10443:  size += gen_max_marshaled_size(stru.view_state);
    #####:10444:  if ((size + padding) % 4) {
    #####:10445:    padding += 4 - ((size + padding) % 4);
        -:10446:  }
    #####:10447:  size += gen_max_marshaled_size(stru.instance_state);
    #####:10448:  gen_find_size(stru.source_timestamp, size, padding);
    #####:10449:  if ((size + padding) % 4) {
    #####:10450:    padding += 4 - ((size + padding) % 4);
        -:10451:  }
    #####:10452:  size += gen_max_marshaled_size(stru.instance_handle);
    #####:10453:  if ((size + padding) % 4) {
    #####:10454:    padding += 4 - ((size + padding) % 4);
        -:10455:  }
    #####:10456:  size += gen_max_marshaled_size(stru.publication_handle);
    #####:10457:  if ((size + padding) % 4) {
    #####:10458:    padding += 4 - ((size + padding) % 4);
        -:10459:  }
    #####:10460:  size += gen_max_marshaled_size(stru.disposed_generation_count);
    #####:10461:  if ((size + padding) % 4) {
    #####:10462:    padding += 4 - ((size + padding) % 4);
        -:10463:  }
    #####:10464:  size += gen_max_marshaled_size(stru.no_writers_generation_count);
    #####:10465:  if ((size + padding) % 4) {
    #####:10466:    padding += 4 - ((size + padding) % 4);
        -:10467:  }
    #####:10468:  size += gen_max_marshaled_size(stru.sample_rank);
    #####:10469:  if ((size + padding) % 4) {
    #####:10470:    padding += 4 - ((size + padding) % 4);
        -:10471:  }
    #####:10472:  size += gen_max_marshaled_size(stru.generation_rank);
    #####:10473:  if ((size + padding) % 4) {
    #####:10474:    padding += 4 - ((size + padding) % 4);
        -:10475:  }
    #####:10476:  size += gen_max_marshaled_size(stru.absolute_generation_rank);
    #####:10477:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.valid_data));
    #####:10478:  if ((size + padding) % 8) {
    #####:10479:    padding += 8 - ((size + padding) % 8);
        -:10480:  }
    #####:10481:  size += gen_max_marshaled_size(stru.opendds_reserved_publication_seq);
    #####:10482:}
        -:10483:
    #####:10484:bool operator<<(Serializer& strm, const DDS::SampleInfo& stru)
        -:10485:{
        -:10486:  ACE_UNUSED_ARG(strm);
        -:10487:  ACE_UNUSED_ARG(stru);
    #####:10488:  return (strm << stru.sample_state)
    #####:10489:    && (strm << stru.view_state)
    #####:10490:    && (strm << stru.instance_state)
    #####:10491:    && (strm << stru.source_timestamp)
    #####:10492:    && (strm << stru.instance_handle)
    #####:10493:    && (strm << stru.publication_handle)
    #####:10494:    && (strm << stru.disposed_generation_count)
    #####:10495:    && (strm << stru.no_writers_generation_count)
    #####:10496:    && (strm << stru.sample_rank)
    #####:10497:    && (strm << stru.generation_rank)
    #####:10498:    && (strm << stru.absolute_generation_rank)
    #####:10499:    && (strm << ACE_OutputCDR::from_boolean(stru.valid_data))
    #####:10500:    && (strm << stru.opendds_reserved_publication_seq);
        -:10501:}
        -:10502:
    #####:10503:bool operator>>(Serializer& strm, DDS::SampleInfo& stru)
        -:10504:{
        -:10505:  ACE_UNUSED_ARG(strm);
        -:10506:  ACE_UNUSED_ARG(stru);
    #####:10507:  return (strm >> stru.sample_state)
    #####:10508:    && (strm >> stru.view_state)
    #####:10509:    && (strm >> stru.instance_state)
    #####:10510:    && (strm >> stru.source_timestamp)
    #####:10511:    && (strm >> stru.instance_handle)
    #####:10512:    && (strm >> stru.publication_handle)
    #####:10513:    && (strm >> stru.disposed_generation_count)
    #####:10514:    && (strm >> stru.no_writers_generation_count)
    #####:10515:    && (strm >> stru.sample_rank)
    #####:10516:    && (strm >> stru.generation_rank)
    #####:10517:    && (strm >> stru.absolute_generation_rank)
    #####:10518:    && (strm >> ACE_InputCDR::to_boolean(stru.valid_data))
    #####:10519:    && (strm >> stru.opendds_reserved_publication_seq);
        -:10520:}
        -:10521:
        -:10522:}  }
        -:10523:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:10524:
        -:10525:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:10526:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:10527:namespace OpenDDS { namespace DCPS {
        -:10528:
        -:10529:template<>
    #####:10530:struct MetaStructImpl<DDS::SampleInfo> : MetaStruct {
        -:10531:  typedef DDS::SampleInfo T;
        -:10532:
        -:10533:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:10534:  void* allocate() const { return new T; }
        -:10535:
    #####:10536:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:10537:
    #####:10538:  size_t numDcpsKeys() const { return 0; }
        -:10539:
        -:10540:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:10541:
    #####:10542:  bool isDcpsKey(const char* field) const
        -:10543:  {
        -:10544:    ACE_UNUSED_ARG(field);
    #####:10545:    return false;
        -:10546:  }
        -:10547:
    #####:10548:  Value getValue(const void* stru, const char* field) const
        -:10549:  {
    #####:10550:    const DDS::SampleInfo& typed = *static_cast<const DDS::SampleInfo*>(stru);
    #####:10551:    if (std::strcmp(field, "sample_state") == 0) {
    #####:10552:      return typed.sample_state;
        -:10553:    }
    #####:10554:    if (std::strcmp(field, "view_state") == 0) {
    #####:10555:      return typed.view_state;
        -:10556:    }
    #####:10557:    if (std::strcmp(field, "instance_state") == 0) {
    #####:10558:      return typed.instance_state;
        -:10559:    }
    #####:10560:    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
    #####:10561:      return getMetaStruct<DDS::Time_t>().getValue(&typed.source_timestamp, field + 17);
        -:10562:    }
    #####:10563:    if (std::strcmp(field, "instance_handle") == 0) {
    #####:10564:      return typed.instance_handle;
        -:10565:    }
    #####:10566:    if (std::strcmp(field, "publication_handle") == 0) {
    #####:10567:      return typed.publication_handle;
        -:10568:    }
    #####:10569:    if (std::strcmp(field, "disposed_generation_count") == 0) {
    #####:10570:      return typed.disposed_generation_count;
        -:10571:    }
    #####:10572:    if (std::strcmp(field, "no_writers_generation_count") == 0) {
    #####:10573:      return typed.no_writers_generation_count;
        -:10574:    }
    #####:10575:    if (std::strcmp(field, "sample_rank") == 0) {
    #####:10576:      return typed.sample_rank;
        -:10577:    }
    #####:10578:    if (std::strcmp(field, "generation_rank") == 0) {
    #####:10579:      return typed.generation_rank;
        -:10580:    }
    #####:10581:    if (std::strcmp(field, "absolute_generation_rank") == 0) {
    #####:10582:      return typed.absolute_generation_rank;
        -:10583:    }
    #####:10584:    if (std::strcmp(field, "valid_data") == 0) {
    #####:10585:      return typed.valid_data;
        -:10586:    }
    #####:10587:    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
    #####:10588:      return typed.opendds_reserved_publication_seq;
        -:10589:    }
        -:10590:    ACE_UNUSED_ARG(typed);
    #####:10591:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
        -:10592:  }
        -:10593:
    #####:10594:  Value getValue(Serializer& ser, const char* field) const
        -:10595:  {
    #####:10596:    if (std::strcmp(field, "sample_state") == 0) {
        -:10597:      ACE_CDR::ULong val;
    #####:10598:      if (!(ser >> val)) {
    #####:10599:        throw std::runtime_error("Field 'sample_state' could not be deserialized");
        -:10600:      }
    #####:10601:      return val;
        -:10602:    } else {
    #####:10603:      if (!ser.skip(1, 4)) {
    #####:10604:        throw std::runtime_error("Field 'sample_state' could not be skipped");
        -:10605:      }
        -:10606:    }
    #####:10607:    if (std::strcmp(field, "view_state") == 0) {
        -:10608:      ACE_CDR::ULong val;
    #####:10609:      if (!(ser >> val)) {
    #####:10610:        throw std::runtime_error("Field 'view_state' could not be deserialized");
        -:10611:      }
    #####:10612:      return val;
        -:10613:    } else {
    #####:10614:      if (!ser.skip(1, 4)) {
    #####:10615:        throw std::runtime_error("Field 'view_state' could not be skipped");
        -:10616:      }
        -:10617:    }
    #####:10618:    if (std::strcmp(field, "instance_state") == 0) {
        -:10619:      ACE_CDR::ULong val;
    #####:10620:      if (!(ser >> val)) {
    #####:10621:        throw std::runtime_error("Field 'instance_state' could not be deserialized");
        -:10622:      }
    #####:10623:      return val;
        -:10624:    } else {
    #####:10625:      if (!ser.skip(1, 4)) {
    #####:10626:        throw std::runtime_error("Field 'instance_state' could not be skipped");
        -:10627:      }
        -:10628:    }
    #####:10629:    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
    #####:10630:      return getMetaStruct<DDS::Time_t>().getValue(ser, field + 17);
        -:10631:    } else {
    #####:10632:      if (!gen_skip_over(ser, static_cast<DDS::Time_t*>(0))) {
    #####:10633:        throw std::runtime_error("Field 'source_timestamp' could not be skipped");
        -:10634:      }
        -:10635:    }
    #####:10636:    if (std::strcmp(field, "instance_handle") == 0) {
        -:10637:      ACE_CDR::Long val;
    #####:10638:      if (!(ser >> val)) {
    #####:10639:        throw std::runtime_error("Field 'instance_handle' could not be deserialized");
        -:10640:      }
    #####:10641:      return val;
        -:10642:    } else {
    #####:10643:      if (!ser.skip(1, 4)) {
    #####:10644:        throw std::runtime_error("Field 'instance_handle' could not be skipped");
        -:10645:      }
        -:10646:    }
    #####:10647:    if (std::strcmp(field, "publication_handle") == 0) {
        -:10648:      ACE_CDR::Long val;
    #####:10649:      if (!(ser >> val)) {
    #####:10650:        throw std::runtime_error("Field 'publication_handle' could not be deserialized");
        -:10651:      }
    #####:10652:      return val;
        -:10653:    } else {
    #####:10654:      if (!ser.skip(1, 4)) {
    #####:10655:        throw std::runtime_error("Field 'publication_handle' could not be skipped");
        -:10656:      }
        -:10657:    }
    #####:10658:    if (std::strcmp(field, "disposed_generation_count") == 0) {
        -:10659:      ACE_CDR::Long val;
    #####:10660:      if (!(ser >> val)) {
    #####:10661:        throw std::runtime_error("Field 'disposed_generation_count' could not be deserialized");
        -:10662:      }
    #####:10663:      return val;
        -:10664:    } else {
    #####:10665:      if (!ser.skip(1, 4)) {
    #####:10666:        throw std::runtime_error("Field 'disposed_generation_count' could not be skipped");
        -:10667:      }
        -:10668:    }
    #####:10669:    if (std::strcmp(field, "no_writers_generation_count") == 0) {
        -:10670:      ACE_CDR::Long val;
    #####:10671:      if (!(ser >> val)) {
    #####:10672:        throw std::runtime_error("Field 'no_writers_generation_count' could not be deserialized");
        -:10673:      }
    #####:10674:      return val;
        -:10675:    } else {
    #####:10676:      if (!ser.skip(1, 4)) {
    #####:10677:        throw std::runtime_error("Field 'no_writers_generation_count' could not be skipped");
        -:10678:      }
        -:10679:    }
    #####:10680:    if (std::strcmp(field, "sample_rank") == 0) {
        -:10681:      ACE_CDR::Long val;
    #####:10682:      if (!(ser >> val)) {
    #####:10683:        throw std::runtime_error("Field 'sample_rank' could not be deserialized");
        -:10684:      }
    #####:10685:      return val;
        -:10686:    } else {
    #####:10687:      if (!ser.skip(1, 4)) {
    #####:10688:        throw std::runtime_error("Field 'sample_rank' could not be skipped");
        -:10689:      }
        -:10690:    }
    #####:10691:    if (std::strcmp(field, "generation_rank") == 0) {
        -:10692:      ACE_CDR::Long val;
    #####:10693:      if (!(ser >> val)) {
    #####:10694:        throw std::runtime_error("Field 'generation_rank' could not be deserialized");
        -:10695:      }
    #####:10696:      return val;
        -:10697:    } else {
    #####:10698:      if (!ser.skip(1, 4)) {
    #####:10699:        throw std::runtime_error("Field 'generation_rank' could not be skipped");
        -:10700:      }
        -:10701:    }
    #####:10702:    if (std::strcmp(field, "absolute_generation_rank") == 0) {
        -:10703:      ACE_CDR::Long val;
    #####:10704:      if (!(ser >> val)) {
    #####:10705:        throw std::runtime_error("Field 'absolute_generation_rank' could not be deserialized");
        -:10706:      }
    #####:10707:      return val;
        -:10708:    } else {
    #####:10709:      if (!ser.skip(1, 4)) {
    #####:10710:        throw std::runtime_error("Field 'absolute_generation_rank' could not be skipped");
        -:10711:      }
        -:10712:    }
    #####:10713:    if (std::strcmp(field, "valid_data") == 0) {
        -:10714:      ACE_CDR::Boolean val;
    #####:10715:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####:10716:        throw std::runtime_error("Field 'valid_data' could not be deserialized");
        -:10717:      }
    #####:10718:      return val;
        -:10719:    } else {
    #####:10720:      if (!ser.skip(1, 1)) {
    #####:10721:        throw std::runtime_error("Field 'valid_data' could not be skipped");
        -:10722:      }
        -:10723:    }
    #####:10724:    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
        -:10725:      ACE_CDR::LongLong val;
    #####:10726:      if (!(ser >> val)) {
    #####:10727:        throw std::runtime_error("Field 'opendds_reserved_publication_seq' could not be deserialized");
        -:10728:      }
    #####:10729:      return val;
        -:10730:    } else {
    #####:10731:      if (!ser.skip(1, 8)) {
    #####:10732:        throw std::runtime_error("Field 'opendds_reserved_publication_seq' could not be skipped");
        -:10733:      }
        -:10734:    }
    #####:10735:    if (!field[0]) {
    #####:10736:      return 0;
        -:10737:    }
    #####:10738:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct DDS::SampleInfo");
        -:10739:  }
        -:10740:
    #####:10741:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:10742:  {
        -:10743:    ACE_UNUSED_ARG(next);
    #####:10744:    if (std::strcmp(field, "sample_state") == 0) {
    #####:10745:      return make_field_cmp(&T::sample_state, next);
        -:10746:    }
    #####:10747:    if (std::strcmp(field, "view_state") == 0) {
    #####:10748:      return make_field_cmp(&T::view_state, next);
        -:10749:    }
    #####:10750:    if (std::strcmp(field, "instance_state") == 0) {
    #####:10751:      return make_field_cmp(&T::instance_state, next);
        -:10752:    }
    #####:10753:    if (std::strncmp(field, "source_timestamp.", 17) == 0) {
    #####:10754:      return make_struct_cmp(&T::source_timestamp, getMetaStruct<DDS::Time_t>().create_qc_comparator(field + 17), next);
        -:10755:    }
    #####:10756:    if (std::strcmp(field, "instance_handle") == 0) {
    #####:10757:      return make_field_cmp(&T::instance_handle, next);
        -:10758:    }
    #####:10759:    if (std::strcmp(field, "publication_handle") == 0) {
    #####:10760:      return make_field_cmp(&T::publication_handle, next);
        -:10761:    }
    #####:10762:    if (std::strcmp(field, "disposed_generation_count") == 0) {
    #####:10763:      return make_field_cmp(&T::disposed_generation_count, next);
        -:10764:    }
    #####:10765:    if (std::strcmp(field, "no_writers_generation_count") == 0) {
    #####:10766:      return make_field_cmp(&T::no_writers_generation_count, next);
        -:10767:    }
    #####:10768:    if (std::strcmp(field, "sample_rank") == 0) {
    #####:10769:      return make_field_cmp(&T::sample_rank, next);
        -:10770:    }
    #####:10771:    if (std::strcmp(field, "generation_rank") == 0) {
    #####:10772:      return make_field_cmp(&T::generation_rank, next);
        -:10773:    }
    #####:10774:    if (std::strcmp(field, "absolute_generation_rank") == 0) {
    #####:10775:      return make_field_cmp(&T::absolute_generation_rank, next);
        -:10776:    }
    #####:10777:    if (std::strcmp(field, "valid_data") == 0) {
    #####:10778:      return make_field_cmp(&T::valid_data, next);
        -:10779:    }
    #####:10780:    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
    #####:10781:      return make_field_cmp(&T::opendds_reserved_publication_seq, next);
        -:10782:    }
    #####:10783:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
        -:10784:  }
        -:10785:
        -:10786:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:10787:  const char** getFieldNames() const
        -:10788:  {
        -:10789:    static const char* names[] = {"sample_state", "view_state", "instance_state", "source_timestamp", "instance_handle", "publication_handle", "disposed_generation_count", "no_writers_generation_count", "sample_rank", "generation_rank", "absolute_generation_rank", "valid_data", "opendds_reserved_publication_seq", 0};
    #####:10790:    return names;
        -:10791:  }
        -:10792:
    #####:10793:  const void* getRawField(const void* stru, const char* field) const
        -:10794:  {
    #####:10795:    if (std::strcmp(field, "sample_state") == 0) {
    #####:10796:      return &static_cast<const T*>(stru)->sample_state;
        -:10797:    }
    #####:10798:    if (std::strcmp(field, "view_state") == 0) {
    #####:10799:      return &static_cast<const T*>(stru)->view_state;
        -:10800:    }
    #####:10801:    if (std::strcmp(field, "instance_state") == 0) {
    #####:10802:      return &static_cast<const T*>(stru)->instance_state;
        -:10803:    }
    #####:10804:    if (std::strcmp(field, "source_timestamp") == 0) {
    #####:10805:      return &static_cast<const T*>(stru)->source_timestamp;
        -:10806:    }
    #####:10807:    if (std::strcmp(field, "instance_handle") == 0) {
    #####:10808:      return &static_cast<const T*>(stru)->instance_handle;
        -:10809:    }
    #####:10810:    if (std::strcmp(field, "publication_handle") == 0) {
    #####:10811:      return &static_cast<const T*>(stru)->publication_handle;
        -:10812:    }
    #####:10813:    if (std::strcmp(field, "disposed_generation_count") == 0) {
    #####:10814:      return &static_cast<const T*>(stru)->disposed_generation_count;
        -:10815:    }
    #####:10816:    if (std::strcmp(field, "no_writers_generation_count") == 0) {
    #####:10817:      return &static_cast<const T*>(stru)->no_writers_generation_count;
        -:10818:    }
    #####:10819:    if (std::strcmp(field, "sample_rank") == 0) {
    #####:10820:      return &static_cast<const T*>(stru)->sample_rank;
        -:10821:    }
    #####:10822:    if (std::strcmp(field, "generation_rank") == 0) {
    #####:10823:      return &static_cast<const T*>(stru)->generation_rank;
        -:10824:    }
    #####:10825:    if (std::strcmp(field, "absolute_generation_rank") == 0) {
    #####:10826:      return &static_cast<const T*>(stru)->absolute_generation_rank;
        -:10827:    }
    #####:10828:    if (std::strcmp(field, "valid_data") == 0) {
    #####:10829:      return &static_cast<const T*>(stru)->valid_data;
        -:10830:    }
    #####:10831:    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
    #####:10832:      return &static_cast<const T*>(stru)->opendds_reserved_publication_seq;
        -:10833:    }
    #####:10834:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
        -:10835:  }
        -:10836:
    #####:10837:  void assign(void* lhs, const char* field, const void* rhs,
        -:10838:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:10839:  {
        -:10840:    ACE_UNUSED_ARG(lhs);
        -:10841:    ACE_UNUSED_ARG(field);
        -:10842:    ACE_UNUSED_ARG(rhs);
        -:10843:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:10844:    ACE_UNUSED_ARG(rhsMeta);
    #####:10845:    if (std::strcmp(field, "sample_state") == 0) {
    #####:10846:      static_cast<T*>(lhs)->sample_state = *static_cast<const DDS::SampleStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10847:      return;
        -:10848:    }
    #####:10849:    if (std::strcmp(field, "view_state") == 0) {
    #####:10850:      static_cast<T*>(lhs)->view_state = *static_cast<const DDS::ViewStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10851:      return;
        -:10852:    }
    #####:10853:    if (std::strcmp(field, "instance_state") == 0) {
    #####:10854:      static_cast<T*>(lhs)->instance_state = *static_cast<const DDS::InstanceStateKind*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10855:      return;
        -:10856:    }
    #####:10857:    if (std::strcmp(field, "source_timestamp") == 0) {
    #####:10858:      static_cast<T*>(lhs)->source_timestamp = *static_cast<const DDS::Time_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10859:      return;
        -:10860:    }
    #####:10861:    if (std::strcmp(field, "instance_handle") == 0) {
    #####:10862:      static_cast<T*>(lhs)->instance_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10863:      return;
        -:10864:    }
    #####:10865:    if (std::strcmp(field, "publication_handle") == 0) {
    #####:10866:      static_cast<T*>(lhs)->publication_handle = *static_cast<const DDS::InstanceHandle_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10867:      return;
        -:10868:    }
    #####:10869:    if (std::strcmp(field, "disposed_generation_count") == 0) {
    #####:10870:      static_cast<T*>(lhs)->disposed_generation_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10871:      return;
        -:10872:    }
    #####:10873:    if (std::strcmp(field, "no_writers_generation_count") == 0) {
    #####:10874:      static_cast<T*>(lhs)->no_writers_generation_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10875:      return;
        -:10876:    }
    #####:10877:    if (std::strcmp(field, "sample_rank") == 0) {
    #####:10878:      static_cast<T*>(lhs)->sample_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10879:      return;
        -:10880:    }
    #####:10881:    if (std::strcmp(field, "generation_rank") == 0) {
    #####:10882:      static_cast<T*>(lhs)->generation_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10883:      return;
        -:10884:    }
    #####:10885:    if (std::strcmp(field, "absolute_generation_rank") == 0) {
    #####:10886:      static_cast<T*>(lhs)->absolute_generation_rank = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10887:      return;
        -:10888:    }
    #####:10889:    if (std::strcmp(field, "valid_data") == 0) {
    #####:10890:      static_cast<T*>(lhs)->valid_data = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10891:      return;
        -:10892:    }
    #####:10893:    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
    #####:10894:      static_cast<T*>(lhs)->opendds_reserved_publication_seq = *static_cast<const CORBA::LongLong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:10895:      return;
        -:10896:    }
    #####:10897:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
        -:10898:  }
        -:10899:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:10900:
    #####:10901:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:10902:  {
        -:10903:    ACE_UNUSED_ARG(lhs);
        -:10904:    ACE_UNUSED_ARG(field);
        -:10905:    ACE_UNUSED_ARG(rhs);
    #####:10906:    if (std::strcmp(field, "sample_state") == 0) {
    #####:10907:      return static_cast<const T*>(lhs)->sample_state == static_cast<const T*>(rhs)->sample_state;
        -:10908:    }
    #####:10909:    if (std::strcmp(field, "view_state") == 0) {
    #####:10910:      return static_cast<const T*>(lhs)->view_state == static_cast<const T*>(rhs)->view_state;
        -:10911:    }
    #####:10912:    if (std::strcmp(field, "instance_state") == 0) {
    #####:10913:      return static_cast<const T*>(lhs)->instance_state == static_cast<const T*>(rhs)->instance_state;
        -:10914:    }
    #####:10915:    if (std::strcmp(field, "instance_handle") == 0) {
    #####:10916:      return static_cast<const T*>(lhs)->instance_handle == static_cast<const T*>(rhs)->instance_handle;
        -:10917:    }
    #####:10918:    if (std::strcmp(field, "publication_handle") == 0) {
    #####:10919:      return static_cast<const T*>(lhs)->publication_handle == static_cast<const T*>(rhs)->publication_handle;
        -:10920:    }
    #####:10921:    if (std::strcmp(field, "disposed_generation_count") == 0) {
    #####:10922:      return static_cast<const T*>(lhs)->disposed_generation_count == static_cast<const T*>(rhs)->disposed_generation_count;
        -:10923:    }
    #####:10924:    if (std::strcmp(field, "no_writers_generation_count") == 0) {
    #####:10925:      return static_cast<const T*>(lhs)->no_writers_generation_count == static_cast<const T*>(rhs)->no_writers_generation_count;
        -:10926:    }
    #####:10927:    if (std::strcmp(field, "sample_rank") == 0) {
    #####:10928:      return static_cast<const T*>(lhs)->sample_rank == static_cast<const T*>(rhs)->sample_rank;
        -:10929:    }
    #####:10930:    if (std::strcmp(field, "generation_rank") == 0) {
    #####:10931:      return static_cast<const T*>(lhs)->generation_rank == static_cast<const T*>(rhs)->generation_rank;
        -:10932:    }
    #####:10933:    if (std::strcmp(field, "absolute_generation_rank") == 0) {
    #####:10934:      return static_cast<const T*>(lhs)->absolute_generation_rank == static_cast<const T*>(rhs)->absolute_generation_rank;
        -:10935:    }
    #####:10936:    if (std::strcmp(field, "valid_data") == 0) {
    #####:10937:      return static_cast<const T*>(lhs)->valid_data == static_cast<const T*>(rhs)->valid_data;
        -:10938:    }
    #####:10939:    if (std::strcmp(field, "opendds_reserved_publication_seq") == 0) {
    #####:10940:      return static_cast<const T*>(lhs)->opendds_reserved_publication_seq == static_cast<const T*>(rhs)->opendds_reserved_publication_seq;
        -:10941:    }
    #####:10942:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct DDS::SampleInfo)");
        -:10943:  }
        -:10944:};
        -:10945:
        -:10946:template<>
    #####:10947:const MetaStruct& getMetaStruct<DDS::SampleInfo>()
        -:10948:{
    #####:10949:  static MetaStructImpl<DDS::SampleInfo> msi;
    #####:10950:  return msi;
        -:10951:}
        -:10952:
    #####:10953:bool gen_skip_over(Serializer& ser, DDS::SampleInfo*)
        -:10954:{
        -:10955:  ACE_UNUSED_ARG(ser);
    #####:10956:  MetaStructImpl<DDS::SampleInfo>().getValue(ser, "");
    #####:10957:  return true;
        -:10958:}
        -:10959:
        -:10960:}  }
        -:10961:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:10962:
        -:10963:#endif
        -:10964:
        -:10965:/* End STRUCT: SampleInfo */
        -:10966:
        -:10967:
        -:10968:/* Begin TYPEDEF: SampleInfoSeq */
        -:10969:
        -:10970:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:10971:namespace OpenDDS { namespace DCPS {
        -:10972:
    #####:10973:void gen_find_size(const DDS::SampleInfoSeq& seq, size_t& size, size_t& padding)
        -:10974:{
        -:10975:  ACE_UNUSED_ARG(seq);
        -:10976:  ACE_UNUSED_ARG(size);
        -:10977:  ACE_UNUSED_ARG(padding);
    #####:10978:  find_size_ulong(size, padding);
    #####:10979:  if (seq.length() == 0) {
    #####:10980:    return;
        -:10981:  }
    #####:10982:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####:10983:    gen_find_size(seq[i], size, padding);
        -:10984:  }
        -:10985:}
        -:10986:
    #####:10987:bool operator<<(Serializer& strm, const DDS::SampleInfoSeq& seq)
        -:10988:{
        -:10989:  ACE_UNUSED_ARG(strm);
        -:10990:  ACE_UNUSED_ARG(seq);
    #####:10991:  const CORBA::ULong length = seq.length();
    #####:10992:  if (!(strm << length)) {
    #####:10993:    return false;
        -:10994:  }
    #####:10995:  if (length == 0) {
    #####:10996:    return true;
        -:10997:  }
    #####:10998:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:10999:    if (!(strm << seq[i])) {
    #####:11000:      return false;
        -:11001:    }
        -:11002:  }
    #####:11003:  return true;
        -:11004:}
        -:11005:
    #####:11006:bool operator>>(Serializer& strm, DDS::SampleInfoSeq& seq)
        -:11007:{
        -:11008:  ACE_UNUSED_ARG(strm);
        -:11009:  ACE_UNUSED_ARG(seq);
        -:11010:  CORBA::ULong length;
    #####:11011:  if (!(strm >> length)) {
    #####:11012:    return false;
        -:11013:  }
    #####:11014:  seq.length(length);
    #####:11015:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:11016:    if (!(strm >> seq[i])) {
    #####:11017:      return false;
        -:11018:    }
        -:11019:  }
    #####:11020:  return true;
        -:11021:}
        -:11022:
        -:11023:}  }
        -:11024:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:11025:
        -:11026:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:11027:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:11028:namespace OpenDDS { namespace DCPS {
        -:11029:
    #####:11030:bool gen_skip_over(Serializer& ser, DDS::SampleInfoSeq*)
        -:11031:{
        -:11032:  ACE_UNUSED_ARG(ser);
        -:11033:  ACE_CDR::ULong length;
    #####:11034:  if (!(ser >> length)) return false;
    #####:11035:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####:11036:    if (!gen_skip_over(ser, static_cast<DDS::SampleInfo*>(0))) return false;
        -:11037:  }
    #####:11038:  return true;
        -:11039:}
        -:11040:
      120:11041:}  }
        -:11042:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:11043:
        -:11044:#endif
        -:11045:
        -:11046:/* End TYPEDEF: SampleInfoSeq */
        -:11047:
        -:11048:/* End MODULE: DDS */
