        -:    0:Source:../dds/DCPS/Serializer.inl
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#include <ace/Message_Block.h>
        -:    9:#include <ace/CDR_Stream.h>
        -:   10:#include "Serializer.h"
        -:   11:
        -:   12:#ifndef OPENDDS_SAFETY_PROFILE
        -:   13:#include <string>
        -:   14:#endif
        -:   15:
        -:   16:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   17:
        -:   18:namespace OpenDDS {
        -:   19:namespace DCPS {
        -:   20:
        -:   21:// NOTE: I use the ternary operators in here for conditionals to help
        -:   22://       the compiler inline the code -- and it does end up fairly
        -:   23://       tight...
        -:   24:ACE_INLINE size_t
    #####:   25:Serializer::doread(char* dest, size_t size, bool swap, size_t offset)
        -:   26:{
        -:   27:  //
        -:   28:  // Ensure we work only with buffer data.
        -:   29:  //
    #####:   30:  if (this->current_ == 0) {
    #####:   31:    this->good_bit_ = false;
    #####:   32:    return size;
        -:   33:  }
        -:   34:
        -:   35:  //
        -:   36:  // Determine how much data will remain to be read after the current
        -:   37:  // buffer has been entirely read.
        -:   38:  //
    #####:   39:  const size_t len = this->current_->length();
    #####:   40:  const size_t remainder = (size - offset > len) ? size - offset - len : 0;
        -:   41:
        -:   42:  //
        -:   43:  // Derive how much data we need to read from the current buffer.
        -:   44:  //
    #####:   45:  const size_t initial = size - offset - remainder;
        -:   46:
        -:   47:  //
        -:   48:  // Copy or swap the source data from the current buffer into the
        -:   49:  // destination.
        -:   50:  //
        -:   51:  swap
    #####:   52:    ? this->swapcpy(dest + remainder, this->current_->rd_ptr(), initial)
    #####:   53:    : this->smemcpy(dest + offset, this->current_->rd_ptr(), initial);
    #####:   54:  this->current_->rd_ptr(initial);
        -:   55:
        -:   56:  //   smemcpy
        -:   57:  //
        -:   58:  //   dest            b1   b2   b3        offset   remainder   initial
        -:   59:  //   xxxxxxxx        01   23   4567xx
        -:   60:  //                   ^                   0        6           2
        -:   61:  //   01xxxxxx        01   23   4567xx
        -:   62:  //                        ^              2        4           2
        -:   63:  //   0123xxxx        01   23   4567xx
        -:   64:  //                             ^         4        0           4
        -:   65:  //   01234567        01   23   4567xx
        -:   66:  //                                 ^
        -:   67:
        -:   68:  //   swapcpy
        -:   69:  //
        -:   70:  //   dest            b1   b2   b3        offset   remainder   initial
        -:   71:  //   xxxxxxxx        01   23   4567xx
        -:   72:  //                   ^                   0        6           2
        -:   73:  //   xxxxxx10        01   23   4567xx
        -:   74:  //                        ^              2        4           2
        -:   75:  //   xxxx3210        01   23   4567xx
        -:   76:  //                             ^         4        0           4
        -:   77:  //   76543210        01   23   4567xx
        -:   78:  //                                 ^
        -:   79:
        -:   80:  //
        -:   81:  // Move to the next chained block if this one is spent.
        -:   82:  //
    #####:   83:  if (this->current_->length() == 0) {
        -:   84:
    #####:   85:    if (this->alignment_ == ALIGN_NONE) {
    #####:   86:      this->current_ = this->current_->cont();
        -:   87:    } else {
    #####:   88:      this->align_cont_r();
        -:   89:    }
        -:   90:  }
        -:   91:  //
        -:   92:  // Return the current location in the read.
        -:   93:  //
    #####:   94:  return offset + initial;
        -:   95:}
        -:   96:
        -:   97:ACE_INLINE void
    #####:   98:Serializer::buffer_read(char* dest, size_t size, bool swap)
        -:   99:{
    #####:  100:  size_t offset = 0;
        -:  101:
    #####:  102:  while (size > offset) {
    #####:  103:    offset = this->doread(dest, size, swap, offset);
        -:  104:  }
    #####:  105:}
        -:  106:
        -:  107:// NOTE: I use the ternary operators in here for conditionals to help
        -:  108://       the compiler inline the code -- and it does end up fairly
        -:  109://       tight...
        -:  110:ACE_INLINE size_t
     1182:  111:Serializer::dowrite(const char* src, size_t size, bool swap, size_t offset)
        -:  112:{
        -:  113:  //
        -:  114:  // Ensure we work only with buffer data.
        -:  115:  //
     1182:  116:  if (this->current_ == 0) {
    #####:  117:    this->good_bit_ = false;
    #####:  118:    return size;
        -:  119:  }
        -:  120:
        -:  121:  //
        -:  122:  // Determine how much data will remain to be written after the current
        -:  123:  // buffer has been entirely filled.
        -:  124:  //
     1182:  125:  const size_t spc = this->current_->space();
     1182:  126:  const size_t remainder = (size - offset > spc) ? size - offset - spc : 0;
        -:  127:
        -:  128:  //
        -:  129:  // Derive how much data we need to write to the current buffer.
        -:  130:  //
     1182:  131:  const size_t initial = size - offset - remainder;
        -:  132:
        -:  133:  //
        -:  134:  // Copy or swap the source data into the current buffer.
        -:  135:  //
        -:  136:  swap
     1182:  137:    ? this->swapcpy(this->current_->wr_ptr(), src + remainder, initial)
     1182:  138:    : this->smemcpy(this->current_->wr_ptr(), src + offset, initial);
     1182:  139:  this->current_->wr_ptr(initial);
        -:  140:
        -:  141:  //   smemcpy
        -:  142:  //
        -:  143:  //   src             b1   b2   b3        offset   remainder   initial
        -:  144:  //   01234567        xx   xx   xxxxxx
        -:  145:  //                   ^                   0        6           2
        -:  146:  //                   01   xx   xxxxxx
        -:  147:  //                        ^              2        4           2
        -:  148:  //                   01   23   xxxxxx
        -:  149:  //                             ^         4        0           4
        -:  150:  //                   01   23   4567xx
        -:  151:  //                                 ^
        -:  152:
        -:  153:  //   swapcpy
        -:  154:  //
        -:  155:  //   src             b1   b2   b3        offset   remainder   initial
        -:  156:  //   01234567        xx   xx   xxxxxx
        -:  157:  //                   ^                   0        6           2
        -:  158:  //                   76   xx   xxxxxx
        -:  159:  //                        ^              2        4           2
        -:  160:  //                   76   54   xxxxxx
        -:  161:  //                             ^         4        0           4
        -:  162:  //                   76   54   3210xx
        -:  163:  //                                 ^
        -:  164:
        -:  165:  //
        -:  166:  // Move to the next chained block if this one is spent.
        -:  167:  //
     1182:  168:  if (this->current_->space() == 0) {
        -:  169:
       18:  170:    if (this->alignment_ == ALIGN_NONE) {
       18:  171:      this->current_ = this->current_->cont();
        -:  172:    } else {
    #####:  173:      this->align_cont_w();
        -:  174:    }
        -:  175:  }
        -:  176:
        -:  177:  //
        -:  178:  // Return the current location in the write.
        -:  179:  //
     1182:  180:  return offset + initial;
        -:  181:}
        -:  182:
        -:  183:ACE_INLINE void
     1182:  184:Serializer::buffer_write(const char* src, size_t size, bool swap)
        -:  185:{
     1182:  186:  size_t offset = 0;
        -:  187:
     3546:  188:  while (size > offset) {
     1182:  189:    offset = this->dowrite(src, size, swap, offset);
        -:  190:  }
     1182:  191:}
        -:  192:
        -:  193:ACE_INLINE void
        -:  194:Serializer::swap_bytes(bool do_swap)
        -:  195:{
        -:  196:  this->swap_bytes_ = do_swap;
        -:  197:}
        -:  198:
        -:  199:ACE_INLINE bool
      834:  200:Serializer::swap_bytes() const
        -:  201:{
      834:  202:  return this->swap_bytes_;
        -:  203:}
        -:  204:
        -:  205:ACE_INLINE Serializer::Alignment
      726:  206:Serializer::alignment() const
        -:  207:{
      726:  208:  return this->alignment_;
        -:  209:}
        -:  210:
        -:  211:ACE_INLINE bool
     1302:  212:Serializer::good_bit() const
        -:  213:{
     1302:  214:  return this->good_bit_;
        -:  215:}
        -:  216:
        -:  217:ACE_INLINE size_t
    #####:  218:Serializer::length() const
        -:  219:{
    #####:  220:  return this->good_bit_ && this->current_ ? this->current_->total_length() : 0;
        -:  221:}
        -:  222:
        -:  223:ACE_INLINE bool
    #####:  224:Serializer::skip(ACE_CDR::UShort n, int size)
        -:  225:{
    #####:  226:  if (size > 1 && this->alignment_ != ALIGN_NONE) {
    #####:  227:    if (!this->current_) {
    #####:  228:      this->good_bit_ = false;
    #####:  229:      return false;
        -:  230:    }
    #####:  231:    this->align_r(size_t(size) > MAX_ALIGN ? MAX_ALIGN : size_t(size));
        -:  232:  }
    #####:  233:  for (size_t len = static_cast<size_t>(n * size); len;) {
    #####:  234:    if (!this->current_) {
    #####:  235:      this->good_bit_ = false;
    #####:  236:      return false;
        -:  237:    }
    #####:  238:    const size_t cur_len = this->current_->length();
    #####:  239:    if (cur_len <= len) {
    #####:  240:      len -= cur_len;
    #####:  241:      this->current_->rd_ptr(this->current_->wr_ptr());
    #####:  242:      this->align_cont_r();
        -:  243:    } else {
    #####:  244:      this->current_->rd_ptr(len);
    #####:  245:      break;
        -:  246:    }
        -:  247:  }
    #####:  248:  return this->good_bit();
        -:  249:}
        -:  250:
        -:  251:ACE_INLINE void
      180:  252:Serializer::read_array(char* x, size_t size, ACE_CDR::ULong length)
        -:  253:{
      180:  254:  this->read_array(x, size, length, this->swap_bytes_);
      180:  255:}
        -:  256:
        -:  257:ACE_INLINE void
      180:  258:Serializer::read_array(char* x, size_t size,
        -:  259:                       ACE_CDR::ULong length, bool swap)
        -:  260:{
      180:  261:  if (!swap || size == 1) {
        -:  262:    //
        -:  263:    // No swap, copy direct.  This silently corrupts the data if there is
        -:  264:    // padding in the buffer.
        -:  265:    //
      180:  266:    this->buffer_read(x, size * length, false);
        -:  267:
        -:  268:  } else {
        -:  269:    //
        -:  270:    // Swapping _must_ be done at 'size' boundaries, so we need to spin
        -:  271:    // through the array element by element.  This silently corrupts the
        -:  272:    // data if there is padding in the buffer.
        -:  273:    //
    #####:  274:    while (length-- > 0) {
    #####:  275:      this->buffer_read(x, size, true);
    #####:  276:      x += size;
        -:  277:    }
        -:  278:  }
      180:  279:}
        -:  280:
        -:  281:ACE_INLINE void
      246:  282:Serializer::write_array(const char* x, size_t size, ACE_CDR::ULong length)
        -:  283:{
      246:  284:  this->write_array(x, size, length, this->swap_bytes_);
      246:  285:}
        -:  286:
        -:  287:ACE_INLINE void
      246:  288:Serializer::write_array(const char* x, size_t size,
        -:  289:                        ACE_CDR::ULong length, bool swap)
        -:  290:{
      246:  291:  if (!swap || size == 1) {
        -:  292:    //
        -:  293:    // No swap, copy direct.
        -:  294:    //
      246:  295:    this->buffer_write(x, size * length, false);
        -:  296:
        -:  297:  } else {
        -:  298:    //
        -:  299:    // Swapping _must_ be done at 'size' boundaries, so we need to spin
        -:  300:    // through the array element by element.
        -:  301:    // NOTE: This assumes that there is _no_ padding between the array
        -:  302:    //       elements.  If this is not the case, do not use this
        -:  303:    //       method.
        -:  304:    //
    #####:  305:    while (length-- > 0) {
    #####:  306:      this->buffer_write(x, size, true);
    #####:  307:      x += size;
        -:  308:    }
        -:  309:  }
      246:  310:}
        -:  311:
        -:  312:ACE_INLINE bool
        -:  313:Serializer::read_boolean_array(ACE_CDR::Boolean* x, ACE_CDR::ULong length)
        -:  314:{
        -:  315:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Boolean), length);
        -:  316:  return this->good_bit();
        -:  317:}
        -:  318:
        -:  319:ACE_INLINE bool
        -:  320:Serializer::read_char_array(ACE_CDR::Char* x, ACE_CDR::ULong length)
        -:  321:{
        -:  322:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Char), length);
        -:  323:  return this->good_bit();
        -:  324:}
        -:  325:
        -:  326:ACE_INLINE bool
        -:  327:Serializer::read_wchar_array(ACE_CDR::WChar* x, ACE_CDR::ULong length)
        -:  328:{
        -:  329:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
        -:  330:    if (!((*this) >> ACE_InputCDR::to_wchar(x[i]))) {
        -:  331:      break;
        -:  332:    }
        -:  333:  }
        -:  334:  return this->good_bit();
        -:  335:}
        -:  336:
        -:  337:ACE_INLINE bool
       90:  338:Serializer::read_octet_array(ACE_CDR::Octet* x, ACE_CDR::ULong length)
        -:  339:{
       90:  340:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Octet), length);
       90:  341:  return this->good_bit();
        -:  342:}
        -:  343:
        -:  344:ACE_INLINE bool
        -:  345:Serializer::read_short_array(ACE_CDR::Short* x, ACE_CDR::ULong length)
        -:  346:{
        -:  347:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::Short));
        -:  348:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Short), length);
        -:  349:  return this->good_bit();
        -:  350:}
        -:  351:
        -:  352:ACE_INLINE bool
        -:  353:Serializer::read_ushort_array(ACE_CDR::UShort* x, ACE_CDR::ULong length)
        -:  354:{
        -:  355:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::UShort));
        -:  356:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::UShort), length);
        -:  357:  return this->good_bit();
        -:  358:}
        -:  359:
        -:  360:ACE_INLINE bool
    #####:  361:Serializer::read_long_array(ACE_CDR::Long* x, ACE_CDR::ULong length)
        -:  362:{
    #####:  363:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::Long));
    #####:  364:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Long), length);
    #####:  365:  return this->good_bit();
        -:  366:}
        -:  367:
        -:  368:ACE_INLINE bool
        -:  369:Serializer::read_ulong_array(ACE_CDR::ULong* x, ACE_CDR::ULong length)
        -:  370:{
        -:  371:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::ULong));
        -:  372:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::ULong), length);
        -:  373:  return this->good_bit();
        -:  374:}
        -:  375:
        -:  376:ACE_INLINE bool
        -:  377:Serializer::read_longlong_array(ACE_CDR::LongLong* x, ACE_CDR::ULong length)
        -:  378:{
        -:  379:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::LongLong));
        -:  380:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::LongLong), length);
        -:  381:  return this->good_bit();
        -:  382:}
        -:  383:
        -:  384:ACE_INLINE bool
        -:  385:Serializer::read_ulonglong_array(ACE_CDR::ULongLong* x, ACE_CDR::ULong length)
        -:  386:{
        -:  387:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::ULongLong));
        -:  388:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::ULongLong), length);
        -:  389:  return this->good_bit();
        -:  390:}
        -:  391:
        -:  392:ACE_INLINE bool
        -:  393:Serializer::read_float_array(ACE_CDR::Float* x, ACE_CDR::ULong length)
        -:  394:{
        -:  395:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::Float));
        -:  396:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Float), length);
        -:  397:  return this->good_bit();
        -:  398:}
        -:  399:
        -:  400:ACE_INLINE bool
        -:  401:Serializer::read_double_array(ACE_CDR::Double* x, ACE_CDR::ULong length)
        -:  402:{
        -:  403:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(sizeof(ACE_CDR::Double));
        -:  404:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::Double), length);
        -:  405:  return this->good_bit();
        -:  406:}
        -:  407:
        -:  408:ACE_INLINE bool
        -:  409:Serializer::read_longdouble_array(ACE_CDR::LongDouble* x, ACE_CDR::ULong length)
        -:  410:{
        -:  411:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_r(8);
        -:  412:  this->read_array(reinterpret_cast<char*>(x), sizeof(ACE_CDR::LongDouble), length);
        -:  413:  return this->good_bit();
        -:  414:}
        -:  415:
        -:  416:ACE_INLINE bool
        -:  417:Serializer::write_boolean_array(const ACE_CDR::Boolean* x,
        -:  418:                                ACE_CDR::ULong length)
        -:  419:{
        -:  420:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Boolean), length);
        -:  421:  return this->good_bit();
        -:  422:}
        -:  423:
        -:  424:ACE_INLINE bool
        -:  425:Serializer::write_char_array(const ACE_CDR::Char* x, ACE_CDR::ULong length)
        -:  426:{
        -:  427:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Char), length);
        -:  428:  return this->good_bit();
        -:  429:}
        -:  430:
        -:  431:ACE_INLINE bool
        -:  432:Serializer::write_wchar_array(const ACE_CDR::WChar* x, ACE_CDR::ULong length)
        -:  433:{
        -:  434:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
        -:  435:    if (!((*this) << ACE_OutputCDR::from_wchar(x[i]))) {
        -:  436:      break;
        -:  437:    }
        -:  438:  }
        -:  439:  return this->good_bit();
        -:  440:}
        -:  441:
        -:  442:ACE_INLINE bool
      222:  443:Serializer::write_octet_array(const ACE_CDR::Octet* x, ACE_CDR::ULong length)
        -:  444:{
      222:  445:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Octet), length);
      222:  446:  return this->good_bit();
        -:  447:}
        -:  448:
        -:  449:ACE_INLINE bool
        -:  450:Serializer::write_short_array(const ACE_CDR::Short* x, ACE_CDR::ULong length)
        -:  451:{
        -:  452:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::Short));
        -:  453:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Short), length);
        -:  454:  return this->good_bit();
        -:  455:}
        -:  456:
        -:  457:ACE_INLINE bool
        -:  458:Serializer::write_ushort_array(const ACE_CDR::UShort* x, ACE_CDR::ULong length)
        -:  459:{
        -:  460:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::UShort));
        -:  461:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::UShort), length);
        -:  462:  return this->good_bit();
        -:  463:}
        -:  464:
        -:  465:ACE_INLINE bool
       24:  466:Serializer::write_long_array(const ACE_CDR::Long* x, ACE_CDR::ULong length)
        -:  467:{
       24:  468:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::Long));
       24:  469:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Long), length);
       24:  470:  return this->good_bit();
        -:  471:}
        -:  472:
        -:  473:ACE_INLINE bool
        -:  474:Serializer::write_ulong_array(const ACE_CDR::ULong* x, ACE_CDR::ULong length)
        -:  475:{
        -:  476:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::ULong));
        -:  477:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::ULong), length);
        -:  478:  return this->good_bit();
        -:  479:}
        -:  480:
        -:  481:ACE_INLINE bool
        -:  482:Serializer::write_longlong_array(const ACE_CDR::LongLong* x,
        -:  483:                                 ACE_CDR::ULong length)
        -:  484:{
        -:  485:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::LongLong));
        -:  486:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::LongLong), length);
        -:  487:  return this->good_bit();
        -:  488:}
        -:  489:
        -:  490:ACE_INLINE bool
        -:  491:Serializer::write_ulonglong_array(const ACE_CDR::ULongLong* x,
        -:  492:                                  ACE_CDR::ULong length)
        -:  493:{
        -:  494:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::ULongLong));
        -:  495:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::ULongLong), length);
        -:  496:  return this->good_bit();
        -:  497:}
        -:  498:
        -:  499:ACE_INLINE bool
        -:  500:Serializer::write_float_array(const ACE_CDR::Float* x, ACE_CDR::ULong length)
        -:  501:{
        -:  502:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::Float));
        -:  503:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Float), length);
        -:  504:  return this->good_bit();
        -:  505:}
        -:  506:
        -:  507:ACE_INLINE bool
        -:  508:Serializer::write_double_array(const ACE_CDR::Double* x, ACE_CDR::ULong length)
        -:  509:{
        -:  510:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(sizeof(ACE_CDR::Double));
        -:  511:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::Double), length);
        -:  512:  return this->good_bit();
        -:  513:}
        -:  514:
        -:  515:ACE_INLINE bool
        -:  516:Serializer::write_longdouble_array(const ACE_CDR::LongDouble* x,
        -:  517:                                   ACE_CDR::ULong length)
        -:  518:{
        -:  519:  this->alignment() == Serializer::ALIGN_NONE ? 0 : this->align_w(8);
        -:  520:  this->write_array(reinterpret_cast<const char*>(x), sizeof(ACE_CDR::LongDouble), length);
        -:  521:  return this->good_bit();
        -:  522:}
        -:  523:
        -:  524:ACE_INLINE int
    #####:  525:Serializer::align_r(size_t al)
        -:  526:{
        -:  527:  const size_t len =
    #####:  528:    (al - ptrdiff_t(this->current_->rd_ptr()) + this->align_rshift_) % al;
    #####:  529:  this->skip(static_cast<ACE_CDR::UShort>(len));
    #####:  530:  return 0;
        -:  531:}
        -:  532:
        -:  533:ACE_INLINE int
    #####:  534:Serializer::align_w(size_t al)
        -:  535:{
        -:  536:  size_t len =
    #####:  537:    (al - ptrdiff_t(this->current_->wr_ptr()) + this->align_wshift_) % al;
    #####:  538:  while (len) {
    #####:  539:    if (!this->current_) {
    #####:  540:      this->good_bit_ = false;
    #####:  541:      break;
        -:  542:    }
    #####:  543:    const size_t cur_spc = this->current_->space();
    #####:  544:    if (cur_spc <= len) {
    #####:  545:      len -= cur_spc;
    #####:  546:      if (this->alignment_ == ALIGN_INITIALIZE) {
    #####:  547:        this->smemcpy(this->current_->wr_ptr(), ALIGN_PAD, cur_spc);
        -:  548:      }
    #####:  549:      this->current_->wr_ptr(cur_spc);
    #####:  550:      this->align_cont_w();
        -:  551:    } else {
    #####:  552:      if (this->alignment_ == ALIGN_INITIALIZE) {
    #####:  553:        this->smemcpy(this->current_->wr_ptr(), ALIGN_PAD, len);
        -:  554:      }
    #####:  555:      this->current_->wr_ptr(len);
    #####:  556:      break;
        -:  557:    }
        -:  558:  }
    #####:  559:  return 0;
        -:  560:}
        -:  561:
        -:  562:
        -:  563:ACE_INLINE void
    #####:  564:Serializer::align_cont_r()
        -:  565:{
        -:  566:  const size_t thisblock =
    #####:  567:    (ptrdiff_t(this->current_->rd_ptr()) - this->align_rshift_) % MAX_ALIGN;
        -:  568:
    #####:  569:  this->current_ = this->current_->cont();
        -:  570:
    #####:  571:  if (this->current_) {
    #####:  572:    this->align_rshift_ =
    #####:  573:      (ptrdiff_t(this->current_->rd_ptr()) - thisblock) % MAX_ALIGN;
        -:  574:  }
    #####:  575:}
        -:  576:
        -:  577:ACE_INLINE void
    #####:  578:Serializer::align_cont_w()
        -:  579:{
        -:  580:  const size_t thisblock =
    #####:  581:    (ptrdiff_t(this->current_->wr_ptr()) - this->align_wshift_) % MAX_ALIGN;
        -:  582:
    #####:  583:  this->current_ = this->current_->cont();
        -:  584:
    #####:  585:  if (this->current_) {
    #####:  586:    this->align_wshift_ =
    #####:  587:      (ptrdiff_t(this->current_->wr_ptr()) - thisblock) % MAX_ALIGN;
        -:  588:  }
    #####:  589:}
        -:  590:
        -:  591://
        -:  592:// The following insertion operators are done in the style of the
        -:  593:// ACE_CDR insertion operators instead of a stream abstraction.  This
        -:  594:// is done to allow their use in the same way as existing ACE_CDR
        -:  595:// inserters, rather than as a true stream abstraction (which would
        -:  596:// return the argument stream).
        -:  597://
        -:  598:
        -:  599:ACE_INLINE bool
        -:  600:operator<<(Serializer& s, ACE_CDR::Char x)
        -:  601:{
        -:  602:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Char), s.swap_bytes());
        -:  603:  return s.good_bit();
        -:  604:}
        -:  605:
        -:  606:ACE_INLINE bool
        -:  607:operator<<(Serializer& s, ACE_CDR::Short x)
        -:  608:{
        -:  609:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::Short));
        -:  610:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Short), s.swap_bytes());
        -:  611:  return s.good_bit();
        -:  612:}
        -:  613:
        -:  614:ACE_INLINE bool
    #####:  615:operator<<(Serializer& s, ACE_CDR::UShort x)
        -:  616:{
    #####:  617:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::UShort));
    #####:  618:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::UShort), s.swap_bytes());
    #####:  619:  return s.good_bit();
        -:  620:}
        -:  621:
        -:  622:ACE_INLINE bool
      312:  623:operator<<(Serializer& s, ACE_CDR::Long x)
        -:  624:{
      312:  625:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::Long));
      312:  626:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Long), s.swap_bytes());
      312:  627:  return s.good_bit();
        -:  628:}
        -:  629:
        -:  630:ACE_INLINE bool
      390:  631:operator<<(Serializer& s, ACE_CDR::ULong x)
        -:  632:{
      390:  633:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::ULong));
      390:  634:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::ULong), s.swap_bytes());
      390:  635:  return s.good_bit();
        -:  636:}
        -:  637:
        -:  638:ACE_INLINE bool
       30:  639:operator<<(Serializer& s, ACE_CDR::LongLong x)
        -:  640:{
       30:  641:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::LongLong));
       30:  642:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::LongLong), s.swap_bytes());
       30:  643:  return s.good_bit();
        -:  644:}
        -:  645:
        -:  646:ACE_INLINE bool
        -:  647:operator<<(Serializer& s, ACE_CDR::ULongLong x)
        -:  648:{
        -:  649:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::ULongLong));
        -:  650:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::ULongLong), s.swap_bytes());
        -:  651:  return s.good_bit();
        -:  652:}
        -:  653:
        -:  654:ACE_INLINE bool
        -:  655:operator<<(Serializer& s, ACE_CDR::LongDouble x)
        -:  656:{
        -:  657:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(8);
        -:  658:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::LongDouble), s.swap_bytes());
        -:  659:  return s.good_bit();
        -:  660:}
        -:  661:
        -:  662:ACE_INLINE bool
        -:  663:operator<<(Serializer& s, ACE_CDR::Float x)
        -:  664:{
        -:  665:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::Float));
        -:  666:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Float), s.swap_bytes());
        -:  667:  return s.good_bit();
        -:  668:}
        -:  669:
        -:  670:ACE_INLINE bool
        -:  671:operator<<(Serializer& s, ACE_CDR::Double x)
        -:  672:{
        -:  673:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_w(sizeof(ACE_CDR::Double));
        -:  674:  s.buffer_write(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Double), s.swap_bytes());
        -:  675:  return s.good_bit();
        -:  676:}
        -:  677:
        -:  678:ACE_INLINE bool
       24:  679:operator<<(Serializer& s, const ACE_CDR::Char* x)
        -:  680:{
       24:  681:  if (x != 0) {
        -:  682:    // Include the null termination in the serialized data.
        -:  683:    const ACE_CDR::ULong stringlen =
       24:  684:      1 + static_cast<ACE_CDR::ULong>(ACE_OS::strlen(x));
       24:  685:    s << stringlen;
       24:  686:    s.buffer_write(reinterpret_cast<const char*>(x), stringlen, false);
        -:  687:
        -:  688:  } else {
    #####:  689:    s << ACE_CDR::ULong(0);
        -:  690:  }
        -:  691:
       24:  692:  return s.good_bit();
        -:  693:}
        -:  694:
        -:  695:ACE_INLINE bool
        -:  696:operator<<(Serializer& s, const ACE_CDR::WChar* x)
        -:  697:{
        -:  698:  //NOTE: Serializing wchar/wstring uses UTF-16BE
        -:  699:  if (x != 0) {
        -:  700:    // Do not include the null terminatator in the serialized data.
        -:  701:    const ACE_CDR::ULong length = static_cast<ACE_CDR::ULong>(ACE_OS::strlen(x));
        -:  702:    s << ACE_CDR::ULong(length * Serializer::WCHAR_SIZE);
        -:  703:
        -:  704:#if ACE_SIZEOF_WCHAR == 2
        -:  705:    s.write_array(reinterpret_cast<const char*>(x), Serializer::WCHAR_SIZE,
        -:  706:                  length, Serializer::SWAP_BE);
        -:  707:#else
        -:  708:    for (size_t i = 0; i < length && s.good_bit(); ++i) {
        -:  709:      const ACE_UINT16 as_utf16 = static_cast<ACE_UINT16>(x[i]);
        -:  710:      if (as_utf16 != x[i]) { // not currently handling surrogates
        -:  711:        s.good_bit_ = false;
        -:  712:        break;
        -:  713:      }
        -:  714:      s.buffer_write(reinterpret_cast<const char*>(&as_utf16), Serializer::WCHAR_SIZE, Serializer::SWAP_BE);
        -:  715:    }
        -:  716:#endif
        -:  717:  } else {
        -:  718:    s << ACE_CDR::ULong(0);
        -:  719:  }
        -:  720:
        -:  721:  return s.good_bit();
        -:  722:}
        -:  723:
        -:  724:#ifdef NONNATIVE_LONGDOUBLE
        -:  725:ACE_INLINE bool
        -:  726:operator<<(Serializer& s, long double x)
        -:  727:{
        -:  728:  ACE_CDR::LongDouble ld;
        -:  729:  ACE_CDR_LONG_DOUBLE_ASSIGNMENT(ld, x);
        -:  730:  return s << ld;
        -:  731:}
        -:  732:#endif
        -:  733:
        -:  734:ACE_INLINE bool
       12:  735:operator<<(Serializer& s, ACE_OutputCDR::from_boolean x)
        -:  736:{
       12:  737:  s.buffer_write(reinterpret_cast<char*>(&x.val_), sizeof(ACE_CDR::Boolean), s.swap_bytes());
       12:  738:  return s.good_bit();
        -:  739:}
        -:  740:
        -:  741:ACE_INLINE bool
        -:  742:operator<<(Serializer& s, ACE_OutputCDR::from_char x)
        -:  743:{
        -:  744:  s.buffer_write(reinterpret_cast<char*>(&x.val_), sizeof(ACE_CDR::Char), false);
        -:  745:  return s.good_bit();
        -:  746:}
        -:  747:
        -:  748:ACE_INLINE bool
        -:  749:operator<<(Serializer& s, ACE_OutputCDR::from_wchar x)
        -:  750:{
        -:  751:  // CDR wchar format: 1 octet for # of bytes in wchar, followed by those bytes
        -:  752:  static const ACE_CDR::Octet wchar_bytes = Serializer::WCHAR_SIZE;
        -:  753:  s.buffer_write(reinterpret_cast<const char*>(&wchar_bytes), 1, false);
        -:  754:#if ACE_SIZEOF_WCHAR == 2
        -:  755:  s.buffer_write(reinterpret_cast<char*>(&x.val_), Serializer::WCHAR_SIZE, Serializer::SWAP_BE);
        -:  756:#else
        -:  757:  const ACE_UINT16 as_utf16 = static_cast<ACE_UINT16>(x.val_);
        -:  758:  if (as_utf16 != x.val_) { // not currently handling surrogates
        -:  759:    ACE_DEBUG((LM_DEBUG, ACE_TEXT("(%P|%t) operator<<(Serializer&, ACE_OutputCDR::from_wchar): failure to convert UTF-32 to UTF-16.\n")));
        -:  760:    s.good_bit_ = false;
        -:  761:  } else {
        -:  762:    s.buffer_write(reinterpret_cast<const char*>(&as_utf16), Serializer::WCHAR_SIZE, Serializer::SWAP_BE);
        -:  763:  }
        -:  764:#endif
        -:  765:  return s.good_bit();
        -:  766:}
        -:  767:
        -:  768:#ifndef OPENDDS_SAFETY_PROFILE
        -:  769:ACE_INLINE bool
        -:  770:operator<<(Serializer& s, const std::string& x)
        -:  771:{
        -:  772:  return s << x.c_str();
        -:  773:}
        -:  774:
        -:  775:ACE_INLINE bool
        -:  776:operator<<(Serializer& s, Serializer::FromBoundedString<char> x)
        -:  777:{
        -:  778:  return (x.bound_ == 0 || x.str_.size() <= x.bound_) && s << x.str_;
        -:  779:}
        -:  780:
        -:  781:#ifdef DDS_HAS_WCHAR
        -:  782:ACE_INLINE bool
        -:  783:operator<<(Serializer& s, const std::wstring& x)
        -:  784:{
        -:  785:  return s << x.c_str();
        -:  786:}
        -:  787:
        -:  788:ACE_INLINE bool
        -:  789:operator<<(Serializer& s, Serializer::FromBoundedString<wchar_t> x)
        -:  790:{
        -:  791:  return (x.bound_ == 0 || x.str_.size() <= x.bound_) && s << x.str_;
        -:  792:}
        -:  793:#endif /* DDS_HAS_WCHAR */
        -:  794:#endif /* !OPENDDS_SAFETY_PROFILE */
        -:  795:
        -:  796:ACE_INLINE bool
      180:  797:operator<<(Serializer& s, ACE_OutputCDR::from_octet x)
        -:  798:{
      180:  799:  s.buffer_write(reinterpret_cast<char*>(&x.val_), sizeof(ACE_CDR::Octet), false);
      180:  800:  return s.good_bit();
        -:  801:}
        -:  802:
        -:  803:ACE_INLINE bool
    #####:  804:operator<<(Serializer& s, ACE_OutputCDR::from_string x)
        -:  805:{
        -:  806:  // Include the null termination in the serialized data.
    #####:  807:  ACE_CDR::ULong stringlen = 0;
        -:  808:
    #####:  809:  if (x.val_ != 0) {
    #####:  810:    stringlen = 1 + static_cast<ACE_CDR::ULong>(ACE_OS::strlen(x.val_));
    #####:  811:    s << stringlen;
    #####:  812:    s.buffer_write(reinterpret_cast<char*>(x.val_), stringlen, false);
        -:  813:
        -:  814:  } else {
    #####:  815:    s << ACE_CDR::ULong(0);
        -:  816:  }
        -:  817:
    #####:  818:  return s.good_bit() && ((x.bound_ == 0) || (stringlen - 1 <= x.bound_));
        -:  819:}
        -:  820:
        -:  821:ACE_INLINE bool
        -:  822:operator<<(Serializer& s, ACE_OutputCDR::from_wstring x)
        -:  823:{
        -:  824:  s << x.val_;
        -:  825:  const ACE_CDR::ULong stringlen =
        -:  826:    x.bound_ ? static_cast<ACE_CDR::ULong>(ACE_OS::strlen(x.val_)) : 0;
        -:  827:  return s.good_bit() && ((x.bound_ == 0) || (stringlen <= x.bound_));
        -:  828:}
        -:  829:
        -:  830://
        -:  831:// The following extraction operators are done in the style of the
        -:  832:// ACE_CDR extraction operators instead of a stream abstraction.  This
        -:  833:// is done to allow their use in the same way as existing ACE_CDR
        -:  834:// extractors, rather than as a true stream abstraction (which would
        -:  835:// return the argument stream).
        -:  836://
        -:  837:
        -:  838:ACE_INLINE bool
        -:  839:operator>>(Serializer& s, ACE_CDR::Char& x)
        -:  840:{
        -:  841:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Char), s.swap_bytes());
        -:  842:  return s.good_bit();
        -:  843:}
        -:  844:
        -:  845:ACE_INLINE bool
        -:  846:operator>>(Serializer& s, ACE_CDR::Short& x)
        -:  847:{
        -:  848:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::Short));
        -:  849:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Short), s.swap_bytes());
        -:  850:  return s.good_bit();
        -:  851:}
        -:  852:
        -:  853:ACE_INLINE bool
        -:  854:operator>>(Serializer& s, ACE_CDR::UShort& x)
        -:  855:{
        -:  856:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::UShort));
        -:  857:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::UShort), s.swap_bytes());
        -:  858:  return s.good_bit();
        -:  859:}
        -:  860:
        -:  861:ACE_INLINE bool
    #####:  862:operator>>(Serializer& s, ACE_CDR::Long& x)
        -:  863:{
    #####:  864:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::Long));
    #####:  865:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Long), s.swap_bytes());
    #####:  866:  return s.good_bit();
        -:  867:}
        -:  868:
        -:  869:ACE_INLINE bool
    #####:  870:operator>>(Serializer& s, ACE_CDR::ULong& x)
        -:  871:{
    #####:  872:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::ULong));
    #####:  873:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::ULong), s.swap_bytes());
    #####:  874:  return s.good_bit();
        -:  875:}
        -:  876:
        -:  877:ACE_INLINE bool
       30:  878:operator>>(Serializer& s, ACE_CDR::LongLong& x)
        -:  879:{
       30:  880:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::LongLong));
       30:  881:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::LongLong), s.swap_bytes());
       30:  882:  return s.good_bit();
        -:  883:}
        -:  884:
        -:  885:ACE_INLINE bool
        -:  886:operator>>(Serializer& s, ACE_CDR::ULongLong& x)
        -:  887:{
        -:  888:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::ULongLong));
        -:  889:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::ULongLong), s.swap_bytes());
        -:  890:  return s.good_bit();
        -:  891:}
        -:  892:
        -:  893:ACE_INLINE bool
        -:  894:operator>>(Serializer& s, ACE_CDR::LongDouble& x)
        -:  895:{
        -:  896:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(8);
        -:  897:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::LongDouble), s.swap_bytes());
        -:  898:  return s.good_bit();
        -:  899:}
        -:  900:
        -:  901:ACE_INLINE bool
        -:  902:operator>>(Serializer& s, ACE_CDR::Float& x)
        -:  903:{
        -:  904:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::Float));
        -:  905:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Float), s.swap_bytes());
        -:  906:  return s.good_bit();
        -:  907:}
        -:  908:
        -:  909:ACE_INLINE bool
        -:  910:operator>>(Serializer& s, ACE_CDR::Double& x)
        -:  911:{
        -:  912:  s.alignment() == Serializer::ALIGN_NONE ? 0 : s.align_r(sizeof(ACE_CDR::Double));
        -:  913:  s.buffer_read(reinterpret_cast<char*>(&x), sizeof(ACE_CDR::Double), s.swap_bytes());
        -:  914:  return s.good_bit();
        -:  915:}
        -:  916:
        -:  917:ACE_INLINE bool
    #####:  918:operator>>(Serializer& s, ACE_CDR::Char*& x)
        -:  919:{
    #####:  920:  s.read_string(x);
    #####:  921:  return s.good_bit();
        -:  922:}
        -:  923:
        -:  924:ACE_INLINE bool
        -:  925:operator>>(Serializer& s, ACE_CDR::WChar*& x)
        -:  926:{
        -:  927:  s.read_string(x);
        -:  928:  return s.good_bit();
        -:  929:}
        -:  930:
        -:  931:#ifdef NONNATIVE_LONGDOUBLE
        -:  932:ACE_INLINE bool
        -:  933:operator>>(Serializer& s, long double& x)
        -:  934:{
        -:  935:  ACE_CDR::LongDouble ld;
        -:  936:  if (s >> ld) {
        -:  937:    x = ld;
        -:  938:    return true;
        -:  939:  }
        -:  940:  return false;
        -:  941:}
        -:  942:#endif
        -:  943:
        -:  944:ACE_INLINE bool
    #####:  945:operator>>(Serializer& s, ACE_InputCDR::to_boolean x)
        -:  946:{
    #####:  947:  s.buffer_read(reinterpret_cast<char*>(&x.ref_), sizeof(ACE_CDR::Boolean), s.swap_bytes());
    #####:  948:  return s.good_bit();
        -:  949:}
        -:  950:
        -:  951:ACE_INLINE bool
        -:  952:operator>>(Serializer& s, ACE_InputCDR::to_char x)
        -:  953:{
        -:  954:  s.buffer_read(reinterpret_cast<char*>(&x.ref_), sizeof(ACE_CDR::Char), s.swap_bytes());
        -:  955:  return s.good_bit();
        -:  956:}
        -:  957:
        -:  958:ACE_INLINE bool
        -:  959:operator>>(Serializer& s, ACE_InputCDR::to_wchar x)
        -:  960:{
        -:  961:  ACE_CDR::Octet len;
        -:  962:  s.buffer_read(reinterpret_cast<char*>(&len), 1, false);
        -:  963:  if (len != Serializer::WCHAR_SIZE) {
        -:  964:    s.good_bit_ = false;
        -:  965:  } else {
        -:  966:#if ACE_SIZEOF_WCHAR == 2
        -:  967:    s.buffer_read(reinterpret_cast<char*>(&x.ref_), Serializer::WCHAR_SIZE, Serializer::SWAP_BE);
        -:  968:#else
        -:  969:    ACE_UINT16 as_utf16;
        -:  970:    s.buffer_read(reinterpret_cast<char*>(&as_utf16), Serializer::WCHAR_SIZE, Serializer::SWAP_BE);
        -:  971:    x.ref_ = as_utf16;
        -:  972:#endif
        -:  973:  }
        -:  974:  return s.good_bit();
        -:  975:}
        -:  976:
        -:  977:ACE_INLINE bool
      150:  978:operator>>(Serializer& s, ACE_InputCDR::to_octet x)
        -:  979:{
      150:  980:  s.buffer_read(reinterpret_cast<char*>(&x.ref_), sizeof(ACE_CDR::Octet), false);
      150:  981:  return s.good_bit();
        -:  982:}
        -:  983:
        -:  984:ACE_INLINE bool
    #####:  985:operator>>(Serializer& s, ACE_InputCDR::to_string x)
        -:  986:{
    #####:  987:  const size_t length = s.read_string(const_cast<char*&>(x.val_));
    #####:  988:  return s.good_bit()
    #####:  989:         && ((x.bound_ == 0) || (length <= x.bound_));
        -:  990:}
        -:  991:
        -:  992:ACE_INLINE bool
        -:  993:operator>>(Serializer& s, ACE_InputCDR::to_wstring x)
        -:  994:{
        -:  995:  const size_t length = s.read_string(const_cast<ACE_CDR::WChar*&>(x.val_));
        -:  996:  return s.good_bit()
        -:  997:         && ((x.bound_ == 0) || (length <= x.bound_));
        -:  998:}
        -:  999:
        -: 1000:#ifndef OPENDDS_SAFETY_PROFILE
        -: 1001:ACE_INLINE bool
        -: 1002:operator>>(Serializer& s, std::string& x)
        -: 1003:{
        -: 1004:  char* buf = 0;
        -: 1005:  const size_t length = s.read_string(buf);
        -: 1006:  x.assign(buf, length);
        -: 1007:  CORBA::string_free(buf);
        -: 1008:  return s.good_bit();
        -: 1009:}
        -: 1010:
        -: 1011:ACE_INLINE bool
        -: 1012:operator>>(Serializer& s, Serializer::ToBoundedString<char> x)
        -: 1013:{
        -: 1014:  return (s >> x.str_) && (x.bound_ == 0 || x.str_.size() <= x.bound_);
        -: 1015:}
        -: 1016:
        -: 1017:#ifdef DDS_HAS_WCHAR
        -: 1018:ACE_INLINE bool
        -: 1019:operator>>(Serializer& s, std::wstring& x)
        -: 1020:{
        -: 1021:  ACE_CDR::WChar* buf = 0;
        -: 1022:  const size_t length = s.read_string(buf);
        -: 1023:  x.assign(buf, length);
        -: 1024:  CORBA::wstring_free(buf);
        -: 1025:  return s.good_bit();
        -: 1026:}
        -: 1027:
        -: 1028:ACE_INLINE bool
        -: 1029:operator>>(Serializer& s, Serializer::ToBoundedString<wchar_t> x)
        -: 1030:{
        -: 1031:  return (s >> x.str_) && (x.bound_ == 0 || x.str_.size() <= x.bound_);
        -: 1032:}
        -: 1033:#endif /* DDS_HAS_WCHAR */
        -: 1034:#endif /* !OPENDDS_SAFETY_PROFILE */
        -: 1035:
        -: 1036://----------------------------------------------------------------------------
        -: 1037:// predefined type gen_max_marshaled_size methods
        -: 1038:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::Short& /* x */)
        -: 1039:{
        -: 1040:  return sizeof(ACE_CDR::Short);
        -: 1041:}
        -: 1042:
        -: 1043:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::UShort& /* x */)
        -: 1044:{
        -: 1045:  return sizeof(ACE_CDR::UShort);
        -: 1046:}
        -: 1047:
      192: 1048:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::Long& /* x */)
        -: 1049:{
      192: 1050:  return sizeof(ACE_CDR::Long);
        -: 1051:}
        -: 1052:
       69: 1053:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::ULong& /* x */)
        -: 1054:{
       69: 1055:  return sizeof(ACE_CDR::ULong);
        -: 1056:}
        -: 1057:
    #####: 1058:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::LongLong& /* x */)
        -: 1059:{
    #####: 1060:  return sizeof(ACE_CDR::LongLong);
        -: 1061:}
        -: 1062:
        -: 1063:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::ULongLong& /* x */)
        -: 1064:{
        -: 1065:  return sizeof(ACE_CDR::ULongLong);
        -: 1066:}
        -: 1067:
        -: 1068:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::LongDouble& /* x */)
        -: 1069:{
        -: 1070:  return sizeof(ACE_CDR::LongDouble);
        -: 1071:}
        -: 1072:
        -: 1073:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::Float& /* x */)
        -: 1074:{
        -: 1075:  return sizeof(ACE_CDR::Float);
        -: 1076:}
        -: 1077:
        -: 1078:ACE_INLINE size_t gen_max_marshaled_size(const ACE_CDR::Double& /* x */)
        -: 1079:{
        -: 1080:  return sizeof(ACE_CDR::Double);
        -: 1081:}
        -: 1082:
        -: 1083:// predefined type gen_max_marshaled_size method disambiguators.
       12: 1084:ACE_INLINE size_t gen_max_marshaled_size(const ACE_OutputCDR::from_boolean /* x */)
        -: 1085:{
       12: 1086:  return sizeof(ACE_CDR::Char);
        -: 1087:}
        -: 1088:
        -: 1089:ACE_INLINE size_t gen_max_marshaled_size(const ACE_OutputCDR::from_char /* x */)
        -: 1090:{
        -: 1091:  return sizeof(ACE_CDR::Char);
        -: 1092:}
        -: 1093:
        -: 1094:ACE_INLINE size_t gen_max_marshaled_size(const ACE_OutputCDR::from_wchar /* x */)
        -: 1095:{
        -: 1096:  return Serializer::WCHAR_SIZE + 1; //CDR encoding adds 1 octet for length
        -: 1097:}
        -: 1098:
       30: 1099:ACE_INLINE size_t gen_max_marshaled_size(const ACE_OutputCDR::from_octet /* x */)
        -: 1100:{
       30: 1101:  return sizeof(ACE_CDR::Char);
        -: 1102:}
        -: 1103:
        -: 1104:// predefined type gen_max_marshaled_size method explicit disambiguators.
        -: 1105:ACE_INLINE size_t max_marshaled_size_boolean()
        -: 1106:{
        -: 1107:  return sizeof(ACE_CDR::Char);
        -: 1108:}
        -: 1109:
        -: 1110:ACE_INLINE size_t max_marshaled_size_char()
        -: 1111:{
        -: 1112:  return sizeof(ACE_CDR::Char);
        -: 1113:}
        -: 1114:
        -: 1115:ACE_INLINE size_t max_marshaled_size_wchar()
        -: 1116:{
        -: 1117:  return Serializer::WCHAR_SIZE + 1; //CDR encoding adds 1 octet for length
        -: 1118:}
        -: 1119:
       60: 1120:ACE_INLINE size_t max_marshaled_size_octet()
        -: 1121:{
       60: 1122:  return sizeof(ACE_CDR::Char);
        -: 1123:}
        -: 1124:
        -: 1125:ACE_INLINE size_t max_marshaled_size_ulong()
        -: 1126:{
        -: 1127:  return sizeof(ACE_CDR::ULong);
        -: 1128:}
        -: 1129:
      171: 1130:ACE_INLINE void find_size_ulong(size_t& size, size_t& padding)
        -: 1131:{
      171: 1132:  const size_t sz = sizeof(ACE_CDR::ULong);
      171: 1133:  if ((size + padding) % sz) {
       30: 1134:    padding += sz - ((size + padding) % sz);
        -: 1135:  }
      171: 1136:  size += sz;
      171: 1137:}
        -: 1138:
        -: 1139:} // namespace DCPS
        -: 1140:} // namespace OpenDDS
        -: 1141:
        -: 1142:OPENDDS_END_VERSIONED_NAMESPACE_DECL
