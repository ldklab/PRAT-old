        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/TAO/tao/Range_Checking_T.h
        -:    0:Programs:51
        -:    1:#ifndef guard_range_checking_hpp
        -:    2:#define guard_range_checking_hpp
        -:    3:/**
        -:    4: * @file
        -:    5: *
        -:    6: * @brief Details can be found in the documentation for
        -:    7: * TAO::details::generic_sequence
        -:    8: *
        -:    9: * $Id: Range_Checking_T.h 1861 2011-08-31 16:18:08Z mesnierp $
        -:   10: *
        -:   11: * @author Carlos O'Ryan
        -:   12: */
        -:   13:
        -:   14:#include "tao/Basic_Types.h"
        -:   15:#include "tao/SystemException.h"
        -:   16:
        -:   17:#if !defined (TAO_CHECKED_SEQUENCE_INDEXING) && !defined (ACE_NDEBUG)
        -:   18:# define TAO_CHECKED_SEQUENCE_INDEXING 1
        -:   19:#endif
        -:   20:
        -:   21:TAO_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   22:
        -:   23:namespace TAO
        -:   24:{
        -:   25:namespace details
        -:   26:{
        -:   27:
        -:   28:/**
        -:   29: * @struct range_checking
        -:   30: *
        -:   31: * @brief Configurable traits to tradeoff safety vs. performance in
        -:   32: *        the implementation of TAO sequences.
        -:   33: *
        -:   34: * The CORBA specification grants certain latitude to implementors by
        -:   35: * not defining the behavior of sequences under certain conditions.
        -:   36: * Probably the most clear example is the operator[] access, where the
        -:   37: * application <b>must</b> set the length to a high enough value
        -:   38: * before using the operator[].
        -:   39: *
        -:   40: * Implementors that cater to high-performance applications tend to
        -:   41: * exploit this latitude to the extreme, basically reasoning that
        -:   42: * correct applications will behave normally, while incorrect
        -:   43: * applications will crash, but those crashes will be detected during
        -:   44: * development/testing.
        -:   45: *
        -:   46: * Realizing that this may be a bad tradeoff some implementors offer
        -:   47: * compile-time hooks to control the behavior of sequences when used
        -:   48: * improperly, some implementors may go as far as using run-time
        -:   49: * hooks.
        -:   50: *
        -:   51: * The implementation of sequences calls the following template class
        -:   52: * in points where the application may trigger undefined behavior.
        -:   53: * The application developer can use partial (or full) template
        -:   54: * specialization to introduce her own code at these critical points.
        -:   55: *
        -:   56: * Some examples may help, suppose you want to change your application
        -:   57: * so for all sequence types the operator[] raises an exception if the
        -:   58: * index is out of range.  Then you would provide the following
        -:   59: * (partial) template specialization:
        -:   60: *
        -:   61: * <PRE>
        -:   62: * template<typename T>
        -:   63: * struct range_checking<T,true> {
        -:   64: *   void check(CORBA::ULong index, CORBA::ULong length) {
        -:   65: *     if (index < length)
        -:   66: *       return;
        -:   67: *     throw std::range_error("CORBA sequence range error");
        -:   68: *   };
        -:   69: * ...
        -:   70: * ..
        -:   71: * };
        -:   72: * </PRE>
        -:   73: *
        -:   74: * This specialization must be introduced before any sequence code is
        -:   75: * seen, therefore, the application would also need to define the
        -:   76: * following macro in their $ACE_ROOT/ace/config.h file:
        -:   77: *
        -:   78: * - #define TAO_USER_DEFINED_SEQUENCE_SAFETY_TRAITS_INCLUDE "<filename here>"
        -:   79: *
        -:   80: * Likewise, if the application only wanted to check the range for a
        -:   81: * special type, say some structure MyStruct, then they would provide
        -:   82: * a full specialization.  Just for giggles, we will also introduce
        -:   83: * run-time controls to this example:
        -:   84: *
        -:   85: * <PRE>
        -:   86: * template<>
        -:   87: * struct safety_traits<tao::details::value_traits<MyStruct>,true> {
        -:   88: *   bool enable_range_checking;
        -:   89: *   void check_range(CORBA::ULong index, CORBA::ULong length) {
        -:   90: *     if (!enable_range_checking || index < length)
        -:   91: *       return;
        -:   92: *     throw std::range_error("CORBA sequence range error");
        -:   93: *   };
        -:   94: * ...
        -:   95: * ..
        -:   96: * };
        -:   97: * </PRE>
        -:   98: *
        -:   99: *
        -:  100: *
        -:  101: * @todo There is no control on a per-sequence type basis, only on a
        -:  102: *       per-underlying type basis, for example, the following two IDL
        -:  103: *       sequences would get the same behavior:
        -:  104: *       // IDL
        -:  105: *       typedef sequence<MyStruct> MyStructSequence;
        -:  106: *       typedef sequence<MyStruct> MyStructList;
        -:  107: *
        -:  108: * @todo There is no way to control behavior on a per-sequence basis,
        -:  109: *       i.e. to have some sequences of longs checked while others are
        -:  110: *       not.  This is easy to fix, simply:
        -:  111: *       - make all members of safety_traits non-static
        -:  112: *       - have each sequence contain their own instance of
        -:  113: *         safety_traits
        -:  114: *       - grant users read/write access to the safety_traits of each
        -:  115: *         sequence
        -:  116: *       but there are footprint consequences to that approach.  Until
        -:  117: *       there is more demand to justify the cost, I will not
        -:  118: *       implement such a change.
        -:  119: */
        -:  120:template<typename T, bool dummy>
        -:  121:struct range_checking
        -:  122:{
        -:  123:  typedef T value_type;
        -:  124:
    #####:  125:  inline static void check(
        -:  126:      CORBA::ULong index,
        -:  127:      CORBA::ULong length,
        -:  128:      CORBA::ULong /* maximum */,
        -:  129:      char const * /* function_name */)
        -:  130:  {
        -:  131:    // Applications and tests can specialize this function to define
        -:  132:    // their own behavior
        -:  133:#if defined (TAO_CHECKED_SEQUENCE_INDEXING) && (TAO_CHECKED_SEQUENCE_INDEXING == 1)
    #####:  134:    if (length <= index)
    #####:  135:      throw ::CORBA::BAD_PARAM ();
        -:  136:#else
        -:  137:    ACE_UNUSED_ARG (index);
        -:  138:    ACE_UNUSED_ARG (length);
        -:  139:#endif // TAO_CHECKED_SEQUENCE_INDEXING
    #####:  140:  }
        -:  141:
        -:  142:  inline static void check_length(
        -:  143:      CORBA::ULong &new_length,
        -:  144:      CORBA::ULong maximum)
        -:  145:  {
        -:  146:    if (maximum < new_length)
        -:  147:      throw ::CORBA::BAD_PARAM ();
        -:  148:  }
        -:  149:};
        -:  150:
        -:  151:} // namespace details
        -:  152:} // namespace TAO
        -:  153:
        -:  154:TAO_END_VERSIONED_NAMESPACE_DECL
        -:  155:
        -:  156:#if defined(TAO_USER_DEFINED_SEQUENCE_RANGE_CHECKING_INCLUDE)
        -:  157:#  include TAO_USER_DEFINED_SEQUENCE_RANGE_CHECKING_INCLUDE
        -:  158:#endif // TAO_USER_DEFINED_SEQUENCE_RANGE_CHECKING_INCLUDE
        -:  159:
        -:  160:#endif // guard_range_checking_hpp
