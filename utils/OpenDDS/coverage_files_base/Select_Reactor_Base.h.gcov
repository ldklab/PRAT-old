        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Select_Reactor_Base.h
        -:    0:Programs:51
        -:    1:// -*- C++ -*-
        -:    2:
        -:    3://=============================================================================
        -:    4:/**
        -:    5: *  @file    Select_Reactor_Base.h
        -:    6: *
        -:    7: *  $Id: Select_Reactor_Base.h 1861 2011-08-31 16:18:08Z mesnierp $
        -:    8: *
        -:    9: *  @author Douglas C. Schmidt <schmidt@cs.wustl.edu>
        -:   10: */
        -:   11://=============================================================================
        -:   12:
        -:   13:#ifndef ACE_SELECT_REACTOR_BASE_H
        -:   14:#define ACE_SELECT_REACTOR_BASE_H
        -:   15:
        -:   16:#include /**/ "ace/pre.h"
        -:   17:
        -:   18:#include "ace/Timer_Queuefwd.h"
        -:   19:
        -:   20:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   21:# pragma once
        -:   22:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   23:
        -:   24:#include "ace/Event_Handler.h"
        -:   25:#include "ace/Handle_Set.h"
        -:   26:#include "ace/Pipe.h"
        -:   27:#include "ace/Reactor_Impl.h"
        -:   28:
        -:   29:#if defined (ACE_HAS_REACTOR_NOTIFICATION_QUEUE)
        -:   30:# include "ace/Notification_Queue.h"
        -:   31:#endif /* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
        -:   32:
        -:   33:#ifdef ACE_WIN32
        -:   34:# include "ace/Null_Mutex.h"
        -:   35:# include "ace/Hash_Map_Manager_T.h"
        -:   36:# include "ace/Functor.h"  /* For ACE_Hash<void *> */
        -:   37:# include <functional>      /* For std::equal_to<>  */
        -:   38:#else
        -:   39:# include "ace/Array_Base.h"
        -:   40:#endif  /* ACE_WIN32 */
        -:   41:
        -:   42:#if !defined (ACE_DISABLE_NOTIFY_PIPE_DEFAULT)
        -:   43:# define ACE_DISABLE_NOTIFY_PIPE_DEFAULT 0
        -:   44:#endif /* ACE_DISABLE_NOTIFY_PIPE_DEFAULT */
        -:   45:
        -:   46:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   47:
        -:   48:// Add useful typedefs to simplify the following code.
        -:   49:typedef void (ACE_Handle_Set::*ACE_FDS_PTMF) (ACE_HANDLE);
        -:   50:typedef int (ACE_Event_Handler::*ACE_EH_PTMF) (ACE_HANDLE);
        -:   51:
        -:   52:// Forward declaration.
        -:   53:class ACE_Select_Reactor_Impl;
        -:   54:class ACE_Sig_Handler;
        -:   55:
        -:   56:/*
        -:   57: * Hook to specialize the Select_Reactor_Base implementation
        -:   58: * with the concrete reactor, e.g., select or tp reactor
        -:   59: * specified at build/compilation time.
        -:   60: */
        -:   61://@@ REACTOR_SPL_INCLUDE_FORWARD_DECL_ADD_HOOK
        -:   62:
        -:   63:/**
        -:   64: * @class ACE_Select_Reactor_Handle_Set
        -:   65: *
        -:   66: * @brief Track handles we are interested for various events.
        -:   67: */
    #####:   68:class ACE_Export ACE_Select_Reactor_Handle_Set
        -:   69:{
        -:   70:public:
        -:   71:  /// Read events (e.g., input pending, accept pending).
        -:   72:  ACE_Handle_Set rd_mask_;
        -:   73:
        -:   74:  /// Write events (e.g., flow control abated, non-blocking connection
        -:   75:  /// complete).
        -:   76:  ACE_Handle_Set wr_mask_;
        -:   77:
        -:   78:  /// Exception events (e.g., SIG_URG).
        -:   79:  ACE_Handle_Set ex_mask_;
        -:   80:};
        -:   81:
        -:   82:/**
        -:   83: * @class ACE_Event_Tuple
        -:   84: *
        -:   85: * @brief An ACE_Event_Handler and its associated ACE_HANDLE.
        -:   86: *
        -:   87: * One ACE_Event_Handler is registered for one or more
        -:   88: * ACE_HANDLE.  At various points, this information must be
        -:   89: * stored explicitly.  This class provides a lightweight
        -:   90: * mechanism to do so.
        -:   91: */
        -:   92:class ACE_Event_Tuple
        -:   93:{
        -:   94:public:
        -:   95:  /// Default constructor.
        -:   96:  ACE_Event_Tuple (void);
        -:   97:
        -:   98:  /// Constructor.
        -:   99:  ACE_Event_Tuple (ACE_Event_Handler *eh, ACE_HANDLE h);
        -:  100:
        -:  101:  /// Equality operator.
        -:  102:  bool operator== (const ACE_Event_Tuple &rhs) const;
        -:  103:
        -:  104:  /// Inequality operator.
        -:  105:  bool operator!= (const ACE_Event_Tuple &rhs) const;
        -:  106:
        -:  107:public:
        -:  108:  /// Handle.
        -:  109:  ACE_HANDLE handle_;
        -:  110:
        -:  111:  /// ACE_Event_Handler associated with the ACE_HANDLE.
        -:  112:  ACE_Event_Handler *event_handler_;
        -:  113:
        -:  114:};
        -:  115:
        -:  116:/**
        -:  117: * @class ACE_Select_Reactor_Notify
        -:  118: *
        -:  119: * @brief Unblock the ACE_Select_Reactor from its event loop.
        -:  120: *
        -:  121: * This implementation is necessary for cases where the
        -:  122: * ACE_Select_Reactor is run in a multi-threaded program.  In
        -:  123: * this case, we need to be able to unblock @c select or @c poll
        -:  124: * when updates occur other than in the main
        -:  125: * ACE_Select_Reactor thread.  To do this, we signal an
        -:  126: * auto-reset event the ACE_Select_Reactor is listening on.
        -:  127: * If an ACE_Event_Handler and ACE_Select_Reactor_Mask is
        -:  128: * passed to @c notify, the appropriate @c handle_* method is
        -:  129: * dispatched in the context of the ACE_Select_Reactor thread.
        -:  130: */
        -:  131:class ACE_Export ACE_Select_Reactor_Notify : public ACE_Reactor_Notify
        -:  132:{
        -:  133:public:
        -:  134:  /// Constructor.
        -:  135:  ACE_Select_Reactor_Notify (void);
        -:  136:
        -:  137:  /// Destructor.
        -:  138:  virtual ~ACE_Select_Reactor_Notify (void);
        -:  139:
        -:  140:  // = Initialization and termination methods.
        -:  141:  /// Initialize.
        -:  142:  virtual int open (ACE_Reactor_Impl *,
        -:  143:                    ACE_Timer_Queue * = 0,
        -:  144:                    int disable_notify_pipe = ACE_DISABLE_NOTIFY_PIPE_DEFAULT);
        -:  145:
        -:  146:  /// Destroy.
        -:  147:  virtual int close (void);
        -:  148:
        -:  149:  /**
        -:  150:   * Called by a thread when it wants to unblock the
        -:  151:   * ACE_Select_Reactor.  This wakeups the ACE_Select_Reactor if
        -:  152:   * currently blocked in @c select/poll.  Pass over both the
        -:  153:   * @c Event_Handler *and* the @c mask to allow the caller to dictate
        -:  154:   * which @c Event_Handler method the ACE_Select_Reactor will
        -:  155:   * invoke.  The ACE_Time_Value indicates how long to blocking
        -:  156:   * trying to notify the ACE_Select_Reactor.  If @a timeout == 0,
        -:  157:   * the caller will block until action is possible, else will wait
        -:  158:   * until the relative time specified in @c *timeout elapses).
        -:  159:   */
        -:  160:  virtual int notify (ACE_Event_Handler * = 0,
        -:  161:                      ACE_Reactor_Mask = ACE_Event_Handler::EXCEPT_MASK,
        -:  162:                      ACE_Time_Value * timeout = 0);
        -:  163:
        -:  164:  /// Handles pending threads (if any) that are waiting to unblock the
        -:  165:  /// ACE_Select_Reactor.
        -:  166:  virtual int dispatch_notifications (int &number_of_active_handles,
        -:  167:                                      ACE_Handle_Set &rd_mask);
        -:  168:
        -:  169:  /// Returns the ACE_HANDLE of the notify pipe on which the reactor
        -:  170:  /// is listening for notifications so that other threads can unblock
        -:  171:  /// the Select_Reactor
        -:  172:  virtual ACE_HANDLE notify_handle (void);
        -:  173:
        -:  174:  /// Handle one of the notify call on the @c handle. This could be
        -:  175:  /// because of a thread trying to unblock the Reactor_Impl
        -:  176:  virtual int dispatch_notify (ACE_Notification_Buffer &buffer);
        -:  177:
        -:  178:  /// Read one of the notify call on the @a handle into the
        -:  179:  /// @a buffer. This could be because of a thread trying to unblock
        -:  180:  /// the Reactor_Impl
        -:  181:  ///
        -:  182:  /// Return value semantics for this are:
        -:  183:  /// -1: nothing read, fatal, unrecoverable error
        -:  184:  ///  0: nothing read at all
        -:  185:  ///  1: complete buffer read
        -:  186:  virtual int read_notify_pipe (ACE_HANDLE handle,
        -:  187:                                ACE_Notification_Buffer &buffer);
        -:  188:
        -:  189:  /// Verify whether the buffer has dispatchable info or not.
        -:  190:  virtual int is_dispatchable (ACE_Notification_Buffer &buffer);
        -:  191:
        -:  192:  /// Called back by the ACE_Select_Reactor when a thread wants to
        -:  193:  /// unblock us.
        -:  194:  virtual int handle_input (ACE_HANDLE handle);
        -:  195:
        -:  196:  /**
        -:  197:   * Set the maximum number of times that the
        -:  198:   * ACE_Select_Reactor_Notify::handle_input() method will iterate and
        -:  199:   * dispatch the ACE_Event_Handlers that are passed in via the
        -:  200:   * notify pipe before breaking out of its @c recv loop.  By default,
        -:  201:   * this is set to -1, which means "iterate until the pipe is empty."
        -:  202:   * Setting this to a value like "1 or 2" will increase "fairness"
        -:  203:   * (and thus prevent starvation) at the expense of slightly higher
        -:  204:   * dispatching overhead.
        -:  205:   */
        -:  206:  virtual void max_notify_iterations (int);
        -:  207:
        -:  208:  /**
        -:  209:   * Get the maximum number of times that the
        -:  210:   * ACE_Select_Reactor_Notify::handle_input() method will iterate and
        -:  211:   * dispatch the ACE_Event_Handlers that are passed in via the
        -:  212:   * notify pipe before breaking out of its recv loop.
        -:  213:   */
        -:  214:  virtual int max_notify_iterations (void);
        -:  215:
        -:  216:  /**
        -:  217:   * Purge any notifications pending in this reactor for the specified
        -:  218:   * ACE_Event_Handler object. If @a eh == 0, all notifications for all
        -:  219:   * handlers are removed (but not any notifications posted just to wake up
        -:  220:   * the reactor itself). Returns the number of notifications purged.
        -:  221:   * Returns -1 on error.
        -:  222:   */
        -:  223:  virtual int purge_pending_notifications (
        -:  224:      ACE_Event_Handler *sh,
        -:  225:      ACE_Reactor_Mask mask = ACE_Event_Handler::ALL_EVENTS_MASK);
        -:  226:
        -:  227:  /// Dump the state of an object.
        -:  228:  virtual void dump (void) const;
        -:  229:
        -:  230:  /// Declare the dynamic allocation hooks.
        -:  231:  ACE_ALLOC_HOOK_DECLARE;
        -:  232:
        -:  233:protected:
        -:  234:  /**
        -:  235:   * Keep a back pointer to the ACE_Select_Reactor.  If this value
        -:  236:   * if NULL then the ACE_Select_Reactor has been initialized with
        -:  237:   * disable_notify_pipe.
        -:  238:   */
        -:  239:  ACE_Select_Reactor_Impl *select_reactor_;
        -:  240:
        -:  241:  /**
        -:  242:   * Contains the ACE_HANDLE the ACE_Select_Reactor is listening
        -:  243:   * on, as well as the ACE_HANDLE that threads wanting the
        -:  244:   * attention of the ACE_Select_Reactor will write to.
        -:  245:   */
        -:  246:  ACE_Pipe notification_pipe_;
        -:  247:
        -:  248:  /**
        -:  249:   * Keeps track of the maximum number of times that the
        -:  250:   * ACE_Select_Reactor_Notify::handle_input() method will iterate and
        -:  251:   * dispatch the ACE_Event_Handlers that are passed in via the
        -:  252:   * notify pipe before breaking out of its recv loop.  By default,
        -:  253:   * this is set to -1, which means "iterate until the pipe is empty."
        -:  254:   */
        -:  255:  int max_notify_iterations_;
        -:  256:
        -:  257:#if defined (ACE_HAS_REACTOR_NOTIFICATION_QUEUE)
        -:  258:  /**
        -:  259:   * @brief A user-space queue to store the notifications.
        -:  260:   *
        -:  261:   * The notification pipe has OS-specific size restrictions.  That
        -:  262:   * is, no more than a certain number of bytes may be stored in the
        -:  263:   * pipe without blocking.  This limit may be too small for certain
        -:  264:   * applications.  In this case, ACE can be configured to store all
        -:  265:   * the events in user-space.  The pipe is still needed to wake up
        -:  266:   * the reactor thread, but only one event is sent through the pipe
        -:  267:   * at a time.
        -:  268:   */
        -:  269:  ACE_Notification_Queue notification_queue_;
        -:  270:#endif /* ACE_HAS_REACTOR_NOTIFICATION_QUEUE */
        -:  271:};
        -:  272:
        -:  273:/**
        -:  274: * @class ACE_Select_Reactor_Handler_Repository
        -:  275: *
        -:  276: * @brief Used to map ACE_HANDLEs onto the appropriate
        -:  277: * ACE_Event_Handler *.
        -:  278: *
        -:  279: * This class is necessary to shield differences between UNIX
        -:  280: * and Win32.  In UNIX, ACE_HANDLE is an int, whereas in Win32
        -:  281: * it's a void *.  This class hides all these details from the
        -:  282: * bulk of the ACE_Select_Reactor code.  All of these methods
        -:  283: * are called with the main <Select_Reactor> token lock held.
        -:  284: */
    #####:  285:class ACE_Export ACE_Select_Reactor_Handler_Repository
        -:  286:{
        -:  287:public:
        -:  288:  friend class ACE_Select_Reactor_Handler_Repository_Iterator;
        -:  289:
        -:  290:  typedef ACE_HANDLE          key_type;
        -:  291:  typedef ACE_Event_Handler * value_type;
        -:  292:
        -:  293:  // = The mapping from <HANDLES> to <Event_Handlers>.
        -:  294:#ifdef ACE_WIN32
        -:  295:  /**
        -:  296:   * The NT version implements this via a hash map
        -:  297:   * @c ACE_Event_Handler*.  Since NT implements @c ACE_HANDLE
        -:  298:   * as a void * we can't directly index into this array.  Therefore,
        -:  299:   * we must explicitly map @c ACE_HANDLE to @c ACE_Event_Handler.
        -:  300:   */
        -:  301:  typedef ACE_Hash_Map_Manager_Ex<key_type,
        -:  302:                                  value_type,
        -:  303:                                  ACE_Hash<key_type>,
        -:  304:                                  std::equal_to<key_type>,
        -:  305:                                  ACE_Null_Mutex> map_type;
        -:  306:
        -:  307:  typedef map_type::size_type max_handlep1_type;
        -:  308:#else
        -:  309:  /**
        -:  310:   * The UNIX version implements this via a dynamically allocated
        -:  311:   * array of @c ACE_Event_Handler* that is indexed directly using
        -:  312:   * the @c ACE_HANDLE value.
        -:  313:   */
        -:  314:  typedef ACE_Array_Base<value_type> map_type;
        -:  315:  typedef ACE_HANDLE max_handlep1_type;
        -:  316:#endif  /* ACE_WIN32 */
        -:  317:
        -:  318:  typedef map_type::size_type size_type;
        -:  319:
        -:  320:  // = Initialization and termination methods.
        -:  321:  /// Default "do-nothing" constructor.
        -:  322:  ACE_Select_Reactor_Handler_Repository (ACE_Select_Reactor_Impl &);
        -:  323:
        -:  324:  /// Initialize a repository of the appropriate @a size.
        -:  325:  /**
        -:  326:   * On Unix platforms, the size parameter should be as large as the
        -:  327:   * maximum number of file descriptors allowed for a given process.
        -:  328:   * This is necessary since a file descriptor is used to directly
        -:  329:   * index the array of event handlers maintained by the Reactor's
        -:  330:   * handler repository.  Direct indexing is used for efficiency
        -:  331:   * reasons.
        -:  332:   */
        -:  333:  int open (size_type size);
        -:  334:
        -:  335:  /// Close down the repository.
        -:  336:  int close (void);
        -:  337:
        -:  338:  // = Search structure operations.
        -:  339:
        -:  340:  /**
        -:  341:   * Return the @c ACE_Event_Handler* associated with @c ACE_HANDLE.
        -:  342:   */
        -:  343:  ACE_Event_Handler * find (ACE_HANDLE handle);
        -:  344:
        -:  345:  /// Bind the ACE_Event_Handler * to the ACE_HANDLE with the
        -:  346:  /// appropriate ACE_Reactor_Mask settings.
        -:  347:  int bind (ACE_HANDLE,
        -:  348:            ACE_Event_Handler *,
        -:  349:            ACE_Reactor_Mask);
        -:  350:
        -:  351:  /// Remove the binding of ACE_HANDLE in accordance with the @a mask.
        -:  352:  int unbind (ACE_HANDLE,
        -:  353:              ACE_Reactor_Mask mask);
        -:  354:
        -:  355:  /// Remove all the <ACE_HANDLE, ACE_Event_Handler> tuples.
        -:  356:  int unbind_all (void);
        -:  357:
        -:  358:  // = Sanity checking.
        -:  359:
        -:  360:  // Check the @a handle to make sure it's a valid @c ACE_HANDLE that
        -:  361:  // is within the range of legal handles (i.e., >= 0 && < max_size_).
        -:  362:  bool invalid_handle (ACE_HANDLE handle);
        -:  363:
        -:  364:  // Check the @a handle to make sure it's a valid @c ACE_HANDLE that
        -:  365:  // within the range of currently registered handles (i.e., >= 0 && <
        -:  366:  // @c max_handlep1_).
        -:  367:  bool handle_in_range (ACE_HANDLE handle);
        -:  368:
        -:  369:  // = Accessors.
        -:  370:  /// Returns the current table size.
        -:  371:  size_type size (void) const;
        -:  372:
        -:  373:  /// Maximum ACE_HANDLE value, plus 1.
        -:  374:  max_handlep1_type max_handlep1 (void) const;
        -:  375:
        -:  376:  /// Dump the state of an object.
        -:  377:  void dump (void) const;
        -:  378:
        -:  379:  /// Declare the dynamic allocation hooks.
        -:  380:  ACE_ALLOC_HOOK_DECLARE;
        -:  381:
        -:  382:private:
        -:  383:
        -:  384:  /// Remove the binding of @a handle corresponding to position @a pos
        -:  385:  /// in accordance with the @a mask.
        -:  386:  int unbind (ACE_HANDLE handle,
        -:  387:              map_type::iterator pos,
        -:  388:              ACE_Reactor_Mask mask);
        -:  389:
        -:  390:  /**
        -:  391:   * @return @c iterator corresponding @c ACE_Event_Handler*
        -:  392:   *         associated with @c ACE_HANDLE.
        -:  393:   */
        -:  394:  map_type::iterator find_eh (ACE_HANDLE handle);
        -:  395:
        -:  396:private:
        -:  397:  /// Reference to our @c Select_Reactor.
        -:  398:  ACE_Select_Reactor_Impl &select_reactor_;
        -:  399:
        -:  400:#ifndef ACE_WIN32
        -:  401:  /// The highest currently active handle, plus 1 (ranges between 0 and
        -:  402:  /// @c max_size_.
        -:  403:  max_handlep1_type max_handlep1_;
        -:  404:#endif  /* !ACE_WIN32 */
        -:  405:
        -:  406:  /// Underlying table of event handlers.
        -:  407:  map_type event_handlers_;
        -:  408:};
        -:  409:
        -:  410:/**
        -:  411: * @class ACE_Select_Reactor_Handler_Repository_Iterator
        -:  412: *
        -:  413: * @brief Iterate through the ACE_Select_Reactor_Handler_Repository.
        -:  414: */
        -:  415:class ACE_Export ACE_Select_Reactor_Handler_Repository_Iterator
        -:  416:{
        -:  417:public:
        -:  418:
        -:  419:  typedef
        -:  420:    ACE_Select_Reactor_Handler_Repository::map_type::const_iterator const_base_iterator;
        -:  421:
        -:  422:  // = Initialization method.
        -:  423:  explicit ACE_Select_Reactor_Handler_Repository_Iterator (
        -:  424:    ACE_Select_Reactor_Handler_Repository const * s);
        -:  425:
        -:  426:  // = Iteration methods.
        -:  427:
        -:  428:  /// Pass back the @a next_item that hasn't been seen in the Set.
        -:  429:  /// Returns @c false when all items have been seen, else @c true.
        -:  430:  bool next (ACE_Event_Handler* & next_item);
        -:  431:
        -:  432:  /// Returns @c true when all items have been seen, else @c false.
        -:  433:  bool done (void) const;
        -:  434:
        -:  435:  /// Move forward by one element in the set.  Returns @c false when
        -:  436:  /// all the items in the set have been seen, else @c true.
        -:  437:  bool advance (void);
        -:  438:
        -:  439:  /// Dump the state of an object.
        -:  440:  void dump (void) const;
        -:  441:
        -:  442:  /// Declare the dynamic allocation hooks.
        -:  443:  ACE_ALLOC_HOOK_DECLARE;
        -:  444:
        -:  445:private:
        -:  446:
        -:  447:  /// Reference to the Handler_Repository we are iterating over.
        -:  448:  ACE_Select_Reactor_Handler_Repository const * const rep_;
        -:  449:
        -:  450:  /// Pointer to the current iteration level.
        -:  451:  const_base_iterator current_;
        -:  452:};
        -:  453:
        -:  454:/**
        -:  455: * @class ACE_Select_Reactor_Impl
        -:  456: *
        -:  457: * @brief This class simply defines how Select_Reactor's basic interface
        -:  458: * functions should look like and provides a common base class for
        -:  459: * @c Select_Reactor using various locking mechanism.
        -:  460: */
    #####:  461:class ACE_Export ACE_Select_Reactor_Impl : public ACE_Reactor_Impl
        -:  462:{
        -:  463:public:
        -:  464:  enum
        -:  465:  {
        -:  466:    /// Default size of the Select_Reactor's handle table.
        -:  467:    DEFAULT_SIZE = ACE_DEFAULT_SELECT_REACTOR_SIZE
        -:  468:  };
        -:  469:
        -:  470:  /// Constructor.
        -:  471:  ACE_Select_Reactor_Impl (bool mask_signals = true);
        -:  472:
        -:  473:  friend class ACE_Select_Reactor_Notify;
        -:  474:  friend class ACE_Select_Reactor_Handler_Repository;
        -:  475:
        -:  476:  /**
        -:  477:   * Purge any notifications pending in this reactor for the specified
        -:  478:   * ACE_Event_Handler object. Returns the number of notifications
        -:  479:   * purged. Returns -1 on error.
        -:  480:   */
        -:  481:  virtual int purge_pending_notifications (ACE_Event_Handler * = 0,
        -:  482:                                           ACE_Reactor_Mask    = ACE_Event_Handler::ALL_EVENTS_MASK);
        -:  483:
        -:  484:  /// Does the reactor allow the application to resume the handle on
        -:  485:  /// its own ie. can it pass on the control of handle resumption to
        -:  486:  /// the application.  The select reactor has no handlers that can be
        -:  487:  /// resumed by the  application. So return 0;
        -:  488:  virtual int resumable_handler (void);
        -:  489:
        -:  490:  /*
        -:  491:   * Hook to add concrete methods required to specialize the
        -:  492:   * implementation with concrete methods required for the concrete
        -:  493:   * reactor implementation, for example, select, tp reactors.
        -:  494:   */
        -:  495:  //@@ REACTOR_SPL_PUBLIC_METHODS_ADD_HOOK
        -:  496:
        -:  497:protected:
        -:  498:  /// Allow manipulation of the <wait_set_> mask and <ready_set_> mask.
        -:  499:  virtual int bit_ops (ACE_HANDLE handle,
        -:  500:                       ACE_Reactor_Mask mask,
        -:  501:                       ACE_Select_Reactor_Handle_Set &handle_set,
        -:  502:                       int ops);
        -:  503:
        -:  504:  /// Enqueue ourselves into the list of waiting threads at the
        -:  505:  /// appropriate point specified by <requeue_position_>.
        -:  506:  virtual void renew (void) = 0;
        -:  507:
        -:  508:  /// Check to see if the Event_Handler associated with @a handle is
        -:  509:  /// suspended. Returns 0 if not, 1 if so.
        -:  510:  virtual int is_suspended_i (ACE_HANDLE handle) = 0;
        -:  511:
        -:  512:  /// When register/unregister occur, then we need to re-eval our
        -:  513:  /// wait/suspend/dispatch set.
        -:  514:  virtual void clear_dispatch_mask (ACE_HANDLE handle,
        -:  515:                                    ACE_Reactor_Mask mask);
        -:  516:
        -:  517:  /// Table that maps <ACE_HANDLEs> to <ACE_Event_Handler *>'s.
        -:  518:  ACE_Select_Reactor_Handler_Repository handler_rep_;
        -:  519:
        -:  520:  /// Tracks handles that are ready for dispatch from <select>
        -:  521:  ACE_Select_Reactor_Handle_Set dispatch_set_;
        -:  522:
        -:  523:  /// Tracks handles that are waited for by <select>.
        -:  524:  ACE_Select_Reactor_Handle_Set wait_set_;
        -:  525:
        -:  526:  /// Tracks handles that are currently suspended.
        -:  527:  ACE_Select_Reactor_Handle_Set suspend_set_;
        -:  528:
        -:  529:  /// Track HANDLES we are interested in for various events that must
        -:  530:  /// be dispatched *without* going through <select>.
        -:  531:  ACE_Select_Reactor_Handle_Set ready_set_;
        -:  532:
        -:  533:  /// Defined as a pointer to allow overriding by derived classes...
        -:  534:  ACE_Timer_Queue *timer_queue_;
        -:  535:
        -:  536:  /// Handle signals without requiring global/static variables.
        -:  537:  ACE_Sig_Handler *signal_handler_;
        -:  538:
        -:  539:  /// Callback object that unblocks the ACE_Select_Reactor if it's
        -:  540:  /// sleeping.
        -:  541:  ACE_Reactor_Notify *notify_handler_;
        -:  542:
        -:  543:  /// Keeps track of whether we should delete the timer queue (if we
        -:  544:  /// didn't create it, then we don't delete it).
        -:  545:  bool delete_timer_queue_;
        -:  546:
        -:  547:  /// Keeps track of whether we should delete the signal handler (if we
        -:  548:  /// didn't create it, then we don't delete it).
        -:  549:  bool delete_signal_handler_;
        -:  550:
        -:  551:  /// Keeps track of whether we need to delete the notify handler (if
        -:  552:  /// we didn't create it, then we don't delete it).
        -:  553:  bool delete_notify_handler_;
        -:  554:
        -:  555:  /// True if we've been initialized yet...
        -:  556:  bool initialized_;
        -:  557:
        -:  558:  /// Restart the <handle_events> event-loop method automatically when
        -:  559:  /// <select> is interrupted via <EINTR>.
        -:  560:  bool restart_;
        -:  561:
        -:  562:  /**
        -:  563:   * Position that the main ACE_Select_Reactor thread is requeued in
        -:  564:   * the list of waiters during a <notify> callback.  If this value ==
        -:  565:   * -1 we are requeued at the end of the list.  Else if it's 0 then
        -:  566:   * we are requeued at the front of the list.  Else if it's > 1 then
        -:  567:   * that indicates the number of waiters to skip over.
        -:  568:   */
        -:  569:  int requeue_position_;
        -:  570:
        -:  571:  /// The original thread that created this Select_Reactor.
        -:  572:  ACE_thread_t owner_;
        -:  573:
        -:  574:  /**
        -:  575:   * True if state has changed during dispatching of
        -:  576:   * ACE_Event_Handlers, else false.  This is used to determine
        -:  577:   * whether we need to make another trip through the
        -:  578:   * <Select_Reactor>'s <wait_for_multiple_events> loop.
        -:  579:   */
        -:  580:  bool state_changed_;
        -:  581:
        -:  582:  /**
        -:  583:   * If false then the Reactor will not mask the signals during the event
        -:  584:   * dispatching.  This is useful for applications that do not
        -:  585:   * register any signal handlers and want to reduce the overhead
        -:  586:   * introduce by the kernel level locks required to change the mask.
        -:  587:   */
        -:  588:  bool mask_signals_;
        -:  589:
        -:  590:  /// Controls/access whether the notify handler should renew the
        -:  591:  /// Select_Reactor's token or not.
        -:  592:  int supress_notify_renew (void);
        -:  593:  void supress_notify_renew (int sr);
        -:  594:
        -:  595:private:
        -:  596:
        -:  597:  /// Determine whether we should renew Select_Reactor's token after handling
        -:  598:  /// the notification message.
        -:  599:  int supress_renew_;
        -:  600:
        -:  601:  /// Deny access since member-wise won't work...
        -:  602:  ACE_Select_Reactor_Impl (const ACE_Select_Reactor_Impl &);
        -:  603:  ACE_Select_Reactor_Impl &operator = (const ACE_Select_Reactor_Impl &);
        -:  604:};
        -:  605:
        -:  606:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  607:
        -:  608:#if defined (__ACE_INLINE__)
        -:  609:#include "ace/Select_Reactor_Base.inl"
        -:  610:#endif /* __ACE_INLINE__ */
        -:  611:
        -:  612:#include /**/ "ace/post.h"
        -:  613:
        -:  614:#endif /* ACE_SELECT_REACTOR_BASE_H */
