        -:    0:Source:../dds/DCPS/DataWriterImpl_T.h
        -:    0:Programs:72
        -:    1:#ifndef dds_DCPS_DataWriterImpl_T_h
        -:    2:#define dds_DCPS_DataWriterImpl_T_h
        -:    3:
        -:    4:#include "dds/DCPS/PublicationInstance.h"
        -:    5:#include "dds/DCPS/DataWriterImpl.h"
        -:    6:#include "dds/DCPS/DataReaderImpl.h"
        -:    7:#include "dds/DCPS/Util.h"
        -:    8:#include "dds/DCPS/TypeSupportImpl.h"
        -:    9:#include "dcps_export.h"
        -:   10:
        -:   11:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   12:
        -:   13:namespace OpenDDS {
        -:   14:  namespace DCPS {
        -:   15:
        -:   16:/** Servant for DataWriter interface of the Traits::MessageType data type.
        -:   17: *
        -:   18: * See the DDS specification, OMG formal/04-12-02, for a description of
        -:   19: * this interface.
        -:   20: */
        -:   21:  template <typename MessageType>
        -:   22:  class
        -:   23:#if ( __GNUC__ == 4 && __GNUC_MINOR__ == 1)
        -:   24:    OpenDDS_Dcps_Export
        -:   25:#endif
        -:   26:    DataWriterImpl_T
        -:   27:    : public virtual OpenDDS::DCPS::LocalObject<typename DDSTraits<MessageType>::DataWriterType>,
        -:   28:      public virtual OpenDDS::DCPS::DataWriterImpl
        -:   29:  {
        -:   30:  public:
        -:   31:    typedef DDSTraits<MessageType> TraitsType;
        -:   32:    typedef MarshalTraits<MessageType> MarshalTraitsType;
        -:   33:
        -:   34:    typedef OPENDDS_MAP_CMP_T(MessageType, DDS::InstanceHandle_t,
        -:   35:                              typename TraitsType::LessThanType) InstanceMap;
        -:   36:    typedef ::OpenDDS::DCPS::Dynamic_Cached_Allocator_With_Overflow<ACE_Thread_Mutex>  DataAllocator;
        -:   37:
        -:   38:    enum {
        -:   39:      cdr_header_size = 4
        -:   40:    };
        -:   41:
       12:   42:    DataWriterImpl_T (void)
        -:   43:      : marshaled_size_ (0)
       12:   44:      , key_marshaled_size_ (0)
        -:   45:    {
       24:   46:      MessageType data;
       12:   47:      if (MarshalTraitsType::gen_is_bounded_size()) {
    #####:   48:        marshaled_size_ = 8 + TraitsType::gen_max_marshaled_size(data, true);
        -:   49:        // worst case: CDR encapsulation (4 bytes) + Padding for alignment (4 bytes)
        -:   50:      } else {
       12:   51:        marshaled_size_ = 0; // should use gen_find_size when marshaling
        -:   52:      }
       12:   53:      if (MarshalTraitsType::gen_is_bounded_key_size()) {
       12:   54:        OpenDDS::DCPS::KeyOnly<const MessageType > ko(data);
       12:   55:        key_marshaled_size_ = 8 + TraitsType::gen_max_marshaled_size(ko, true);
        -:   56:        // worst case: CDR Encapsulation (4 bytes) + Padding for alignment (4 bytes)
        -:   57:      } else {
    #####:   58:        key_marshaled_size_ = 0; // should use gen_find_size when marshaling
        -:   59:      }
       12:   60:    }
        -:   61:
       24:   62:    virtual ~DataWriterImpl_T (void)
        -:   63:    {
       24:   64:    }
        -:   65:
       18:   66:  virtual DDS::InstanceHandle_t register_instance (
        -:   67:      const MessageType & instance)
        -:   68:    {
       18:   69:      DDS::Time_t const timestamp =
       36:   70:        ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
       18:   71:      return register_instance_w_timestamp (instance, timestamp);
        -:   72:    }
        -:   73:
       18:   74:  virtual DDS::InstanceHandle_t register_instance_w_timestamp (
        -:   75:      const MessageType & instance,
        -:   76:      const DDS::Time_t & timestamp)
        -:   77:    {
       18:   78:      DDS::InstanceHandle_t registered_handle = DDS::HANDLE_NIL;
        -:   79:
       18:   80:      DDS::ReturnCode_t const ret
        -:   81:          = this->get_or_create_instance_handle(registered_handle,
        -:   82:                                                instance,
        -:   83:                                                timestamp);
       18:   84:      if (ret != DDS::RETCODE_OK)
        -:   85:        {
    #####:   86:          ACE_ERROR ((LM_ERROR,
        -:   87:                      ACE_TEXT("(%P|%t) ")
        -:   88:                      ACE_TEXT("%CDataWriterImpl::")
        -:   89:                      ACE_TEXT("register_instance_w_timestamp, ")
        -:   90:                      ACE_TEXT("register failed error=%d.\n"),
        -:   91:                      TraitsType::type_name(),
        -:   92:                      ret));
        -:   93:        }
        -:   94:
       18:   95:      return registered_handle;
        -:   96:    }
        -:   97:
    #####:   98:  virtual DDS::ReturnCode_t unregister_instance (
        -:   99:      const MessageType & instance,
        -:  100:      DDS::InstanceHandle_t handle)
        -:  101:    {
    #####:  102:      DDS::Time_t const timestamp =
    #####:  103:        ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
        -:  104:
    #####:  105:      return unregister_instance_w_timestamp (instance,
        -:  106:                                              handle,
    #####:  107:                                              timestamp);
        -:  108:    }
        -:  109:
    #####:  110:  virtual DDS::ReturnCode_t unregister_instance_w_timestamp (
        -:  111:      const MessageType & instance_data,
        -:  112:      DDS::InstanceHandle_t instance_handle,
        -:  113:      const DDS::Time_t & timestamp)
        -:  114:    {
    #####:  115:      if (instance_handle == DDS::HANDLE_NIL)
        -:  116:        {
    #####:  117:          instance_handle = this->lookup_instance(instance_data);
    #####:  118:          if (instance_handle == DDS::HANDLE_NIL)
        -:  119:            {
    #####:  120:              ACE_ERROR_RETURN ((LM_ERROR,
        -:  121:                                 ACE_TEXT("(%P|%t) ")
        -:  122:                                 ACE_TEXT("%CDataWriterImpl::unregister_instance_w_timestamp, ")
        -:  123:                                 ACE_TEXT("The instance sample is not registered.\n"),
        -:  124:                                 TraitsType::type_name()),
        -:  125:                                DDS::RETCODE_ERROR);
        -:  126:            }
        -:  127:        }
        -:  128:
        -:  129:      // DataWriterImpl::unregister_instance_i will call back to inform the
        -:  130:      // DataWriter.
        -:  131:      // That the instance handle is removed from there and hence
        -:  132:      // DataWriter can remove the instance here.
    #####:  133:      return OpenDDS::DCPS::DataWriterImpl::unregister_instance_i(instance_handle, timestamp);
        -:  134:    }
        -:  135:
        -:  136:  //WARNING: If the handle is non-nil and the instance is not registered
        -:  137:  //         then this operation may cause an access violation.
        -:  138:  //         This lack of safety helps performance.
       18:  139:  virtual DDS::ReturnCode_t write (
        -:  140:      const MessageType & instance_data,
        -:  141:      DDS::InstanceHandle_t handle)
        -:  142:    {
       18:  143:      DDS::Time_t const source_timestamp =
       36:  144:        ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
       18:  145:      return write_w_timestamp (instance_data,
        -:  146:                                handle,
       18:  147:                                source_timestamp);
        -:  148:    }
        -:  149:
        -:  150:
        -:  151:  //WARNING: If the handle is non-nil and the instance is not registered
        -:  152:  //         then this operation may cause an access violation.
        -:  153:  //         This lack of safety helps performance.
       18:  154:  virtual DDS::ReturnCode_t write_w_timestamp (
        -:  155:      const MessageType & instance_data,
        -:  156:      DDS::InstanceHandle_t handle,
        -:  157:      const DDS::Time_t & source_timestamp)
        -:  158:    {
        -:  159:      //  This operation assumes the provided handle is valid. The handle
        -:  160:      //  provided will not be verified.
        -:  161:
       18:  162:      if (handle == DDS::HANDLE_NIL) {
    #####:  163:        DDS::InstanceHandle_t registered_handle = DDS::HANDLE_NIL;
    #####:  164:        DDS::ReturnCode_t ret
        -:  165:            = this->get_or_create_instance_handle(registered_handle,
        -:  166:                                                  instance_data,
        -:  167:                                                  source_timestamp);
    #####:  168:        if (ret != DDS::RETCODE_OK) {
    #####:  169:          ACE_ERROR_RETURN((LM_ERROR,
        -:  170:                            ACE_TEXT("(%P|%t) ")
        -:  171:                            ACE_TEXT("%CDataWriterImpl::write_w_timestamp, ")
        -:  172:                            ACE_TEXT("register failed err=%d.\n"),
        -:  173:                            TraitsType::type_name(),
        -:  174:                            ret),
        -:  175:                           ret);
        -:  176:        }
        -:  177:
    #####:  178:        handle = registered_handle;
        -:  179:      }
        -:  180:
        -:  181:      // list of reader RepoIds that should not get data
       36:  182:      OpenDDS::DCPS::GUIDSeq_var filter_out;
        -:  183:#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
       18:  184:      if (TheServiceParticipant->publisher_content_filter()) {
       36:  185:        ACE_GUARD_RETURN(ACE_Thread_Mutex, reader_info_guard, this->reader_info_lock_, DDS::RETCODE_ERROR);
       42:  186:        for (RepoIdToReaderInfoMap::iterator iter = reader_info_.begin(),
       18:  187:               end = reader_info_.end(); iter != end; ++iter) {
       24:  188:          const ReaderInfo& ri = iter->second;
       24:  189:          if (!ri.eval_.is_nil()) {
    #####:  190:            if (!filter_out.ptr()) {
    #####:  191:              filter_out = new OpenDDS::DCPS::GUIDSeq;
        -:  192:            }
    #####:  193:            if (!ri.eval_->eval(instance_data, ri.expression_params_)) {
    #####:  194:              push_back(filter_out.inout(), iter->first);
        -:  195:            }
        -:  196:          }
        -:  197:        }
        -:  198:      }
        -:  199:#endif
        -:  200:
       36:  201:      Message_Block_Ptr marshalled(
        -:  202:        dds_marshal (instance_data, OpenDDS::DCPS::FULL_MARSHALING));
        -:  203:
       36:  204:      return OpenDDS::DCPS::DataWriterImpl::write(move(marshalled), handle,
        -:  205:                                                  source_timestamp,
       18:  206:                                                  filter_out._retn());
        -:  207:    }
        -:  208:
       12:  209:  virtual DDS::ReturnCode_t dispose (
        -:  210:      const MessageType & instance_data,
        -:  211:      DDS::InstanceHandle_t instance_handle)
        -:  212:    {
       12:  213:      DDS::Time_t const source_timestamp =
       24:  214:        ::OpenDDS::DCPS::time_value_to_time (ACE_OS::gettimeofday ());
       12:  215:      return dispose_w_timestamp (instance_data,
        -:  216:                                  instance_handle,
       12:  217:                                  source_timestamp);
        -:  218:    }
        -:  219:
       12:  220:  virtual DDS::ReturnCode_t dispose_w_timestamp (
        -:  221:      const MessageType & instance_data,
        -:  222:      DDS::InstanceHandle_t instance_handle,
        -:  223:      const DDS::Time_t & source_timestamp)
        -:  224:    {
       12:  225:      if (instance_handle == DDS::HANDLE_NIL)
        -:  226:        {
    #####:  227:          instance_handle = this->lookup_instance(instance_data);
    #####:  228:          if (instance_handle == DDS::HANDLE_NIL)
        -:  229:            {
    #####:  230:              ACE_ERROR_RETURN ((LM_ERROR,
        -:  231:                                 ACE_TEXT("(%P|%t) ")
        -:  232:                                 ACE_TEXT("%CDataWriterImpl::dispose_w_timestamp, ")
        -:  233:                                 ACE_TEXT("The instance sample is not registered.\n"),
        -:  234:                                 TraitsType::type_name()),
        -:  235:                                DDS::RETCODE_ERROR);
        -:  236:            }
        -:  237:        }
        -:  238:
       12:  239:      return OpenDDS::DCPS::DataWriterImpl::dispose(instance_handle,
       12:  240:                                                    source_timestamp);
        -:  241:    }
        -:  242:
       12:  243:  virtual DDS::ReturnCode_t get_key_value (
        -:  244:      MessageType & key_holder,
        -:  245:      DDS::InstanceHandle_t handle)
        -:  246:    {
       24:  247:      ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  248:                        guard,
        -:  249:                        get_lock (),
        -:  250:                        DDS::RETCODE_ERROR);
        -:  251:
       12:  252:      typename InstanceMap::iterator const the_end = instance_map_.end ();
       18:  253:      for (typename InstanceMap::iterator it = instance_map_.begin ();
       18:  254:           it != the_end;
        -:  255:           ++it)
        -:  256:        {
       18:  257:          if (it->second == handle)
        -:  258:            {
       12:  259:              key_holder = it->first;
       12:  260:              return DDS::RETCODE_OK;
        -:  261:            }
        -:  262:        }
        -:  263:
    #####:  264:      return DDS::RETCODE_BAD_PARAMETER;
        -:  265:    }
        -:  266:
    #####:  267:  virtual DDS::InstanceHandle_t lookup_instance (
        -:  268:      const MessageType & instance_data)
        -:  269:    {
    #####:  270:      ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  271:                        guard,
        -:  272:                        get_lock (),
        -:  273:                        DDS::RETCODE_ERROR);
        -:  274:
    #####:  275:      typename InstanceMap::const_iterator const it = instance_map_.find(instance_data);
        -:  276:
    #####:  277:      if (it == instance_map_.end())
        -:  278:        {
    #####:  279:          return DDS::HANDLE_NIL;
        -:  280:        }
        -:  281:      else
        -:  282:        {
    #####:  283:          return it->second;
        -:  284:        }
        -:  285:    }
        -:  286:
        -:  287:
        -:  288:  /**
        -:  289:   * Do parts of enable specific to the datatype.
        -:  290:   * Called by DataWriterImpl::enable().
        -:  291:   */
       12:  292:    virtual DDS::ReturnCode_t enable_specific ()
        -:  293:    {
       12:  294:      if (MarshalTraitsType::gen_is_bounded_size ())
        -:  295:        {
    #####:  296:          data_allocator_.reset(new DataAllocator (n_chunks_, marshaled_size_));
    #####:  297:          if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    #####:  298:            ACE_DEBUG((LM_DEBUG,
        -:  299:                       ACE_TEXT("(%P|%t) %CDataWriterImpl::")
        -:  300:                       ACE_TEXT("enable_specific-data")
        -:  301:                       ACE_TEXT(" Dynamic_Cached_Allocator_With_Overflow %x ")
        -:  302:                       ACE_TEXT("with %d chunks\n"),
        -:  303:                       TraitsType::type_name(),
        -:  304:                       data_allocator_.get(),
        -:  305:                       n_chunks_));
        -:  306:        }
        -:  307:      else
        -:  308:        {
       12:  309:          if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
    #####:  310:            ACE_DEBUG((LM_DEBUG,
        -:  311:                       ACE_TEXT("(%P|%t) %CDataWriterImpl::enable_specific")
        -:  312:                       ACE_TEXT(" is unbounded data - allocate from heap\n"), TraitsType::type_name()));
        -:  313:        }
        -:  314:
       24:  315:      mb_allocator_.reset(
       24:  316:        new ::OpenDDS::DCPS::MessageBlockAllocator (
       12:  317:                                                    n_chunks_ * association_chunk_multiplier_));
       12:  318:      db_allocator_.reset(new ::OpenDDS::DCPS::DataBlockAllocator (n_chunks_));
        -:  319:
       12:  320:      if (::OpenDDS::DCPS::DCPS_debug_level >= 2)
        -:  321:        {
    #####:  322:          ACE_DEBUG((LM_DEBUG,
        -:  323:                     ACE_TEXT("(%P|%t) %CDataWriterImpl::")
        -:  324:                     ACE_TEXT("enable_specific-mb ")
        -:  325:                     ACE_TEXT("Cached_Allocator_With_Overflow ")
        -:  326:                     ACE_TEXT("%x with %d chunks\n"),
        -:  327:                     TraitsType::type_name(),
        -:  328:                     mb_allocator_.get(),
        -:  329:                     n_chunks_ * association_chunk_multiplier_));
    #####:  330:          ACE_DEBUG((LM_DEBUG,
        -:  331:                     ACE_TEXT("(%P|%t) %CDataWriterImpl::")
        -:  332:                     ACE_TEXT("enable_specific-db ")
        -:  333:                     ACE_TEXT("Cached_Allocator_With_Overflow ")
        -:  334:                     ACE_TEXT("%x with %d chunks\n"),
        -:  335:                     TraitsType::type_name(),
        -:  336:                     db_allocator_.get(),
        -:  337:                     n_chunks_));
        -:  338:        }
        -:  339:
       12:  340:      return DDS::RETCODE_OK;
        -:  341:    }
        -:  342:
        -:  343:  /**
        -:  344:   * Accessor to the marshalled data sample allocator.
        -:  345:   */
        -:  346:  ACE_INLINE
        -:  347:  DataAllocator* data_allocator () const  {
        -:  348:    return data_allocator_.get();
        -:  349:  };
        -:  350:
        -:  351:private:
        -:  352:
        -:  353:  /**
        -:  354:   * Serialize the instance data.
        -:  355:   *
        -:  356:   * @param instance_data The data to serialize.
        -:  357:   * @param marshaling_type Enumerated type specifying whether to marshal
        -:  358:   *        just the keys or the entire message.
        -:  359:   * @return returns the serialized data.
        -:  360:   */
       36:  361:    ACE_Message_Block* dds_marshal(
        -:  362:                                   const MessageType& instance_data,
        -:  363:                                   OpenDDS::DCPS::MarshalingType marshaling_type)
        -:  364:    {
       36:  365:      const bool cdr = this->cdr_encapsulation(), swap = this->swap_bytes();
        -:  366:
       72:  367:      Message_Block_Ptr mb;
        -:  368:      ACE_Message_Block* tmp_mb;
        -:  369:
       36:  370:      if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
        -:  371:        // Don't use the cached allocator for the registered sample message
        -:  372:        // block.
        -:  373:
       18:  374:        OpenDDS::DCPS::KeyOnly<const MessageType > ko_instance_data(instance_data);
       18:  375:        size_t effective_size = 0, padding = 0;
       18:  376:        if (key_marshaled_size_) {
       18:  377:          effective_size = key_marshaled_size_;
        -:  378:        } else {
    #####:  379:          if (cdr && !Serializer::use_rti_serialization()) {
    #####:  380:            effective_size = cdr_header_size; // CDR encapsulation
        -:  381:          }
    #####:  382:          TraitsType::gen_find_size(ko_instance_data, effective_size, padding);
    #####:  383:          if (cdr && Serializer::use_rti_serialization()) {
    #####:  384:            effective_size += (cdr_header_size);
        -:  385:          }
        -:  386:        }
       18:  387:        if (cdr) {
    #####:  388:          effective_size += padding;
        -:  389:        }
        -:  390:
       18:  391:        ACE_NEW_RETURN(tmp_mb, ACE_Message_Block(effective_size,
        -:  392:                                             ACE_Message_Block::MB_DATA,
        -:  393:                                             0, //cont
        -:  394:                                             0, //data
        -:  395:                                             0, //alloc_strategy
        -:  396:                                             get_db_lock()), 0);
       18:  397:        mb.reset(tmp_mb);
       36:  398:        OpenDDS::DCPS::Serializer serializer(mb.get(), swap, cdr
        -:  399:                                             ? OpenDDS::DCPS::Serializer::ALIGN_CDR
        -:  400:                                             : OpenDDS::DCPS::Serializer::ALIGN_NONE);
       18:  401:        if (cdr) {
    #####:  402:          serializer << ACE_OutputCDR::from_octet(0);
    #####:  403:          serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
    #####:  404:          serializer << ACE_CDR::UShort(0);
        -:  405:        }
        -:  406:        // If this is RTI serialization, start counting byte offset AFTER
        -:  407:        // the header
       18:  408:        if (cdr && Serializer::use_rti_serialization()) {
        -:  409:          // Start counting byte-offset AFTER header
    #####:  410:          serializer.reset_alignment();
        -:  411:        }
       18:  412:        serializer << ko_instance_data;
        -:  413:      } else { // OpenDDS::DCPS::FULL_MARSHALING
       18:  414:        size_t effective_size = 0, padding = 0;
       18:  415:        if (marshaled_size_) {
    #####:  416:          effective_size = marshaled_size_;
        -:  417:        } else {
       18:  418:          if (cdr && !Serializer::use_rti_serialization()) {
    #####:  419:            effective_size = cdr_header_size; // CDR encapsulation
        -:  420:          }
       18:  421:          TraitsType::gen_find_size(instance_data, effective_size, padding);
       18:  422:          if (cdr && Serializer::use_rti_serialization()) {
    #####:  423:            effective_size += (cdr_header_size);
        -:  424:          }
        -:  425:        }
       18:  426:        if (cdr) {
    #####:  427:          effective_size += padding;
        -:  428:        }
        -:  429:
        -:  430:
       18:  431:        ACE_NEW_MALLOC_RETURN(tmp_mb,
        -:  432:                              static_cast<ACE_Message_Block*>(
        -:  433:                                                              mb_allocator_->malloc(
        -:  434:                                                                                    sizeof(ACE_Message_Block))),
        -:  435:                              ACE_Message_Block(
        -:  436:                                                effective_size,
        -:  437:                                                ACE_Message_Block::MB_DATA,
        -:  438:                                                0, //cont
        -:  439:                                                0, //data
        -:  440:                                                data_allocator_.get(), //allocator_strategy
        -:  441:                                                get_db_lock(), //data block locking_strategy
        -:  442:                                                ACE_DEFAULT_MESSAGE_BLOCK_PRIORITY,
        -:  443:                                                ACE_Time_Value::zero,
        -:  444:                                                ACE_Time_Value::max_time,
        -:  445:                                                db_allocator_.get(),
        -:  446:                                                mb_allocator_.get()),
        -:  447:                              0);
       18:  448:        mb.reset(tmp_mb);
       36:  449:        OpenDDS::DCPS::Serializer serializer(mb.get(), swap, cdr
        -:  450:                                             ? OpenDDS::DCPS::Serializer::ALIGN_CDR
        -:  451:                                             : OpenDDS::DCPS::Serializer::ALIGN_NONE);
       18:  452:        if (cdr) {
    #####:  453:          serializer << ACE_OutputCDR::from_octet(0);
    #####:  454:          serializer << ACE_OutputCDR::from_octet(swap ? !ACE_CDR_BYTE_ORDER : ACE_CDR_BYTE_ORDER);
    #####:  455:          serializer << ACE_CDR::UShort(0);
        -:  456:        }
        -:  457:        // If this is RTI serialization, start counting byte offset AFTER
        -:  458:        // the header
       18:  459:        if (cdr && Serializer::use_rti_serialization()) {
        -:  460:          // Start counting byte-offset AFTER header
    #####:  461:          serializer.reset_alignment();
        -:  462:        }
        -:  463:
       18:  464:        if (! (serializer << instance_data)) {
    #####:  465:          ACE_ERROR_RETURN((LM_ERROR,
        -:  466:            ACE_TEXT("(%P|%t) OpenDDS::DCPS::DataWriterImpl::dds_marshal(), ")
        -:  467:            ACE_TEXT("instance_data serialization error.\n")),
        -:  468:            0);
        -:  469:        }
        -:  470:      }
        -:  471:
       36:  472:      return mb.release();
        -:  473:    }
        -:  474:
        -:  475:  /**
        -:  476:   * Find the instance handle for the given instance_data using
        -:  477:   * the data type's key(s).  If the instance does not already exist
        -:  478:   * create a new instance handle for it.
        -:  479:   */
       18:  480:  DDS::ReturnCode_t get_or_create_instance_handle(
        -:  481:    DDS::InstanceHandle_t& handle,
        -:  482:    const MessageType& instance_data,
        -:  483:    const DDS::Time_t & source_timestamp)
        -:  484:    {
       36:  485:      ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex,
        -:  486:                       guard,
        -:  487:                       get_lock(),
        -:  488:                       DDS::RETCODE_ERROR);
        -:  489:
       18:  490:      handle = DDS::HANDLE_NIL;
       18:  491:      typename InstanceMap::const_iterator it = instance_map_.find(instance_data);
        -:  492:
       18:  493:      bool needs_creation = true;
       18:  494:      bool needs_registration = true;
        -:  495:
       18:  496:      if (it != instance_map_.end())
        -:  497:        {
    #####:  498:          needs_creation = false;
        -:  499:
    #####:  500:          handle = it->second;
    #####:  501:          OpenDDS::DCPS::PublicationInstance_rch instance = get_handle_instance(handle);
        -:  502:
    #####:  503:          if (instance->unregistered_ == false)
        -:  504:            {
    #####:  505:              needs_registration = false;
        -:  506:            }
        -:  507:          // else: The instance is unregistered and now register again.
        -:  508:        }
        -:  509:
       18:  510:      if (needs_registration)
        -:  511:        {
        -:  512:          // don't use fast allocator for registration.
       36:  513:          Message_Block_Ptr marshalled(
        -:  514:            this->dds_marshal(instance_data,
        -:  515:                              OpenDDS::DCPS::KEY_ONLY_MARSHALING));
        -:  516:
        -:  517:          // tell DataWriterLocal and Publisher about the instance.
       18:  518:          DDS::ReturnCode_t ret = register_instance_i(handle, move(marshalled), source_timestamp);
        -:  519:          // note: the WriteDataContainer/PublicationInstance maintains ownership
        -:  520:          // of the marshalled sample.
        -:  521:
       18:  522:          if (ret != DDS::RETCODE_OK)
        -:  523:            {
    #####:  524:              handle = DDS::HANDLE_NIL;
    #####:  525:              return ret;
        -:  526:            }
        -:  527:
       18:  528:          if (needs_creation)
        -:  529:            {
       18:  530:              std::pair<typename InstanceMap::iterator, bool> pair =
        -:  531:                instance_map_.insert(typename InstanceMap::value_type(instance_data, handle));
        -:  532:
       18:  533:              if (pair.second == false)
        -:  534:                {
    #####:  535:                  handle = DDS::HANDLE_NIL;
    #####:  536:                  ACE_ERROR_RETURN ((LM_ERROR,
        -:  537:                                     ACE_TEXT("(%P|%t) ")
        -:  538:                                     ACE_TEXT("%CDataWriterImpl::")
        -:  539:                                     ACE_TEXT("get_or_create_instance_handle, ")
        -:  540:                                     ACE_TEXT("insert %C failed. \n"),
        -:  541:                                     TraitsType::type_name(), TraitsType::type_name()),
        -:  542:                                    DDS::RETCODE_ERROR);
        -:  543:                }
        -:  544:            } // end of if (needs_creation)
        -:  545:
       18:  546:          send_all_to_flush_control(guard);
        -:  547:
        -:  548:        } // end of if (needs_registration)
        -:  549:
       18:  550:      return DDS::RETCODE_OK;
        -:  551:    }
        -:  552:
        -:  553:    InstanceMap  instance_map_;
        -:  554:    size_t       marshaled_size_;
        -:  555:    size_t       key_marshaled_size_;
        -:  556:    unique_ptr<DataAllocator> data_allocator_;
        -:  557:    unique_ptr<MessageBlockAllocator> mb_allocator_;
        -:  558:    unique_ptr<DataBlockAllocator>    db_allocator_;
        -:  559:
        -:  560:    // A class, normally provided by an unit test, that needs access to
        -:  561:    // private methods/members.
        -:  562:    friend class ::DDS_TEST;
        -:  563:  };
        -:  564:
        -:  565:  }
        -:  566:}
        -:  567:
        -:  568:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  569:
        -:  570:#endif /* dds_DCPS_DataWriterImpl_T_h */
