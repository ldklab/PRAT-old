        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Basic_String_Sequence_T.h
        -:    0:Programs:51
        -:    1:#ifndef guard_unbounded_basic_string_sequence_hpp
        -:    2:#define guard_unbounded_basic_string_sequence_hpp
        -:    3:/**
        -:    4: * @file
        -:    5: *
        -:    6: * @brief Implement unbounded sequences for strings and wide-strings.
        -:    7: *
        -:    8: * $Id: Unbounded_Basic_String_Sequence_T.h 1861 2011-08-31 16:18:08Z mesnierp $
        -:    9: *
        -:   10: * @author Carlos O'Ryan
        -:   11: */
        -:   12:#include "tao/Unbounded_Reference_Allocation_Traits_T.h"
        -:   13:#include "tao/String_Traits_T.h"
        -:   14:#include "tao/Generic_Sequence_T.h"
        -:   15:#include "tao/String_Sequence_Element_T.h"
        -:   16:#include "tao/String_Const_Sequence_Element_T.h"
        -:   17:#include "tao/MM_Sequence_Iterator_T.h"
        -:   18:
        -:   19:TAO_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   20:
        -:   21:namespace TAO
        -:   22:{
        -:   23:template<typename charT>
    #####:   24:class unbounded_basic_string_sequence
        -:   25:{
        -:   26:public:
        -:   27:  typedef charT character_type;
        -:   28:  typedef character_type * value_type;
        -:   29:  typedef character_type const * const_value_type;
        -:   30:  typedef ::CORBA::ULong size_type;
        -:   31:
        -:   32:  typedef details::string_traits<character_type,true> element_traits;
        -:   33:  typedef details::unbounded_reference_allocation_traits<value_type,element_traits,true> allocation_traits;
        -:   34:
        -:   35:  typedef details::string_sequence_element<element_traits> element_type;
        -:   36:  typedef details::string_const_sequence_element<element_traits> const_element_type;
        -:   37:
        -:   38:  typedef details::generic_sequence<value_type, allocation_traits, element_traits> implementation_type;
        -:   39:
        -:   40:  typedef element_type subscript_type;
        -:   41:  typedef const_value_type const_subscript_type;
        -:   42:
        -:   43:
        -:   44:  /// @copydoc TAO::details::generic_sequence::generic_sequence()
        -:   45:  inline unbounded_basic_string_sequence()
        -:   46:    : impl_()
        -:   47:  {}
        -:   48:
        -:   49:
        -:   50:  inline explicit unbounded_basic_string_sequence(CORBA::ULong maximum)
        -:   51:    : impl_(maximum)
        -:   52:  {}
        -:   53:  inline unbounded_basic_string_sequence(
        -:   54:      CORBA::ULong maximum,
        -:   55:      CORBA::ULong length,
        -:   56:      value_type * data,
        -:   57:      CORBA::Boolean release)
        -:   58:    : impl_(maximum, length, data, release)
        -:   59:  {}
        -:   60:
        -:   61:  /* Use default ctor, operator= and dtor */
        -:   62:
        -:   63:  /// @copydoc TAO::details::generic_sequence::maximum()
        -:   64:  inline CORBA::ULong maximum() const {
        -:   65:    return impl_.maximum();
        -:   66:  }
        -:   67:  /// @copydoc TAO::details::generic_sequence::release()
        -:   68:  inline CORBA::Boolean release() const {
        -:   69:    return impl_.release();
        -:   70:  }
        -:   71:  /// @copydoc TAO::details::generic_sequence::length()
        -:   72:  inline CORBA::ULong length() const {
        -:   73:    return impl_.length();
        -:   74:  }
        -:   75:  /// @copydoc TAO::details::generic_sequence::length()
        -:   76:  inline void length(CORBA::ULong length) {
        -:   77:    impl_.length(length);
        -:   78:  }
        -:   79:  /// @copydoc TAO::details::generic_sequence::operator[]
        -:   80:  inline const_element_type operator[](CORBA::ULong i) const {
        -:   81:    return const_element_type (impl_[i], release());
        -:   82:  }
        -:   83:  /// @copydoc TAO::details::generic_sequence::operator[]
        -:   84:  inline element_type operator[](CORBA::ULong i) {
        -:   85:    return element_type(impl_[i], release());
        -:   86:  }
        -:   87:  /// @copydoc TAO::details::generic_sequence::get_buffer()
        -:   88:  inline const_value_type const * get_buffer() const {
        -:   89:    return impl_.get_buffer();
        -:   90:  }
        -:   91:  /// @copydoc TAO::details::generic_sequence::replace()
        -:   92:  inline void replace(
        -:   93:      CORBA::ULong maximum,
        -:   94:      CORBA::ULong length,
        -:   95:      value_type * data,
        -:   96:      CORBA::Boolean release = false) {
        -:   97:    impl_.replace(maximum, length, data, release);
        -:   98:  }
        -:   99:  /// @copydoc TAO::details::generic_sequence::get_buffer(CORBA::Boolean)
        -:  100:  inline value_type * get_buffer(CORBA::Boolean orphan = false) {
        -:  101:    return impl_.get_buffer(orphan);
        -:  102:  }
        -:  103:  /// @copydoc TAO::details::generic_sequence::swap
        -:  104:  inline void swap(unbounded_basic_string_sequence & rhs) throw() {
        -:  105:    impl_.swap(rhs.impl_);
        -:  106:  }
        -:  107:
        -:  108:  static value_type * allocbuf(CORBA::ULong maximum)
        -:  109:  {
        -:  110:    return implementation_type::allocbuf(maximum);
        -:  111:  }
        -:  112:  static void freebuf(value_type * buffer)
        -:  113:  {
        -:  114:    implementation_type::freebuf(buffer);
        -:  115:  }
        -:  116:
        -:  117:
        -:  118:#if defined TAO_HAS_SEQUENCE_ITERATORS && TAO_HAS_SEQUENCE_ITERATORS == 1
        -:  119:
        -:  120:  ///
        -:  121:  /// Additions to support iterator semantics for TAO unbounded basic
        -:  122:  /// string sequences.
        -:  123:  ///
        -:  124:
        -:  125:  // = Traits and factory methods that create iterators.
        -:  126:  typedef MM_Sequence_Iterator<unbounded_basic_string_sequence<charT> > iterator;
        -:  127:  typedef Const_MM_Sequence_Iterator<unbounded_basic_string_sequence<charT> > const_iterator;
        -:  128:  typedef MM_Sequence_Reverse_Iterator<unbounded_basic_string_sequence<charT> > reverse_iterator;
        -:  129:  typedef Const_MM_Sequence_Reverse_Iterator<unbounded_basic_string_sequence<charT> > const_reverse_iterator;
        -:  130:
        -:  131:  /// Get an iterator that points to the beginning of the sequence.
        -:  132:  inline iterator begin (void)
        -:  133:  {
        -:  134:    return iterator (&this->impl_);
        -:  135:  }
        -:  136:
        -:  137:  /// Get a const iterator that points to the beginning of the sequence.
        -:  138:  inline const_iterator begin (void) const
        -:  139:  {
        -:  140:    return const_iterator (&this->impl_);
        -:  141:  }
        -:  142:
        -:  143:  /// Get an iterator that points to the end of the sequence.
        -:  144:  inline iterator end (void)
        -:  145:  {
        -:  146:    return iterator (&this->impl_,
        -:  147:                     this->impl_.length ());
        -:  148:  }
        -:  149:
        -:  150:  /// Get a const iterator that points to the end of the sequence.
        -:  151:  inline const_iterator end (void) const
        -:  152:  {
        -:  153:    return const_iterator (&this->impl_,
        -:  154:                           this->impl_.length ());
        -:  155:  }
        -:  156:
        -:  157:  /// Get a reverse iterator that points to the end of the sequence.
        -:  158:  inline reverse_iterator rbegin (void)
        -:  159:  {
        -:  160:    return reverse_iterator (&this->impl_,
        -:  161:                             this->impl_.length () - 1);
        -:  162:  }
        -:  163:
        -:  164:  /// Get a const reverse iterator that points to the end of the sequence.
        -:  165:  inline const_reverse_iterator rbegin (void) const
        -:  166:  {
        -:  167:    return const_reverse_iterator (&this->impl_,
        -:  168:                                   this->impl_.length () - 1);
        -:  169:  }
        -:  170:
        -:  171:  /// Get a reverse iterator that points to one before the beginning
        -:  172:  /// of the sequence.
        -:  173:  inline reverse_iterator rend (void)
        -:  174:  {
        -:  175:    return reverse_iterator (&this->impl_,
        -:  176:                             -1);
        -:  177:  }
        -:  178:
        -:  179:  /// Get a const reverse iterator that points to one before the
        -:  180:  /// beginning of the sequence.
        -:  181:  inline const_reverse_iterator rend (void) const
        -:  182:  {
        -:  183:    return const_reverse_iterator (&this->impl_,
        -:  184:                                   -1);
        -:  185:  }
        -:  186:
        -:  187:#endif /* TAO_HAS_SEQUENCE_ITERATORS==1 */
        -:  188:
        -:  189:private:
        -:  190:  implementation_type impl_;
        -:  191:};
        -:  192:
        -:  193:#if defined TAO_HAS_SEQUENCE_ITERATORS && TAO_HAS_SEQUENCE_ITERATORS == 1
        -:  194:/*
        -:  195:// Below is an attempt at template specialization that would
        -:  196:// not compile. It might be useful later.
        -:  197:// Generic_Sequence_Iterator template specializations for
        -:  198:// Unbounded_Basic_String_Sequence. These are needed since
        -:  199:// Unbounded_Basic_String_Sequence does some memory management with
        -:  200:// the strings. Without these specialization we leak memory.
        -:  201:
        -:  202:/// Dereference operator returns a reference to the item contained
        -:  203:/// at the current position. This dereference implies string
        -:  204:/// memory management.
        -:  205:// template<typename charT>
        -:  206:   unbounded_basic_string_sequence<char>::element_type&
        -:  207:     details::Generic_Sequence_Iterator<unbounded_basic_string_sequence<char>, unbounded_basic_string_sequence::allocation_traits, unbounded_basic_string_sequence::element_traits >::operator* (void)
        -:  208:     {
        -:  209:       // Access the underlying element in the sequence.
        -:  210:       //return element_type (impl_[i], release());
        -:  211:       return element_type ((*(this->sequence_))[this->pos_],
        -:  212:                            this->sequence_->release());
        -:  213:     }
        -:  214:
        -:  215: /// Returns a const reference to the item contained at the current position
        -:  216:   // template<typename charT>
        -:  217:   unbounded_basic_string_sequence<char>::const_element_type&
        -:  218:   details::Generic_Sequence_Iterator<unbounded_basic_string_sequence<char> >::operator* (void) const
        -:  219: {
        -:  220:   // Access the underlying element in the sequence.
        -:  221:   //return const_element_type (impl_[i], release());
        -:  222:   return const_element_type ((*(this->sequence_))[this->pos_],
        -:  223:                              this->sequence_->release ());
        -:  224: }
        -:  225:*/
        -:  226:#endif /* TAO_HAS_SEQUENCE_ITERATORS==1 */
        -:  227:
        -:  228:} // namespace TAO
        -:  229:
        -:  230:TAO_END_VERSIONED_NAMESPACE_DECL
        -:  231:
        -:  232:#endif // guard_unbounded_basic_string_sequence_hpp
