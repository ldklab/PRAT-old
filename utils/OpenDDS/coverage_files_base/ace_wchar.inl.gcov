        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/ace_wchar.inl
        -:    0:Programs:70
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id: ace_wchar.inl 2622 2015-08-13 18:30:00Z mitza $
        -:    4:
        -:    5:// These are always inlined
        -:    6:// FUZZ: disable check_for_inline
        -:    7:
        -:    8:#if defined (ACE_HAS_WCHAR)
        -:    9:
        -:   10:#if !defined (ACE_WIN32)
        -:   11:#  include /**/ <string.h>             // Need to see strlen()
        -:   12:#endif /* ACE_WIN32 */
        -:   13:
        -:   14:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   15:
        -:   16:inline
    #####:   17:ACE_Wide_To_Ascii::~ACE_Wide_To_Ascii (void)
        -:   18:{
    #####:   19:  delete [] this->s_;
    #####:   20:}
        -:   21:
        -:   22:inline char *
    #####:   23:ACE_Wide_To_Ascii::char_rep (void)
        -:   24:{
    #####:   25:  return this->s_;
        -:   26:}
        -:   27:
        -:   28:inline char *
    #####:   29:ACE_Wide_To_Ascii::convert (const wchar_t *wstr)
        -:   30:{
        -:   31:  // Short circuit null pointer case
    #####:   32:  if (wstr == 0)
    #####:   33:    return 0;
        -:   34:
        -:   35:# if defined (ACE_WIN32)
        -:   36:  UINT const cp = GetACP ();  // Codepage
        -:   37:  int const len = ::WideCharToMultiByte (cp,
        -:   38:                                         0,
        -:   39:                                         wstr,
        -:   40:                                         -1,
        -:   41:                                         0,
        -:   42:                                         0,
        -:   43:                                         0,
        -:   44:                                         0);
        -:   45:# elif defined (ACE_LACKS_WCSLEN)
        -:   46:  const wchar_t * wtemp = wstr;
        -:   47:  while ((*wtemp) != 0) // Hopefully the string is null terminated!
        -:   48:    ++wtemp;
        -:   49:
        -:   50:  size_t const len = wtemp - wstr + 1;
        -:   51:# else  /* ACE_WIN32 */
    #####:   52:  size_t const len = ::wcslen (wstr) + 1;
        -:   53:# endif /* ACE_WIN32 */
        -:   54:
        -:   55:#if !defined (ACE_HAS_ICONV)
    #####:   56:  char *str = new char[len];
        -:   57:#endif
        -:   58:
        -:   59:# if defined (ACE_WIN32)
        -:   60:  ::WideCharToMultiByte (cp, 0, wstr, -1, str, len, 0, 0);
        -:   61:# elif defined (ACE_VXWORKS)
        -:   62:  ::wcstombs (str, wstr, len);
        -:   63:# elif defined (ACE_HAS_ICONV)
        -:   64:  wchar_t * wstri = const_cast<wchar_t*> (wstr);
        -:   65:  size_t lensi = ACE_MAX_ICONV_BUFFER;
        -:   66:  size_t lenwi = len * sizeof(wchar_t);
        -:   67:  char buf[ACE_MAX_ICONV_BUFFER];
        -:   68:  char *stri = buf;
        -:   69:
        -:   70:  size_t hr = iconv (ACE_Wide_To_Ascii_iconv_env, (char**)&wstri, &lenwi, &stri, &lensi);
        -:   71:  if ((hr==size_t(-1))||(lensi==ACE_MAX_ICONV_BUFFER))
        -:   72:    {
        -:   73:      char *str=new char[len];
        -:   74:      for (size_t i = 0; i < len; i++)
        -:   75:        {
        -:   76:          wchar_t *t = const_cast <wchar_t *> (wstr);
        -:   77:          str[i] = static_cast<char> (*(t + i));
        -:   78:        }
        -:   79:
        -:   80:      return str;
        -:   81:    }
        -:   82:  char *str = new char[ACE_MAX_ICONV_BUFFER-lensi];
        -:   83:  ::memcpy(str, buf, ACE_MAX_ICONV_BUFFER-lensi);
        -:   84:# else /* ACE_HAS_ICONV */
    #####:   85:  for (size_t i = 0; i < len; ++i)
        -:   86:    {
    #####:   87:      wchar_t *t = const_cast <wchar_t *> (wstr);
    #####:   88:      str[i] = static_cast<char> (*(t + i));
        -:   89:    }
        -:   90:# endif /* ACE_WIN32 */
    #####:   91:  return str;
        -:   92:}
        -:   93:
        -:   94:inline
    #####:   95:ACE_Wide_To_Ascii::ACE_Wide_To_Ascii (const wchar_t *s)
        -:   96:{
        -:   97:#if defined(ACE_HAS_ICONV)
        -:   98:  if (ACE_Wide_To_Ascii_iconv_env == 0)
        -:   99:    {
        -:  100:      ACE_Wide_To_Ascii_iconv_env = iconv_open("", "WCHAR_T");
        -:  101:    }
        -:  102:#endif
    #####:  103:  s_ = ACE_Wide_To_Ascii::convert (s);
    #####:  104:}
        -:  105:
        -:  106:inline
        -:  107:ACE_Ascii_To_Wide::~ACE_Ascii_To_Wide (void)
        -:  108:{
        -:  109:  delete [] this->s_;
        -:  110:}
        -:  111:
        -:  112:inline wchar_t *
        -:  113:ACE_Ascii_To_Wide::wchar_rep (void)
        -:  114:{
        -:  115:  return this->s_;
        -:  116:}
        -:  117:
        -:  118:inline wchar_t *
        -:  119:ACE_Ascii_To_Wide::convert (const char *str)
        -:  120:{
        -:  121:  // Short circuit null pointer case
        -:  122:  if (str == 0)
        -:  123:    return 0;
        -:  124:
        -:  125:# if defined (ACE_WIN32)
        -:  126:  UINT const cp = GetACP ();  // Codepage
        -:  127:  int const len = ::MultiByteToWideChar (cp, 0, str, -1, 0, 0);
        -:  128:# else /* ACE_WIN32 */
        -:  129:  size_t const len = strlen (str) + 1;
        -:  130:# endif /* ACE_WIN32 */
        -:  131:
        -:  132:#if !defined (ACE_HAS_ICONV)
        -:  133:  wchar_t *wstr = new wchar_t[len];
        -:  134:#endif
        -:  135:
        -:  136:# if defined (ACE_WIN32)
        -:  137:  ::MultiByteToWideChar (cp, 0, str, -1, wstr, len);
        -:  138:# elif defined (ACE_VXWORKS)
        -:  139:  ::mbstowcs (wstr, str, len);
        -:  140:# elif defined (ACE_HAS_ICONV) /* ACE_VXWORKS */
        -:  141:  char *stri = const_cast<char*>(str);
        -:  142:  size_t lensi = len;
        -:  143:  size_t lenwi = ACE_MAX_ICONV_BUFFER;
        -:  144:  wchar_t buf[ACE_MAX_ICONV_BUFFER/sizeof(wchar_t)];
        -:  145:  wchar_t *wstri=buf;
        -:  146:
        -:  147:  size_t hr=iconv(ACE_Ascii_To_Wide_iconv_env, &stri, &lensi, (char**)&wstri, &lenwi);
        -:  148:  if((hr==size_t(-1))||(lenwi==ACE_MAX_ICONV_BUFFER)){
        -:  149:  wchar_t *wstr=new wchar_t[len*sizeof(wchar_t)];
        -:  150:  for (size_t i = 0; i < len; i++){
        -:  151:    char *t = const_cast<char *> (str);
        -:  152:    wstr[i] = static_cast<wchar_t> (*((unsigned char*)t + i));
        -:  153:  }
        -:  154:
        -:  155:  return wstr;
        -:  156:  }
        -:  157:  wchar_t *wstr=new wchar_t[(ACE_MAX_ICONV_BUFFER-lenwi)/sizeof(wchar_t)];
        -:  158:  ::memcpy(wstr,buf,ACE_MAX_ICONV_BUFFER-lenwi);
        -:  159:# else /* ACE_HAS_ICONV */
        -:  160:  for (size_t i = 0; i < len; ++i)
        -:  161:    {
        -:  162:      char *t = const_cast<char *> (str);
        -:  163:      wstr[i] = static_cast<wchar_t> (*((unsigned char*)(t + i)));
        -:  164:    }
        -:  165:# endif /* ACE_WIN32 */
        -:  166:  return wstr;
        -:  167:}
        -:  168:
        -:  169:inline
        -:  170:ACE_Ascii_To_Wide::ACE_Ascii_To_Wide (const char *s)
        -:  171:{
        -:  172:#if defined(ACE_HAS_ICONV)
        -:  173:  if (ACE_Ascii_To_Wide_iconv_env == 0)
        -:  174:    {
        -:  175:      ACE_Ascii_To_Wide_iconv_env = iconv_open("WCHAR_T", "");
        -:  176:    }
        -:  177:#endif
        -:  178:  s_ = ACE_Ascii_To_Wide::convert (s);
        -:  179:}
        -:  180:
        -:  181:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  182:
        -:  183:#endif /* ACE_HAS_WCHAR */
