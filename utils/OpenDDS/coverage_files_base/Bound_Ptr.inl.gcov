        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Bound_Ptr.inl
        -:    0:Programs:70
        -:    1:/* -*- C++ -*- */
        -:    2:// $Id: Bound_Ptr.inl 2622 2015-08-13 18:30:00Z mitza $
        -:    3:
        -:    4:#include "ace/Guard_T.h"
        -:    5:#if !defined (ACE_NEW_THROWS_EXCEPTIONS)
        -:    6:#  include "ace/Log_Category.h"
        -:    7:#endif /* ACE_NEW_THROWS_EXCEPTIONS */
        -:    8:
        -:    9:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   10:
        -:   11:template <class ACE_LOCK> inline ACE_Bound_Ptr_Counter<ACE_LOCK> *
    #####:   12:ACE_Bound_Ptr_Counter<ACE_LOCK>::internal_create (long init_obj_ref_count)
        -:   13:{
    #####:   14:  ACE_Bound_Ptr_Counter<ACE_LOCK> *temp = 0;
    #####:   15:  ACE_NEW_RETURN (temp,
        -:   16:                  ACE_Bound_Ptr_Counter<ACE_LOCK> (init_obj_ref_count),
        -:   17:                  0);
    #####:   18:  return temp;
        -:   19:}
        -:   20:
        -:   21:template <class ACE_LOCK> inline ACE_Bound_Ptr_Counter<ACE_LOCK> *
    #####:   22:ACE_Bound_Ptr_Counter<ACE_LOCK>::create_strong (void)
        -:   23:{
        -:   24:  // Set initial object reference count to 1.
    #####:   25:  ACE_Bound_Ptr_Counter<ACE_LOCK> *temp = internal_create (1);
        -:   26:#if defined (ACE_NEW_THROWS_EXCEPTIONS)
    #####:   27:  if (temp == 0)
    #####:   28:    ACE_throw_bad_alloc;
        -:   29:#else
        -:   30:  ACE_ASSERT (temp != 0);
        -:   31:#endif /* ACE_NEW_THROWS_EXCEPTIONS */
    #####:   32:  return temp;
        -:   33:}
        -:   34:
        -:   35:
        -:   36:
        -:   37:template <class ACE_LOCK> inline long
    #####:   38:ACE_Bound_Ptr_Counter<ACE_LOCK>::attach_strong (ACE_Bound_Ptr_Counter<ACE_LOCK>* counter)
        -:   39:{
    #####:   40:  ACE_GUARD_RETURN (ACE_LOCK, guard, counter->lock_, -1);
        -:   41:
        -:   42:  // Can't attach a strong pointer to an object that has already been deleted.
    #####:   43:  if (counter->obj_ref_count_ == -1)
    #####:   44:    return -1;
        -:   45:
    #####:   46:  long new_obj_ref_count = ++counter->obj_ref_count_;
    #####:   47:  ++counter->self_ref_count_;
        -:   48:
    #####:   49:  return new_obj_ref_count;
        -:   50:}
        -:   51:
        -:   52:template <class ACE_LOCK> inline long
    #####:   53:ACE_Bound_Ptr_Counter<ACE_LOCK>::detach_strong (ACE_Bound_Ptr_Counter<ACE_LOCK>* counter)
        -:   54:{
    #####:   55:  ACE_Bound_Ptr_Counter<ACE_LOCK> *counter_del = 0;
        -:   56:  long new_obj_ref_count;
        -:   57:
        -:   58:  {
    #####:   59:    ACE_GUARD_RETURN (ACE_LOCK, guard, counter->lock_, -1);
        -:   60:
    #####:   61:    if ((new_obj_ref_count = --counter->obj_ref_count_) == 0)
        -:   62:      // Change the object reference count to -1 to indicate that the
        -:   63:      // object has been deleted, as opposed to a weak pointer that
        -:   64:      // simply hasn't had any strong pointers created from it yet.
    #####:   65:      counter->obj_ref_count_ = -1;
        -:   66:
    #####:   67:    if (--counter->self_ref_count_ == 0)
        -:   68:      // Since counter contains the lock held by the guard, the
        -:   69:      // guard needs to be released before freeing the memory holding
        -:   70:      // the lock. So save the pointer to free, then release, then
        -:   71:      // free.
    #####:   72:      counter_del = counter;
        -:   73:
        -:   74:  }  // Release the lock
        -:   75:
    #####:   76:  delete counter_del;
        -:   77:
    #####:   78:  return new_obj_ref_count;
        -:   79:}
        -:   80:
        -:   81:template <class ACE_LOCK> inline ACE_Bound_Ptr_Counter<ACE_LOCK> *
        -:   82:ACE_Bound_Ptr_Counter<ACE_LOCK>::create_weak (void)
        -:   83:{
        -:   84:  // Set initial object reference count to 0.
        -:   85:
        -:   86:  ACE_Bound_Ptr_Counter<ACE_LOCK> *temp = internal_create (0);
        -:   87:#if defined (ACE_NEW_THROWS_EXCEPTIONS)
        -:   88:  if (temp == 0)
        -:   89:    ACE_throw_bad_alloc;
        -:   90:#else
        -:   91:  ACE_ASSERT (temp != 0);
        -:   92:#endif /* ACE_NEW_THROWS_EXCEPTIONS */
        -:   93:  return temp;
        -:   94:}
        -:   95:
        -:   96:template <class ACE_LOCK> inline void
        -:   97:ACE_Bound_Ptr_Counter<ACE_LOCK>::attach_weak (ACE_Bound_Ptr_Counter<ACE_LOCK>* counter)
        -:   98:{
        -:   99:  ACE_GUARD (ACE_LOCK, guard, counter->lock_);
        -:  100:
        -:  101:  ++counter->self_ref_count_;
        -:  102:}
        -:  103:
        -:  104:template <class ACE_LOCK> inline void
        -:  105:ACE_Bound_Ptr_Counter<ACE_LOCK>::detach_weak (ACE_Bound_Ptr_Counter<ACE_LOCK>* counter)
        -:  106:{
        -:  107:  ACE_Bound_Ptr_Counter<ACE_LOCK> *counter_del = 0;
        -:  108:
        -:  109:  {
        -:  110:    ACE_GUARD (ACE_LOCK, guard, counter->lock_);
        -:  111:
        -:  112:    if (--counter->self_ref_count_ == 0)
        -:  113:      // Since counter contains the lock held by the guard, the
        -:  114:      // guard needs to be released before freeing the memory holding
        -:  115:      // the lock. So save the pointer to free, then release, then
        -:  116:      // free.
        -:  117:      counter_del = counter;
        -:  118:
        -:  119:  }  // Release the lock
        -:  120:
        -:  121:  delete counter_del;
        -:  122:}
        -:  123:
        -:  124:template <class ACE_LOCK> inline bool
        -:  125:ACE_Bound_Ptr_Counter<ACE_LOCK>::object_was_deleted (ACE_Bound_Ptr_Counter<ACE_LOCK> *counter)
        -:  126:{
        -:  127:  ACE_GUARD_RETURN (ACE_LOCK, guard, counter->lock_, 0);
        -:  128:
        -:  129:  return counter->obj_ref_count_ == -1;
        -:  130:}
        -:  131:
        -:  132:template <class ACE_LOCK> inline
    #####:  133:ACE_Bound_Ptr_Counter<ACE_LOCK>::ACE_Bound_Ptr_Counter (long init_obj_ref_count)
        -:  134:  : obj_ref_count_ (init_obj_ref_count),
    #####:  135:    self_ref_count_ (1)
        -:  136:{
    #####:  137:}
        -:  138:
        -:  139:template <class ACE_LOCK> inline
    #####:  140:ACE_Bound_Ptr_Counter<ACE_LOCK>::~ACE_Bound_Ptr_Counter (void)
        -:  141:{
    #####:  142:}
        -:  143:
        -:  144:template <class X, class ACE_LOCK> inline
    #####:  145:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::ACE_Strong_Bound_Ptr (X *p)
    #####:  146:  : counter_ (COUNTER::create_strong ()),
    #####:  147:    ptr_ (p)
        -:  148:{
    #####:  149:}
        -:  150:
        -:  151:template <class X, class ACE_LOCK> inline
        -:  152:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::ACE_Strong_Bound_Ptr (auto_ptr<X> p)
        -:  153:  : counter_ (COUNTER::create_strong ()),
        -:  154:    ptr_ (p.release())
        -:  155:{
        -:  156:}
        -:  157:
        -:  158:template <class X, class ACE_LOCK> inline
    #####:  159:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::ACE_Strong_Bound_Ptr (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &r)
    #####:  160:  : counter_ (r.counter_),
    #####:  161:    ptr_ (r.ptr_)
        -:  162:{
    #####:  163:  COUNTER::attach_strong (this->counter_);
    #####:  164:}
        -:  165:
        -:  166:template <class X, class ACE_LOCK> inline
        -:  167:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::ACE_Strong_Bound_Ptr (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &r)
        -:  168:  : counter_ (r.counter_),
        -:  169:    ptr_ (r.ptr_)
        -:  170:{
        -:  171:  // When creating a strong pointer from a weak one we can't assume that the
        -:  172:  // underlying object still exists. Therefore we must check for a return value
        -:  173:  // of -1, which indicates that the object has been destroyed.
        -:  174:  if (COUNTER::attach_strong (this->counter_) == -1)
        -:  175:    {
        -:  176:      // Underlying object has already been deleted, so set this pointer to null.
        -:  177:      this->counter_ = COUNTER::create_strong ();
        -:  178:      this->ptr_ = 0;
        -:  179:    }
        -:  180:}
        -:  181:
        -:  182:template <class X, class ACE_LOCK> inline
    #####:  183:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::~ACE_Strong_Bound_Ptr (void)
        -:  184:{
    #####:  185:  if (COUNTER::detach_strong (this->counter_) == 0)
    #####:  186:    delete this->ptr_;
    #####:  187:}
        -:  188:
        -:  189:template <class X, class ACE_LOCK> inline void
    #####:  190:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator = (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &rhs)
        -:  191:{
        -:  192:  // This will work if &r == this, by first increasing the ref count, but
        -:  193:  // why go through all that?
    #####:  194:  if (&rhs == this)
    #####:  195:    return;
        -:  196:
    #####:  197:  COUNTER *new_counter = rhs.counter_;
    #####:  198:  X_t *new_ptr = rhs.ptr_;
    #####:  199:  COUNTER::attach_strong (new_counter);
    #####:  200:  if (COUNTER::detach_strong (this->counter_) == 0)
    #####:  201:    delete this->ptr_;
    #####:  202:  this->counter_ = new_counter;
    #####:  203:  this->ptr_ = new_ptr;
        -:  204:}
        -:  205:
        -:  206:template <class X, class ACE_LOCK> inline void
        -:  207:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator = (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &rhs)
        -:  208:{
        -:  209:  // This will work if &r == this, by first increasing the ref count, but
        -:  210:  // why go through all that?
        -:  211:  if (&rhs == this)
        -:  212:    return;
        -:  213:
        -:  214:  COUNTER *new_counter = rhs.counter_;
        -:  215:  X_t *new_ptr = rhs.ptr_;
        -:  216:
        -:  217:  // When creating a strong pointer from a weak one we can't assume that the
        -:  218:  // underlying object still exists. Therefore we must check for a return value
        -:  219:  // of -1, which indicates that the object has been destroyed.
        -:  220:  if (COUNTER::attach_strong (new_counter) == -1)
        -:  221:    {
        -:  222:      // Underlying object has already been deleted, so set this pointer to null.
        -:  223:      new_counter = COUNTER::create_strong ();
        -:  224:      new_ptr = 0;
        -:  225:    }
        -:  226:
        -:  227:  if (COUNTER::detach_strong (this->counter_) == 0)
        -:  228:    delete this->ptr_;
        -:  229:  this->counter_ = new_counter;
        -:  230:  this->ptr_ = new_ptr;
        -:  231:}
        -:  232:
        -:  233:template <class X, class ACE_LOCK> inline bool
        -:  234:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator== (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  235:{
        -:  236:  return this->ptr_ == r.ptr_;
        -:  237:}
        -:  238:
        -:  239:template <class X, class ACE_LOCK> inline bool
        -:  240:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator== (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  241:{
        -:  242:  // Use the weak pointer's operator== since it will check for null.
        -:  243:  return r == *this;
        -:  244:}
        -:  245:
        -:  246:template <class X, class ACE_LOCK> inline bool
        -:  247:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator== (X *p) const
        -:  248:{
        -:  249:  return this->ptr_ == p;
        -:  250:}
        -:  251:
        -:  252:template <class X, class ACE_LOCK> inline bool
        -:  253:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator!= (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  254:{
        -:  255:  return this->ptr_ != r.ptr_;
        -:  256:}
        -:  257:
        -:  258:template <class X, class ACE_LOCK> inline bool
        -:  259:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator!= (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  260:{
        -:  261:  // Use the weak pointer's operator!= since it will check for null.
        -:  262:  return r != *this;
        -:  263:}
        -:  264:
        -:  265:template <class X, class ACE_LOCK> inline bool
        -:  266:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator!= (X *p) const
        -:  267:{
        -:  268:  return this->ptr_ != p;
        -:  269:}
        -:  270:
        -:  271:template <class X, class ACE_LOCK> inline X *
        -:  272:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator-> (void) const
        -:  273:{
        -:  274:  return this->ptr_;
        -:  275:}
        -:  276:
        -:  277:template<class X, class ACE_LOCK> inline X &
        -:  278:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::operator *() const
        -:  279:{
        -:  280:  return *this->ptr_;
        -:  281:}
        -:  282:
        -:  283:template <class X, class ACE_LOCK> inline X*
        -:  284:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::get (void) const
        -:  285:{
        -:  286:  return this->ptr_;
        -:  287:}
        -:  288:
        -:  289:template <class X, class ACE_LOCK> inline bool
        -:  290:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::null (void) const
        -:  291:{
        -:  292:  return this->ptr_ == 0;
        -:  293:}
        -:  294:
        -:  295:template<class X, class ACE_LOCK> inline void
        -:  296:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::reset (X *p)
        -:  297:{
        -:  298:  COUNTER *old_counter = this->counter_;
        -:  299:  X_t *old_ptr = this->ptr_;
        -:  300:  this->counter_ = COUNTER::create_strong ();
        -:  301:  this->ptr_ = p;
        -:  302:  if (COUNTER::detach_strong (old_counter) == 0)
        -:  303:    delete old_ptr;
        -:  304:}
        -:  305:
        -:  306:template<class X, class ACE_LOCK> inline void
        -:  307:ACE_Strong_Bound_Ptr<X, ACE_LOCK>::reset (auto_ptr<X> p)
        -:  308:{
        -:  309:  COUNTER *old_counter = this->counter_;
        -:  310:  X_t *old_ptr = this->ptr_;
        -:  311:  this->counter_ = COUNTER::create_strong ();
        -:  312:  this->ptr_ = p.release ();
        -:  313:  if (COUNTER::detach_strong (old_counter) == 0)
        -:  314:    delete old_ptr;
        -:  315:}
        -:  316:
        -:  317:template <class X, class ACE_LOCK> inline
        -:  318:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::ACE_Weak_Bound_Ptr (X *p)
        -:  319:  : counter_ (COUNTER::create_weak ()),
        -:  320:    ptr_ (p)
        -:  321:{
        -:  322:}
        -:  323:
        -:  324:template <class X, class ACE_LOCK> inline
        -:  325:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::ACE_Weak_Bound_Ptr (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &r)
        -:  326:  : counter_ (r.counter_),
        -:  327:    ptr_ (r.ptr_)
        -:  328:{
        -:  329:  COUNTER::attach_weak (this->counter_);
        -:  330:}
        -:  331:
        -:  332:template <class X, class ACE_LOCK> inline
        -:  333:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::ACE_Weak_Bound_Ptr (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &r)
        -:  334:  : counter_ (r.counter_),
        -:  335:    ptr_ (r.ptr_)
        -:  336:{
        -:  337:  COUNTER::attach_weak (this->counter_);
        -:  338:}
        -:  339:
        -:  340:template <class X, class ACE_LOCK> inline
        -:  341:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::~ACE_Weak_Bound_Ptr (void)
        -:  342:{
        -:  343:  COUNTER::detach_weak (this->counter_);
        -:  344:}
        -:  345:
        -:  346:template <class X, class ACE_LOCK> inline void
        -:  347:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator = (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &rhs)
        -:  348:{
        -:  349:  // This will work if &rhs == this, by first increasing the ref count
        -:  350:  COUNTER *new_counter = rhs.counter_;
        -:  351:  COUNTER::attach_weak (new_counter);
        -:  352:  COUNTER::detach_weak (this->counter_);
        -:  353:  this->counter_ = new_counter;
        -:  354:  this->ptr_ = rhs.ptr_;
        -:  355:}
        -:  356:
        -:  357:template <class X, class ACE_LOCK> inline void
        -:  358:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator = (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &rhs)
        -:  359:{
        -:  360:  // This will work if &rhs == this, by first increasing the ref count
        -:  361:  COUNTER *new_counter = rhs.counter_;
        -:  362:  COUNTER::attach_weak (new_counter);
        -:  363:  COUNTER::detach_weak (this->counter_);
        -:  364:  this->counter_ = new_counter;
        -:  365:  this->ptr_ = rhs.ptr_;
        -:  366:}
        -:  367:
        -:  368:template <class X, class ACE_LOCK> inline bool
        -:  369:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator== (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  370:{
        -:  371:  // A weak pointer must behave as though it is automatically set to null
        -:  372:  // if the underlying object has been deleted.
        -:  373:  if (COUNTER::object_was_deleted (this->counter_))
        -:  374:    return r.ptr_ == 0;
        -:  375:
        -:  376:  return this->ptr_ == r.ptr_;
        -:  377:}
        -:  378:
        -:  379:template <class X, class ACE_LOCK> inline bool
        -:  380:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator== (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  381:{
        -:  382:  // A weak pointer must behave as though it is automatically set to null
        -:  383:  // if the underlying object has been deleted.
        -:  384:  if (COUNTER::object_was_deleted (this->counter_))
        -:  385:    return r.ptr_ == 0;
        -:  386:
        -:  387:  return this->ptr_ == r.ptr_;
        -:  388:}
        -:  389:
        -:  390:template <class X, class ACE_LOCK> inline bool
        -:  391:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator== (X *p) const
        -:  392:{
        -:  393:  // A weak pointer must behave as though it is automatically set to null
        -:  394:  // if the underlying object has been deleted.
        -:  395:  if (COUNTER::object_was_deleted (this->counter_))
        -:  396:    return p == 0;
        -:  397:
        -:  398:  return this->ptr_ == p;
        -:  399:}
        -:  400:
        -:  401:template <class X, class ACE_LOCK> inline bool
        -:  402:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator!= (const ACE_Weak_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  403:{
        -:  404:  // A weak pointer must behave as though it is automatically set to null
        -:  405:  // if the underlying object has been deleted.
        -:  406:  if (COUNTER::object_was_deleted (this->counter_))
        -:  407:    return r.ptr_ != 0;
        -:  408:
        -:  409:  return this->ptr_ != r.ptr_;
        -:  410:}
        -:  411:
        -:  412:template <class X, class ACE_LOCK> inline bool
        -:  413:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator!= (const ACE_Strong_Bound_Ptr<X, ACE_LOCK> &r) const
        -:  414:{
        -:  415:  // A weak pointer must behave as though it is automatically set to null
        -:  416:  // if the underlying object has been deleted.
        -:  417:  if (COUNTER::object_was_deleted (this->counter_))
        -:  418:    return r.ptr_ != 0;
        -:  419:
        -:  420:  return this->ptr_ != r.ptr_;
        -:  421:}
        -:  422:
        -:  423:template <class X, class ACE_LOCK> inline bool
        -:  424:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator!= (X *p) const
        -:  425:{
        -:  426:  // A weak pointer must behave as though it is automatically set to null
        -:  427:  // if the underlying object has been deleted.
        -:  428:  if (COUNTER::object_was_deleted (this->counter_))
        -:  429:    return p != 0;
        -:  430:
        -:  431:  return this->ptr_ != p;
        -:  432:}
        -:  433:
        -:  434:template <class X, class ACE_LOCK> inline ACE_Strong_Bound_Ptr<X, ACE_LOCK>
        -:  435:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::operator-> (void) const
        -:  436:{
        -:  437:  return ACE_Strong_Bound_Ptr<X, ACE_LOCK> (*this);
        -:  438:}
        -:  439:
        -:  440:template <class X, class ACE_LOCK> inline ACE_Strong_Bound_Ptr<X, ACE_LOCK>
        -:  441:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::strong (void) const
        -:  442:{
        -:  443:  return ACE_Strong_Bound_Ptr<X, ACE_LOCK> (*this);
        -:  444:}
        -:  445:
        -:  446:template <class X, class ACE_LOCK> inline X*
        -:  447:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::unsafe_get (void) const
        -:  448:{
        -:  449:  // We do not check if the object has been deleted, since this operation
        -:  450:  // is defined to be unsafe!
        -:  451:  return this->ptr_;
        -:  452:}
        -:  453:
        -:  454:template <class X, class ACE_LOCK> inline bool
        -:  455:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::null (void) const
        -:  456:{
        -:  457:  // A weak pointer must behave as though it is automatically set to null
        -:  458:  // if the underlying object has been deleted.
        -:  459:  if (COUNTER::object_was_deleted (this->counter_))
        -:  460:    return true;
        -:  461:
        -:  462:  return this->ptr_ == 0;
        -:  463:}
        -:  464:
        -:  465:template<class X, class ACE_LOCK> inline void
        -:  466:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::reset (X *p)
        -:  467:{
        -:  468:  COUNTER *old_counter = this->counter_;
        -:  469:  this->counter_ = COUNTER::create_weak ();
        -:  470:  this->ptr_ = p;
        -:  471:  COUNTER::detach_weak (old_counter);
        -:  472:}
        -:  473:
        -:  474:template<class X, class ACE_LOCK> inline long
        -:  475:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::add_ref ()
        -:  476:{
        -:  477:  return COUNTER::attach_strong (counter_);
        -:  478:}
        -:  479:
        -:  480:template<class X, class ACE_LOCK> inline long
        -:  481:ACE_Weak_Bound_Ptr<X, ACE_LOCK>::remove_ref ()
        -:  482:{
        -:  483:  long new_obj_ref_count = COUNTER::detach_strong (counter_);
        -:  484:  if (new_obj_ref_count == 0)
        -:  485:    {
        -:  486:      delete this->ptr_;
        -:  487:      this->ptr_ = 0;
        -:  488:    }
        -:  489:  return new_obj_ref_count;
        -:  490:}
        -:  491:
        -:  492:ACE_END_VERSIONED_NAMESPACE_DECL
