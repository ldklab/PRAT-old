        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Sequence_CDR_T.h
        -:    0:Programs:72
        -:    1:#ifndef guard_unbounded_sequence_cdr
        -:    2:#define guard_unbounded_sequence_cdr
        -:    3:/**
        -:    4: * @file
        -:    5: *
        -:    6: * @brief Extract the sequence
        -:    7: *
        -:    8: * $Id: Unbounded_Sequence_CDR_T.h 1861 2011-08-31 16:18:08Z mesnierp $
        -:    9: *
        -:   10: * @author Carlos O'Ryan
        -:   11: * @author Johnny Willemsen
        -:   12: */
        -:   13:
        -:   14:#include "tao/orbconf.h"
        -:   15:#include "tao/CORBA_String.h"
        -:   16:#include "tao/SystemException.h"
        -:   17:
        -:   18:TAO_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   19:
        -:   20:namespace TAO {
        -:   21:  template <typename stream>
        -:   22:  bool demarshal_sequence(stream & strm, unbounded_value_sequence <CORBA::Short> & target) {
        -:   23:    typedef TAO::unbounded_value_sequence <CORBA::Short> sequence;
        -:   24:    ::CORBA::ULong new_length = 0;
        -:   25:    if (!(strm >> new_length)) {
        -:   26:      return false;
        -:   27:    }
        -:   28:    if (new_length > strm.length()) {
        -:   29:      return false;
        -:   30:    }
        -:   31:    sequence tmp(new_length);
        -:   32:    tmp.length(new_length);
        -:   33:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:   34:    if (!strm.read_short_array (buffer, new_length)) {
        -:   35:      return false;
        -:   36:    }
        -:   37:    tmp.swap(target);
        -:   38:    return true;
        -:   39:  }
        -:   40:
        -:   41:  template <typename stream>
    #####:   42:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Long> & target) {
        -:   43:    typedef TAO::unbounded_value_sequence <CORBA::Long> sequence;
    #####:   44:    ::CORBA::ULong new_length = 0;
    #####:   45:    if (!(strm >> new_length)) {
    #####:   46:      return false;
        -:   47:    }
    #####:   48:    if (new_length > strm.length()) {
    #####:   49:      return false;
        -:   50:    }
    #####:   51:    sequence tmp(new_length);
    #####:   52:    tmp.length(new_length);
    #####:   53:    typename sequence::value_type * buffer = tmp.get_buffer();
    #####:   54:    if (!strm.read_long_array (buffer, new_length)) {
    #####:   55:      return false;
        -:   56:    }
    #####:   57:    tmp.swap(target);
    #####:   58:    return true;
        -:   59:  }
        -:   60:
        -:   61:  template <typename stream>
        -:   62:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::ULong> & target) {
        -:   63:    typedef TAO::unbounded_value_sequence <CORBA::ULong> sequence;
        -:   64:    ::CORBA::ULong new_length = 0;
        -:   65:    if (!(strm >> new_length)) {
        -:   66:      return false;
        -:   67:    }
        -:   68:    if (new_length > strm.length()) {
        -:   69:      return false;
        -:   70:    }
        -:   71:    sequence tmp(new_length);
        -:   72:    tmp.length(new_length);
        -:   73:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:   74:    if (!strm.read_ulong_array (buffer, new_length)) {
        -:   75:      return false;
        -:   76:    }
        -:   77:    tmp.swap(target);
        -:   78:    return true;
        -:   79:  }
        -:   80:
        -:   81:  template <typename stream>
        -:   82:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::UShort> & target) {
        -:   83:    typedef TAO::unbounded_value_sequence <CORBA::UShort> sequence;
        -:   84:    ::CORBA::ULong new_length = 0;
        -:   85:    if (!(strm >> new_length)) {
        -:   86:      return false;
        -:   87:    }
        -:   88:    if (new_length > strm.length()) {
        -:   89:      return false;
        -:   90:    }
        -:   91:    sequence tmp(new_length);
        -:   92:    tmp.length(new_length);
        -:   93:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:   94:    if (!strm.read_ushort_array (buffer, new_length)) {
        -:   95:      return false;
        -:   96:    }
        -:   97:    tmp.swap(target);
        -:   98:    return true;
        -:   99:  }
        -:  100:
        -:  101:#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
        -:  102:  template <typename stream>
      246:  103:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Octet> & target) {
        -:  104:    typedef TAO::unbounded_value_sequence <CORBA::Octet> sequence;
      246:  105:    ::CORBA::ULong new_length = 0;
      246:  106:    if (!(strm >> new_length)) {
    #####:  107:      return false;
        -:  108:    }
      246:  109:    if (new_length > strm.length()) {
    #####:  110:      return false;
        -:  111:    }
      492:  112:    sequence tmp(new_length);
      246:  113:    tmp.length(new_length);
      246:  114:    if (ACE_BIT_DISABLED (strm.start ()->flags (), ACE_Message_Block::DONT_DELETE))
        -:  115:    {
    #####:  116:      TAO_ORB_Core* orb_core = strm.orb_core ();
    #####:  117:      if (orb_core != 0 && strm.orb_core ()->resource_factory ()->
    #####:  118:        input_cdr_allocator_type_locked () == 1)
        -:  119:      {
    #####:  120:        tmp.replace (new_length, strm.start ());
    #####:  121:        tmp.mb ()->wr_ptr (tmp.mb()->rd_ptr () + new_length);
    #####:  122:        strm.skip_bytes (new_length);
    #####:  123:        tmp.swap(target);
    #####:  124:        return true;
        -:  125:      }
        -:  126:    }
      246:  127:    typename sequence::value_type * buffer = tmp.get_buffer();
      246:  128:    if (!strm.read_octet_array (buffer, new_length)) {
    #####:  129:      return false;
        -:  130:    }
      246:  131:    tmp.swap(target);
      246:  132:    return true;
        -:  133:  }
        -:  134:#else
        -:  135:  template <typename stream>
        -:  136:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Octet> & target) {
        -:  137:    typedef TAO::unbounded_value_sequence <CORBA::Octet> sequence;
        -:  138:    ::CORBA::ULong new_length = 0;
        -:  139:    if (!(strm >> new_length)) {
        -:  140:      return false;
        -:  141:    }
        -:  142:    if (new_length > strm.length()) {
        -:  143:      return false;
        -:  144:    }
        -:  145:    sequence tmp(new_length);
        -:  146:    tmp.length(new_length);
        -:  147:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  148:    if (!strm.read_octet_array (buffer, new_length)) {
        -:  149:      return false;
        -:  150:    }
        -:  151:    tmp.swap(target);
        -:  152:    return true;
        -:  153:  }
        -:  154:#endif
        -:  155:
        -:  156:  template <typename stream>
        -:  157:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Char> & target) {
        -:  158:    typedef TAO::unbounded_value_sequence <CORBA::Char> sequence;
        -:  159:    ::CORBA::ULong new_length = 0;
        -:  160:    if (!(strm >> new_length)) {
        -:  161:      return false;
        -:  162:    }
        -:  163:    if (new_length > strm.length()) {
        -:  164:      return false;
        -:  165:    }
        -:  166:    sequence tmp(new_length);
        -:  167:    tmp.length(new_length);
        -:  168:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  169:    if (!strm.read_char_array (buffer, new_length)) {
        -:  170:      return false;
        -:  171:    }
        -:  172:    tmp.swap(target);
        -:  173:    return true;
        -:  174:  }
        -:  175:
        -:  176:# if (defined (ACE_HAS_WCHAR) || defined (ACE_HAS_XPG4_MULTIBYTE_CHAR)) && !defined (ACE_LACKS_NATIVE_WCHAR_T)
        -:  177:  template <typename stream>
        -:  178:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::WChar> & target) {
        -:  179:    typedef TAO::unbounded_value_sequence <CORBA::WChar> sequence;
        -:  180:    ::CORBA::ULong new_length = 0;
        -:  181:    if (!(strm >> new_length)) {
        -:  182:      return false;
        -:  183:    }
        -:  184:    if (new_length > strm.length()) {
        -:  185:      return false;
        -:  186:    }
        -:  187:    sequence tmp(new_length);
        -:  188:    tmp.length(new_length);
        -:  189:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  190:    if (!strm.read_wchar_array (buffer, new_length)) {
        -:  191:      return false;
        -:  192:    }
        -:  193:    tmp.swap(target);
        -:  194:    return true;
        -:  195:  }
        -:  196:#endif
        -:  197:
        -:  198:  template <typename stream>
        -:  199:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Float> & target) {
        -:  200:    typedef TAO::unbounded_value_sequence <CORBA::Float> sequence;
        -:  201:    ::CORBA::ULong new_length = 0;
        -:  202:    if (!(strm >> new_length)) {
        -:  203:      return false;
        -:  204:    }
        -:  205:    if (new_length > strm.length()) {
        -:  206:      return false;
        -:  207:    }
        -:  208:    sequence tmp(new_length);
        -:  209:    tmp.length(new_length);
        -:  210:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  211:    if (!strm.read_float_array (buffer, new_length)) {
        -:  212:      return false;
        -:  213:    }
        -:  214:    tmp.swap(target);
        -:  215:    return true;
        -:  216:  }
        -:  217:
        -:  218:  template <typename stream>
        -:  219:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Double> & target) {
        -:  220:    typedef TAO::unbounded_value_sequence <CORBA::Double> sequence;
        -:  221:    ::CORBA::ULong new_length = 0;
        -:  222:    if (!(strm >> new_length)) {
        -:  223:      return false;
        -:  224:    }
        -:  225:    if (new_length > strm.length()) {
        -:  226:      return false;
        -:  227:    }
        -:  228:    sequence tmp(new_length);
        -:  229:    tmp.length(new_length);
        -:  230:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  231:    if (!strm.read_double_array (buffer, new_length)) {
        -:  232:      return false;
        -:  233:    }
        -:  234:    tmp.swap(target);
        -:  235:    return true;
        -:  236:  }
        -:  237:
        -:  238:  template <typename stream>
        -:  239:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::LongLong> & target) {
        -:  240:    typedef TAO::unbounded_value_sequence <CORBA::LongLong> sequence;
        -:  241:    ::CORBA::ULong new_length = 0;
        -:  242:    if (!(strm >> new_length)) {
        -:  243:      return false;
        -:  244:    }
        -:  245:    if (new_length > strm.length()) {
        -:  246:      return false;
        -:  247:    }
        -:  248:    sequence tmp(new_length);
        -:  249:    tmp.length(new_length);
        -:  250:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  251:    if (!strm.read_longlong_array (buffer, new_length)) {
        -:  252:      return false;
        -:  253:    }
        -:  254:    tmp.swap(target);
        -:  255:    return true;
        -:  256:  }
        -:  257:
        -:  258:  template <typename stream>
        -:  259:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::ULongLong> & target) {
        -:  260:    typedef TAO::unbounded_value_sequence <CORBA::ULongLong> sequence;
        -:  261:    ::CORBA::ULong new_length = 0;
        -:  262:    if (!(strm >> new_length)) {
        -:  263:      return false;
        -:  264:    }
        -:  265:    if (new_length > strm.length()) {
        -:  266:      return false;
        -:  267:    }
        -:  268:    sequence tmp(new_length);
        -:  269:    tmp.length(new_length);
        -:  270:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  271:    if (!strm.read_ulonglong_array (buffer, new_length)) {
        -:  272:      return false;
        -:  273:    }
        -:  274:    tmp.swap(target);
        -:  275:    return true;
        -:  276:  }
        -:  277:
        -:  278:  template <typename stream>
        -:  279:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::LongDouble> & target) {
        -:  280:    typedef TAO::unbounded_value_sequence <CORBA::LongDouble> sequence;
        -:  281:    ::CORBA::ULong new_length = 0;
        -:  282:    if (!(strm >> new_length)) {
        -:  283:      return false;
        -:  284:    }
        -:  285:    if (new_length > strm.length()) {
        -:  286:      return false;
        -:  287:    }
        -:  288:    sequence tmp(new_length);
        -:  289:    tmp.length(new_length);
        -:  290:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  291:    if (!strm.read_longdouble_array (buffer, new_length)) {
        -:  292:      return false;
        -:  293:    }
        -:  294:    tmp.swap(target);
        -:  295:    return true;
        -:  296:  }
        -:  297:
        -:  298:  template <typename stream>
        -:  299:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Boolean> & target) {
        -:  300:    typedef TAO::unbounded_value_sequence <CORBA::Boolean> sequence;
        -:  301:    ::CORBA::ULong new_length = 0;
        -:  302:    if (!(strm >> new_length)) {
        -:  303:      return false;
        -:  304:    }
        -:  305:    if (new_length > strm.length()) {
        -:  306:      return false;
        -:  307:    }
        -:  308:    sequence tmp(new_length);
        -:  309:    tmp.length(new_length);
        -:  310:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  311:    if (!strm.read_boolean_array (buffer, new_length)) {
        -:  312:      return false;
        -:  313:    }
        -:  314:    tmp.swap(target);
        -:  315:    return true;
        -:  316:  }
        -:  317:
        -:  318:  template <typename stream, typename value_t>
      108:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
        -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
      108:  321:    ::CORBA::ULong new_length = 0;
      108:  322:    if (!(strm >> new_length)) {
    #####:  323:      return false;
        -:  324:    }
      108:  325:    if (new_length > strm.length()) {
    #####:  326:      return false;
        -:  327:    }
      216:  328:    sequence tmp(new_length);
      108:  329:    tmp.length(new_length);
      108:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
      174:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
       66:  332:      if (!(strm >> buffer[i])) {
    #####:  333:        return false;
        -:  334:      }
        -:  335:    }
      108:  336:    tmp.swap(target);
      108:  337:    return true;
        -:  338:  }
        -:  339:
        -:  340:  template <typename stream, typename charT>
      102:  341:  bool demarshal_sequence(stream & strm, TAO::unbounded_basic_string_sequence <charT> & target) {
        -:  342:    typedef TAO::unbounded_basic_string_sequence <charT> sequence;
        -:  343:    typedef typename sequence::element_traits::string_var string_var;
        -:  344:    typedef typename sequence::allocation_traits sequence_allocation_traits;
      102:  345:    ::CORBA::ULong new_length = 0;
      102:  346:    if (!(strm >> new_length)) {
    #####:  347:      return false;
        -:  348:    }
      102:  349:    if (new_length > strm.length()) {
    #####:  350:      return false;
        -:  351:    }
      204:  352:    sequence tmp(new_length, new_length,
        -:  353:                 sequence_allocation_traits::allocbuf_noinit(new_length),
        -:  354:                 true);
      102:  355:    for(CORBA::ULong i = 0; i < new_length; ++i) {
    #####:  356:      string_var string;
    #####:  357:      if (!(strm >> string.inout ())) {
    #####:  358:        return false;
        -:  359:      }
        -:  360:      else {
    #####:  361:        tmp[i] = string._retn ();
        -:  362:      }
        -:  363:    }
      102:  364:    tmp.swap(target);
      102:  365:    return true;
        -:  366:  }
        -:  367:
        -:  368:  template <typename stream, typename charT, CORBA::ULong BD_STR_MAX>
        -:  369:  bool demarshal_sequence(stream & strm, TAO::unbounded_bd_string_sequence <charT, BD_STR_MAX> & target) {
        -:  370:    typedef TAO::unbounded_bd_string_sequence <charT, BD_STR_MAX> sequence;
        -:  371:    typedef typename sequence::element_traits::string_var string_var;
        -:  372:    typedef typename sequence::allocation_traits sequence_allocation_traits;
        -:  373:    ::CORBA::ULong new_length = 0;
        -:  374:    if (!(strm >> new_length)) {
        -:  375:      return false;
        -:  376:    }
        -:  377:    if (new_length > strm.length()) {
        -:  378:      return false;
        -:  379:    }
        -:  380:    sequence tmp(new_length, new_length,
        -:  381:                 sequence_allocation_traits::allocbuf_noinit(new_length),
        -:  382:                 true);
        -:  383:    for(CORBA::ULong i = 0; i < new_length; ++i) {
        -:  384:      string_var string;
        -:  385:      if (!(strm >> string.inout ())) {
        -:  386:        return false;
        -:  387:      }
        -:  388:      else {
        -:  389:        if (string.in () != 0 &&
        -:  390:            ACE_OS::strlen (string.in ()) > tmp.bd_string_maximum ()) {
        -:  391:          throw ::CORBA::BAD_PARAM ();
        -:  392:        }
        -:  393:        tmp[i] = string._retn ();
        -:  394:      }
        -:  395:    }
        -:  396:    tmp.swap(target);
        -:  397:    return true;
        -:  398:  }
        -:  399:
        -:  400:  template <typename stream, typename object_t, typename object_t_var>
        -:  401:  bool demarshal_sequence(stream & strm, TAO::unbounded_object_reference_sequence<object_t, object_t_var> & target) {
        -:  402:    typedef TAO::unbounded_object_reference_sequence<object_t, object_t_var> sequence;
        -:  403:    typedef typename sequence::allocation_traits sequence_allocation_traits;
        -:  404:    ::CORBA::ULong new_length = 0;
        -:  405:    if (!(strm >> new_length)) {
        -:  406:      return false;
        -:  407:    }
        -:  408:    if (new_length > strm.length()) {
        -:  409:      return false;
        -:  410:    }
        -:  411:    sequence tmp(new_length, new_length,
        -:  412:                 sequence_allocation_traits::allocbuf_noinit(new_length),
        -:  413:                 true);
        -:  414:    typename sequence::value_type * buffer = tmp.get_buffer();
        -:  415:    for(CORBA::ULong i = 0; i < new_length; ++i) {
        -:  416:      if (!(strm >> buffer[i])) {
        -:  417:        return false;
        -:  418:      }
        -:  419:    }
        -:  420:    tmp.swap(target);
        -:  421:    return true;
        -:  422:  }
        -:  423:}
        -:  424:
        -:  425:namespace TAO {
        -:  426:  template <typename stream>
        -:  427:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Short> & source) {
        -:  428:    ::CORBA::ULong const length = source.length ();
        -:  429:    if (!(strm << length)) {
        -:  430:      return false;
        -:  431:    }
        -:  432:    return strm.write_short_array (source.get_buffer (), length);
        -:  433:  }
        -:  434:
        -:  435:  template <typename stream>
    #####:  436:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Long> & source) {
    #####:  437:    ::CORBA::ULong const length = source.length ();
    #####:  438:    if (!(strm << length)) {
    #####:  439:      return false;
        -:  440:    }
    #####:  441:    return strm.write_long_array (source.get_buffer (), length);
        -:  442:  }
        -:  443:
        -:  444:  template <typename stream>
        -:  445:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::ULong> & source) {
        -:  446:    ::CORBA::ULong const length = source.length ();
        -:  447:    if (!(strm << length)) {
        -:  448:      return false;
        -:  449:    }
        -:  450:    return strm.write_ulong_array (source.get_buffer (), length);
        -:  451:  }
        -:  452:
        -:  453:  template <typename stream>
        -:  454:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::UShort> & source) {
        -:  455:    ::CORBA::ULong const length = source.length ();
        -:  456:    if (!(strm << length)) {
        -:  457:      return false;
        -:  458:    }
        -:  459:    return strm.write_ushort_array (source.get_buffer (), length);
        -:  460:  }
        -:  461:
        -:  462:#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
        -:  463:  template <typename stream>
      234:  464:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Octet> & source) {
      234:  465:    ::CORBA::ULong const length = source.length ();
      234:  466:    if (!(strm << length)) {
    #####:  467:      return false;
        -:  468:    }
      234:  469:    if (source.mb ()) {
    #####:  470:      return strm.write_octet_array_mb (source.mb ());
        -:  471:    }
      234:  472:    return strm.write_octet_array (source.get_buffer (), length);
        -:  473:  }
        -:  474:#else
        -:  475:  template <typename stream>
        -:  476:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Octet> & source) {
        -:  477:    ::CORBA::ULong const length = source.length ();
        -:  478:    if (!(strm << length)) {
        -:  479:      return false;
        -:  480:    }
        -:  481:    return strm.write_octet_array (source.get_buffer (), length);
        -:  482:  }
        -:  483:#endif
        -:  484:
        -:  485:  template <typename stream>
        -:  486:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Char> & source) {
        -:  487:    ::CORBA::ULong const length = source.length ();
        -:  488:    if (!(strm << length)) {
        -:  489:      return false;
        -:  490:    }
        -:  491:    return strm.write_char_array (source.get_buffer (), length);
        -:  492:  }
        -:  493:
        -:  494:# if (defined (ACE_HAS_WCHAR) || defined (ACE_HAS_XPG4_MULTIBYTE_CHAR)) && !defined (ACE_LACKS_NATIVE_WCHAR_T)
        -:  495:  template <typename stream>
        -:  496:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::WChar> & source) {
        -:  497:    ::CORBA::ULong const length = source.length ();
        -:  498:    if (!(strm << length)) {
        -:  499:      return false;
        -:  500:    }
        -:  501:    return strm.write_wchar_array (source.get_buffer (), length);
        -:  502:  }
        -:  503:#endif
        -:  504:
        -:  505:  template <typename stream>
        -:  506:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Float> & source) {
        -:  507:    ::CORBA::ULong const length = source.length ();
        -:  508:    if (!(strm << length)) {
        -:  509:      return false;
        -:  510:    }
        -:  511:    return strm.write_float_array (source.get_buffer (), length);
        -:  512:  }
        -:  513:
        -:  514:  template <typename stream>
        -:  515:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Double> & source) {
        -:  516:    ::CORBA::ULong const length = source.length ();
        -:  517:    if (!(strm << length)) {
        -:  518:      return false;
        -:  519:    }
        -:  520:    return strm.write_double_array (source.get_buffer (), length);
        -:  521:  }
        -:  522:
        -:  523:  template <typename stream>
        -:  524:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::LongLong> & source) {
        -:  525:    ::CORBA::ULong const length = source.length ();
        -:  526:    if (!(strm << length)) {
        -:  527:      return false;
        -:  528:    }
        -:  529:    return strm.write_longlong_array (source.get_buffer (), length);
        -:  530:  }
        -:  531:
        -:  532:  template <typename stream>
        -:  533:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::ULongLong> & source) {
        -:  534:    ::CORBA::ULong const length = source.length ();
        -:  535:    if (!(strm << length)) {
        -:  536:      return false;
        -:  537:    }
        -:  538:    return strm.write_ulonglong_array (source.get_buffer (), length);
        -:  539:  }
        -:  540:
        -:  541:  template <typename stream>
        -:  542:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::LongDouble> & source) {
        -:  543:    ::CORBA::ULong const length = source.length ();
        -:  544:    if (!(strm << length)) {
        -:  545:      return false;
        -:  546:    }
        -:  547:    return strm.write_longdouble_array (source.get_buffer (), length);
        -:  548:  }
        -:  549:
        -:  550:  template <typename stream>
        -:  551:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Boolean> & source) {
        -:  552:    ::CORBA::ULong const length = source.length ();
        -:  553:    if (!(strm << length)) {
        -:  554:      return false;
        -:  555:    }
        -:  556:    return strm.write_boolean_array (source.get_buffer (), length);
        -:  557:  }
        -:  558:
        -:  559:  template <typename stream, typename value_t>
      120:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
      120:  561:    ::CORBA::ULong const length = source.length ();
      120:  562:    if (!(strm << length)) {
    #####:  563:      return false;
        -:  564:    }
      204:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
       84:  566:      if (!(strm << source[i])) {
    #####:  567:        return false;
        -:  568:      }
        -:  569:    }
      120:  570:    return true;
        -:  571:  }
        -:  572:
        -:  573:  template <typename stream, typename charT>
       90:  574:  bool marshal_sequence(stream & strm, const TAO::unbounded_basic_string_sequence <charT> & source) {
       90:  575:    ::CORBA::ULong const length = source.length ();
       90:  576:    if (!(strm << length)) {
    #####:  577:      return false;
        -:  578:    }
       90:  579:    for(CORBA::ULong i = 0; i < length; ++i) {
    #####:  580:      if (!(strm << source[i])) {
    #####:  581:        return false;
        -:  582:      }
        -:  583:    }
       90:  584:    return true;
        -:  585:  }
        -:  586:
        -:  587:  template <typename stream, typename charT, CORBA::ULong BD_STR_MAX>
        -:  588:  bool marshal_sequence(stream & strm, const TAO::unbounded_bd_string_sequence <charT, BD_STR_MAX> & source) {
        -:  589:    ::CORBA::ULong const length = source.length ();
        -:  590:    if (!(strm << length)) {
        -:  591:      return false;
        -:  592:    }
        -:  593:    for(CORBA::ULong i = 0; i < length; ++i) {
        -:  594:      if (source[i].in () != 0 &&
        -:  595:          ACE_OS::strlen (source[i]) > source.bd_string_maximum ()) {
        -:  596:        throw ::CORBA::BAD_PARAM ();
        -:  597:      }
        -:  598:      if (!(strm << source[i])) {
        -:  599:        return false;
        -:  600:      }
        -:  601:    }
        -:  602:    return true;
        -:  603:  }
        -:  604:
        -:  605:  template <typename stream, typename object_t, typename object_t_var>
        -:  606:  bool marshal_sequence(stream & strm, const TAO::unbounded_object_reference_sequence<object_t, object_t_var> & source) {
        -:  607:    typedef typename TAO::unbounded_object_reference_sequence<object_t, object_t_var>::object_type objec_t;
        -:  608:    ::CORBA::ULong const length = source.length ();
        -:  609:    if (!(strm << length)) {
        -:  610:      return false;
        -:  611:    }
        -:  612:    for(CORBA::ULong i = 0; i < length; ++i) {
        -:  613:      if (!TAO::Objref_Traits<objec_t>::marshal (source[i], strm)) {
        -:  614:        return false;
        -:  615:      }
        -:  616:    }
        -:  617:    return true;
        -:  618:  }
        -:  619:} // namespace TAO
        -:  620:
        -:  621:TAO_END_VERSIONED_NAMESPACE_DECL
        -:  622:
        -:  623:#endif /* guard_unbounded_sequence_cdr */
