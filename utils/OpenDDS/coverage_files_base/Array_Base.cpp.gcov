        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Array_Base.cpp
        -:    0:Programs:72
        -:    1:// $Id: Array_Base.cpp 935 2008-12-10 21:47:27Z mitza $
        -:    2:
        -:    3:#ifndef ACE_ARRAY_BASE_CPP
        -:    4:#define ACE_ARRAY_BASE_CPP
        -:    5:
        -:    6:#include "ace/Array_Base.h"
        -:    7:
        -:    8:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:    9:# pragma once
        -:   10:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   11:
        -:   12:#if !defined (__ACE_INLINE__)
        -:   13:#include "ace/Array_Base.inl"
        -:   14:#endif /* __ACE_INLINE__ */
        -:   15:
        -:   16:#include "ace/Malloc_Base.h"
        -:   17:#include "ace/os_include/os_errno.h"
        -:   18:
        -:   19:#include <algorithm>
        -:   20:
        -:   21:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   22:
        -:   23:// Dynamically initialize an array.
        -:   24:template <class T>
    #####:   25:ACE_Array_Base<T>::ACE_Array_Base (typename ACE_Array_Base<T>::size_type size,
        -:   26:                                   ACE_Allocator *alloc)
        -:   27:  : max_size_ (size),
        -:   28:    cur_size_ (size),
    #####:   29:    allocator_ (alloc)
        -:   30:{
    #####:   31:  if (this->allocator_ == 0)
    #####:   32:    this->allocator_ = ACE_Allocator::instance ();
        -:   33:
    #####:   34:  if (size != 0)
        -:   35:    {
    #####:   36:      ACE_ALLOCATOR (this->array_,
        -:   37:                     (T *) this->allocator_->malloc (size * sizeof (T)));
    #####:   38:      for (size_type i = 0; i < size; ++i)
    #####:   39:        new (&array_[i]) T;
        -:   40:    }
        -:   41:  else
    #####:   42:    this->array_ = 0;
        -:   43:}
        -:   44:
        -:   45:template <class T>
        -:   46:ACE_Array_Base<T>::ACE_Array_Base (typename ACE_Array_Base<T>::size_type size,
        -:   47:                                   const T &default_value,
        -:   48:                                   ACE_Allocator *alloc)
        -:   49:  : max_size_ (size),
        -:   50:    cur_size_ (size),
        -:   51:    allocator_ (alloc)
        -:   52:{
        -:   53:  if (this->allocator_ == 0)
        -:   54:    this->allocator_ = ACE_Allocator::instance ();
        -:   55:
        -:   56:  if (size != 0)
        -:   57:    {
        -:   58:      ACE_ALLOCATOR (this->array_,
        -:   59:                     (T *) this->allocator_->malloc (size * sizeof (T)));
        -:   60:      for (size_type i = 0; i < size; ++i)
        -:   61:        new (&array_[i]) T (default_value);
        -:   62:    }
        -:   63:  else
        -:   64:    this->array_ = 0;
        -:   65:}
        -:   66:
        -:   67:// The copy constructor (performs initialization).
        -:   68:
        -:   69:template <class T>
        -:   70:ACE_Array_Base<T>::ACE_Array_Base (const ACE_Array_Base<T> &s)
        -:   71:  : max_size_ (s.size ()),
        -:   72:    cur_size_ (s.size ()),
        -:   73:    allocator_ (s.allocator_)
        -:   74:{
        -:   75:  if (this->allocator_ == 0)
        -:   76:    this->allocator_ = ACE_Allocator::instance ();
        -:   77:
        -:   78:  ACE_ALLOCATOR (this->array_,
        -:   79:                 (T *) this->allocator_->malloc (s.size () * sizeof (T)));
        -:   80:  for (size_type i = 0; i < this->size (); ++i)
        -:   81:    new (&this->array_[i]) T (s.array_[i]);
        -:   82:}
        -:   83:
        -:   84:// Assignment operator (performs assignment).
        -:   85:
        -:   86:template <class T> void
        -:   87:ACE_Array_Base<T>::operator= (const ACE_Array_Base<T> &s)
        -:   88:{
        -:   89:  // Check for "self-assignment".
        -:   90:
        -:   91:  if (this != &s)
        -:   92:    {
        -:   93:      if (this->max_size_ < s.size ())
        -:   94:        {
        -:   95:          // Need to reallocate memory.
        -:   96:
        -:   97:          // Strongly exception-safe assignment.
        -:   98:          //
        -:   99:          // Note that we're swapping the allocators here, too.
        -:  100:          // Should we?  Probably.  "*this" should be a duplicate of
        -:  101:          // the "right hand side".
        -:  102:          ACE_Array_Base<T> tmp (s);
        -:  103:          this->swap (tmp);
        -:  104:        }
        -:  105:      else
        -:  106:        {
        -:  107:          // Underlying array is large enough.  No need to reallocate
        -:  108:          // memory.
        -:  109:          //
        -:  110:          // "*this" still owns the memory for the underlying array.
        -:  111:          // Do not swap out the allocator.
        -:  112:          //
        -:  113:          // @@ Why don't we just drop the explicit destructor and
        -:  114:          //    placement operator new() calls with a straight
        -:  115:          //    element-by-element assignment?  Is the existing
        -:  116:          //    approach more efficient?
        -:  117:          //        -Ossama
        -:  118:
        -:  119:          ACE_DES_ARRAY_NOFREE (this->array_,
        -:  120:                                s.size (),
        -:  121:                                T);
        -:  122:
        -:  123:          this->cur_size_ = s.size ();
        -:  124:
        -:  125:          for (size_type i = 0; i < this->size (); ++i)
        -:  126:            new (&this->array_[i]) T (s.array_[i]);
        -:  127:        }
        -:  128:    }
        -:  129:}
        -:  130:
        -:  131:// Set an item in the array at location slot.
        -:  132:
        -:  133:template <class T> int
        -:  134:ACE_Array_Base<T>::set (const T &new_item,
        -:  135:                        typename ACE_Array_Base<T>::size_type slot)
        -:  136:{
        -:  137:  if (this->in_range (slot))
        -:  138:    {
        -:  139:      this->array_[slot] = new_item;
        -:  140:      return 0;
        -:  141:    }
        -:  142:  else
        -:  143:    return -1;
        -:  144:}
        -:  145:
        -:  146:// Get an item in the array at location slot.
        -:  147:
        -:  148:template <class T> int
        -:  149:ACE_Array_Base<T>::get (T &item,
        -:  150:                        typename ACE_Array_Base<T>::size_type slot) const
        -:  151:{
        -:  152:  if (this->in_range (slot))
        -:  153:    {
        -:  154:      // Copies the item.  If you don't want to copy, use operator []
        -:  155:      // instead (but then you'll be responsible for range checking).
        -:  156:      item = this->array_[slot];
        -:  157:      return 0;
        -:  158:    }
        -:  159:  else
        -:  160:    return -1;
        -:  161:}
        -:  162:
        -:  163:template<class T> int
    #####:  164:ACE_Array_Base<T>::max_size (typename ACE_Array_Base<T>::size_type new_size)
        -:  165:{
    #####:  166:  if (new_size > this->max_size_)
        -:  167:    {
    #####:  168:      T *tmp = 0;
        -:  169:
    #####:  170:      ACE_ALLOCATOR_RETURN (tmp,
        -:  171:                            (T *) this->allocator_->malloc (new_size * sizeof (T)),
        -:  172:                            -1);
    #####:  173:      for (size_type i = 0; i < this->cur_size_; ++i)
    #####:  174:        new (&tmp[i]) T (this->array_[i]);
        -:  175:
        -:  176:      // Initialize the new portion of the array that exceeds the
        -:  177:      // previously allocated section.
    #####:  178:      for (size_type j = this->cur_size_; j < new_size; ++j)
    #####:  179:        new (&tmp[j]) T;
        -:  180:
    #####:  181:      ACE_DES_ARRAY_FREE (this->array_,
        -:  182:                          this->max_size_,
        -:  183:                          this->allocator_->free,
        -:  184:                          T);
    #####:  185:      this->array_ = tmp;
    #####:  186:      this->max_size_ = new_size;
    #####:  187:      this->cur_size_ = new_size;
        -:  188:    }
        -:  189:
    #####:  190:  return 0;
        -:  191:}
        -:  192:
        -:  193:template<class T> int
    #####:  194:ACE_Array_Base<T>::size (typename ACE_Array_Base<T>::size_type new_size)
        -:  195:{
    #####:  196:  int const r = this->max_size (new_size);
        -:  197:
    #####:  198:  if (r == 0)
    #####:  199:    this->cur_size_ = new_size;
        -:  200:
    #####:  201:  return r;
        -:  202:}
        -:  203:
        -:  204:template<class T>
        -:  205:void
    #####:  206:ACE_Array_Base<T>::swap (ACE_Array_Base<T> & rhs)
        -:  207:{
    #####:  208:  std::swap (this->max_size_ , rhs.max_size_);
    #####:  209:  std::swap (this->cur_size_ , rhs.cur_size_);
    #####:  210:  std::swap (this->array_    , rhs.array_);
    #####:  211:  std::swap (this->allocator_, rhs.allocator_);
    #####:  212:}
        -:  213:
        -:  214:// ****************************************************************
        -:  215:
        -:  216:template <class T> int
        -:  217:ACE_Array_Iterator<T>::next (T *&item)
        -:  218:{
        -:  219:  // ACE_TRACE ("ACE_Array_Iterator<T>::next");
        -:  220:
        -:  221:  if (this->done ())
        -:  222:    {
        -:  223:      item = 0;
        -:  224:      return 0;
        -:  225:    }
        -:  226:  else
        -:  227:    {
        -:  228:      item = &array_[current_];
        -:  229:      return 1;
        -:  230:    }
        -:  231:}
        -:  232:
        -:  233:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  234:
        -:  235:#endif /* ACE_ARRAY_BASE_CPP */
