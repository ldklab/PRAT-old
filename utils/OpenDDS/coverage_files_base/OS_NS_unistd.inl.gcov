        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/OS_NS_unistd.inl
        -:    0:Programs:70
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id: OS_NS_unistd.inl 2622 2015-08-13 18:30:00Z mitza $
        -:    4:
        -:    5:#include "ace/OS_NS_sys_utsname.h"
        -:    6:#include "ace/OS_NS_string.h"
        -:    7:#include "ace/OS_NS_errno.h"
        -:    8:#include "ace/OS_NS_macros.h"
        -:    9:#include "ace/OS_NS_fcntl.h"
        -:   10:#include "ace/Default_Constants.h"
        -:   11:#include "ace/OS_Memory.h"
        -:   12:#include "ace/Truncate.h"
        -:   13:
        -:   14:#if defined (ACE_HAS_CLOCK_GETTIME)
        -:   15:# include "ace/os_include/os_time.h"
        -:   16:#endif /* ACE_HAS_CLOCK_GETTIME */
        -:   17:
        -:   18:#if defined (ACE_LACKS_ACCESS)
        -:   19:#  include "ace/OS_NS_stdio.h"
        -:   20:#endif /* ACE_LACKS_ACCESS */
        -:   21:
        -:   22:#if defined (ACE_HAS_ACCESS_EMULATION)
        -:   23:#  include "ace/os_include/os_unistd.h"
        -:   24:#endif /* ACE_HAS_ACCESS_EMULATION */
        -:   25:
        -:   26:#if defined (ACE_VXWORKS) && (ACE_VXWORKS <= 0x690)
        -:   27:#  if defined (__RTP__)
        -:   28:#    include "ace/os_include/os_strings.h"
        -:   29:#  else
        -:   30:#    include "ace/os_include/os_string.h"
        -:   31:#  endif
        -:   32:#endif
        -:   33:
        -:   34:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   35:
        -:   36:ACE_INLINE int
        -:   37:ACE_OS::access (const char *path, int amode)
        -:   38:{
        -:   39:  ACE_OS_TRACE ("ACE_OS::access");
        -:   40:#if defined (ACE_LACKS_ACCESS)
        -:   41:#  if defined (ACE_HAS_ACCESS_EMULATION)
        -:   42:  // @@ WINCE: There should be a Win32 API that can do this.
        -:   43:  // Hard coded read access here.
        -:   44:  ACE_UNUSED_ARG (amode);
        -:   45:  FILE* handle = ACE_OS::fopen (ACE_TEXT_CHAR_TO_TCHAR(path),
        -:   46:                                ACE_TEXT ("r"));
        -:   47:  if (handle != 0)
        -:   48:    {
        -:   49:      ACE_OS::fclose (handle);
        -:   50:      return 0;
        -:   51:    }
        -:   52:  return -1;
        -:   53:#  else
        -:   54:    ACE_UNUSED_ARG (path);
        -:   55:    ACE_UNUSED_ARG (amode);
        -:   56:    ACE_NOTSUP_RETURN (-1);
        -:   57:#  endif  /* ACE_HAS_ACCESS_EMULATION */
        -:   58:#elif defined(ACE_WIN32)
        -:   59:  // Windows doesn't support checking X_OK(6)
        -:   60:  ACE_OSCALL_RETURN (::access (path, amode & 6), int, -1);
        -:   61:#else
        -:   62:  ACE_OSCALL_RETURN (::access (path, amode), int, -1);
        -:   63:#endif /* ACE_LACKS_ACCESS */
        -:   64:}
        -:   65:
        -:   66:
        -:   67:#if defined (ACE_HAS_WCHAR)
        -:   68:ACE_INLINE int
        -:   69:ACE_OS::access (const wchar_t *path, int amode)
        -:   70:{
        -:   71:#if defined (ACE_WIN32) && !defined (ACE_LACKS__WACCESS)
        -:   72:  ACE_OSCALL_RETURN (::_waccess (path, amode), int, -1);
        -:   73:#else /* ACE_WIN32 && !ACE_HAS_WINCE */
        -:   74:  return ACE_OS::access (ACE_Wide_To_Ascii (path).char_rep (), amode);
        -:   75:#endif /* ACE_WIN32 && !ACE_LACKS__WACCESS */
        -:   76:}
        -:   77:#endif /* ACE_HAS_WCHAR */
        -:   78:
        -:   79:ACE_INLINE u_int
        -:   80:ACE_OS::alarm (u_int secs)
        -:   81:{
        -:   82:  ACE_OS_TRACE ("ACE_OS::alarm");
        -:   83:#if defined (ACE_LACKS_ALARM)
        -:   84:  ACE_UNUSED_ARG (secs);
        -:   85:  ACE_NOTSUP_RETURN (0);
        -:   86:#else
        -:   87:  return ::alarm (secs);
        -:   88:#endif /* ACE_LACKS_ALARM */
        -:   89:}
        -:   90:
        -:   91:ACE_INLINE long
        -:   92:ACE_OS::getpagesize (void)
        -:   93:{
        -:   94:  ACE_OS_TRACE ("ACE_OS::getpagesize");
        -:   95:#if defined (ACE_WIN32) && !defined (ACE_HAS_PHARLAP)
        -:   96:  SYSTEM_INFO sys_info;
        -:   97:  ::GetSystemInfo (&sys_info);
        -:   98:  return (long) sys_info.dwPageSize;
        -:   99:#elif defined (_SC_PAGESIZE) && !defined (ACE_HAS_NOTSUP_SC_PAGESIZE)
        -:  100:  return ::sysconf (_SC_PAGESIZE);
        -:  101:#elif defined (ACE_HAS_GETPAGESIZE)
        -:  102:  return ::getpagesize ();
        -:  103:#else
        -:  104:  // Use the default set in config.h
        -:  105:  return ACE_PAGE_SIZE;
        -:  106:#endif /* ACE_WIN32 */
        -:  107:}
        -:  108:
        -:  109:ACE_INLINE long
        -:  110:ACE_OS::allocation_granularity (void)
        -:  111:{
        -:  112:#if defined (ACE_WIN32)
        -:  113:  SYSTEM_INFO sys_info;
        -:  114:  ::GetSystemInfo (&sys_info);
        -:  115:  return sys_info.dwAllocationGranularity;
        -:  116:#else
        -:  117:  return ACE_OS::getpagesize ();
        -:  118:#endif /* ACE_WIN32 */
        -:  119:}
        -:  120:
        -:  121:ACE_INLINE int
    #####:  122:ACE_OS::chdir (const char *path)
        -:  123:{
        -:  124:  ACE_OS_TRACE ("ACE_OS::chdir");
        -:  125:#if defined (ACE_LACKS_CHDIR)
        -:  126:  ACE_UNUSED_ARG (path);
        -:  127:  ACE_NOTSUP_RETURN (-1);
        -:  128:#elif defined (ACE_HAS_NONCONST_CHDIR)
        -:  129:  ACE_OSCALL_RETURN (::chdir (const_cast<char *> (path)), int, -1);
        -:  130:#else
    #####:  131:  ACE_OSCALL_RETURN (::chdir (path), int, -1);
        -:  132:#endif /* ACE_HAS_NONCONST_CHDIR */
        -:  133:}
        -:  134:
        -:  135:#if defined (ACE_HAS_WCHAR)
        -:  136:ACE_INLINE int
        -:  137:ACE_OS::chdir (const wchar_t *path)
        -:  138:{
        -:  139:#if defined (ACE_LACKS_CHDIR)
        -:  140:  ACE_UNUSED_ARG (path);
        -:  141:  ACE_NOTSUP_RETURN (-1);
        -:  142:#elif defined (ACE_WIN32)
        -:  143:  ACE_OSCALL_RETURN (::_wchdir (path), int, -1);
        -:  144:#else /* ACE_WIN32 */
        -:  145:  return ACE_OS::chdir (ACE_Wide_To_Ascii (path).char_rep ());
        -:  146:#endif /* ACE_WIN32 */
        -:  147:}
        -:  148:#endif /* ACE_HAS_WCHAR */
        -:  149:
        -:  150:ACE_INLINE int
    #####:  151:ACE_OS::rmdir (const char *path)
        -:  152:{
        -:  153:#if defined (ACE_HAS_WINCE)
        -:  154:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::RemoveDirectory (ACE_TEXT_CHAR_TO_TCHAR(path)),
        -:  155:                                          ace_result_),
        -:  156:                        int, -1);
        -:  157:#else
    #####:  158:  ACE_OSCALL_RETURN (::rmdir (path), int, -1);
        -:  159:#endif /* ACE_WIN32 */
        -:  160:}
        -:  161:
        -:  162:#if defined (ACE_HAS_WCHAR)
        -:  163:ACE_INLINE int
        -:  164:ACE_OS::rmdir (const wchar_t *path)
        -:  165:{
        -:  166:#if defined (ACE_HAS_WINCE)
        -:  167:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::RemoveDirectoryW (path),
        -:  168:                                          ace_result_),
        -:  169:                        int, -1);
        -:  170:#elif defined (ACE_WIN32)
        -:  171:  ACE_OSCALL_RETURN (::_wrmdir (path), int, -1);
        -:  172:#else
        -:  173:  ACE_Wide_To_Ascii n_path (path);
        -:  174:  return ACE_OS::rmdir (n_path.char_rep ());
        -:  175:#endif /* ACE_HAS_WINCE */
        -:  176:}
        -:  177:#endif /* ACE_HAS_WCHAR */
        -:  178:
        -:  179:// @todo: which 4 and why???  dhinton
        -:  180:// NOTE: The following four function definitions must appear before
        -:  181:// ACE_OS::sema_init ().
        -:  182:
        -:  183:ACE_INLINE int
        -:  184:ACE_OS::close (ACE_HANDLE handle)
        -:  185:{
        -:  186:  ACE_OS_TRACE ("ACE_OS::close");
        -:  187:#if defined (ACE_WIN32)
        -:  188:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::CloseHandle (handle), ace_result_), int, -1);
        -:  189:#else
        -:  190:  ACE_OSCALL_RETURN (::close (handle), int, -1);
        -:  191:#endif /* ACE_WIN32 */
        -:  192:}
        -:  193:
        -:  194:ACE_INLINE ACE_HANDLE
        -:  195:ACE_OS::dup (ACE_HANDLE handle)
        -:  196:{
        -:  197:  ACE_OS_TRACE ("ACE_OS::dup");
        -:  198:#if defined (ACE_LACKS_DUP)
        -:  199:  ACE_UNUSED_ARG (handle);
        -:  200:  ACE_NOTSUP_RETURN (ACE_INVALID_HANDLE);
        -:  201:#elif defined (ACE_WIN32)
        -:  202:  ACE_HANDLE new_fd;
        -:  203:  if (::DuplicateHandle(::GetCurrentProcess (),
        -:  204:                        handle,
        -:  205:                        ::GetCurrentProcess(),
        -:  206:                        &new_fd,
        -:  207:                        0,
        -:  208:                        TRUE,
        -:  209:                        DUPLICATE_SAME_ACCESS))
        -:  210:    return new_fd;
        -:  211:  else
        -:  212:    ACE_FAIL_RETURN (ACE_INVALID_HANDLE);
        -:  213:  /* NOTREACHED */
        -:  214:#else
        -:  215:  ACE_OSCALL_RETURN (::dup (handle), ACE_HANDLE, ACE_INVALID_HANDLE);
        -:  216:#endif /* ACE_LACKS_DUP */
        -:  217:}
        -:  218:
        -:  219:ACE_INLINE ACE_HANDLE
        -:  220:ACE_OS::dup(ACE_HANDLE handle, pid_t pid)
        -:  221:{
        -:  222:  ACE_OS_TRACE("ACE_OS::dup");
        -:  223:#if defined (ACE_LACKS_DUP)
        -:  224:  ACE_UNUSED_ARG (handle);
        -:  225:  ACE_UNUSED_ARG (pid);
        -:  226:  ACE_NOTSUP_RETURN (ACE_INVALID_HANDLE);
        -:  227:#elif defined (ACE_WIN32)
        -:  228:  ACE_HANDLE new_fd;
        -:  229:  ACE_HANDLE hTargetProcess = ::OpenProcess (PROCESS_DUP_HANDLE,
        -:  230:                                             FALSE,
        -:  231:                                             pid);
        -:  232:  if(::DuplicateHandle(::GetCurrentProcess (),
        -:  233:                       handle,
        -:  234:                       hTargetProcess,
        -:  235:                       &new_fd,
        -:  236:                       0,
        -:  237:                       TRUE,
        -:  238:                       DUPLICATE_SAME_ACCESS))
        -:  239:    {
        -:  240:      ::CloseHandle (hTargetProcess);
        -:  241:      return new_fd;
        -:  242:    }
        -:  243:  else
        -:  244:    ACE_FAIL_RETURN (ACE_INVALID_HANDLE);
        -:  245:  /*NOTREACHED*/
        -:  246:#else
        -:  247:  ACE_UNUSED_ARG (pid);
        -:  248:  ACE_OSCALL_RETURN(::dup(handle), ACE_HANDLE, ACE_INVALID_HANDLE);
        -:  249:#endif /*ACE_WIN32 &&  !ACE_HAS_WINCE*/
        -:  250:}
        -:  251:
        -:  252:ACE_INLINE int
        -:  253:ACE_OS::dup2 (ACE_HANDLE oldhandle, ACE_HANDLE newhandle)
        -:  254:{
        -:  255:  ACE_OS_TRACE ("ACE_OS::dup2");
        -:  256:#if defined (ACE_LACKS_DUP2)
        -:  257:  // msvcrt has _dup2 ?!
        -:  258:  ACE_UNUSED_ARG (oldhandle);
        -:  259:  ACE_UNUSED_ARG (newhandle);
        -:  260:  ACE_NOTSUP_RETURN (-1);
        -:  261:#else
        -:  262:  ACE_OSCALL_RETURN (::dup2 (oldhandle, newhandle), int, -1);
        -:  263:#endif /* ACE_LACKS_DUP2 */
        -:  264:}
        -:  265:
        -:  266:ACE_INLINE int
        -:  267:ACE_OS::execv (const char *path,
        -:  268:               char *const argv[])
        -:  269:{
        -:  270:  ACE_OS_TRACE ("ACE_OS::execv");
        -:  271:#if defined (ACE_LACKS_EXEC)
        -:  272:  ACE_UNUSED_ARG (path);
        -:  273:  ACE_UNUSED_ARG (argv);
        -:  274:
        -:  275:  ACE_NOTSUP_RETURN (-1);
        -:  276:#elif defined (ACE_WIN32)
        -:  277:# if defined (__BORLANDC__)
        -:  278:  return ::execv (path, argv);
        -:  279:# elif defined (__MINGW32__)
        -:  280:  return ::_execv (path, (char *const *) argv);
        -:  281:# else
        -:  282:  // Why this odd-looking code? If execv() returns at all, it's an error.
        -:  283:  // Windows defines this as returning an intptr_t rather than a simple int,
        -:  284:  // and the conversion triggers compile warnings. So just return -1 if
        -:  285:  // the call returns.
        -:  286:  ::_execv (path, (const char *const *) argv);
        -:  287:  return -1;
        -:  288:# endif /* __BORLANDC__ */
        -:  289:#else
        -:  290:  ACE_OSCALL_RETURN (::execv (path, argv), int, -1);
        -:  291:#endif /* ACE_LACKS_EXEC */
        -:  292:}
        -:  293:
        -:  294:ACE_INLINE int
        -:  295:ACE_OS::execve (const char *path,
        -:  296:                char *const argv[],
        -:  297:                char *const envp[])
        -:  298:{
        -:  299:  ACE_OS_TRACE ("ACE_OS::execve");
        -:  300:#if defined (ACE_LACKS_EXEC)
        -:  301:  ACE_UNUSED_ARG (path);
        -:  302:  ACE_UNUSED_ARG (argv);
        -:  303:  ACE_UNUSED_ARG (envp);
        -:  304:
        -:  305:  ACE_NOTSUP_RETURN (-1);
        -:  306:#elif defined (ACE_WIN32)
        -:  307:# if defined (__BORLANDC__)
        -:  308:  return ::execve (path, argv, envp);
        -:  309:# elif defined (__MINGW32__)
        -:  310:  return ::_execve (path, (char *const *) argv, (char *const *) envp);
        -:  311:# else
        -:  312:  // Why this odd-looking code? If execv() returns at all, it's an error.
        -:  313:  // Windows defines this as returning an intptr_t rather than a simple int,
        -:  314:  // and the conversion triggers compile warnings. So just return -1 if
        -:  315:  // the call returns.
        -:  316:  ::_execve (path, (const char *const *) argv, (const char *const *) envp);
        -:  317:  return -1;
        -:  318:# endif /* __BORLANDC__ */
        -:  319:#else
        -:  320:  ACE_OSCALL_RETURN (::execve (path, argv, envp), int, -1);
        -:  321:#endif /* ACE_LACKS_EXEC */
        -:  322:}
        -:  323:
        -:  324:ACE_INLINE int
        -:  325:ACE_OS::execvp (const char *file,
        -:  326:                char *const argv[])
        -:  327:{
        -:  328:  ACE_OS_TRACE ("ACE_OS::execvp");
        -:  329:#if defined (ACE_LACKS_EXEC) || defined (ACE_LACKS_EXECVP)
        -:  330:  ACE_UNUSED_ARG (file);
        -:  331:  ACE_UNUSED_ARG (argv);
        -:  332:
        -:  333:  ACE_NOTSUP_RETURN (-1);
        -:  334:#elif defined (ACE_WIN32)
        -:  335:# if defined (__BORLANDC__)
        -:  336:  return ::execvp (file, argv);
        -:  337:# elif defined (__MINGW32__)
        -:  338:  return ::_execvp (file, (char *const *) argv);
        -:  339:# else
        -:  340:  // Why this odd-looking code? If execv() returns at all, it's an error.
        -:  341:  // Windows defines this as returning an intptr_t rather than a simple int,
        -:  342:  // and the conversion triggers compile warnings. So just return -1 if
        -:  343:  // the call returns.
        -:  344:  ::_execvp (file, (const char *const *) argv);
        -:  345:  return -1;
        -:  346:# endif /* __BORLANDC__ */
        -:  347:#else
        -:  348:  ACE_OSCALL_RETURN (::execvp (file, argv), int, -1);
        -:  349:#endif /* ACE_LACKS_EXEC */
        -:  350:}
        -:  351:
        -:  352:ACE_INLINE pid_t
        -:  353:ACE_OS::fork (void)
        -:  354:{
        -:  355:  ACE_OS_TRACE ("ACE_OS::fork");
        -:  356:#if defined (ACE_LACKS_FORK)
        -:  357:  ACE_NOTSUP_RETURN (pid_t (-1));
        -:  358:#else
        -:  359:  ACE_OSCALL_RETURN (::fork (), pid_t, -1);
        -:  360:#endif /* ACE_LACKS_FORK */
        -:  361:}
        -:  362:
        -:  363:ACE_INLINE int
        -:  364:ACE_OS::fsync (ACE_HANDLE handle)
        -:  365:{
        -:  366:  ACE_OS_TRACE ("ACE_OS::fsync");
        -:  367:# if defined (ACE_LACKS_FSYNC)
        -:  368:  ACE_UNUSED_ARG (handle);
        -:  369:  ACE_NOTSUP_RETURN (-1);
        -:  370:# elif defined (ACE_WIN32)
        -:  371:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::FlushFileBuffers (handle), ace_result_), int, -1);
        -:  372:# else
        -:  373:  ACE_OSCALL_RETURN (::fsync (handle), int, -1);
        -:  374:# endif /* ACE_LACKS_FSYNC */
        -:  375:}
        -:  376:
        -:  377:ACE_INLINE int
        -:  378:ACE_OS::ftruncate (ACE_HANDLE handle, ACE_OFF_T offset)
        -:  379:{
        -:  380:  ACE_OS_TRACE ("ACE_OS::ftruncate");
        -:  381:#if defined (ACE_WIN32)
        -:  382:#  if !defined (ACE_LACKS_WIN32_SETFILEPOINTEREX)
        -:  383:  LARGE_INTEGER loff;
        -:  384:  loff.QuadPart = offset;
        -:  385:  if (::SetFilePointerEx (handle, loff, 0, FILE_BEGIN))
        -:  386:#  else
        -:  387:  if (::SetFilePointer (handle,
        -:  388:                        offset,
        -:  389:                        0,
        -:  390:                        FILE_BEGIN) != INVALID_SET_FILE_POINTER)
        -:  391:#  endif
        -:  392:    ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::SetEndOfFile (handle), ace_result_), int, -1);
        -:  393:  else
        -:  394:    ACE_FAIL_RETURN (-1);
        -:  395:#else
        -:  396:  ACE_OSCALL_RETURN (::ftruncate (handle, offset), int, -1);
        -:  397:#endif /* ACE_WIN32 */
        -:  398:}
        -:  399:
        -:  400:ACE_INLINE char *
    #####:  401:ACE_OS::getcwd (char *buf, size_t size)
        -:  402:{
        -:  403:  ACE_OS_TRACE ("ACE_OS::getcwd");
        -:  404:#if defined (ACE_LACKS_GETCWD)
        -:  405:  ACE_UNUSED_ARG (buf);
        -:  406:  ACE_UNUSED_ARG (size);
        -:  407:  ACE_NOTSUP_RETURN (0);
        -:  408:#elif defined (ACE_WIN32)
        -:  409:  return ::getcwd (buf, static_cast<int> (size));
        -:  410:#else
    #####:  411:  ACE_OSCALL_RETURN (::getcwd (buf, size), char *, 0);
        -:  412:#endif /* ACE_LACKS_GETCWD */
        -:  413:}
        -:  414:
        -:  415:#if defined (ACE_HAS_WCHAR)
        -:  416:ACE_INLINE wchar_t *
        -:  417:ACE_OS::getcwd (wchar_t *buf, size_t size)
        -:  418:{
        -:  419:#  if defined (ACE_HAS_WINCE)
        -:  420:  ACE_UNUSED_ARG (buf);
        -:  421:  ACE_UNUSED_ARG (size);
        -:  422:  ACE_NOTSUP_RETURN (0);
        -:  423:#  elif defined (ACE_WIN32)
        -:  424:  return ::_wgetcwd (buf, static_cast<int> (size));
        -:  425:#  else
        -:  426:  char *narrow_buf = new char[size];
        -:  427:  char *result = 0;
        -:  428:  result = ACE_OS::getcwd (narrow_buf, size);
        -:  429:  ACE_Ascii_To_Wide wide_buf (result);
        -:  430:  delete [] narrow_buf;
        -:  431:  if (result != 0)
        -:  432:    ACE_OS::strsncpy (buf, wide_buf.wchar_rep (), size);
        -:  433:  return result == 0 ? 0 : buf;
        -:  434:#  endif /* ACE_WIN32 */
        -:  435:}
        -:  436:#endif /* ACE_HAS_WCHAR */
        -:  437:
        -:  438:ACE_INLINE gid_t
        -:  439:ACE_OS::getgid (void)
        -:  440:{
        -:  441:  ACE_OS_TRACE ("ACE_OS::getgid");
        -:  442:#if defined (ACE_LACKS_GETGID)
        -:  443:  ACE_NOTSUP_RETURN (static_cast<gid_t> (-1));
        -:  444:# else
        -:  445:  ACE_OSCALL_RETURN (::getgid (), gid_t, static_cast<gid_t> (-1));
        -:  446:# endif /* ACE_LACKS_GETGID */
        -:  447:}
        -:  448:
        -:  449:ACE_INLINE gid_t
        -:  450:ACE_OS::getegid (void)
        -:  451:{
        -:  452:  ACE_OS_TRACE ("ACE_OS::getegid");
        -:  453:#if defined (ACE_LACKS_GETEGID)
        -:  454:  ACE_NOTSUP_RETURN (static_cast<gid_t> (-1));
        -:  455:# else
        -:  456:  ACE_OSCALL_RETURN (::getegid (), gid_t, static_cast<gid_t> (-1));
        -:  457:# endif /* ACE_LACKS_GETEGID */
        -:  458:}
        -:  459:
        -:  460:ACE_INLINE int
        -:  461:ACE_OS::getopt (int argc, char *const *argv, const char *optstring)
        -:  462:{
        -:  463:  ACE_OS_TRACE ("ACE_OS::getopt");
        -:  464:#if defined (ACE_LACKS_GETOPT)
        -:  465:  ACE_UNUSED_ARG (argc);
        -:  466:  ACE_UNUSED_ARG (argv);
        -:  467:  ACE_UNUSED_ARG (optstring);
        -:  468:  ACE_NOTSUP_RETURN (-1);
        -:  469:# else
        -:  470:  ACE_OSCALL_RETURN (::getopt (argc, argv, optstring), int, -1);
        -:  471:# endif /* ACE_LACKS_GETOPT */
        -:  472:}
        -:  473:
        -:  474:ACE_INLINE pid_t
        -:  475:ACE_OS::getpgid (pid_t pid)
        -:  476:{
        -:  477:  ACE_OS_TRACE ("ACE_OS::getpgid");
        -:  478:#if defined (ACE_LACKS_GETPGID)
        -:  479:  ACE_UNUSED_ARG (pid);
        -:  480:  ACE_NOTSUP_RETURN (-1);
        -:  481:#elif defined (ACE_LINUX) && __GLIBC__ > 1 && __GLIBC_MINOR__ >= 0
        -:  482:  // getpgid() is from SVR4, which appears to be the reason why GLIBC
        -:  483:  // doesn't enable its prototype by default.
        -:  484:  // Rather than create our own extern prototype, just use the one
        -:  485:  // that is visible (ugh).
        -:  486:  ACE_OSCALL_RETURN (::__getpgid (pid), pid_t, -1);
        -:  487:#else
        -:  488:  ACE_OSCALL_RETURN (::getpgid (pid), pid_t, -1);
        -:  489:#endif /* ACE_LACKS_GETPGID */
        -:  490:}
        -:  491:
        -:  492:ACE_INLINE pid_t
        -:  493:ACE_OS::getpid (void)
        -:  494:{
        -:  495:  // ACE_OS_TRACE ("ACE_OS::getpid");
        -:  496:#if defined (ACE_LACKS_GETPID)
        -:  497:  ACE_NOTSUP_RETURN (-1);
        -:  498:#elif defined (ACE_WIN32)
        -:  499:  return ::GetCurrentProcessId ();
        -:  500:#else
        -:  501:  ACE_OSCALL_RETURN (::getpid (), pid_t, -1);
        -:  502:#endif /* ACE_LACKS_GETPID */
        -:  503:}
        -:  504:
        -:  505:ACE_INLINE pid_t
        -:  506:ACE_OS::getppid (void)
        -:  507:{
        -:  508:  ACE_OS_TRACE ("ACE_OS::getppid");
        -:  509:#if defined (ACE_LACKS_GETPPID)
        -:  510:  ACE_NOTSUP_RETURN (-1);
        -:  511:#else
        -:  512:  ACE_OSCALL_RETURN (::getppid (), pid_t, -1);
        -:  513:#endif /* ACE_LACKS_GETPPID */
        -:  514:}
        -:  515:
        -:  516:ACE_INLINE uid_t
        -:  517:ACE_OS::getuid (void)
        -:  518:{
        -:  519:  ACE_OS_TRACE ("ACE_OS::getuid");
        -:  520:#if defined (ACE_LACKS_GETUID)
        -:  521:  ACE_NOTSUP_RETURN (static_cast<uid_t> (-1));
        -:  522:# else
        -:  523:  ACE_OSCALL_RETURN (::getuid (), uid_t, static_cast<uid_t> (-1));
        -:  524:# endif /* ACE_LACKS_GETUID*/
        -:  525:}
        -:  526:
        -:  527:ACE_INLINE uid_t
        -:  528:ACE_OS::geteuid (void)
        -:  529:{
        -:  530:  ACE_OS_TRACE ("ACE_OS::geteuid");
        -:  531:#if defined (ACE_LACKS_GETEUID)
        -:  532:  ACE_NOTSUP_RETURN (static_cast<uid_t> (-1));
        -:  533:# else
        -:  534:  ACE_OSCALL_RETURN (::geteuid (), uid_t, (uid_t) -1);
        -:  535:# endif /* ACE_LACKS_GETEUID */
        -:  536:}
        -:  537:
        -:  538:ACE_INLINE int
        -:  539:ACE_OS::hostname (char name[], size_t maxnamelen)
        -:  540:{
        -:  541:  ACE_OS_TRACE ("ACE_OS::hostname");
        -:  542:#if defined (ACE_HAS_PHARLAP)
        -:  543:  // PharLap only can do net stuff with the RT version.
        -:  544:#   if defined (ACE_HAS_PHARLAP_RT)
        -:  545:  // @@This is not at all reliable... requires ethernet and BOOTP to be used.
        -:  546:  // A more reliable way is to go thru the devices w/ EtsTCPGetDeviceCfg until
        -:  547:  // a legit IP address is found, then get its name w/ gethostbyaddr.
        -:  548:  ACE_SOCKCALL_RETURN (gethostname (name, maxnamelen), int, SOCKET_ERROR);
        -:  549:#   else
        -:  550:  ACE_UNUSED_ARG (name);
        -:  551:  ACE_UNUSED_ARG (maxnamelen);
        -:  552:  ACE_NOTSUP_RETURN (-1);
        -:  553:#   endif /* ACE_HAS_PHARLAP_RT */
        -:  554:#elif defined (ACE_VXWORKS) || defined (ACE_HAS_WINCE)
        -:  555:  ACE_OSCALL_RETURN (::gethostname (name, maxnamelen), int, -1);
        -:  556:#elif defined (ACE_WIN32)
        -:  557:  if (::gethostname (name, ACE_Utils::truncate_cast<int> (maxnamelen)) == 0)
        -:  558:  {
        -:  559:    return 0;
        -:  560:  }
        -:  561:  else
        -:  562:  {
        -:  563:    ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::GetComputerNameA (name,
        -:  564:                                            LPDWORD (&maxnamelen)),
        -:  565:                                            ace_result_), int, -1);
        -:  566:  }
        -:  567:#else /* ACE_HAS_PHARLAP */
        -:  568:  ACE_utsname host_info;
        -:  569:
        -:  570:  if (ACE_OS::uname (&host_info) == -1)
        -:  571:    return -1;
        -:  572:  else
        -:  573:    {
        -:  574:      ACE_OS::strsncpy (name, host_info.nodename, maxnamelen);
        -:  575:      return 0;
        -:  576:    }
        -:  577:#endif /* ACE_HAS_PHARLAP */
        -:  578:}
        -:  579:
        -:  580:#if defined (ACE_HAS_WCHAR)
        -:  581:ACE_INLINE int
        -:  582:ACE_OS::hostname (wchar_t name[], size_t maxnamelen)
        -:  583:{
        -:  584:#if defined (ACE_WIN32) && !defined (ACE_HAS_WINCE)
        -:  585:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (GetComputerNameW (name,
        -:  586:                                                        LPDWORD (&maxnamelen)),
        -:  587:                                          ace_result_), int, -1);
        -:  588:#else /* ACE_WIN32 && !ACE_HAS_WINCE */
        -:  589:  // Emulate using the char version
        -:  590:  char *char_name = 0;
        -:  591:
        -:  592:  ACE_NEW_RETURN (char_name, char[maxnamelen], -1);
        -:  593:
        -:  594:  int result = ACE_OS::hostname(char_name, maxnamelen);
        -:  595:  ACE_OS::strcpy (name, ACE_Ascii_To_Wide (char_name).wchar_rep ());
        -:  596:
        -:  597:  delete [] char_name;
        -:  598:  return result;
        -:  599:#endif /* ACE_WIN32 && !ACE_HAS_WINCE */
        -:  600:}
        -:  601:#endif /* ACE_HAS_WCHAR */
        -:  602:
        -:  603:ACE_INLINE int
        -:  604:ACE_OS::isatty (int handle)
        -:  605:{
        -:  606:  ACE_OS_TRACE ("ACE_OS::isatty");
        -:  607:#if defined (ACE_LACKS_ISATTY)
        -:  608:  ACE_UNUSED_ARG (handle);
        -:  609:  return 0;
        -:  610:# elif defined (ACE_WIN32)
        -:  611:  return ::_isatty (handle);
        -:  612:# else
        -:  613:  ACE_OSCALL_RETURN (::isatty (handle), int, -1);
        -:  614:# endif /* ACE_LACKS_ISATTY */
        -:  615:}
        -:  616:
        -:  617:#if defined (ACE_WIN32)
        -:  618:ACE_INLINE int
        -:  619:ACE_OS::isatty (ACE_HANDLE handle)
        -:  620:{
        -:  621:#if defined (ACE_LACKS_ISATTY)
        -:  622:  ACE_UNUSED_ARG (handle);
        -:  623:  return 0;
        -:  624:#else
        -:  625:  int const fd = ::_open_osfhandle (intptr_t (handle), 0);
        -:  626:  int status = 0;
        -:  627:  if (fd != -1)
        -:  628:    {
        -:  629:      status = ::_isatty (fd);
        -:  630:      ::_close (fd);
        -:  631:    }
        -:  632:  return status;
        -:  633:#endif /* ACE_LACKS_ISATTY */
        -:  634:}
        -:  635:
        -:  636:#endif /* ACE_WIN32 */
        -:  637:
        -:  638:ACE_INLINE ACE_OFF_T
        -:  639:ACE_OS::lseek (ACE_HANDLE handle, ACE_OFF_T offset, int whence)
        -:  640:{
        -:  641:  ACE_OS_TRACE ("ACE_OS::lseek");
        -:  642:#if defined (ACE_WIN32)
        -:  643:# if SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END
        -:  644:  //#error Windows NT is evil AND rude!
        -:  645:  switch (whence)
        -:  646:    {
        -:  647:    case SEEK_SET:
        -:  648:      whence = FILE_BEGIN;
        -:  649:      break;
        -:  650:    case SEEK_CUR:
        -:  651:      whence = FILE_CURRENT;
        -:  652:      break;
        -:  653:    case SEEK_END:
        -:  654:      whence = FILE_END;
        -:  655:      break;
        -:  656:    default:
        -:  657:      errno = EINVAL;
        -:  658:      return static_cast<ACE_OFF_T> (-1); // rather safe than sorry
        -:  659:    }
        -:  660:# endif  /* SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END */
        -:  661:  LONG low_offset = ACE_LOW_PART(offset);
        -:  662:  LONG high_offset = ACE_HIGH_PART(offset);
        -:  663:  DWORD const result =
        -:  664:    ::SetFilePointer (handle, low_offset, &high_offset, whence);
        -:  665:  if (result == INVALID_SET_FILE_POINTER && GetLastError() != NO_ERROR)
        -:  666:    ACE_FAIL_RETURN (static_cast<ACE_OFF_T> (-1));
        -:  667:  else
        -:  668:    return result;
        -:  669:#else
        -:  670:  ACE_OSCALL_RETURN (::lseek (handle, offset, whence), ACE_OFF_T, -1);
        -:  671:#endif /* ACE_WIN32 */
        -:  672:}
        -:  673:
        -:  674:#if defined (ACE_HAS_LLSEEK) || defined (ACE_HAS_LSEEK64)
        -:  675:ACE_INLINE ACE_LOFF_T
        -:  676:ACE_OS::llseek (ACE_HANDLE handle, ACE_LOFF_T offset, int whence)
        -:  677:{
        -:  678:  ACE_OS_TRACE ("ACE_OS::llseek");
        -:  679:
        -:  680:#if ACE_SIZEOF_LONG == 8
        -:  681:  /* The native lseek is 64 bit.  Use it. */
        -:  682:  return ACE_OS::lseek (handle, offset, whence);
        -:  683:#elif defined (ACE_HAS_LLSEEK) && defined (ACE_HAS_LSEEK64)
        -:  684:# error Either ACE_HAS_LSEEK64 and ACE_HAS_LLSEEK should be defined, not both!
        -:  685:#elif defined (ACE_HAS_LSEEK64)
        -:  686:  ACE_OSCALL_RETURN (::lseek64 (handle, offset, whence), ACE_LOFF_T, -1);
        -:  687:#elif defined (ACE_HAS_LLSEEK)
        -:  688:# if defined (ACE_WIN32)
        -:  689:#  ifndef ACE_LACKS_WIN32_SETFILEPOINTEREX
        -:  690:  LARGE_INTEGER distance, new_file_pointer;
        -:  691:
        -:  692:  distance.QuadPart = offset;
        -:  693:
        -:  694:  return
        -:  695:    (::SetFilePointerEx (handle, distance, &new_file_pointer, whence)
        -:  696:     ? new_file_pointer.QuadPart
        -:  697:     : static_cast<ACE_LOFF_T> (-1));
        -:  698:#  else
        -:  699:  LARGE_INTEGER l_offset;
        -:  700:  l_offset.QuadPart = offset;
        -:  701:  LONG low_offset = l_offset.LowPart;
        -:  702:  LONG high_offset = l_offset.HighPart;
        -:  703:
        -:  704:  l_offset.LowPart = ::SetFilePointer (handle,
        -:  705:                                       low_offset,
        -:  706:                                       &high_offset,
        -:  707:                                       whence);
        -:  708:  if (l_offset.LowPart == INVALID_SET_FILE_POINTER &&
        -:  709:      GetLastError () != NO_ERROR)
        -:  710:    return static_cast<ACE_LOFF_T> (-1);
        -:  711:  l_offset.HighPart = high_offset;
        -:  712:  return l_offset.QuadPart;
        -:  713:#  endif  /* ACE_LACKS_WIN32_SETFILEPOINTEREX */
        -:  714:# else
        -:  715:    ACE_OSCALL_RETURN (::llseek (handle, offset, whence), ACE_LOFF_T, -1);
        -:  716:# endif /* WIN32 */
        -:  717:#endif
        -:  718:}
        -:  719:#endif /* ACE_HAS_LLSEEK || ACE_HAS_LSEEK64 */
        -:  720:
        -:  721:ACE_INLINE ssize_t
        -:  722:ACE_OS::read (ACE_HANDLE handle, void *buf, size_t len)
        -:  723:{
        -:  724:  ACE_OS_TRACE ("ACE_OS::read");
        -:  725:#if defined (ACE_WIN32)
        -:  726:  DWORD ok_len;
        -:  727:  if (::ReadFile (handle, buf, static_cast<DWORD> (len), &ok_len, 0))
        -:  728:    return (ssize_t) ok_len;
        -:  729:  else
        -:  730:    ACE_FAIL_RETURN (-1);
        -:  731:#else
        -:  732:
        -:  733:  ssize_t result;
        -:  734:
        -:  735:# if defined (ACE_HAS_CHARPTR_SOCKOPT)
        -:  736:  ACE_OSCALL (::read (handle, static_cast <char *> (buf), len), ssize_t, -1, result);
        -:  737:# else
        -:  738:  ACE_OSCALL (::read (handle, buf, len), ssize_t, -1, result);
        -:  739:# endif /* ACE_HAS_CHARPTR_SOCKOPT */
        -:  740:
        -:  741:# if !(defined (EAGAIN) && defined (EWOULDBLOCK) && EAGAIN == EWOULDBLOCK)
        -:  742:  // Optimize this code out if we can detect that EAGAIN ==
        -:  743:  // EWOULDBLOCK at compile time.  If we cannot detect equality at
        -:  744:  // compile-time (e.g. if EAGAIN or EWOULDBLOCK are not preprocessor
        -:  745:  // macros) perform the check at run-time.  The goal is to avoid two
        -:  746:  // TSS accesses in the _REENTRANT case when EAGAIN == EWOULDBLOCK.
        -:  747:  if (result == -1
        -:  748:#  if !defined (EAGAIN) || !defined (EWOULDBLOCK)
        -:  749:      && EAGAIN != EWOULDBLOCK
        -:  750:#  endif  /* !EAGAIN || !EWOULDBLOCK */
        -:  751:      && errno == EAGAIN)
        -:  752:    {
        -:  753:      errno = EWOULDBLOCK;
        -:  754:    }
        -:  755:# endif /* EAGAIN != EWOULDBLOCK*/
        -:  756:
        -:  757:  return result;
        -:  758:#endif /* ACE_WIN32 */
        -:  759:}
        -:  760:
        -:  761:ACE_INLINE ssize_t
        -:  762:ACE_OS::read (ACE_HANDLE handle, void *buf, size_t len,
        -:  763:              ACE_OVERLAPPED *overlapped)
        -:  764:{
        -:  765:  ACE_OS_TRACE ("ACE_OS::read");
        -:  766:#if defined (ACE_WIN32)
        -:  767:  DWORD ok_len;
        -:  768:  DWORD short_len = static_cast<DWORD> (len);
        -:  769:  if (::ReadFile (handle, buf, short_len, &ok_len, overlapped))
        -:  770:    return (ssize_t) ok_len;
        -:  771:  else
        -:  772:    ACE_FAIL_RETURN (-1);
        -:  773:#else
        -:  774:  ACE_UNUSED_ARG (overlapped);
        -:  775:  return ACE_OS::read (handle, buf, len);
        -:  776:#endif /* ACE_WIN32 */
        -:  777:}
        -:  778:
        -:  779:ACE_INLINE ssize_t
        -:  780:ACE_OS::readlink (const char *path, char *buf, size_t bufsiz)
        -:  781:{
        -:  782:  ACE_OS_TRACE ("ACE_OS::readlink");
        -:  783:# if defined (ACE_LACKS_READLINK)
        -:  784:  ACE_UNUSED_ARG (path);
        -:  785:  ACE_UNUSED_ARG (buf);
        -:  786:  ACE_UNUSED_ARG (bufsiz);
        -:  787:  ACE_NOTSUP_RETURN (-1);
        -:  788:# elif defined(ACE_HAS_NONCONST_READLINK)
        -:  789:  ACE_OSCALL_RETURN (
        -:  790:    ::readlink (const_cast <char *>(path), buf, bufsiz), ssize_t, -1);
        -:  791:# else
        -:  792:  ACE_OSCALL_RETURN (::readlink (path, buf, bufsiz), ssize_t, -1);
        -:  793:# endif /* ACE_LACKS_READLINK */
        -:  794:}
        -:  795:
        -:  796:ACE_INLINE int
        -:  797:ACE_OS::pipe (ACE_HANDLE fds[])
        -:  798:{
        -:  799:  ACE_OS_TRACE ("ACE_OS::pipe");
        -:  800:# if defined (ACE_LACKS_PIPE)
        -:  801:  ACE_UNUSED_ARG (fds);
        -:  802:  ACE_NOTSUP_RETURN (-1);
        -:  803:# elif defined (ACE_WIN32)
        -:  804:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL
        -:  805:                        (::CreatePipe (&fds[0], &fds[1], 0, 0),
        -:  806:                         ace_result_), int, -1);
        -:  807:# else
        -:  808:  ACE_OSCALL_RETURN (::pipe (fds), int, -1);
        -:  809:# endif /* ACE_LACKS_PIPE */
        -:  810:}
        -:  811:
        -:  812:ACE_INLINE void *
        -:  813:ACE_OS::sbrk (intptr_t brk)
        -:  814:{
        -:  815:#if defined (ACE_LACKS_SBRK)
        -:  816:  ACE_UNUSED_ARG (brk);
        -:  817:  ACE_NOTSUP_RETURN (0);
        -:  818:#else
        -:  819:  ACE_OSCALL_RETURN (::sbrk (brk), void *, 0);
        -:  820:#endif /* ACE_LACKS_SBRK */
        -:  821:}
        -:  822:
        -:  823:ACE_INLINE int
        -:  824:ACE_OS::setgid (gid_t gid)
        -:  825:{
        -:  826:  ACE_OS_TRACE ("ACE_OS::setgid");
        -:  827:#if defined (ACE_LACKS_SETGID)
        -:  828:  ACE_UNUSED_ARG (gid);
        -:  829:  ACE_NOTSUP_RETURN (-1);
        -:  830:# else
        -:  831:  ACE_OSCALL_RETURN (::setgid (gid), int,  -1);
        -:  832:# endif /* ACE_LACKS_SETGID */
        -:  833:}
        -:  834:
        -:  835:ACE_INLINE int
        -:  836:ACE_OS::setegid (gid_t gid)
        -:  837:{
        -:  838:  ACE_OS_TRACE ("ACE_OS::setegid");
        -:  839:#if defined (ACE_LACKS_SETEGID)
        -:  840:  ACE_UNUSED_ARG (gid);
        -:  841:  ACE_NOTSUP_RETURN (-1);
        -:  842:# else
        -:  843:  ACE_OSCALL_RETURN (::setegid (gid), int,  -1);
        -:  844:# endif /* ACE_LACKS_SETEGID */
        -:  845:}
        -:  846:
        -:  847:ACE_INLINE int
        -:  848:ACE_OS::setpgid (pid_t pid, pid_t pgid)
        -:  849:{
        -:  850:  ACE_OS_TRACE ("ACE_OS::setpgid");
        -:  851:#if defined (ACE_LACKS_SETPGID)
        -:  852:  ACE_UNUSED_ARG (pid);
        -:  853:  ACE_UNUSED_ARG (pgid);
        -:  854:  ACE_NOTSUP_RETURN (-1);
        -:  855:#else
        -:  856:  ACE_OSCALL_RETURN (::setpgid (pid, pgid), int, -1);
        -:  857:#endif /* ACE_LACKS_SETPGID */
        -:  858:}
        -:  859:
        -:  860:ACE_INLINE int
        -:  861:ACE_OS::setregid (gid_t rgid, gid_t egid)
        -:  862:{
        -:  863:  ACE_OS_TRACE ("ACE_OS::setregid");
        -:  864:#if defined (ACE_LACKS_SETREGID)
        -:  865:  ACE_UNUSED_ARG (rgid);
        -:  866:  ACE_UNUSED_ARG (egid);
        -:  867:  ACE_NOTSUP_RETURN (-1);
        -:  868:#else
        -:  869:  ACE_OSCALL_RETURN (::setregid (rgid, egid), int, -1);
        -:  870:#endif /* ACE_LACKS_SETREGID */
        -:  871:}
        -:  872:
        -:  873:ACE_INLINE int
        -:  874:ACE_OS::setreuid (uid_t ruid, uid_t euid)
        -:  875:{
        -:  876:  ACE_OS_TRACE ("ACE_OS::setreuid");
        -:  877:#if defined (ACE_LACKS_SETREUID)
        -:  878:  ACE_UNUSED_ARG (ruid);
        -:  879:  ACE_UNUSED_ARG (euid);
        -:  880:  ACE_NOTSUP_RETURN (-1);
        -:  881:#else
        -:  882:  ACE_OSCALL_RETURN (::setreuid (ruid, euid), int, -1);
        -:  883:#endif /* ACE_LACKS_SETREUID */
        -:  884:}
        -:  885:
        -:  886:ACE_INLINE pid_t
        -:  887:ACE_OS::setsid (void)
        -:  888:{
        -:  889:  ACE_OS_TRACE ("ACE_OS::setsid");
        -:  890:#if defined (ACE_LACKS_SETSID)
        -:  891:  ACE_NOTSUP_RETURN (-1);
        -:  892:#else
        -:  893:  ACE_OSCALL_RETURN (::setsid (), int, -1);
        -:  894:# endif /* ACE_LACKS_SETSID */
        -:  895:}
        -:  896:
        -:  897:ACE_INLINE int
        -:  898:ACE_OS::setuid (uid_t uid)
        -:  899:{
        -:  900:  ACE_OS_TRACE ("ACE_OS::setuid");
        -:  901:#if defined (ACE_LACKS_SETUID)
        -:  902:  ACE_UNUSED_ARG (uid);
        -:  903:  ACE_NOTSUP_RETURN (-1);
        -:  904:# else
        -:  905:  ACE_OSCALL_RETURN (::setuid (uid), int,  -1);
        -:  906:# endif /* ACE_LACKS_SETUID */
        -:  907:}
        -:  908:
        -:  909:ACE_INLINE int
        -:  910:ACE_OS::seteuid (uid_t uid)
        -:  911:{
        -:  912:  ACE_OS_TRACE ("ACE_OS::seteuid");
        -:  913:#if defined (ACE_LACKS_SETEUID)
        -:  914:  ACE_UNUSED_ARG (uid);
        -:  915:  ACE_NOTSUP_RETURN (-1);
        -:  916:# else
        -:  917:  ACE_OSCALL_RETURN (::seteuid (uid), int,  -1);
        -:  918:# endif /* ACE_LACKS_SETEUID */
        -:  919:}
        -:  920:
        -:  921:ACE_INLINE int
    #####:  922:ACE_OS::sleep (u_int seconds)
        -:  923:{
        -:  924:  ACE_OS_TRACE ("ACE_OS::sleep");
        -:  925:#if defined (ACE_HAS_CLOCK_GETTIME)
        -:  926:  struct timespec rqtp;
        -:  927:  // Initializer doesn't work with Green Hills 1.8.7
    #####:  928:  rqtp.tv_sec = seconds;
    #####:  929:  rqtp.tv_nsec = 0L;
        -:  930:  //FUZZ: disable check_for_lack_ACE_OS
    #####:  931:  ACE_OSCALL_RETURN (::nanosleep (&rqtp, 0), int, -1);
        -:  932:  //FUZZ: enable check_for_lack_ACE_OS
        -:  933:#elif defined (ACE_LACKS_SLEEP)
        -:  934:  ACE_UNUSED_ARG (seconds);
        -:  935:  ACE_NOTSUP_RETURN (-1);
        -:  936:#elif defined (ACE_WIN32)
        -:  937:  ::Sleep (seconds * ACE_ONE_SECOND_IN_MSECS);
        -:  938:  return 0;
        -:  939:#else
        -:  940:  ACE_OSCALL_RETURN (::sleep (seconds), int, -1);
        -:  941:#endif /* ACE_WIN32 */
        -:  942:}
        -:  943:
        -:  944:ACE_INLINE int
    #####:  945:ACE_OS::sleep (const ACE_Time_Value &tv)
        -:  946:{
        -:  947:  ACE_OS_TRACE ("ACE_OS::sleep");
        -:  948:#if defined (ACE_WIN32)
        -:  949:  ::Sleep (tv.msec ());
        -:  950:  return 0;
        -:  951:#elif defined (ACE_HAS_CLOCK_GETTIME)
    #####:  952:  timespec_t rqtp = tv;
        -:  953:  //FUZZ: disable check_for_lack_ACE_OS
    #####:  954:  ACE_OSCALL_RETURN (::nanosleep (&rqtp, 0), int, -1);
        -:  955:  //FUZZ: enable check_for_lack_ACE_OS
        -:  956:#else
        -:  957:# if defined (ACE_HAS_NONCONST_SELECT_TIMEVAL)
        -:  958:  // Copy the timeval, because this platform doesn't declare the timeval
        -:  959:  // as a pointer to const.
        -:  960:  timeval tv_copy = tv;
        -:  961:  //FUZZ: disable check_for_lack_ACE_OS
        -:  962:  ACE_OSCALL_RETURN (::select (0, 0, 0, 0, &tv_copy), int, -1);
        -:  963:  //FUZZ: enable check_for_lack_ACE_OS
        -:  964:# else  /* ! ACE_HAS_NONCONST_SELECT_TIMEVAL */
        -:  965:  const timeval *tvp = tv;
        -:  966:  //FUZZ: disable check_for_lack_ACE_OS
        -:  967:  ACE_OSCALL_RETURN (::select (0, 0, 0, 0, tvp), int, -1);
        -:  968:  //FUZZ: enable check_for_lack_ACE_OS
        -:  969:# endif /* ACE_HAS_NONCONST_SELECT_TIMEVAL */
        -:  970:#endif /* ACE_WIN32 */
        -:  971:}
        -:  972:
        -:  973:ACE_INLINE void
        -:  974:ACE_OS::swab (const void *src,
        -:  975:              void *dest,
        -:  976:              ssize_t length)
        -:  977:{
        -:  978:#if defined (ACE_LACKS_SWAB)
        -:  979:  // ------------------------------------------------------------
        -:  980:  // The following copyright notice applies to the swab()
        -:  981:  // implementation within this "ACE_LACKS_SWAB" block of code.
        -:  982:  // ------------------------------------------------------------
        -:  983:  /*
        -:  984:    Copyright (c) 1994-2006  Red Hat, Inc. All rights reserved.
        -:  985:
        -:  986:    This copyrighted material is made available to anyone wishing to
        -:  987:    use, modify, copy, or redistribute it subject to the terms and
        -:  988:    conditions of the BSD License.   This program is distributed in
        -:  989:    the hope that it will be useful, but WITHOUT ANY WARRANTY
        -:  990:    expressed or implied, including the implied warranties of
        -:  991:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  A copy of
        -:  992:    this license is available at
        -:  993:    http://www.opensource.org/licenses. Any Red Hat trademarks that
        -:  994:    are incorporated in the source code or documentation are not
        -:  995:    subject to the BSD License and may only be used or replicated with
        -:  996:    the express permission of Red Hat, Inc.
        -:  997:  */
        -:  998:
        -:  999:  const char *from = static_cast<const char*> (src);
        -: 1000:  char *to = static_cast<char *> (dest);
        -: 1001:  ssize_t ptr = 0;
        -: 1002:  for (ptr = 1; ptr < length; ptr += 2)
        -: 1003:    {
        -: 1004:      char p = from[ptr];
        -: 1005:      char q = from[ptr-1];
        -: 1006:      to[ptr-1] = p;
        -: 1007:      to[ptr  ] = q;
        -: 1008:    }
        -: 1009:  if (ptr == length) /* I.e., if length is odd, */
        -: 1010:    to[ptr-1] = 0;   /* then pad with a NUL. */
        -: 1011:#elif defined (ACE_HAS_NONCONST_SWAB)
        -: 1012:  const char *tmp = static_cast<const char*> (src);
        -: 1013:  char *from = const_cast<char *> (tmp);
        -: 1014:  char *to = static_cast<char *> (dest);
        -: 1015:  ::swab (from, to, length);
        -: 1016:#elif defined (ACE_HAS_CONST_CHAR_SWAB)
        -: 1017:  const char *from = static_cast<const char*> (src);
        -: 1018:  char *to = static_cast<char *> (dest);
        -: 1019:  ::swab (from, to, length);
        -: 1020:#else
        -: 1021:  ::swab (src, dest, length);
        -: 1022:#endif /* ACE_LACKS_SWAB */
        -: 1023:
        -: 1024:}
        -: 1025:
        -: 1026:ACE_INLINE long
        -: 1027:ACE_OS::sysconf (int name)
        -: 1028:{
        -: 1029:  ACE_OS_TRACE ("ACE_OS::sysconf");
        -: 1030:#if defined (ACE_LACKS_SYSCONF)
        -: 1031:  ACE_UNUSED_ARG (name);
        -: 1032:  ACE_NOTSUP_RETURN (-1);
        -: 1033:#else
        -: 1034:  ACE_OSCALL_RETURN (::sysconf (name), long, -1);
        -: 1035:#endif /* ACE_LACKS_SYSCONF */
        -: 1036:}
        -: 1037:
        -: 1038:ACE_INLINE long
        -: 1039:ACE_OS::sysinfo (int cmd, char *buf, long count)
        -: 1040:{
        -: 1041:  ACE_OS_TRACE ("ACE_OS::sysinfo");
        -: 1042:#if defined (ACE_HAS_SYSV_SYSINFO)
        -: 1043:  ACE_OSCALL_RETURN (::sysinfo (cmd, buf, count), long, -1);
        -: 1044:#else
        -: 1045:  ACE_UNUSED_ARG (cmd);
        -: 1046:  ACE_UNUSED_ARG (buf);
        -: 1047:  ACE_UNUSED_ARG (count);
        -: 1048:
        -: 1049:  ACE_NOTSUP_RETURN (0);
        -: 1050:#endif /* ACE_HAS_SYSV_SYSINFO */
        -: 1051:}
        -: 1052:
        -: 1053:ACE_INLINE int
        -: 1054:ACE_OS::truncate (const ACE_TCHAR *filename,
        -: 1055:                  ACE_OFF_T offset)
        -: 1056:{
        -: 1057:  ACE_OS_TRACE ("ACE_OS::truncate");
        -: 1058:#if defined (ACE_WIN32)
        -: 1059:  ACE_HANDLE handle = ACE_OS::open (filename,
        -: 1060:                                    O_WRONLY,
        -: 1061:                                    ACE_DEFAULT_FILE_PERMS);
        -: 1062:
        -: 1063:#  if !defined (ACE_LACKS_WIN32_SETFILEPOINTEREX)
        -: 1064:  LARGE_INTEGER loffset;
        -: 1065:  loffset.QuadPart = offset;
        -: 1066:#else
        -: 1067:  LONG low_offset = ACE_LOW_PART(offset);
        -: 1068:  LONG high_offset = ACE_HIGH_PART(offset);
        -: 1069:#endif
        -: 1070:
        -: 1071:  if (handle == ACE_INVALID_HANDLE)
        -: 1072:    ACE_FAIL_RETURN (-1);
        -: 1073:
        -: 1074:#  if !defined (ACE_LACKS_WIN32_SETFILEPOINTEREX)
        -: 1075:  else if (::SetFilePointerEx (handle,
        -: 1076:                               loffset,
        -: 1077:                               0,
        -: 1078:                               FILE_BEGIN))
        -: 1079:#  else
        -: 1080:  else if (::SetFilePointer (handle,
        -: 1081:                             low_offset,
        -: 1082:                             &high_offset,
        -: 1083:                             FILE_BEGIN) != INVALID_SET_FILE_POINTER
        -: 1084:           || GetLastError () == NO_ERROR)
        -: 1085:#  endif /* ACE_LACKS_WIN32_SETFILEPOINTEREX */
        -: 1086:    {
        -: 1087:      BOOL result = ::SetEndOfFile (handle);
        -: 1088:      ::CloseHandle (handle);
        -: 1089:      ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (result, ace_result_), int, -1);
        -: 1090:    }
        -: 1091:  else
        -: 1092:    {
        -: 1093:      ::CloseHandle (handle);
        -: 1094:      ACE_FAIL_RETURN (-1);
        -: 1095:    }
        -: 1096:  /* NOTREACHED */
        -: 1097:#elif !defined (ACE_LACKS_TRUNCATE)
        -: 1098:  ACE_OSCALL_RETURN
        -: 1099:    (::truncate (ACE_TEXT_ALWAYS_CHAR (filename), offset), int, -1);
        -: 1100:#else
        -: 1101:  ACE_UNUSED_ARG (filename);
        -: 1102:  ACE_UNUSED_ARG (offset);
        -: 1103:  ACE_NOTSUP_RETURN (-1);
        -: 1104:#endif /* ACE_WIN32 */
        -: 1105:}
        -: 1106:
        -: 1107:ACE_INLINE useconds_t
        -: 1108:ACE_OS::ualarm (useconds_t usecs, useconds_t interval)
        -: 1109:{
        -: 1110:  ACE_OS_TRACE ("ACE_OS::ualarm");
        -: 1111:
        -: 1112:#if defined (ACE_HAS_UALARM)
        -: 1113:  return ::ualarm (usecs, interval);
        -: 1114:#elif !defined (ACE_LACKS_UNIX_SIGNALS) && !defined (ACE_LACKS_ALARM)
        -: 1115:  ACE_UNUSED_ARG (interval);
        -: 1116:# if defined (ACE_VXWORKS) && ACE_VXWORKS >= 0x690 && defined (_WRS_CONFIG_LP64)
        -: 1117:  return ::alarm (static_cast<unsigned int> (usecs * ACE_ONE_SECOND_IN_USECS));
        -: 1118:# else
        -: 1119:  return ::alarm (usecs * ACE_ONE_SECOND_IN_USECS);
        -: 1120:#endif
        -: 1121:#else
        -: 1122:  ACE_UNUSED_ARG (usecs);
        -: 1123:  ACE_UNUSED_ARG (interval);
        -: 1124:  ACE_NOTSUP_RETURN (0);
        -: 1125:#endif /* ACE_HAS_UALARM */
        -: 1126:}
        -: 1127:
        -: 1128:ACE_INLINE useconds_t
        -: 1129:ACE_OS::ualarm (const ACE_Time_Value &tv,
        -: 1130:                const ACE_Time_Value &tv_interval)
        -: 1131:{
        -: 1132:  ACE_OS_TRACE ("ACE_OS::ualarm");
        -: 1133:
        -: 1134:#if defined (ACE_HAS_UALARM)
        -: 1135:  useconds_t usecs = (tv.sec () * ACE_ONE_SECOND_IN_USECS) + tv.usec ();
        -: 1136:  useconds_t interval =
        -: 1137:    (tv_interval.sec () * ACE_ONE_SECOND_IN_USECS) + tv_interval.usec ();
        -: 1138:  return ::ualarm (usecs, interval);
        -: 1139:#elif !defined (ACE_LACKS_UNIX_SIGNALS) && !defined (ACE_LACKS_ALARM)
        -: 1140:  ACE_UNUSED_ARG (tv_interval);
        -: 1141:# if defined (ACE_VXWORKS) && ACE_VXWORKS >= 0x690 && defined (_WRS_CONFIG_LP64)
        -: 1142:  return ::alarm (static_cast<unsigned int> (tv.sec ()));
        -: 1143:# else
        -: 1144:  return ::alarm (tv.sec ());
        -: 1145:# endif
        -: 1146:#else
        -: 1147:  ACE_UNUSED_ARG (tv_interval);
        -: 1148:  ACE_UNUSED_ARG (tv);
        -: 1149:  ACE_NOTSUP_RETURN (0);
        -: 1150:#endif /* ACE_HAS_UALARM */
        -: 1151:}
        -: 1152:
        -: 1153:ACE_INLINE int
    #####: 1154:ACE_OS::unlink (const char *path)
        -: 1155:{
        -: 1156:  ACE_OS_TRACE ("ACE_OS::unlink");
        -: 1157:# if defined (ACE_HAS_NONCONST_UNLINK)
        -: 1158:  ACE_OSCALL_RETURN (::unlink (const_cast<char *> (path)), int, -1);
        -: 1159:# elif defined (ACE_HAS_WINCE)
        -: 1160:  // @@ The problem is, DeleteFile is not actually equals to unlink. ;(
        -: 1161:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::DeleteFile (ACE_TEXT_CHAR_TO_TCHAR (path)), ace_result_),
        -: 1162:                        int, -1);
        -: 1163:# elif defined (ACE_LACKS_UNLINK)
        -: 1164:  ACE_UNUSED_ARG (path);
        -: 1165:  ACE_NOTSUP_RETURN (-1);
        -: 1166:# else
    #####: 1167:  ACE_OSCALL_RETURN (::unlink (path), int, -1);
        -: 1168:# endif /* ACE_HAS_NONCONST_UNLINK */
        -: 1169:}
        -: 1170:
        -: 1171:#if defined (ACE_HAS_WCHAR)
        -: 1172:ACE_INLINE int
        -: 1173:ACE_OS::unlink (const wchar_t *path)
        -: 1174:{
        -: 1175:  ACE_OS_TRACE ("ACE_OS::unlink");
        -: 1176:# if defined (ACE_HAS_WINCE)
        -: 1177:  // @@ The problem is, DeleteFile is not actually equals to unlink. ;(
        -: 1178:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::DeleteFileW (path), ace_result_),
        -: 1179:                        int, -1);
        -: 1180:# elif defined (ACE_WIN32)
        -: 1181:  ACE_OSCALL_RETURN (::_wunlink (path), int, -1);
        -: 1182:# else
        -: 1183:  ACE_Wide_To_Ascii npath (path);
        -: 1184:  return ACE_OS::unlink (npath.char_rep ());
        -: 1185:# endif /* ACE_HAS_WINCE */
        -: 1186:}
        -: 1187:#endif /* ACE_HAS_WCHAR */
        -: 1188:
        -: 1189:ACE_INLINE ssize_t
        -: 1190:ACE_OS::write (ACE_HANDLE handle, const void *buf, size_t nbyte)
        -: 1191:{
        -: 1192:  ACE_OS_TRACE ("ACE_OS::write");
        -: 1193:#if defined (ACE_WIN32)
        -: 1194:  DWORD bytes_written; // This is set to 0 byte WriteFile.
        -: 1195:
        -: 1196:  // Strictly correctly, we should loop writing all the data if more
        -: 1197:  // than a DWORD length can hold.
        -: 1198:  DWORD short_nbyte = static_cast<DWORD> (nbyte);
        -: 1199:  if (::WriteFile (handle, buf, short_nbyte, &bytes_written, 0))
        -: 1200:    return (ssize_t) bytes_written;
        -: 1201:  else
        -: 1202:    ACE_FAIL_RETURN (-1);
        -: 1203:#else
        -: 1204:# if defined (ACE_HAS_CHARPTR_SOCKOPT)
        -: 1205:  ACE_OSCALL_RETURN (::write (handle, static_cast <char *> (const_cast <void *> (buf)), nbyte), ssize_t, -1);
        -: 1206:# else
        -: 1207:  ACE_OSCALL_RETURN (::write (handle, buf, nbyte), ssize_t, -1);
        -: 1208:# endif /* ACE_HAS_CHARPTR_SOCKOPT */
        -: 1209:#endif /* ACE_WIN32 */
        -: 1210:}
        -: 1211:
        -: 1212:ACE_INLINE ssize_t
        -: 1213:ACE_OS::write (ACE_HANDLE handle,
        -: 1214:               const void *buf,
        -: 1215:               size_t nbyte,
        -: 1216:               ACE_OVERLAPPED *overlapped)
        -: 1217:{
        -: 1218:  ACE_OS_TRACE ("ACE_OS::write");
        -: 1219:#if defined (ACE_WIN32)
        -: 1220:  DWORD bytes_written; // This is set to 0 byte WriteFile.
        -: 1221:
        -: 1222:  DWORD short_nbyte = static_cast<DWORD> (nbyte);
        -: 1223:  if (::WriteFile (handle, buf, short_nbyte, &bytes_written, overlapped))
        -: 1224:    return (ssize_t) bytes_written;
        -: 1225:  else
        -: 1226:    ACE_FAIL_RETURN (-1);
        -: 1227:#else
        -: 1228:  ACE_UNUSED_ARG (overlapped);
        -: 1229:  return ACE_OS::write (handle, buf, nbyte);
        -: 1230:#endif /* ACE_WIN32 */
        -: 1231:}
        -: 1232:
        -: 1233:ACE_END_VERSIONED_NAMESPACE_DECL
