        -:    0:Source:../dds/DCPS/Cached_Allocator_With_Overflow_T.h
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#ifndef CACHED_ALLOCATOR_WITH_OVERFLOW_T_H
        -:    9:#define CACHED_ALLOCATOR_WITH_OVERFLOW_T_H
        -:   10:
        -:   11:#include "debug.h"
        -:   12:#include "ace/Malloc_Allocator.h"
        -:   13:#include "ace/Malloc_T.h"
        -:   14:#include "ace/Free_List.h"
        -:   15:#include "ace/Guard_T.h"
        -:   16:#include "ace/Atomic_Op.h"
        -:   17:
        -:   18:#include "dds/DCPS/SafetyProfilePool.h"
        -:   19:#include "PoolAllocationBase.h"
        -:   20:
        -:   21:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   22:# pragma once
        -:   23:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   24:
        -:   25:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   26:
        -:   27:namespace OpenDDS {
        -:   28:namespace DCPS {
        -:   29:
        -:   30:/**
        -:   31:* @class Cached_Allocator_With_Overflow
        -:   32:*
        -:   33:* @brief A fixed-size allocator that caches items for quicker access
        -:   34:*        but if the pool is exhausted it will use the heap.
        -:   35:*
        -:   36:* This class enables caching of dynamically allocated,
        -:   37:* fixed-sized classes.  Notice that the <code>sizeof (TYPE)</code>
        -:   38:* must be greater than or equal to <code> sizeof (void*) </code> for
        -:   39:* this to work properly.
        -:   40:* If the free list is empty then memory is allocated from the heap.
        -:   41:* This way the allocations will not fail but may be slower.
        -:   42:*
        -:   43:*/
        -:   44:template <class T, class ACE_LOCK>
        -:   45:class Cached_Allocator_With_Overflow : public ACE_New_Allocator, public PoolAllocationBase {
        -:   46:public:
        -:   47:  /// Create a cached memory pool with @a n_chunks chunks
        -:   48:  /// each with sizeof (TYPE) size.
      270:   49:  Cached_Allocator_With_Overflow(size_t n_chunks)
        -:   50:    : allocs_from_heap_(0),
        -:   51:      allocs_from_pool_(0),
        -:   52:      frees_to_heap_(0),
        -:   53:      frees_to_pool_(0),
      270:   54:      free_list_(ACE_PURE_FREE_LIST) {
        -:   55:    // To maintain alignment requirements, make sure that each element
        -:   56:    // inserted into the free list is aligned properly for the platform.
        -:   57:    // Since the memory is allocated as a char[], the compiler won't help.
        -:   58:    // To make sure enough room is allocated, round up the size so that
        -:   59:    // each element starts aligned.
        -:   60:    //
        -:   61:    // NOTE - this would probably be easier by defining begin_ as a pointer
        -:   62:    // to T and allocating an array of them (the compiler would probably
        -:   63:    // take care of the alignment for us), but then the ACE_NEW below would
        -:   64:    // require a default constructor on T - a requirement that is not in
        -:   65:    // previous versions of ACE
      270:   66:    size_t chunk_size = sizeof(T);
      270:   67:    chunk_size = ACE_MALLOC_ROUNDUP(chunk_size, ACE_MALLOC_ALIGN);
      270:   68:    begin_ = static_cast<unsigned char*> (ACE_Allocator::instance()->malloc(n_chunks * chunk_size));
        -:   69:
        -:   70:    // Remember end of the pool.
      270:   71:    end_ = begin_ + n_chunks * chunk_size;
        -:   72:
        -:   73:    // Put into free list using placement contructor, no real memory
        -:   74:    // allocation in the <new> below.
    11553:   75:    for (size_t c = 0; c < n_chunks; c++) {
    11283:   76:      void* placement = begin_ + c * chunk_size;
    11283:   77:      this->free_list_.add(new(placement) ACE_Cached_Mem_Pool_Node<T>);
        -:   78:    }
      270:   79:  }
        -:   80:
        -:   81:  /// Clear things up.
      468:   82:  ~Cached_Allocator_With_Overflow() {
      270:   83:    ACE_Allocator::instance()->free(begin_);
      738:   84:  }
        -:   85:  /**
        -:   86:  * Get a chunk of memory from free list cache.  Note that @a nbytes is
        -:   87:  * only checked to make sure that it's less or equal to sizeof T, and is
        -:   88:  * otherwise ignored since @c malloc() always returns a pointer to an
        -:   89:  * item of sizeof (T).
        -:   90:  */
      348:   91:  void *malloc(size_t nbytes = sizeof(T)) {
        -:   92:    // Check if size requested fits within pre-determined size.
      348:   93:    if (nbytes > sizeof(T))
    #####:   94:      return 0;
        -:   95:
        -:   96:    // addr() call is really not absolutely necessary because of the way
        -:   97:    // ACE_Cached_Mem_Pool_Node's internal structure arranged.
      348:   98:    void* rtn =  this->free_list_.remove()->addr();
        -:   99:
      348:  100:    if (0 == rtn) {
    #####:  101:      rtn = ACE_Allocator::instance()->malloc(sizeof(T));
    #####:  102:      allocs_from_heap_++;
        -:  103:
    #####:  104:      if (DCPS_debug_level >= 2) {
    #####:  105:        if (allocs_from_heap_ == 1 && DCPS_debug_level >= 2)
    #####:  106:          ACE_DEBUG((LM_DEBUG,
        -:  107:                     "(%P|%t) Cached_Allocator_With_Overflow::malloc %@"
        -:  108:                     " %Lu heap allocs with %Lu outstanding\n",
        -:  109:                     this, this->allocs_from_heap_.value(),
        -:  110:                     this->allocs_from_heap_.value() - this->frees_to_heap_.value()));
        -:  111:
    #####:  112:        if (DCPS_debug_level >= 6)
    #####:  113:          if (allocs_from_heap_.value() % 500 == 0)
    #####:  114:            ACE_DEBUG((LM_DEBUG,
        -:  115:                       "(%P|%t) Cached_Allocator_With_Overflow::malloc %@"
        -:  116:                       " %Lu heap allocs with %Lu outstanding\n",
        -:  117:                       this, this->allocs_from_heap_.value(),
        -:  118:                       this->allocs_from_heap_.value() - this->frees_to_heap_.value()));
        -:  119:      }
        -:  120:
        -:  121:    } else {
      348:  122:      allocs_from_pool_++;
        -:  123:
      348:  124:      if (DCPS_debug_level >= 6)
    #####:  125:        if (allocs_from_pool_.value() % 500 == 0)
    #####:  126:          ACE_DEBUG((LM_DEBUG,
        -:  127:                     "(%P|%t) Cached_Allocator_With_Overflow::malloc %@"
        -:  128:                     " %Lu pool allocs %Lu pool frees with %Lu available\n",
        -:  129:                     this, this->allocs_from_pool_.value(), this->frees_to_pool_.value(),
        -:  130:                     this->available()));
        -:  131:    }
        -:  132:
      348:  133:    return rtn;
        -:  134:  }
        -:  135:
        -:  136:  /**
        -:  137:  * Get a chunk of memory from free list cache, giving them
        -:  138:  * @a initial_value.  Note that @a nbytes is only checked to make sure
        -:  139:  * that it's less or equal to sizeof T, and is otherwise ignored since
        -:  140:  * calloc() always returns a pointer to an item of sizeof (T).
        -:  141:  */
    #####:  142:  virtual void *calloc(size_t /* nbytes */,
        -:  143:                       char /* initial_value */ = '\0') {
    #####:  144:    ACE_NOTSUP_RETURN(0);
        -:  145:  }
        -:  146:
        -:  147:  /// This method is a no-op and just returns 0 since the free list
        -:  148:  /// only works with fixed sized entities.
    #####:  149:  virtual void *calloc(size_t /* n_elem */,
        -:  150:                       size_t /* elem_size */,
        -:  151:                       char /* initial_value */ = '\0') {
    #####:  152:    ACE_NOTSUP_RETURN(0);
        -:  153:  }
        -:  154:
        -:  155:  /// Return a chunk of memory back to free list cache.
      348:  156:  void free(void * ptr) {
      348:  157:    unsigned char* tmp = static_cast<unsigned char*>(ptr);
      696:  158:    if (tmp < begin_ ||
      348:  159:        tmp >= end_) {
    #####:  160:      ACE_Allocator::instance()->free(tmp);
    #####:  161:      frees_to_heap_++;
        -:  162:
    #####:  163:      if (frees_to_heap_ > allocs_from_heap_.value()) {
    #####:  164:        ACE_ERROR((LM_ERROR,
        -:  165:                   "(%P|%t) ERROR:Cached_Allocator_With_Overflow::free %@"
        -:  166:                   " more deletes %Lu than allocs %Lu to the heap\n",
        -:  167:                   this,
        -:  168:                   this->frees_to_heap_.value(),
        -:  169:                   this->allocs_from_heap_.value()));
        -:  170:      }
        -:  171:
    #####:  172:      if (DCPS_debug_level >= 6) {
    #####:  173:        if (frees_to_heap_.value() % 500 == 0) {
    #####:  174:          ACE_DEBUG((LM_DEBUG,
        -:  175:                     "(%P|%t) Cached_Allocator_With_Overflow::free %@"
        -:  176:                     " %Lu heap allocs with %Lu outstanding\n",
        -:  177:                     this, this->allocs_from_heap_.value(),
        -:  178:                     this->allocs_from_heap_.value() - this->frees_to_heap_.value()));
        -:  179:        }
    #####:  180:      }
        -:  181:
      348:  182:    } else if (ptr != 0) {
      348:  183:      frees_to_pool_ ++;
        -:  184:
      348:  185:      if (frees_to_pool_ > allocs_from_pool_.value()) {
    #####:  186:        ACE_ERROR((LM_ERROR,
        -:  187:                   "(%P|%t) ERROR: Cached_Allocator_With_Overflow::free %@"
        -:  188:                   " more deletes %Lu than allocs %Lu from the pool ptr=%@ begin_=%@ end_=%@\n",
        -:  189:                   this,
        -:  190:                   this->frees_to_pool_.value(),
        -:  191:                   this->allocs_from_pool_.value(), ptr, begin_, end_));
        -:  192:      }
        -:  193:
      348:  194:      this->free_list_.add((ACE_Cached_Mem_Pool_Node<T> *) ptr) ;
        -:  195:
      348:  196:      if (DCPS_debug_level >= 6)
    #####:  197:        if (this->available() % 500 == 0)
    #####:  198:          ACE_DEBUG((LM_DEBUG,
        -:  199:                     "(%P|%t) Cached_Allocator_With_Overflow::malloc %@"
        -:  200:                     " %Lu pool allocs %Lu pool free with %Lu available\n",
        -:  201:                     this, this->allocs_from_pool_.value(),
        -:  202:                     this->frees_to_pool_.value(),
        -:  203:                     this->available()));
        -:  204:    }
      348:  205:  }
        -:  206:
        -:  207:  // -- for debug
        -:  208:
        -:  209:  /** How many chunks are available at this time.
        -:  210:  */
    #####:  211:  size_t available() {
    #####:  212:    return free_list_.size();
        -:  213:  };
        -:  214:
        -:  215:  ACE_Atomic_Op<ACE_Thread_Mutex, unsigned long> allocs_from_heap_;
        -:  216:  ACE_Atomic_Op<ACE_Thread_Mutex, unsigned long> allocs_from_pool_;
        -:  217:  ACE_Atomic_Op<ACE_Thread_Mutex, unsigned long> frees_to_heap_ ;
        -:  218:  ACE_Atomic_Op<ACE_Thread_Mutex, unsigned long> frees_to_pool_;
        -:  219:
        -:  220:private:
        -:  221:  /// Remember how we allocate the memory in the first place so
        -:  222:  /// we can clear things up later.
        -:  223:  unsigned char* begin_;
        -:  224:  /// The end of the pool.
        -:  225:  unsigned char* end_;
        -:  226:
        -:  227:  /// Maintain a cached memory free list.
        -:  228:  ACE_Locked_Free_List<ACE_Cached_Mem_Pool_Node<T>, ACE_LOCK> free_list_;
        -:  229:};
        -:  230:
        -:  231:} // namespace DCPS
        -:  232:} // namespace OpenDDS
        -:  233:
        -:  234:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  235:
        -:  236:#endif /* CACHED_ALLOCATOR_WITH_OVERFLOW_T_H */
