        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Unbounded_Queue.cpp
        -:    0:Programs:51
        -:    1:// $Id: Unbounded_Queue.cpp 2622 2015-08-13 18:30:00Z mitza $
        -:    2:
        -:    3:#ifndef ACE_UNBOUNDED_QUEUE_CPP
        -:    4:#define ACE_UNBOUNDED_QUEUE_CPP
        -:    5:
        -:    6:#include "ace/Unbounded_Queue.h"
        -:    7:
        -:    8:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:    9:# pragma once
        -:   10:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   11:
        -:   12:#if !defined (__ACE_INLINE__)
        -:   13:#include "ace/Unbounded_Queue.inl"
        -:   14:#endif /* __ACE_INLINE__ */
        -:   15:
        -:   16:#include "ace/Malloc_Base.h"
        -:   17:#include "ace/Log_Category.h"
        -:   18:#include "ace/os_include/os_errno.h"
        -:   19:
        -:   20:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   21:
        -:   22:ACE_ALLOC_HOOK_DEFINE_Tc(ACE_Unbounded_Queue)
        -:   23:
        -:   24:template <class T>
        4:   25:ACE_Unbounded_Queue<T>::ACE_Unbounded_Queue (ACE_Allocator *alloc)
        -:   26:  : head_ (0),
        -:   27:    cur_size_ (0),
        4:   28:    allocator_ (alloc)
        -:   29:{
        -:   30:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::ACE_Unbounded_Queue (void)");
        -:   31:
        4:   32:  if (this->allocator_ == 0)
        4:   33:    this->allocator_ = ACE_Allocator::instance ();
        -:   34:
        4:   35:  ACE_NEW_MALLOC (this->head_,
        -:   36:                  (ACE_Node<T> *) this->allocator_->malloc (sizeof (ACE_Node<T>)),
        -:   37:                  ACE_Node<T>);
        -:   38:  // Make the list circular by pointing it back to itself.
        4:   39:  this->head_->next_ = this->head_;
        -:   40:}
        -:   41:
        -:   42:template <class T>
        -:   43:ACE_Unbounded_Queue<T>::ACE_Unbounded_Queue (const ACE_Unbounded_Queue<T> &us)
        -:   44:  : head_ (0),
        -:   45:    cur_size_ (0),
        -:   46:    allocator_ (us.allocator_)
        -:   47:{
        -:   48:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::ACE_Unbounded_Queue");
        -:   49:
        -:   50:  if (this->allocator_ == 0)
        -:   51:    this->allocator_ = ACE_Allocator::instance ();
        -:   52:
        -:   53:  ACE_NEW_MALLOC (this->head_,
        -:   54:                  (ACE_Node<T> *) this->allocator_->malloc (sizeof (ACE_Node<T>)),
        -:   55:                  ACE_Node<T>);
        -:   56:  this->head_->next_ = this->head_;
        -:   57:  this->copy_nodes (us);
        -:   58:}
        -:   59:
        -:   60:template <class T> void
        -:   61:ACE_Unbounded_Queue<T>::operator= (const ACE_Unbounded_Queue<T> &us)
        -:   62:{
        -:   63:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::operator=");
        -:   64:
        -:   65:  if (this != &us)
        -:   66:    {
        -:   67:      this->delete_nodes ();
        -:   68:      this->copy_nodes (us);
        -:   69:    }
        -:   70:}
        -:   71:
        -:   72:template <class T> ACE_Unbounded_Queue_Iterator<T>
        -:   73:ACE_Unbounded_Queue<T>::begin (void)
        -:   74:{
        -:   75:  // ACE_TRACE ("ACE_Unbounded_Queue<T>::begin");
        -:   76:  return ACE_Unbounded_Queue_Iterator<T> (*this);
        -:   77:}
        -:   78:
        -:   79:template <class T> ACE_Unbounded_Queue_Iterator<T>
        -:   80:ACE_Unbounded_Queue<T>::end (void)
        -:   81:{
        -:   82:  // ACE_TRACE ("ACE_Unbounded_Queue<T>::end");
        -:   83:  return ACE_Unbounded_Queue_Iterator<T> (*this, 1);
        -:   84:}
        -:   85:
        -:   86:template <class T> void
        -:   87:ACE_Unbounded_Queue<T>::dump (void) const
        -:   88:{
        -:   89:#if defined (ACE_HAS_DUMP)
        -:   90:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::dump");
        -:   91:
        -:   92:  ACELIB_DEBUG ((LM_DEBUG, ACE_BEGIN_DUMP, this));
        -:   93:  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("\nhead_ = %u"), this->head_));
        -:   94:  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("\nhead_->next_ = %u"), this->head_->next_));
        -:   95:  ACELIB_DEBUG ((LM_DEBUG,  ACE_TEXT ("\ncur_size_ = %d\n"), this->cur_size_));
        -:   96:
        -:   97:  T *item = 0;
        -:   98:#if !defined (ACE_NLOGGING)
        -:   99:  size_t count = 1;
        -:  100:#endif /* ! ACE_NLOGGING */
        -:  101:
        -:  102:  for (ACE_Unbounded_Queue_Iterator<T> iter (*(ACE_Unbounded_Queue<T> *) this);
        -:  103:       iter.next (item) != 0;
        -:  104:       iter.advance ())
        -:  105:    ACELIB_DEBUG ((LM_DEBUG, ACE_TEXT ("count = %d\n"), count++));
        -:  106:
        -:  107:  ACELIB_DEBUG ((LM_DEBUG, ACE_END_DUMP));
        -:  108:#endif /* ACE_HAS_DUMP */
        -:  109:}
        -:  110:
        -:  111:template <class T> void
        -:  112:ACE_Unbounded_Queue<T>::copy_nodes (const ACE_Unbounded_Queue<T> &us)
        -:  113:{
        -:  114:  for (ACE_Node<T> *curr = us.head_->next_;
        -:  115:       curr != us.head_;
        -:  116:       curr = curr->next_)
        -:  117:    if (this->enqueue_tail (curr->item_) == -1)
        -:  118:      // @@ What's the right thing to do here?
        -:  119:      this->delete_nodes ();
        -:  120:}
        -:  121:
        -:  122:template <class T> void
        4:  123:ACE_Unbounded_Queue<T>::delete_nodes (void)
        -:  124:{
        4:  125:  for (ACE_Node<T> *curr = this->head_->next_;
        -:  126:       // Keep looking until we've hit the dummy node.
        4:  127:       curr != this->head_;
        -:  128:       )
        -:  129:    {
    #####:  130:      ACE_Node<T> *temp = curr;
    #####:  131:      curr = curr->next_;
        -:  132:
    #####:  133:      ACE_DES_FREE_TEMPLATE (temp,
        -:  134:                             this->allocator_->free,
        -:  135:                             ACE_Node,
        -:  136:                             <T>);
    #####:  137:      --this->cur_size_;
        -:  138:      // @@ Doesnt make sense to have this check since
        -:  139:      // this will always be true.
        -:  140:      //   ACE_ASSERT (this->cur_size_ >= 0);
        -:  141:    }
        -:  142:
        -:  143:  // Reset the list to be a circular list with just a dummy node.
        4:  144:  this->head_->next_ = this->head_;
        4:  145:}
        -:  146:
        -:  147:template <class T>
        4:  148:ACE_Unbounded_Queue<T>::~ACE_Unbounded_Queue (void)
        -:  149:{
        -:  150:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::~ACE_Unbounded_Queue (void)");
        -:  151:
        4:  152:  this->delete_nodes ();
        4:  153:  ACE_DES_FREE_TEMPLATE (head_,
        -:  154:                         this->allocator_->free,
        -:  155:                         ACE_Node,
        -:  156:                         <T>);
        4:  157:}
        -:  158:
        -:  159:template <class T> int
        -:  160:ACE_Unbounded_Queue<T>::enqueue_head (const T &new_item)
        -:  161:{
        -:  162:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::enqueue_head");
        -:  163:
        -:  164:  ACE_Node<T> *temp = 0;
        -:  165:
        -:  166:  // Create a new node that points to the original head.
        -:  167:  ACE_NEW_MALLOC_RETURN (temp,
        -:  168:                         static_cast<ACE_Node<T> *> (this->allocator_->malloc (sizeof (ACE_Node<T>))),
        -:  169:                         ACE_Node<T> (new_item, this->head_->next_),
        -:  170:                         -1);
        -:  171:  // Link this pointer into the front of the list.  Note that the
        -:  172:  // "real" head of the queue is <head_->next_>, whereas <head_> is
        -:  173:  // just a pointer to the dummy node.
        -:  174:  this->head_->next_ = temp;
        -:  175:
        -:  176:  ++this->cur_size_;
        -:  177:  return 0;
        -:  178:}
        -:  179:
        -:  180:template <class T> int
        8:  181:ACE_Unbounded_Queue<T>::enqueue_tail (const T &new_item)
        -:  182:{
        -:  183:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::enqueue_tail");
        -:  184:
        -:  185:  // Insert <item> into the old dummy node location.  Note that this
        -:  186:  // isn't actually the "head" item in the queue, it's a dummy node at
        -:  187:  // the "tail" of the queue...
        8:  188:  this->head_->item_ = new_item;
        -:  189:
        8:  190:  ACE_Node<T> *temp = 0;
        -:  191:
        -:  192:  // Create a new dummy node.
        8:  193:  ACE_NEW_MALLOC_RETURN (temp,
        -:  194:                         static_cast<ACE_Node<T> *> (this->allocator_->malloc (sizeof (ACE_Node<T>))),
        -:  195:                         ACE_Node<T> (this->head_->next_),
        -:  196:                         -1);
        -:  197:  // Link this dummy pointer into the list.
        8:  198:  this->head_->next_ = temp;
        -:  199:
        -:  200:  // Point the head to the new dummy node.
        8:  201:  this->head_ = temp;
        -:  202:
        8:  203:  ++this->cur_size_;
        8:  204:  return 0;
        -:  205:}
        -:  206:
        -:  207:template <class T> int
        8:  208:ACE_Unbounded_Queue<T>::dequeue_head (T &item)
        -:  209:{
        -:  210:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::dequeue_head");
        -:  211:
        -:  212:  // Check for empty queue.
        8:  213:  if (this->is_empty ())
    #####:  214:    return -1;
        -:  215:
        8:  216:  ACE_Node<T> *temp = this->head_->next_;
        -:  217:
        8:  218:  item = temp->item_;
        8:  219:  this->head_->next_ = temp->next_;
        8:  220:  ACE_DES_FREE_TEMPLATE (temp,
        -:  221:                         this->allocator_->free,
        -:  222:                         ACE_Node,
        -:  223:                         <T>);
        8:  224:  --this->cur_size_;
        8:  225:  return 0;
        -:  226:}
        -:  227:
        -:  228:template <class T> void
        -:  229:ACE_Unbounded_Queue<T>::reset (void)
        -:  230:{
        -:  231:  ACE_TRACE ("reset");
        -:  232:
        -:  233:  this->delete_nodes ();
        -:  234:}
        -:  235:
        -:  236:template <class T> int
        -:  237:ACE_Unbounded_Queue<T>::get (T *&item, size_t slot) const
        -:  238:{
        -:  239:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::get");
        -:  240:
        -:  241:  ACE_Node<T> *curr = this->head_->next_;
        -:  242:
        -:  243:  size_t i;
        -:  244:
        -:  245:  for (i = 0; i < this->cur_size_; i++)
        -:  246:    {
        -:  247:      if (i == slot)
        -:  248:        break;
        -:  249:
        -:  250:      curr = curr->next_;
        -:  251:    }
        -:  252:
        -:  253:  if (i < this->cur_size_)
        -:  254:    {
        -:  255:      item = &curr->item_;
        -:  256:      return 0;
        -:  257:    }
        -:  258:  else
        -:  259:    return -1;
        -:  260:}
        -:  261:
        -:  262:template <class T> int
        -:  263:ACE_Unbounded_Queue<T>::set (const T &item,
        -:  264:                             size_t slot)
        -:  265:{
        -:  266:  //   ACE_TRACE ("ACE_Unbounded_Queue<T>::set");
        -:  267:
        -:  268:  ACE_Node<T> *curr = this->head_->next_;
        -:  269:
        -:  270:  size_t i;
        -:  271:
        -:  272:  for (i = 0;
        -:  273:       i < slot && i < this->cur_size_;
        -:  274:       ++i)
        -:  275:    curr = curr->next_;
        -:  276:
        -:  277:  if (i < this->cur_size_)
        -:  278:    {
        -:  279:      // We're in range, so everything's cool.
        -:  280:      curr->item_ = item;
        -:  281:      return 0;
        -:  282:    }
        -:  283:  else
        -:  284:    {
        -:  285:      // We need to expand the list.
        -:  286:
        -:  287:      // A common case will be increasing the set size by 1.
        -:  288:      // Therefore, we'll optimize for this case.
        -:  289:      if (i == slot)
        -:  290:        {
        -:  291:          // Try to expand the size of the set by 1.
        -:  292:          if (this->enqueue_tail (item) == -1)
        -:  293:            return -1;
        -:  294:          else
        -:  295:            return 0;
        -:  296:        }
        -:  297:      else
        -:  298:        {
        -:  299:          T const dummy = T ();
        -:  300:
        -:  301:          // We need to expand the list by multiple (dummy) items.
        -:  302:          for (; i < slot; ++i)
        -:  303:            {
        -:  304:              // This head points to the existing dummy node, which is
        -:  305:              // about to be overwritten when we add the new dummy
        -:  306:              // node.
        -:  307:              curr = this->head_;
        -:  308:
        -:  309:              // Try to expand the size of the set by 1, but don't
        -:  310:              // store anything in the dummy node (yet).
        -:  311:              if (this->enqueue_tail (dummy) == -1)
        -:  312:                return -1;
        -:  313:            }
        -:  314:
        -:  315:          curr->item_ = item;
        -:  316:          return 0;
        -:  317:        }
        -:  318:    }
        -:  319:}
        -:  320:
        -:  321:// ****************************************************************
        -:  322:
        -:  323:template <class T> void
        -:  324:ACE_Unbounded_Queue_Const_Iterator<T>::dump (void) const
        -:  325:{
        -:  326:#if defined (ACE_HAS_DUMP)
        -:  327:  // ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::dump");
        -:  328:#endif /* ACE_HAS_DUMP */
        -:  329:}
        -:  330:
        -:  331:template <class T>
        -:  332:ACE_Unbounded_Queue_Const_Iterator<T>::ACE_Unbounded_Queue_Const_Iterator (const ACE_Unbounded_Queue<T> &q, int end)
        -:  333:  : current_ (end == 0 ? q.head_->next_ : q.head_ ),
        -:  334:    queue_ (q)
        -:  335:{
        -:  336:  // ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::ACE_Unbounded_Queue_Const_Iterator");
        -:  337:}
        -:  338:
        -:  339:template <class T> int
        -:  340:ACE_Unbounded_Queue_Const_Iterator<T>::advance (void)
        -:  341:{
        -:  342:  // ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::advance");
        -:  343:  this->current_ = this->current_->next_;
        -:  344:  return this->current_ != this->queue_.head_;
        -:  345:}
        -:  346:
        -:  347:template <class T> int
        -:  348:ACE_Unbounded_Queue_Const_Iterator<T>::first (void)
        -:  349:{
        -:  350:  // ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::first");
        -:  351:  this->current_ = this->queue_.head_->next_;
        -:  352:  return this->current_ != this->queue_.head_;
        -:  353:}
        -:  354:
        -:  355:template <class T> int
        -:  356:ACE_Unbounded_Queue_Const_Iterator<T>::done (void) const
        -:  357:{
        -:  358:  ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::done");
        -:  359:
        -:  360:  return this->current_ == this->queue_.head_;
        -:  361:}
        -:  362:
        -:  363:template <class T> int
        -:  364:ACE_Unbounded_Queue_Const_Iterator<T>::next (T *&item)
        -:  365:{
        -:  366:  // ACE_TRACE ("ACE_Unbounded_Queue_Const_Iterator<T>::next");
        -:  367:  if (this->current_ == this->queue_.head_)
        -:  368:    return 0;
        -:  369:  else
        -:  370:    {
        -:  371:      item = &this->current_->item_;
        -:  372:      return 1;
        -:  373:    }
        -:  374:}
        -:  375:
        -:  376:// ****************************************************************
        -:  377:
        -:  378:template <class T> void
        -:  379:ACE_Unbounded_Queue_Iterator<T>::dump (void) const
        -:  380:{
        -:  381:#if defined (ACE_HAS_DUMP)
        -:  382:  // ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::dump");
        -:  383:#endif /* ACE_HAS_DUMP */
        -:  384:}
        -:  385:
        -:  386:template <class T>
        -:  387:ACE_Unbounded_Queue_Iterator<T>::ACE_Unbounded_Queue_Iterator (ACE_Unbounded_Queue<T> &q, int end)
        -:  388:  : current_ (end == 0 ? q.head_->next_ : q.head_ ),
        -:  389:    queue_ (q)
        -:  390:{
        -:  391:  // ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::ACE_Unbounded_Queue_Iterator");
        -:  392:}
        -:  393:
        -:  394:template <class T> int
        -:  395:ACE_Unbounded_Queue_Iterator<T>::advance (void)
        -:  396:{
        -:  397:  // ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::advance");
        -:  398:  this->current_ = this->current_->next_;
        -:  399:  return this->current_ != this->queue_.head_;
        -:  400:}
        -:  401:
        -:  402:template <class T> int
        -:  403:ACE_Unbounded_Queue_Iterator<T>::first (void)
        -:  404:{
        -:  405:  // ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::first");
        -:  406:  this->current_ = this->queue_.head_->next_;
        -:  407:  return this->current_ != this->queue_.head_;
        -:  408:}
        -:  409:
        -:  410:template <class T> int
        -:  411:ACE_Unbounded_Queue_Iterator<T>::done (void) const
        -:  412:{
        -:  413:  ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::done");
        -:  414:
        -:  415:  return this->current_ == this->queue_.head_;
        -:  416:}
        -:  417:
        -:  418:template <class T> int
        -:  419:ACE_Unbounded_Queue_Iterator<T>::next (T *&item)
        -:  420:{
        -:  421:  // ACE_TRACE ("ACE_Unbounded_Queue_Iterator<T>::next");
        -:  422:  if (this->current_ == this->queue_.head_)
        -:  423:    return 0;
        -:  424:  else
        -:  425:    {
        -:  426:      item = &this->current_->item_;
        -:  427:      return 1;
        -:  428:    }
        -:  429:}
        -:  430:
        -:  431:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  432:
        -:  433:#endif /* ACE_UNBOUNDED_QUEUE_CPP */
