        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/OS_NS_sys_stat.inl
        -:    0:Programs:51
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id: OS_NS_sys_stat.inl 2179 2013-05-28 22:16:51Z mesnierp $
        -:    4:
        -:    5:#include "ace/OS_NS_unistd.h"
        -:    6:#include "ace/OS_NS_fcntl.h"
        -:    7:#include "ace/OS_NS_errno.h"
        -:    8:#include "ace/OS_NS_macros.h"
        -:    9:
        -:   10:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   11:
        -:   12:namespace ACE_OS
        -:   13:{
        -:   14:
        -:   15:  ACE_INLINE ACE_HANDLE
        -:   16:  creat (const ACE_TCHAR *filename, mode_t mode)
        -:   17:  {
        -:   18:    ACE_OS_TRACE ("ACE_OS::creat");
        -:   19:#if defined (ACE_WIN32)
        -:   20:    return ACE_OS::open (filename, O_CREAT|O_TRUNC|O_WRONLY, mode);
        -:   21:#else
        -:   22:    ACE_OSCALL_RETURN (::creat (ACE_TEXT_ALWAYS_CHAR (filename), mode),
        -:   23:                       ACE_HANDLE, ACE_INVALID_HANDLE);
        -:   24:#endif /* ACE_WIN32 */
        -:   25:  }
        -:   26:
        -:   27:  ACE_INLINE int
    #####:   28:  fstat (ACE_HANDLE handle, ACE_stat *stp)
        -:   29:  {
        -:   30:    ACE_OS_TRACE ("ACE_OS::fstat");
        -:   31:#if defined (ACE_HAS_X86_STAT_MACROS)
        -:   32:    // Solaris for intel uses an macro for fstat(), this is a wrapper
        -:   33:    // for _fxstat() use of the macro.
        -:   34:    // causes compile and runtime problems.
        -:   35:    ACE_OSCALL_RETURN (::_fxstat (_STAT_VER, handle, stp), int, -1);
        -:   36:#elif defined (ACE_WIN32)
        -:   37:    BY_HANDLE_FILE_INFORMATION fdata;
        -:   38:
        -:   39:    if (::GetFileInformationByHandle (handle, &fdata) == FALSE)
        -:   40:      {
        -:   41:        ACE_OS::set_errno_to_last_error ();
        -:   42:        return -1;
        -:   43:      }
        -:   44:    else if (fdata.nFileSizeHigh != 0)
        -:   45:      {
        -:   46:        errno = EINVAL;
        -:   47:        return -1;
        -:   48:      }
        -:   49:    else
        -:   50:      {
        -:   51:        stp->st_size = fdata.nFileSizeLow;
        -:   52:        stp->st_atime = ACE_Time_Value (fdata.ftLastAccessTime).sec ();
        -:   53:        stp->st_mtime = ACE_Time_Value (fdata.ftLastWriteTime).sec ();
        -:   54:        stp->st_ctime = ACE_Time_Value (fdata.ftCreationTime).sec ();
        -:   55:        stp->st_nlink = static_cast<short> (fdata.nNumberOfLinks);
        -:   56:        stp->st_dev = stp->st_rdev = 0; // No equivalent conversion.
        -:   57:        stp->st_mode = S_IXOTH | S_IROTH |
        -:   58:          (fdata.dwFileAttributes & FILE_ATTRIBUTE_READONLY ? 0 : S_IWOTH) |
        -:   59:          (fdata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY ? S_IFDIR : S_IFREG);
        -:   60:      }
        -:   61:    return 0;
        -:   62:#else
        -:   63:# if defined (ACE_OPENVMS)
        -:   64:    //FUZZ: disable check_for_lack_ACE_OS
        -:   65:    ::fsync(handle);
        -:   66:    //FUZZ: enable check_for_lack_ACE_OS
        -:   67: #endif
    #####:   68:    ACE_OSCALL_RETURN (::fstat (handle, stp), int, -1);
        -:   69:# endif /* !ACE_HAS_X86_STAT_MACROS */
        -:   70:  }
        -:   71:
        -:   72:  // This function returns the number of bytes in the file referenced by
        -:   73:  // FD.
        -:   74:
        -:   75:  ACE_INLINE ACE_OFF_T
        -:   76:  filesize (ACE_HANDLE handle)
        -:   77:  {
        -:   78:    ACE_OS_TRACE ("ACE_OS::filesize");
        -:   79:#if defined (ACE_WIN32)
        -:   80:# if defined (_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
        -:   81:    LARGE_INTEGER size;
        -:   82:    return
        -:   83:      (::GetFileSizeEx (handle, &size)
        -:   84:       ? size.QuadPart
        -:   85:       : (ACE_OS::set_errno_to_last_error (), -1));
        -:   86:# else
        -:   87:    DWORD const size = ::GetFileSize (handle, 0);
        -:   88:    return
        -:   89:      (size != INVALID_FILE_SIZE
        -:   90:       ? static_cast<ACE_OFF_T> (size)
        -:   91:       : (ACE_OS::set_errno_to_last_error (), -1));
        -:   92:# endif  /* _FILE_OFFSET_BITS == 64 */
        -:   93:#else /* !ACE_WIN32 */
        -:   94:    ACE_stat sb;
        -:   95:    return ACE_OS::fstat (handle, &sb) == -1 ?
        -:   96:                    static_cast<ACE_OFF_T> (-1) : sb.st_size;
        -:   97:#endif
        -:   98:  }
        -:   99:
        -:  100:  ACE_INLINE ACE_OFF_T
        -:  101:  filesize (const ACE_TCHAR *filename)
        -:  102:  {
        -:  103:    ACE_OS_TRACE ("ACE_OS::filesize");
        -:  104:
        -:  105:    ACE_HANDLE const h = ACE_OS::open (filename, O_RDONLY);
        -:  106:    if (h != ACE_INVALID_HANDLE)
        -:  107:      {
        -:  108:        ACE_OFF_T size = ACE_OS::filesize (h);
        -:  109:        ACE_OS::close (h);
        -:  110:        return size;
        -:  111:      }
        -:  112:    else
        -:  113:      return -1;
        -:  114:  }
        -:  115:
        -:  116:  ACE_INLINE int
        -:  117:  lstat (const char *file, ACE_stat *stp)
        -:  118:  {
        -:  119:    ACE_OS_TRACE ("ACE_OS::lstat");
        -:  120:# if defined (ACE_LACKS_LSTAT)
        -:  121:    return ACE_OS::stat (file, stp);
        -:  122:# elif defined (ACE_HAS_X86_STAT_MACROS)
        -:  123:    // Solaris for intel uses an macro for lstat(), this macro is a
        -:  124:    // wrapper for _lxstat().
        -:  125:    ACE_OSCALL_RETURN (::_lxstat (_STAT_VER, file, stp), int, -1);
        -:  126:# else /* !ACE_HAS_X86_STAT_MACROS */
        -:  127:    ACE_OSCALL_RETURN (::lstat (file, stp), int, -1);
        -:  128:# endif /* ACE_LACKS_LSTAT */
        -:  129:  }
        -:  130:
        -:  131:#if defined (ACE_HAS_WCHAR)
        -:  132:  ACE_INLINE int
        -:  133:  lstat (const wchar_t *file, ACE_stat *stp)
        -:  134:  {
        -:  135:    ACE_OS_TRACE ("ACE_OS::lstat");
        -:  136:# if defined (ACE_LACKS_LSTAT)
        -:  137:    return ACE_OS::stat (file, stp);
        -:  138:# else
        -:  139:    return ACE_OS::lstat (ACE_Wide_To_Ascii (file).char_rep (), stp);
        -:  140:# endif /* ACE_LACKS_LSTAT */
        -:  141:  }
        -:  142:#endif /* ACE_HAS_WCHAR */
        -:  143:
        -:  144:  ACE_INLINE int
        -:  145:  mkdir (const char *path, mode_t mode)
        -:  146:  {
        -:  147:#if defined (ACE_HAS_WINCE)
        -:  148:    ACE_UNUSED_ARG (mode);
        -:  149:    ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::CreateDirectory (ACE_TEXT_CHAR_TO_TCHAR (path), 0),
        -:  150:                                            ace_result_),
        -:  151:                          int, -1);
        -:  152:#elif defined (ACE_MKDIR_LACKS_MODE)
        -:  153:    ACE_UNUSED_ARG (mode);
        -:  154:    ACE_OSCALL_RETURN (::mkdir (path), int, -1);
        -:  155:#else
        -:  156:    ACE_OSCALL_RETURN (::mkdir (path, mode), int, -1);
        -:  157:#endif
        -:  158:  }
        -:  159:
        -:  160:#if defined (ACE_HAS_WCHAR)
        -:  161:
        -:  162:  ACE_INLINE int
        -:  163:  mkdir (const wchar_t *path, mode_t mode)
        -:  164:  {
        -:  165:#if defined (ACE_HAS_WINCE)
        -:  166:    ACE_UNUSED_ARG (mode);
        -:  167:    ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (CreateDirectoryW (path, 0),
        -:  168:                                            ace_result_),
        -:  169:                          int, -1);
        -:  170:#elif defined (ACE_WIN32) && defined (ACE_USES_WCHAR)
        -:  171:    ACE_UNUSED_ARG (mode);
        -:  172:    ACE_OSCALL_RETURN (::_wmkdir (path), int, -1);
        -:  173:#else
        -:  174:    return ACE_OS::mkdir (ACE_Wide_To_Ascii (path).char_rep (), mode);
        -:  175:#endif /* ACE_HAS_WINCE */
        -:  176:  }
        -:  177:
        -:  178:#endif /* ACE_HAS_WCHAR */
        -:  179:
        -:  180:  ACE_INLINE int
        -:  181:  mkfifo (const ACE_TCHAR *file, mode_t mode)
        -:  182:  {
        -:  183:    ACE_OS_TRACE ("ACE_OS::mkfifo");
        -:  184:#if defined (ACE_LACKS_MKFIFO)
        -:  185:    ACE_UNUSED_ARG (file);
        -:  186:    ACE_UNUSED_ARG (mode);
        -:  187:    ACE_NOTSUP_RETURN (-1);
        -:  188:#else
        -:  189:    ACE_OSCALL_RETURN (::mkfifo (ACE_TEXT_ALWAYS_CHAR (file), mode), int, -1);
        -:  190:#endif /* ACE_LACKS_MKFIFO */
        -:  191:  }
        -:  192:
        -:  193:  ACE_INLINE int
        -:  194:  stat (const char *file, ACE_stat *stp)
        -:  195:  {
        -:  196:    ACE_OS_TRACE ("ACE_OS::stat");
        -:  197:#if defined (ACE_HAS_NONCONST_STAT)
        -:  198:    ACE_OSCALL_RETURN (::stat (const_cast <char *> (file), stp), int, -1);
        -:  199:#elif defined (ACE_HAS_WINCE)
        -:  200:    ACE_TEXT_WIN32_FIND_DATA fdata;
        -:  201:
        -:  202:    HANDLE fhandle;
        -:  203:
        -:  204:    fhandle = ::FindFirstFile (ACE_TEXT_CHAR_TO_TCHAR (file), &fdata);
        -:  205:    if (fhandle == INVALID_HANDLE_VALUE)
        -:  206:      {
        -:  207:        ACE_OS::set_errno_to_last_error ();
        -:  208:        return -1;
        -:  209:      }
        -:  210:    else if (fdata.nFileSizeHigh != 0)
        -:  211:      {
        -:  212:        errno = EINVAL;
        -:  213:        return -1;
        -:  214:      }
        -:  215:    else
        -:  216:      {
        -:  217:        stp->st_mode = static_cast<mode_t>(fdata.dwFileAttributes);
        -:  218:        stp->st_size = fdata.nFileSizeLow;
        -:  219:        stp->st_atime = ACE_Time_Value (fdata.ftLastAccessTime).sec ();
        -:  220:        stp->st_mtime = ACE_Time_Value (fdata.ftLastWriteTime).sec ();
        -:  221:        stp->st_ctime = ACE_Time_Value (fdata.ftCreationTime).sec ();
        -:  222:      }
        -:  223:    return 0;
        -:  224:#elif defined (ACE_HAS_X86_STAT_MACROS)
        -:  225:    // Solaris for intel uses an macro for stat(), this macro is a
        -:  226:    // wrapper for _xstat().
        -:  227:    ACE_OSCALL_RETURN (::_xstat (_STAT_VER, file, stp), int, -1);
        -:  228:#else
        -:  229:    ACE_OSCALL_RETURN (ACE_STAT_FUNC_NAME (file, stp), int, -1);
        -:  230:#endif /* ACE_HAS_NONCONST_STAT */
        -:  231:  }
        -:  232:
        -:  233:#if defined (ACE_HAS_WCHAR)
        -:  234:  ACE_INLINE int
        -:  235:  stat (const wchar_t *file, ACE_stat *stp)
        -:  236:  {
        -:  237:    ACE_OS_TRACE ("ACE_OS::stat");
        -:  238:#if defined (ACE_HAS_WINCE)
        -:  239:    WIN32_FIND_DATAW fdata;
        -:  240:
        -:  241:    HANDLE fhandle;
        -:  242:
        -:  243:    fhandle = ::FindFirstFileW (file, &fdata);
        -:  244:    if (fhandle == INVALID_HANDLE_VALUE)
        -:  245:      {
        -:  246:        ACE_OS::set_errno_to_last_error ();
        -:  247:        return -1;
        -:  248:      }
        -:  249:    else if (fdata.nFileSizeHigh != 0)
        -:  250:      {
        -:  251:        errno = EINVAL;
        -:  252:        return -1;
        -:  253:      }
        -:  254:    else
        -:  255:      {
        -:  256:        stp->st_mode = static_cast<mode_t>(fdata.dwFileAttributes);
        -:  257:        stp->st_size = fdata.nFileSizeLow;
        -:  258:        stp->st_atime = ACE_Time_Value (fdata.ftLastAccessTime).sec ();
        -:  259:        stp->st_mtime = ACE_Time_Value (fdata.ftLastWriteTime).sec ();
        -:  260:        stp->st_ctime = ACE_Time_Value (fdata.ftCreationTime).sec ();
        -:  261:      }
        -:  262:    return 0;
        -:  263:#elif defined (__BORLANDC__) \
        -:  264:      || defined (_MSC_VER) \
        -:  265:      || (defined (__MINGW32__) && !defined (__MINGW64_VERSION_MAJOR))
        -:  266:    ACE_OSCALL_RETURN (ACE_WSTAT_FUNC_NAME (file, stp), int, -1);
        -:  267:#else /* ACE_HAS_WINCE */
        -:  268:    ACE_Wide_To_Ascii nfile (file);
        -:  269:    return ACE_OS::stat (nfile.char_rep (), stp);
        -:  270:#endif /* ACE_HAS_WINCE */
        -:  271:  }
        -:  272:#endif /* ACE_HAS_WCHAR */
        -:  273:
        -:  274:  ACE_INLINE mode_t
        -:  275:  umask (mode_t cmask)
        -:  276:  {
        -:  277:    ACE_OS_TRACE ("ACE_OS::umask");
        -:  278:# if defined (ACE_LACKS_UMASK)
        -:  279:    ACE_UNUSED_ARG (cmask);
        -:  280:    ACE_NOTSUP_RETURN ((mode_t)-1);
        -:  281:# elif defined (ACE_HAS_TR24731_2005_CRT)
        -:  282:    int old_mode;
        -:  283:    int new_mode = static_cast<int> (cmask);
        -:  284:    ACE_SECURECRTCALL (_umask_s (new_mode, &old_mode), mode_t, -1, old_mode);
        -:  285:    return static_cast<mode_t> (old_mode);
        -:  286:# elif defined (ACE_WIN32) && !defined (__BORLANDC__)
        -:  287:    ACE_OSCALL_RETURN (::_umask (cmask), mode_t, -1);
        -:  288:# else
        -:  289:    return ::umask (cmask); // This call shouldn't fail...
        -:  290:# endif /* ACE_LACKS_UMASK */
        -:  291:  }
        -:  292:
        -:  293:} // ACE_OS namespace
        -:  294:
        -:  295:ACE_END_VERSIONED_NAMESPACE_DECL
