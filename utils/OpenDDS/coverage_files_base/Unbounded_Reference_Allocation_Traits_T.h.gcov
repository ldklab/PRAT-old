        -:    0:Source:/home/ryan/git/TARGETS/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Reference_Allocation_Traits_T.h
        -:    0:Programs:51
        -:    1:#ifndef guard_unbounded_reference_allocation_traits_hpp
        -:    2:#define guard_unbounded_reference_allocation_traits_hpp
        -:    3:/**
        -:    4: * @file
        -:    5: *
        -:    6: * @brief Details can be found in the documentation for
        -:    7: * TAO::details::generic_sequence
        -:    8: *
        -:    9: * $Id$
        -:   10: *
        -:   11: * @author Carlos O'Ryan
        -:   12: */
        -:   13:
        -:   14:#include "tao/Basic_Types.h"
        -:   15:
        -:   16:TAO_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   17:
        -:   18:namespace TAO
        -:   19:{
        -:   20:namespace details
        -:   21:{
        -:   22:
        -:   23:template<typename T, class ref_traits, bool dummy>
        -:   24:struct unbounded_reference_allocation_traits
        -:   25:{
        -:   26:  typedef T value_type;
        -:   27:  typedef ref_traits reference_traits;
        -:   28:
        -:   29:  inline static CORBA::ULong default_maximum()
        -:   30:  {
        -:   31:    return 0;
        -:   32:  }
        -:   33:
        -:   34:  inline static value_type * default_buffer_allocation()
        -:   35:  {
        -:   36:    return 0;
        -:   37:  }
        -:   38:
        -:   39:  inline static value_type * allocbuf(CORBA::ULong maximum)
        -:   40:  {
        -:   41:    if (maximum == ACE_UINT32_MAX)
        -:   42:      {
        -:   43:        return 0;
        -:   44:      }
        -:   45:    value_type * buffer = new value_type[maximum + 1];
        -:   46:    reinterpret_cast<value_type**>(buffer)[0] = buffer + maximum + 1;
        -:   47:
        -:   48:    // no throw
        -:   49:    reference_traits::initialize_range(buffer + 1, buffer + maximum + 1);
        -:   50:
        -:   51:    return buffer + 1;
        -:   52:  }
        -:   53:
    #####:   54:  inline static value_type * allocbuf_noinit(CORBA::ULong maximum)
        -:   55:  {
    #####:   56:    if (maximum == ACE_UINT32_MAX)
        -:   57:      {
    #####:   58:        return 0;
        -:   59:      }
    #####:   60:    value_type * buffer = new value_type[maximum + 1];
    #####:   61:    reinterpret_cast<value_type**>(buffer)[0] = buffer + maximum + 1;
        -:   62:
        -:   63:    // no throw
    #####:   64:    reference_traits::zero_range(buffer + 1, buffer + maximum + 1);
        -:   65:
    #####:   66:    return buffer + 1;
        -:   67:  }
        -:   68:
    #####:   69:  inline static void freebuf(value_type * buffer)
        -:   70:  {
    #####:   71:    if(buffer != 0)
        -:   72:    {
    #####:   73:      value_type * begin = buffer - 1;
    #####:   74:      value_type * end = reinterpret_cast<value_type*>(*begin);
    #####:   75:      reference_traits::release_range(buffer, end);
        -:   76:
    #####:   77:      buffer = begin;
        -:   78:    }
    #####:   79:    delete[] buffer;
    #####:   80:  }
        -:   81:};
        -:   82:
        -:   83:} // namespace details
        -:   84:} // namespace TAO
        -:   85:
        -:   86:TAO_END_VERSIONED_NAMESPACE_DECL
        -:   87:
        -:   88:#endif // guard_unbounded_reference_allocation_traits_hpp
