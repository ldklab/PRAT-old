        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Reactor_Impl.h
        -:    0:Programs:51
        -:    1:// -*- C++ -*-
        -:    2:
        -:    3://=============================================================================
        -:    4:/**
        -:    5: *  @file    Reactor_Impl.h
        -:    6: *
        -:    7: *  $Id: Reactor_Impl.h 1861 2011-08-31 16:18:08Z mesnierp $
        -:    8: *
        -:    9: *  @author Irfan Pyarali
        -:   10: */
        -:   11://=============================================================================
        -:   12:
        -:   13:
        -:   14:#ifndef ACE_REACTOR_IMPL_H
        -:   15:#define ACE_REACTOR_IMPL_H
        -:   16:#include /**/ "ace/pre.h"
        -:   17:
        -:   18:// Timer Queue is a complicated template class. A simple forward
        -:   19:// declaration will not work
        -:   20:#include "ace/Timer_Queuefwd.h"
        -:   21:
        -:   22:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   23:# pragma once
        -:   24:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   25:
        -:   26:// Event_Handler.h contains the definition of ACE_Reactor_Mask
        -:   27:#include "ace/Event_Handler.h"
        -:   28:#include "ace/Countdown_Time.h"
        -:   29:
        -:   30:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   31:
        -:   32:// Forward decls
        -:   33:class ACE_Handle_Set;
        -:   34:class ACE_Reactor_Impl;
        -:   35:class ACE_Sig_Action;
        -:   36:class ACE_Sig_Handler;
        -:   37:class ACE_Sig_Set;
        -:   38:
        -:   39:/**
        -:   40: * @class ACE_Reactor_Notify
        -:   41: *
        -:   42: * @internal This class is for ACE internal use only.
        -:   43: *
        -:   44: * @brief Abstract class for unblocking an ACE_Reactor_Impl from its
        -:   45: * event loop.
        -:   46: */
        -:   47:class ACE_Export ACE_Reactor_Notify : public ACE_Event_Handler
        -:   48:{
        -:   49:public:
        -:   50:  // = Initialization and termination methods.
        -:   51:  virtual int open (ACE_Reactor_Impl *,
        -:   52:                    ACE_Timer_Queue *timer_queue = 0,
        -:   53:                    int disable_notify = 0) = 0;
        -:   54:  virtual int close (void) = 0;
        -:   55:
        -:   56:  /**
        -:   57:   * Called by a thread when it wants to unblock the <Reactor_Impl>.
        -:   58:   * This wakeups the <Reactor_Impl> if currently blocked.  Pass over
        -:   59:   * both the <Event_Handler> *and* the @a mask to allow the caller to
        -:   60:   * dictate which <Event_Handler> method the <Reactor_Impl> will
        -:   61:   * invoke.  The ACE_Time_Value indicates how long to blocking
        -:   62:   * trying to notify the <Reactor_Impl>.  If @a timeout == 0, the
        -:   63:   * caller will block until action is possible, else will wait until
        -:   64:   * the relative time specified in *@a timeout elapses).
        -:   65:   */
        -:   66:  virtual int notify (ACE_Event_Handler *eh = 0,
        -:   67:                      ACE_Reactor_Mask mask = ACE_Event_Handler::EXCEPT_MASK,
        -:   68:                      ACE_Time_Value *timeout = 0) = 0;
        -:   69:
        -:   70:  /// Handles pending threads (if any) that are waiting to unblock the
        -:   71:  /// <Reactor_Impl>.
        -:   72:  virtual int dispatch_notifications (int &number_of_active_handles,
        -:   73:                                      ACE_Handle_Set &rd_mask) = 0;
        -:   74:
        -:   75:  /// Returns the ACE_HANDLE of the notify pipe on which the reactor
        -:   76:  /// is listening for notifications so that other threads can unblock
        -:   77:  /// the <Reactor_Impl>
        -:   78:  virtual ACE_HANDLE notify_handle (void) = 0;
        -:   79:
        -:   80:  /// Verify whether the buffer has dispatchable info  or not.
        -:   81:  virtual int is_dispatchable (ACE_Notification_Buffer &buffer)= 0;
        -:   82:
        -:   83:  /// Handle one of the notify call on the <handle>. This could be
        -:   84:  /// because of a thread trying to unblock the <Reactor_Impl>
        -:   85:  virtual int dispatch_notify (ACE_Notification_Buffer &buffer) = 0;
        -:   86:
        -:   87:  /// Read one of the notify call on the @a handle into the
        -:   88:  /// @a buffer. This could be because of a thread trying to unblock
        -:   89:  /// the <Reactor_Impl>
        -:   90:  virtual int read_notify_pipe (ACE_HANDLE handle,
        -:   91:                                ACE_Notification_Buffer &buffer) = 0;
        -:   92:  /**
        -:   93:   * Set the maximum number of times that the <handle_input> method
        -:   94:   * will iterate and dispatch the ACE_Event_Handlers that are
        -:   95:   * passed in via the notify queue before breaking out of the event
        -:   96:   * loop.  By default, this is set to -1, which means "iterate until
        -:   97:   * the queue is empty."  Setting this to a value like "1 or 2" will
        -:   98:   * increase "fairness" (and thus prevent starvation) at the expense
        -:   99:   * of slightly higher dispatching overhead.
        -:  100:   */
        -:  101:  virtual void max_notify_iterations (int) = 0;
        -:  102:
        -:  103:  /**
        -:  104:   * Get the maximum number of times that the <handle_input> method
        -:  105:   * will iterate and dispatch the ACE_Event_Handlers that are
        -:  106:   * passed in via the notify queue before breaking out of its event
        -:  107:   * loop.
        -:  108:   */
        -:  109:  virtual int max_notify_iterations (void) = 0;
        -:  110:
        -:  111:  /**
        -:  112:   * Purge any notifications pending in this reactor for the specified
        -:  113:   * ACE_Event_Handler object. Returns the number of notifications
        -:  114:   * purged. Returns -1 on error.
        -:  115:   */
        -:  116:  virtual int purge_pending_notifications (ACE_Event_Handler * = 0,
        -:  117:                                           ACE_Reactor_Mask    = ACE_Event_Handler::ALL_EVENTS_MASK) = 0;
        -:  118:
        -:  119:  /// Dump the state of an object.
        -:  120:  virtual void dump (void) const = 0;
        -:  121:};
        -:  122:
        -:  123:/**
        -:  124: * @class ACE_Reactor_Impl
        -:  125: *
        -:  126: * @brief An abstract class for implementing the Reactor Pattern.
        -:  127: */
    #####:  128:class ACE_Export ACE_Reactor_Impl
        -:  129:{
        -:  130:public:
        -:  131:  /// Close down and release all resources.
        -:  132:  virtual ~ACE_Reactor_Impl (void);
        -:  133:
        -:  134:  /// Initialization.
        -:  135:  virtual int open (size_t size,
        -:  136:                    bool restart = false,
        -:  137:                    ACE_Sig_Handler * = 0,
        -:  138:                    ACE_Timer_Queue * = 0,
        -:  139:                    int disable_notify_pipe = 0,
        -:  140:                    ACE_Reactor_Notify * = 0) = 0;
        -:  141:
        -:  142:  /**
        -:  143:   * Returns 0, if the size of the current message has been put in
        -:  144:   * @a size Returns -1, if not.  ACE_HANDLE allows the reactor to
        -:  145:   * check if the caller is valid.
        -:  146:   */
        -:  147:  virtual int current_info (ACE_HANDLE, size_t & /* size */) = 0;
        -:  148:
        -:  149:  /// Use a user specified signal handler instead.
        -:  150:  virtual int set_sig_handler (ACE_Sig_Handler *signal_handler) = 0;
        -:  151:
        -:  152:  /// Set a user-specified timer queue.
        -:  153:  virtual int timer_queue (ACE_Timer_Queue *tq) = 0;
        -:  154:
        -:  155:  /// Return the current ACE_Timer_Queue.
        -:  156:  virtual ACE_Timer_Queue *timer_queue (void) const = 0;
        -:  157:
        -:  158:  /// Close down and release all resources.
        -:  159:  virtual int close (void) = 0;
        -:  160:
        -:  161:  // = Event loop drivers.
        -:  162:  /**
        -:  163:   * Returns non-zero if there are I/O events "ready" for dispatching,
        -:  164:   * but does not actually dispatch the event handlers.  By default,
        -:  165:   * don't block while checking this, i.e., "poll".
        -:  166:   */
        -:  167:  virtual int work_pending (const ACE_Time_Value &max_wait_time =  ACE_Time_Value::zero)  = 0;
        -:  168:
        -:  169:  /**
        -:  170:   * This event loop driver blocks for up to @a max_wait_time before
        -:  171:   * returning.  It will return earlier if events occur.  Note that
        -:  172:   * @a max_wait_time can be 0, in which case this method blocks
        -:  173:   * indefinitely until events occur.
        -:  174:   *
        -:  175:   * @a max_wait_time is decremented to reflect how much time this call
        -:  176:   * took.  For instance, if a time value of 3 seconds is passed to
        -:  177:   * handle_events and an event occurs after 2 seconds,
        -:  178:   * @a max_wait_time will equal 1 second.  This can be used if an
        -:  179:   * application wishes to handle events for some fixed amount of
        -:  180:   * time.
        -:  181:   *
        -:  182:   * Returns the total number of ACE_Event_Handlers that were
        -:  183:   * dispatched, 0 if the @a max_wait_time elapsed without dispatching
        -:  184:   * any handlers, or -1 if an error occurs.
        -:  185:   *
        -:  186:   * The only difference between <alertable_handle_events> and
        -:  187:   * <handle_events> is that in the alertable case, the eventloop will
        -:  188:   * return when the system queues an I/O completion routine or an
        -:  189:   * Asynchronous Procedure Call.
        -:  190:   */
        -:  191:  virtual int handle_events (ACE_Time_Value *max_wait_time = 0) = 0;
        -:  192:  virtual int alertable_handle_events (ACE_Time_Value *max_wait_time = 0) = 0;
        -:  193:
        -:  194:  /**
        -:  195:   * This method is just like the one above, except the
        -:  196:   * @a max_wait_time value is a reference and can therefore never be
        -:  197:   * NULL.
        -:  198:   *
        -:  199:   * The only difference between <alertable_handle_events> and
        -:  200:   * <handle_events> is that in the alertable case, the eventloop will
        -:  201:   * return when the system queues an I/O completion routine or an
        -:  202:   * Asynchronous Procedure Call.
        -:  203:   */
        -:  204:  virtual int handle_events (ACE_Time_Value &max_wait_time) = 0;
        -:  205:  virtual int alertable_handle_events (ACE_Time_Value &max_wait_time) = 0;
        -:  206:
        -:  207:  // = Event handling control.
        -:  208:
        -:  209:  /**
        -:  210:   * Return the status of Reactor.  If this function returns 0, the reactor is
        -:  211:   * actively handling events.  If it returns non-zero, <handling_events> and
        -:  212:   * <handle_alertable_events> return -1 immediately.
        -:  213:   */
        -:  214:  virtual int deactivated (void) = 0;
        -:  215:
        -:  216:  /**
        -:  217:   * Control whether the Reactor will handle any more incoming events or not.
        -:  218:   * If @a do_stop == 1, the Reactor will be disabled.  By default, a reactor
        -:  219:   * is in active state and can be deactivated/reactived as wish.
        -:  220:   */
        -:  221:  virtual void deactivate (int do_stop) = 0;
        -:  222:
        -:  223:  // = Register and remove Handlers.
        -:  224:
        -:  225:  /// Register @a event_handler with @a mask.  The I/O handle will always
        -:  226:  /// come from <get_handle> on the @a event_handler.
        -:  227:  virtual int register_handler (ACE_Event_Handler *event_handler,
        -:  228:                                ACE_Reactor_Mask mask) = 0;
        -:  229:
        -:  230:  /// Register @a event_handler with @a mask.  The I/O handle is provided
        -:  231:  /// through the <io_handle> parameter.
        -:  232:  virtual int register_handler (ACE_HANDLE io_handle,
        -:  233:                                ACE_Event_Handler *event_handler,
        -:  234:                                ACE_Reactor_Mask mask) = 0;
        -:  235:
        -:  236:#if defined (ACE_WIN32)
        -:  237:
        -:  238:  // Originally this interface was available for all platforms, but
        -:  239:  // because ACE_HANDLE is an int on non-Win32 platforms, compilers
        -:  240:  // are not able to tell the difference between
        -:  241:  // register_handler(ACE_Event_Handler*,ACE_Reactor_Mask) and
        -:  242:  // register_handler(ACE_Event_Handler*,ACE_HANDLE). Therefore, we
        -:  243:  // have restricted this method to Win32 only.
        -:  244:
        -:  245:  /**
        -:  246:   * Register an @a event_handler that will be notified when
        -:  247:   * <event_handle> is signaled.  Since no event mask is passed
        -:  248:   * through this interface, it is assumed that the <event_handle>
        -:  249:   * being passed in is an event handle and not an I/O handle.
        -:  250:   */
        -:  251:  virtual int register_handler (ACE_Event_Handler *event_handler,
        -:  252:                                ACE_HANDLE event_handle = ACE_INVALID_HANDLE) = 0;
        -:  253:
        -:  254:#endif /* ACE_WIN32 */
        -:  255:
        -:  256:  /**
        -:  257:   * Register an @a event_handler that will be notified when
        -:  258:   * <event_handle> is signaled.  @a mask specifies the network events
        -:  259:   * that the @a event_handler is interested in.
        -:  260:   */
        -:  261:  virtual int register_handler (ACE_HANDLE event_handle,
        -:  262:                                ACE_HANDLE io_handle,
        -:  263:                                ACE_Event_Handler *event_handler,
        -:  264:                                ACE_Reactor_Mask mask) = 0;
        -:  265:
        -:  266:  /// Register @a event_handler with all the @a handles in the <Handle_Set>.
        -:  267:  virtual int register_handler (const ACE_Handle_Set &handles,
        -:  268:                                ACE_Event_Handler *event_handler,
        -:  269:                                ACE_Reactor_Mask mask) = 0;
        -:  270:
        -:  271:  /**
        -:  272:   * Register @a new_sh to handle the signal @a signum using the
        -:  273:   * @a new_disp.  Returns the @a old_sh that was previously registered
        -:  274:   * (if any), along with the @a old_disp of the signal handler.
        -:  275:   */
        -:  276:  virtual int register_handler (int signum,
        -:  277:                                ACE_Event_Handler *new_sh,
        -:  278:                                ACE_Sig_Action *new_disp = 0,
        -:  279:                                ACE_Event_Handler **old_sh = 0,
        -:  280:                                ACE_Sig_Action *old_disp = 0) = 0;
        -:  281:
        -:  282:  /// Registers @a new_sh to handle a set of signals @a sigset using the
        -:  283:  /// @a new_disp.
        -:  284:  virtual int register_handler (const ACE_Sig_Set &sigset,
        -:  285:                                ACE_Event_Handler *new_sh,
        -:  286:                                ACE_Sig_Action *new_disp = 0) = 0;
        -:  287:
        -:  288:  /**
        -:  289:   * Removes @a event_handler.  Note that the I/O handle will be
        -:  290:   * obtained using <get_handle> method of @a event_handler .  If
        -:  291:   * @a mask == ACE_Event_Handler::DONT_CALL then the <handle_close>
        -:  292:   * method of the @a event_handler is not invoked.
        -:  293:   */
        -:  294:  virtual int remove_handler (ACE_Event_Handler *event_handler,
        -:  295:                              ACE_Reactor_Mask mask) = 0;
        -:  296:
        -:  297:  /**
        -:  298:   * Removes @a handle.  If @a mask == ACE_Event_Handler::DONT_CALL
        -:  299:   * then the <handle_close> method of the associated <event_handler>
        -:  300:   * is not invoked.
        -:  301:   */
        -:  302:  virtual int remove_handler (ACE_HANDLE handle,
        -:  303:                              ACE_Reactor_Mask mask) = 0;
        -:  304:
        -:  305:  /**
        -:  306:   * Removes all handles in @a handle_set.  If @a mask ==
        -:  307:   * ACE_Event_Handler::DONT_CALL then the <handle_close> method of
        -:  308:   * the associated <event_handler>s is not invoked.
        -:  309:   */
        -:  310:  virtual int remove_handler (const ACE_Handle_Set &handle_set,
        -:  311:                              ACE_Reactor_Mask mask) = 0;
        -:  312:
        -:  313:  /**
        -:  314:   * Remove the ACE_Event_Handler currently associated with @a signum.
        -:  315:   * Install the new disposition (if given) and return the previous
        -:  316:   * disposition (if desired by the caller).  Returns 0 on success and
        -:  317:   * -1 if @a signum is invalid.
        -:  318:   */
        -:  319:  virtual int remove_handler (int signum,
        -:  320:                              ACE_Sig_Action *new_disp,
        -:  321:                              ACE_Sig_Action *old_disp = 0,
        -:  322:                              int sigkey = -1) = 0;
        -:  323:
        -:  324:  /// Calls <remove_handler> for every signal in @a sigset.
        -:  325:  virtual int remove_handler (const ACE_Sig_Set &sigset) = 0;
        -:  326:
        -:  327:  // = Suspend and resume Handlers.
        -:  328:
        -:  329:  /// Suspend @a event_handler temporarily.  Use
        -:  330:  /// <ACE_Event_Handler::get_handle> to get the handle.
        -:  331:  virtual int suspend_handler (ACE_Event_Handler *event_handler) = 0;
        -:  332:
        -:  333:  /// Suspend @a handle temporarily.
        -:  334:  virtual int suspend_handler (ACE_HANDLE handle) = 0;
        -:  335:
        -:  336:  /// Suspend all @a handles in handle set temporarily.
        -:  337:  virtual int suspend_handler (const ACE_Handle_Set &handles) = 0;
        -:  338:
        -:  339:  /// Suspend all <handles> temporarily.
        -:  340:  virtual int suspend_handlers (void) = 0;
        -:  341:
        -:  342:  /// Resume @a event_handler. Use <ACE_Event_Handler::get_handle> to
        -:  343:  /// get the handle.
        -:  344:  virtual int resume_handler (ACE_Event_Handler *event_handler) = 0;
        -:  345:
        -:  346:  /// Resume @a handle.
        -:  347:  virtual int resume_handler (ACE_HANDLE handle) = 0;
        -:  348:
        -:  349:  /// Resume all @a handles in handle set.
        -:  350:  virtual int resume_handler (const ACE_Handle_Set &handles) = 0;
        -:  351:
        -:  352:  /// Resume all <handles>.
        -:  353:  virtual int resume_handlers (void) = 0;
        -:  354:
        -:  355:  /// Does the reactor allow the application to resume the handle on
        -:  356:  /// its own ie. can it pass on the control of handle resumption to
        -:  357:  /// the application
        -:  358:  virtual int resumable_handler (void) = 0;
        -:  359:
        -:  360:  /// Return true if we any event associations were made by the reactor
        -:  361:  /// for the handles that it waits on, false otherwise.
        -:  362:  virtual bool uses_event_associations (void) = 0;
        -:  363:
        -:  364:  // If we need to reset handles returned from accept/connect.
        -:  365:
        -:  366:  // = Timer management.
        -:  367:
        -:  368:  /**
        -:  369:   * Schedule an ACE_Event_Handler that will expire after an amount
        -:  370:   * of time.  The return value of this method, a timer_id value,
        -:  371:   * uniquely identifies the event_handler in the ACE_Reactor's
        -:  372:   * internal list of timers.
        -:  373:   * This timer_id value can be used to cancel the timer
        -:  374:   * with the cancel_timer() call.
        -:  375:   *
        -:  376:   * @see cancel_timer()
        -:  377:   * @see reset_timer_interval()
        -:  378:   *
        -:  379:   * @param event_handler  event handler to schedule on reactor
        -:  380:   * @param arg   argument passed to the handle_timeout() method of  event_handler
        -:  381:   * @param delay  time interval after which the timer will expire
        -:  382:   * @param interval  time interval after which the timer will be automatically rescheduled
        -:  383:   * @return -1 on failure, a timer_id value on success
        -:  384:   */
        -:  385:  virtual long schedule_timer (ACE_Event_Handler *event_handler,
        -:  386:                               const void *arg,
        -:  387:                               const ACE_Time_Value &delay,
        -:  388:                               const ACE_Time_Value &interval = ACE_Time_Value::zero) = 0;
        -:  389:
        -:  390:  /**
        -:  391:   * Resets the interval of the timer represented by @a timer_id to
        -:  392:   * @a interval, which is specified in relative time to the current
        -:  393:   * <gettimeofday>.  If @a interval is equal to
        -:  394:   * ACE_Time_Value::zero, the timer will become a non-rescheduling
        -:  395:   * timer.  Returns 0 if successful, -1 if not.
        -:  396:   */
        -:  397:  virtual int reset_timer_interval (long timer_id,
        -:  398:                                    const ACE_Time_Value &interval) = 0;
        -:  399:
        -:  400:  /// Cancel all Event_Handlers that match the address of
        -:  401:  /// @a event_handler.  Returns number of handlers cancelled.
        -:  402:  virtual int cancel_timer (ACE_Event_Handler *event_handler,
        -:  403:                            int dont_call_handle_close = 1) = 0;
        -:  404:
        -:  405:  /**
        -:  406:   * Cancel the single Event_Handler that matches the @a timer_id value
        -:  407:   * (which was returned from the schedule method).  If arg is
        -:  408:   * non-NULL then it will be set to point to the ``magic cookie''
        -:  409:   * argument passed in when the Event_Handler was registered.  This
        -:  410:   * makes it possible to free up the memory and avoid memory leaks.
        -:  411:   * Returns 1 if cancellation succeeded and 0 if the @a timer_id
        -:  412:   * wasn't found.
        -:  413:   */
        -:  414:  virtual int cancel_timer (long timer_id,
        -:  415:                            const void **arg = 0,
        -:  416:                            int dont_call_handle_close = 1) = 0;
        -:  417:
        -:  418:  // = High-level Event_Handler scheduling operations
        -:  419:
        -:  420:  /// Add @a masks_to_be_added to the @a event_handler's entry.
        -:  421:  /// @a event_handler must already have been registered.
        -:  422:  virtual int schedule_wakeup (ACE_Event_Handler *event_handler,
        -:  423:                               ACE_Reactor_Mask masks_to_be_added) = 0;
        -:  424:
        -:  425:  /// Add @a masks_to_be_added to the @a handle's entry.  <event_handler>
        -:  426:  /// associated with @a handle must already have been registered.
        -:  427:  virtual int schedule_wakeup (ACE_HANDLE handle,
        -:  428:                               ACE_Reactor_Mask masks_to_be_added) = 0;
        -:  429:
        -:  430:  /// Clear @a masks_to_be_cleared from the @a event_handler's entry.
        -:  431:  virtual int cancel_wakeup (ACE_Event_Handler *event_handler,
        -:  432:                             ACE_Reactor_Mask masks_to_be_cleared) = 0;
        -:  433:
        -:  434:  /// Clear @a masks_to_be_cleared from the @a handle's entry.
        -:  435:  virtual int cancel_wakeup (ACE_HANDLE handle,
        -:  436:                             ACE_Reactor_Mask masks_to_be_cleared) = 0;
        -:  437:
        -:  438:  // = Notification methods.
        -:  439:
        -:  440:  /**
        -:  441:   * Notify @a event_handler of @a mask event.  The ACE_Time_Value
        -:  442:   * indicates how long to blocking trying to notify.  If @a timeout ==
        -:  443:   * 0, the caller will block until action is possible, else will wait
        -:  444:   * until the relative time specified in @a timeout elapses).
        -:  445:   */
        -:  446:  virtual int notify (ACE_Event_Handler *event_handler = 0,
        -:  447:                      ACE_Reactor_Mask mask = ACE_Event_Handler::EXCEPT_MASK,
        -:  448:                      ACE_Time_Value * = 0) = 0;
        -:  449:
        -:  450:  /**
        -:  451:   * Set the maximum number of times that ACE_Reactor_Impl will
        -:  452:   * iterate and dispatch the ACE_Event_Handlers that are passed in
        -:  453:   * via the notify queue before breaking out of its
        -:  454:   * <ACE_Message_Queue::dequeue> loop.  By default, this is set to
        -:  455:   * -1, which means "iterate until the queue is empty."  Setting this
        -:  456:   * to a value like "1 or 2" will increase "fairness" (and thus
        -:  457:   * prevent starvation) at the expense of slightly higher dispatching
        -:  458:   * overhead.
        -:  459:   */
        -:  460:  virtual void max_notify_iterations (int) = 0;
        -:  461:
        -:  462:  /**
        -:  463:   * Get the maximum number of times that the ACE_Reactor_Impl will
        -:  464:   * iterate and dispatch the ACE_Event_Handlers that are passed in
        -:  465:   * via the notify queue before breaking out of its
        -:  466:   * <ACE_Message_Queue::dequeue> loop.
        -:  467:   */
        -:  468:  virtual int max_notify_iterations (void) = 0;
        -:  469:
        -:  470:  /**
        -:  471:   * Purge any notifications pending in this reactor for the specified
        -:  472:   * ACE_Event_Handler object. Returns the number of notifications
        -:  473:   * purged. Returns -1 on error.
        -:  474:   */
        -:  475:  virtual int purge_pending_notifications (ACE_Event_Handler * = 0,
        -:  476:                                           ACE_Reactor_Mask    = ACE_Event_Handler::ALL_EVENTS_MASK) = 0;
        -:  477:
        -:  478:  /**
        -:  479:   * Return the Event_Handler associated with @a handle.  Return 0 if
        -:  480:   * @a handle is not registered.
        -:  481:   */
        -:  482:  virtual ACE_Event_Handler *find_handler (ACE_HANDLE handle) = 0;
        -:  483:
        -:  484:  /**
        -:  485:   * Check to see if @a handle is associated with a valid Event_Handler
        -:  486:   * bound to @a mask.  Return the @a event_handler associated with this
        -:  487:   * handler if @a event_handler != 0.
        -:  488:   */
        -:  489:  virtual int handler (ACE_HANDLE handle,
        -:  490:                       ACE_Reactor_Mask mask,
        -:  491:                       ACE_Event_Handler **event_handler = 0) = 0;
        -:  492:
        -:  493:  /**
        -:  494:   * Check to see if @a signum is associated with a valid Event_Handler
        -:  495:   * bound to a signal.  Return the @a event_handler associated with
        -:  496:   * this handler if @a event_handler != 0.
        -:  497:   */
        -:  498:  virtual int handler (int signum,
        -:  499:                       ACE_Event_Handler ** = 0) = 0;
        -:  500:
        -:  501:  /// Returns true if Reactor has been successfully initialized, else
        -:  502:  /// false.
        -:  503:  virtual bool initialized (void) = 0;
        -:  504:
        -:  505:  /// Returns the current size of the Reactor's internal descriptor
        -:  506:  /// table.
        -:  507:  virtual size_t size (void) const = 0;
        -:  508:
        -:  509:  /// Returns a reference to the Reactor's internal lock.
        -:  510:  virtual ACE_Lock &lock (void) = 0;
        -:  511:
        -:  512:  /// Wake up all threads in waiting in the event loop
        -:  513:  virtual void wakeup_all_threads (void) = 0;
        -:  514:
        -:  515:  /// Transfers ownership of Reactor_Impl to the @a new_owner.
        -:  516:  virtual int owner (ACE_thread_t new_owner, ACE_thread_t *old_owner = 0) = 0;
        -:  517:
        -:  518:  /// Return the ID of the "owner" thread.
        -:  519:  virtual int owner (ACE_thread_t *owner) = 0;
        -:  520:
        -:  521:  /// Get the existing restart value.
        -:  522:  virtual bool restart (void) = 0;
        -:  523:
        -:  524:  /// Set a new value for restart and return the original value.
        -:  525:  virtual bool restart (bool r) = 0;
        -:  526:
        -:  527:  /// Set position of the owner thread.
        -:  528:  virtual void requeue_position (int) = 0;
        -:  529:
        -:  530:  /// Get position of the owner thread.
        -:  531:  virtual int requeue_position (void) = 0;
        -:  532:
        -:  533:  // = Low-level wait_set mask manipulation methods.
        -:  534:
        -:  535:  /// GET/SET/ADD/CLR the dispatch mask "bit" bound with the
        -:  536:  /// @a event_handler and @a mask.
        -:  537:  virtual int mask_ops (ACE_Event_Handler *event_handler,
        -:  538:                        ACE_Reactor_Mask mask,
        -:  539:                        int ops) = 0;
        -:  540:
        -:  541:  /// GET/SET/ADD/CLR the dispatch MASK "bit" bound with the @a handle
        -:  542:  /// and @a mask.
        -:  543:  virtual int mask_ops (ACE_HANDLE handle,
        -:  544:                        ACE_Reactor_Mask mask,
        -:  545:                        int ops) = 0;
        -:  546:
        -:  547:  // = Low-level ready_set mask manipulation methods.
        -:  548:  /// GET/SET/ADD/CLR the ready "bit" bound with the @a event_handler
        -:  549:  /// and @a mask.
        -:  550:  virtual int ready_ops (ACE_Event_Handler *event_handler,
        -:  551:                         ACE_Reactor_Mask mask,
        -:  552:                         int ops) = 0;
        -:  553:
        -:  554:  /// GET/SET/ADD/CLR the ready "bit" bound with the @a handle and @a mask.
        -:  555:  virtual int ready_ops (ACE_HANDLE handle,
        -:  556:                         ACE_Reactor_Mask,
        -:  557:                         int ops) = 0;
        -:  558:
        -:  559:  /// Dump the state of an object.
        -:  560:  virtual void dump (void) const = 0;
        -:  561:
        -:  562:  /// Declare the dynamic allocation hooks.
        -:  563:  ACE_ALLOC_HOOK_DECLARE;
        -:  564:};
        -:  565:
        -:  566:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  567:
        -:  568:#include /**/ "ace/post.h"
        -:  569:#endif /* ACE_REACTOR_IMPL_H */
