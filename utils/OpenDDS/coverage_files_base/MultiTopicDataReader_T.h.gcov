        -:    0:Source:../dds/DCPS/MultiTopicDataReader_T.h
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#ifndef OPENDDS_DCPS_MULTITOPICDATAREADER_T_H
        -:    9:#define OPENDDS_DCPS_MULTITOPICDATAREADER_T_H
        -:   10:
        -:   11:#ifndef OPENDDS_NO_MULTI_TOPIC
        -:   12:
        -:   13:#include "dds/DCPS/MultiTopicDataReaderBase.h"
        -:   14:
        -:   15:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   16:#pragma once
        -:   17:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   18:
        -:   19:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   20:
        -:   21:namespace OpenDDS {
        -:   22:namespace DCPS {
        -:   23:
        -:   24:template<typename Sample, typename TypedDataReader>
    #####:   25:class MultiTopicDataReader_T
        -:   26:  : public virtual LocalObject<typename TypedDataReader::Interface>
        -:   27:  , public virtual MultiTopicDataReaderBase {
        -:   28:public:
        -:   29:  typedef TAO::DCPS::ZeroCopyDataSeq<Sample> SampleSeq;
        -:   30:
    #####:   31:  MultiTopicDataReader_T() {}
        -:   32:
        -:   33:  void init_typed(DataReaderEx* dr);
        -:   34:  const MetaStruct& getResultingMeta();
        -:   35:  void incoming_sample(void* sample, const DDS::SampleInfo& info,
        -:   36:                       const char* topic, const MetaStruct& meta);
        -:   37:
        -:   38:  DDS::ReturnCode_t read(SampleSeq& received_data, DDS::SampleInfoSeq& info_seq,
        -:   39:    CORBA::Long max_samples, DDS::SampleStateMask sample_states,
        -:   40:    DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states);
        -:   41:
        -:   42:  DDS::ReturnCode_t take(SampleSeq& received_data, DDS::SampleInfoSeq& info_seq,
        -:   43:    CORBA::Long max_samples, DDS::SampleStateMask sample_states,
        -:   44:    DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states);
        -:   45:
        -:   46:  DDS::ReturnCode_t read_w_condition(SampleSeq& data_values,
        -:   47:    DDS::SampleInfoSeq& sample_infos, CORBA::Long max_samples,
        -:   48:    DDS::ReadCondition_ptr a_condition);
        -:   49:
        -:   50:  DDS::ReturnCode_t take_w_condition(SampleSeq& data_values,
        -:   51:    DDS::SampleInfoSeq& sample_infos, CORBA::Long max_samples,
        -:   52:    DDS::ReadCondition_ptr a_condition);
        -:   53:
        -:   54:  DDS::ReturnCode_t read_next_sample(Sample& received_data,
        -:   55:    DDS::SampleInfo& sample_info);
        -:   56:
        -:   57:  DDS::ReturnCode_t take_next_sample(Sample& received_data,
        -:   58:    DDS::SampleInfo& sample_info);
        -:   59:
        -:   60:  DDS::ReturnCode_t read_instance(SampleSeq& received_data,
        -:   61:    DDS::SampleInfoSeq & info_seq, CORBA::Long max_samples,
        -:   62:    DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states,
        -:   63:    DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states);
        -:   64:
        -:   65:  DDS::ReturnCode_t take_instance(SampleSeq& received_data,
        -:   66:    DDS::SampleInfoSeq & info_seq, CORBA::Long max_samples,
        -:   67:    DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states,
        -:   68:    DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states);
        -:   69:
        -:   70:  DDS::ReturnCode_t read_instance_w_condition(SampleSeq& data_values,
        -:   71:    DDS::SampleInfoSeq& sample_infos, CORBA::Long max_samples,
        -:   72:    DDS::InstanceHandle_t handle, DDS::ReadCondition_ptr a_condition);
        -:   73:
        -:   74:  DDS::ReturnCode_t take_instance_w_condition(SampleSeq& data_values,
        -:   75:    DDS::SampleInfoSeq & sample_infos, CORBA::Long max_samples,
        -:   76:    DDS::InstanceHandle_t handle, DDS::ReadCondition_ptr a_condition);
        -:   77:
        -:   78:  DDS::ReturnCode_t read_next_instance(SampleSeq& received_data,
        -:   79:    DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples,
        -:   80:    DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states,
        -:   81:    DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states);
        -:   82:
        -:   83:  DDS::ReturnCode_t take_next_instance(SampleSeq& received_data,
        -:   84:    DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples,
        -:   85:    DDS::InstanceHandle_t a_handle, DDS::SampleStateMask sample_states,
        -:   86:    DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states);
        -:   87:
        -:   88:  DDS::ReturnCode_t read_next_instance_w_condition(SampleSeq& data_values,
        -:   89:    DDS::SampleInfoSeq& sample_infos, CORBA::Long max_samples,
        -:   90:    DDS::InstanceHandle_t previous_handle, DDS::ReadCondition_ptr a_condition);
        -:   91:
        -:   92:  DDS::ReturnCode_t take_next_instance_w_condition(SampleSeq& data_values,
        -:   93:    DDS::SampleInfoSeq & sample_infos, CORBA::Long max_samples,
        -:   94:    DDS::InstanceHandle_t previous_handle, DDS::ReadCondition_ptr a_condition);
        -:   95:
        -:   96:  DDS::ReturnCode_t return_loan(SampleSeq& received_data,
        -:   97:    DDS::SampleInfoSeq& info_seq);
        -:   98:
        -:   99:  DDS::ReturnCode_t get_key_value(Sample& key_holder,
        -:  100:    DDS::InstanceHandle_t handle);
        -:  101:
        -:  102:  DDS::InstanceHandle_t lookup_instance(const Sample& instance_data);
        -:  103:
        -:  104:private:
        -:  105:
    #####:  106:  struct SampleWithInfo {
    #####:  107:    SampleWithInfo(const OPENDDS_STRING& topic, const DDS::SampleInfo& sampinfo)
        -:  108:      : sample_(),
    #####:  109:        view_(sampinfo.view_state) {
    #####:  110:      info_[topic] = sampinfo.instance_handle;
    #####:  111:    }
    #####:  112:    void combine(const SampleWithInfo& other) {
    #####:  113:      info_.insert(other.info_.begin(), other.info_.end());
    #####:  114:      if (other.view_ == DDS::NEW_VIEW_STATE) view_ = DDS::NEW_VIEW_STATE;
    #####:  115:    }
        -:  116:    Sample sample_;
        -:  117:    DDS::ViewStateKind view_;
        -:  118:    OPENDDS_MAP(OPENDDS_STRING/*topicName*/, DDS::InstanceHandle_t) info_;
        -:  119:  };
        -:  120:
        -:  121:  typedef std::vector<SampleWithInfo> SampleVec;
        -:  122:  typedef std::set<OPENDDS_STRING> TopicSet;
        -:  123:
        -:  124:  // Given a QueryPlan that describes how to treat 'incoming' data from a
        -:  125:  // certain topic (with MetaStruct 'meta'), assign its relevant fields to
        -:  126:  // the corresponding fields of 'resulting'.
        -:  127:  void assign_fields(void* incoming, Sample& resulting, const QueryPlan& qp,
        -:  128:                     const MetaStruct& meta);
        -:  129:
        -:  130:  // Process all joins (recursively) in the QueryPlan 'qp'.
        -:  131:  void process_joins(OPENDDS_MAP(TopicSet, SampleVec)& partialResults,
        -:  132:                     SampleVec starting, const TopicSet& seen,
        -:  133:                     const QueryPlan& qp);
        -:  134:
        -:  135:  // Starting with a 'prototype' sample, fill a 'resulting' vector with all
        -:  136:  // data from 'other_dr' (with MetaStruct 'other_meta') such that all key
        -:  137:  // fields named in 'key_names' match the values in 'key_data'.  The struct
        -:  138:  // pointed-to by 'key_data' is of the type used by the 'other_dr'.
        -:  139:  void join(SampleVec& resulting, const SampleWithInfo& prototype,
        -:  140:            const std::vector<OPENDDS_STRING>& key_names, const void* key_data,
        -:  141:            DDS::DataReader_ptr other_dr, const MetaStruct& other_meta);
        -:  142:
        -:  143:  // When no common keys are found, natural join devolves to a cross-join where
        -:  144:  // each instance in the joined-to-topic (qp) is combined with the results so
        -:  145:  // far (partialResults).
        -:  146:  void cross_join(OPENDDS_MAP(TopicSet, SampleVec)& partialResults,
        -:  147:                  const TopicSet& seen, const QueryPlan& qp);
        -:  148:
        -:  149:  // Combine two vectors of data, 'resulting' and 'other', with the results of
        -:  150:  // the combination going into 'resulting'.  Use the keys in 'key_names' to
        -:  151:  // determine which elements to combine, and the topic names in 'other_topics'
        -:  152:  // to determine which fields from 'other' should be assigned to 'resulting'.
        -:  153:  void combine(SampleVec& resulting, const SampleVec& other,
        -:  154:               const std::vector<OPENDDS_STRING>& key_names,
        -:  155:               const TopicSet& other_topics);
        -:  156:
        -:  157:  // Helper for combine(), similar to assign_fields but instead of coming from
        -:  158:  // a differently-typed struct in a void*, the data comes from an existing
        -:  159:  // Sample, 'source'.  Each field projeted from any of the topics in
        -:  160:  // 'other_topics' is copied from 'source' to 'target'.
        -:  161:  void assign_resulting_fields(Sample& target, const Sample& source,
        -:  162:                               const TopicSet& other_topics);
        -:  163:
        -:  164:  struct GenericData {
    #####:  165:    explicit GenericData(const MetaStruct& meta, bool doAlloc = true)
    #####:  166:      : meta_(meta), ptr_(doAlloc ? meta.allocate() : NULL) {}
    #####:  167:    ~GenericData() { meta_.deallocate(ptr_); }
        -:  168:    const MetaStruct& meta_;
        -:  169:    void* ptr_;
        -:  170:  };
        -:  171:
        -:  172:  struct Contains { // predicate for std::find_if()
        -:  173:    const OPENDDS_STRING& look_for_;
    #####:  174:    explicit Contains(const OPENDDS_STRING& s) : look_for_(s) {}
    #####:  175:    bool operator()(const std::pair<const std::set<OPENDDS_STRING>, SampleVec>& e)
        -:  176:      const {
    #####:  177:      return e.first.count(look_for_);
        -:  178:    }
        -:  179:  };
        -:  180:
        -:  181:  typename TypedDataReader::Interface::_var_type typed_reader_;
        -:  182:};
        -:  183:
        -:  184:}
        -:  185:}
        -:  186:
        -:  187:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  188:
        -:  189:#ifdef ACE_TEMPLATES_REQUIRE_SOURCE
        -:  190:#include "dds/DCPS/MultiTopicDataReader_T.cpp"
        -:  191:#endif
        -:  192:
        -:  193:#endif
        -:  194:#endif
