        -:    0:Source:../dds/DCPS/RcHandle_T.h
        -:    0:Programs:72
        -:    1:/*
        -:    2: * Distributed under the OpenDDS License.
        -:    3: * See: http://www.opendds.org/license.html
        -:    4: */
        -:    5:
        -:    6:#ifndef OPENDDS_RCHANDLE_T_H
        -:    7:#define OPENDDS_RCHANDLE_T_H
        -:    8:
        -:    9:#include "dds/Versioned_Namespace.h"
        -:   10:#include <cassert>
        -:   11:#include "unique_ptr.h"
        -:   12:
        -:   13:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   14:
        -:   15:namespace OpenDDS {
        -:   16:namespace DCPS {
        -:   17:
        -:   18:struct inc_count {};
        -:   19:struct keep_count {};
        -:   20:
        -:   21:/// Templated Reference counted handle to a pointer.
        -:   22:/// A non-DDS specific helper class.
        -:   23:template <typename T>
        -:   24:class RcHandle {
        -:   25:public:
        -:   26:
       57:   27:  RcHandle()
       57:   28:    : ptr_(0)
       57:   29:  {}
        -:   30:
      345:   31:  RcHandle(T* p, keep_count)
      345:   32:    : ptr_(p)
        -:   33:  {
      345:   34:  }
        -:   35:
        -:   36:  template <typename U>
        -:   37:  RcHandle(unique_ptr<U> p)
        -:   38:    : ptr_(p.release())
        -:   39:  {
        -:   40:  }
        -:   41:
        -:   42:
    #####:   43:  RcHandle(T* p, inc_count)
    #####:   44:    : ptr_(p)
        -:   45:  {
    #####:   46:    this->bump_up();
    #####:   47:  }
        -:   48:
        -:   49:  template <typename U>
    #####:   50:  RcHandle(const RcHandle<U>& other)
    #####:   51:    : ptr_(other.in())
        -:   52:  {
    #####:   53:    this->bump_up();
    #####:   54:  }
        -:   55:
       72:   56:  RcHandle(const RcHandle& b)
       72:   57:    : ptr_(b.ptr_)
        -:   58:  {
       72:   59:    this->bump_up();
       72:   60:  }
        -:   61:
     1344:   62:  ~RcHandle()
        -:   63:  {
     1344:   64:    this->bump_down();
     1344:   65:  }
        -:   66:
    #####:   67:  void reset()
        -:   68:  {
    #####:   69:    RcHandle tmp;
    #####:   70:    swap(tmp);
    #####:   71:  }
        -:   72:
        -:   73:  template <typename U>
        -:   74:  void reset(T* p, U counting_strategy)
        -:   75:  {
        -:   76:    RcHandle tmp(p, counting_strategy);
        -:   77:    swap(tmp);
        -:   78:  }
        -:   79:
    #####:   80:  RcHandle& operator=(const RcHandle& b)
        -:   81:  {
    #####:   82:    RcHandle tmp(b);
    #####:   83:    swap(tmp);
    #####:   84:    return *this;
        -:   85:  }
        -:   86:
        -:   87:  template <class U>
        -:   88:  RcHandle& operator=(const RcHandle<U>& b)
        -:   89:  {
        -:   90:    RcHandle<T> tmp(b);
        -:   91:    swap(tmp);
        -:   92:    return *this;
        -:   93:  }
        -:   94:
        -:   95:  template <typename U>
        -:   96:  RcHandle& operator=(unique_ptr<U> b)
        -:   97:  {
        -:   98:    RcHandle<T> tmp(b.release(), keep_count());
        -:   99:    swap(tmp);
        -:  100:    return *this;
        -:  101:  }
        -:  102:
    #####:  103:  void swap(RcHandle& rhs)
        -:  104:  {
    #####:  105:    T* t = this->ptr_;
    #####:  106:    this->ptr_ = rhs.ptr_;
    #####:  107:    rhs.ptr_ = t;
    #####:  108:  }
        -:  109:
      699:  110:  T* operator->() const
        -:  111:  {
      699:  112:    return this->ptr_;
        -:  113:  }
        -:  114:
    #####:  115:  T& operator*() const
        -:  116:  {
    #####:  117:    return *this->ptr_;
        -:  118:  }
        -:  119:
       24:  120:  bool is_nil() const
        -:  121:  {
       24:  122:    return this->ptr_ == 0;
        -:  123:  }
        -:  124:
      594:  125:  T* in() const
        -:  126:  {
      594:  127:    return this->ptr_;
        -:  128:  }
        -:  129:
        -:  130:  T* get() const
        -:  131:  {
        -:  132:    return this->ptr_;
        -:  133:  }
        -:  134:
        -:  135:  T*& inout()
        -:  136:  {
        -:  137:    return this->ptr_;
        -:  138:  }
        -:  139:
        -:  140:  T*& out()
        -:  141:  {
        -:  142:    this->bump_down();
        -:  143:    return this->ptr_;
        -:  144:  }
        -:  145:
        -:  146:  T* _retn()
        -:  147:  {
        -:  148:    T* retval = this->ptr_;
        -:  149:    this->ptr_ = 0;
        -:  150:    return retval;
        -:  151:  }
        -:  152:
        -:  153:
      180:  154:  operator bool() const
        -:  155:  {
      180:  156:    return in() != 0;
        -:  157:  }
        -:  158:
        -:  159:  bool operator==(const RcHandle& rhs) const
        -:  160:  {
        -:  161:    return in() == rhs.in();
        -:  162:  }
        -:  163:
        -:  164:  bool operator!=(const RcHandle& rhs) const
        -:  165:  {
        -:  166:    return in() != rhs.in();
        -:  167:  }
        -:  168:
        -:  169:  bool operator < (const RcHandle& rhs) const
        -:  170:  {
        -:  171:    return in() < rhs.in();
        -:  172:  }
        -:  173:
        -:  174:private:
        -:  175:
       72:  176:  void bump_up()
        -:  177:  {
       72:  178:    if (this->ptr_ != 0) {
       72:  179:      this->ptr_->_add_ref();
        -:  180:    }
       72:  181:  }
        -:  182:
     1344:  183:  void bump_down()
        -:  184:  {
     1344:  185:    if (this->ptr_ != 0) {
      948:  186:      this->ptr_->_remove_ref();
      948:  187:      this->ptr_ = 0;
        -:  188:    }
     1344:  189:  }
        -:  190:
        -:  191:  /// The actual "unsmart" pointer to the T object.
        -:  192:  T* ptr_;
        -:  193:};
        -:  194:
        -:  195:
        -:  196:template <typename T>
        -:  197:void swap(RcHandle<T>& lhs, RcHandle<T>& rhs)
        -:  198:{
        -:  199:  lhs.swap(rhs);
        -:  200:}
        -:  201:
        -:  202:template <typename T, typename U>
        -:  203:RcHandle<T> static_rchandle_cast(const RcHandle<U>& h)
        -:  204:{
        -:  205:  return RcHandle<T>(static_cast<T*>(h.in()), inc_count());
        -:  206:}
        -:  207:
        -:  208:template <typename T, typename U>
        -:  209:RcHandle<T> const_rchandle_cast(const RcHandle<U>& h)
        -:  210:{
        -:  211:  return RcHandle<T>(const_cast<T*>(h.in()), inc_count());
        -:  212:}
        -:  213:
        -:  214:template <typename T, typename U>
    #####:  215:RcHandle<T> dynamic_rchandle_cast(const RcHandle<U>& h)
        -:  216:{
    #####:  217:  return RcHandle<T>(dynamic_cast<T*>(h.in()), inc_count());
        -:  218:}
        -:  219:
        -:  220:
        -:  221:template< class T >
        -:  222:class reference_wrapper{
        -:  223:public:
        -:  224:  // types
        -:  225:  typedef T type;
        -:  226:
        -:  227:  // construct/copy/destroy
    #####:  228:  reference_wrapper(T& ref): _ptr(&ref) {}
        -:  229:  // access
        -:  230:  operator T& () const { return *_ptr; }
    #####:  231:  T& get() const { return *_ptr; }
        -:  232:
        -:  233:private:
        -:  234:  T* _ptr;
        -:  235:};
        -:  236:
        -:  237:template <typename T>
    #####:  238:reference_wrapper<T> ref(T& r)
        -:  239:{
    #####:  240:  return reference_wrapper<T>(r);
        -:  241:}
        -:  242:
        -:  243:template <typename T>
       12:  244:T const& unwrap_reference(T const& t)
        -:  245:{
       12:  246:  return t;
        -:  247:}
        -:  248:
        -:  249:template <typename T>
    #####:  250:T& unwrap_reference(reference_wrapper<T> const& t)
        -:  251:{
    #####:  252:  return t.get();
        -:  253:}
        -:  254:
        -:  255:
        -:  256:template <typename T>
    #####:  257:RcHandle<T> make_rch()
        -:  258:{
    #####:  259:  return RcHandle<T>(new T(), keep_count());
        -:  260:}
        -:  261:
        -:  262:template <typename T, typename U>
    #####:  263:RcHandle<T> make_rch(U const& u)
        -:  264:{
    #####:  265:  return RcHandle<T>(new T(unwrap_reference(u)), keep_count());
        -:  266:}
        -:  267:
        -:  268:template <typename T, typename U0, typename U1>
    #####:  269:RcHandle<T> make_rch(U0 const& u0, U1 const& u1)
        -:  270:{
    #####:  271:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1)), keep_count());
        -:  272:}
        -:  273:
        -:  274:template <typename T, typename U0, typename U1, typename U2>
    #####:  275:RcHandle<T> make_rch(U0 const& u0, U1 const& u1, U2 const& u2)
        -:  276:{
    #####:  277:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1), unwrap_reference(u2)), keep_count());
        -:  278:}
        -:  279:
        -:  280:template <typename T, typename U0, typename U1, typename U2, typename U3>
    #####:  281:RcHandle<T> make_rch(U0 const& u0, U1 const& u1, U2 const& u2, U3 const& u3)
        -:  282:{
    #####:  283:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1), unwrap_reference(u2), unwrap_reference(u3)), keep_count());
        -:  284:}
        -:  285:
        -:  286:template <typename T, typename U0, typename U1, typename U2, typename U3, typename U4>
        -:  287:RcHandle<T> make_rch(U0 const& u0, U1 const& u1, U2 const& u2, U3 const& u3, U4 const& u4)
        -:  288:{
        -:  289:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1), unwrap_reference(u2), unwrap_reference(u3), unwrap_reference(u4)), keep_count());
        -:  290:}
        -:  291:
        -:  292:template <typename T, typename U0, typename U1, typename U2, typename U3, typename U4, typename U5>
        -:  293:RcHandle<T> make_rch(U0 const& u0, U1 const& u1, U2 const& u2, U3 const& u3, U4 const& u4, U5 const& u5)
        -:  294:{
        -:  295:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1), unwrap_reference(u2), unwrap_reference(u3), unwrap_reference(u4), unwrap_reference(u5)), keep_count());
        -:  296:}
        -:  297:
        -:  298:template <typename T, typename U0, typename U1, typename U2, typename U3, typename U4, typename U5, typename U6>
        -:  299:RcHandle<T> make_rch(U0 const& u0, U1 const& u1, U2 const& u2, U3 const& u3, U4 const& u4, U5 const& u5, U6 const& u6)
        -:  300:{
        -:  301:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1), unwrap_reference(u2), unwrap_reference(u3), unwrap_reference(u4), unwrap_reference(u5), unwrap_reference(u6)), keep_count());
        -:  302:}
        -:  303:
        -:  304:template <typename T, typename U0, typename U1, typename U2, typename U3, typename U4, typename U5, typename U6, typename U7>
        -:  305:RcHandle<T> make_rch(U0 const& u0, U1 const& u1, U2 const& u2, U3 const& u3, U4 const& u4, U5 const& u5, U6 const& u6, U7 const& u7)
        -:  306:{
        -:  307:  return RcHandle<T>(new T(unwrap_reference(u0), unwrap_reference(u1), unwrap_reference(u2), unwrap_reference(u3), unwrap_reference(u4), unwrap_reference(u5), unwrap_reference(u6), unwrap_reference(u7)), keep_count());
        -:  308:}
        -:  309:
        -:  310:template<typename T>
        -:  311:RcHandle<T> rchandle_from(T* pointer)
        -:  312:{
        -:  313:#ifndef OPENDDS_SAFETY_PROFILE
        -:  314:  assert(pointer == 0 || pointer->ref_count() > 0);
        -:  315:#endif
        -:  316:  return RcHandle<T>(pointer, inc_count());
        -:  317:}
        -:  318:
        -:  319:
        -:  320:} // namespace DCPS
        -:  321:} // namespace OpenDDS
        -:  322:
        -:  323:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  324:
        -:  325:#endif  /* OPENDDS_RCHANDLE_T_H */
