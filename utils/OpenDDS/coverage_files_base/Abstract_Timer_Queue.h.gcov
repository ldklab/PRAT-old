        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Abstract_Timer_Queue.h
        -:    0:Programs:51
        -:    1://$Id: Abstract_Timer_Queue.h 2595 2015-07-06 17:31:25Z mesnierp $
        -:    2:
        -:    3:#ifndef ACE_ABSTRACT_TIMER_QUEUE_H
        -:    4:#define ACE_ABSTRACT_TIMER_QUEUE_H
        -:    5:
        -:    6:#include /**/ "ace/pre.h"
        -:    7:/**
        -:    8: * @file Abstract_Timer_Queue.h
        -:    9: *
        -:   10: * @author Carlos O'Ryan <coryan@atdesk.com>
        -:   11: *
        -:   12: * Based on classes and files developed by Doug Schmidt, Darrell
        -:   13: * Brunsch, Irfan Pyarali and a cast of thousands.
        -:   14: */
        -:   15:
        -:   16:#include "ace/Versioned_Namespace.h"
        -:   17:
        -:   18:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   19:
        -:   20:// Forward declares
        -:   21:class ACE_Time_Value;
        -:   22:class ACE_Command_Base;
        -:   23:template<typename TYPE> class ACE_Timer_Queue_Iterator_T;
        -:   24:template<typename TYPE> class ACE_Timer_Node_T;
        -:   25:
        -:   26:/**
        -:   27: * @class ACE_Abstract_Timer_Queue
        -:   28: *
        -:   29: * @brief Base class for all timer queues of a single type.
        -:   30: *
        -:   31: * This is a base class for all the timer queues, regardless of
        -:   32: * locking strategy, upcall mechanism, internal implementation, etc.
        -:   33: * The class was motivated by bug 3706:
        -:   34: *    http://bugzilla.dre.vanderbilt.edu/show_bug.cgi?id=3706
        -:   35: * In short, the Reactor (and potentially other classes) want to refer
        -:   36: * to timer queues regardless of the implementation internals.
        -:   37: */
        -:   38:template<typename TYPE>
    #####:   39:class ACE_Abstract_Timer_Queue
        -:   40:{
        -:   41:public:
        -:   42:  /// Destructor
        -:   43:  virtual ~ACE_Abstract_Timer_Queue (void) = 0;
        -:   44:
        -:   45:  /// True if queue is empty, else false.
        -:   46:  virtual bool is_empty (void) const = 0;
        -:   47:
        -:   48:  /// Returns the time of the earlier node in the Timer_Queue.  Must
        -:   49:  /// be called on a non-empty queue.
        -:   50:  virtual const ACE_Time_Value &earliest_time (void) const = 0;
        -:   51:
        -:   52:  /**
        -:   53:   * Schedule @a type that will expire at @a future_time, which is
        -:   54:   * specified in absolute time.  If it expires then @a act is passed
        -:   55:   * in as the value to the <functor>.  If @a interval is != to
        -:   56:   * ACE_Time_Value::zero then it is used to reschedule the @a type
        -:   57:   * automatically, using relative time to the current <gettimeofday>.
        -:   58:   * This method returns a <timer_id> that uniquely identifies the the
        -:   59:   * @a type entry in an internal list.  This <timer_id> can be used to
        -:   60:   * cancel the timer before it expires.  The cancellation ensures
        -:   61:   * that <timer_ids> are unique up to values of greater than 2
        -:   62:   * billion timers.  As long as timers don't stay around longer than
        -:   63:   * this there should be no problems with accidentally deleting the
        -:   64:   * wrong timer.  Returns -1 on failure (which is guaranteed never to
        -:   65:   * be a valid <timer_id>).
        -:   66:   */
        -:   67:  virtual long schedule (const TYPE &type,
        -:   68:                         const void *act,
        -:   69:                         const ACE_Time_Value &future_time,
        -:   70:                         const ACE_Time_Value &interval = ACE_Time_Value::zero) = 0;
        -:   71:
        -:   72:  /**
        -:   73:   * Run the <functor> for all timers whose values are <= @a current_time.
        -:   74:   * This does not account for <timer_skew>.  Returns the number of
        -:   75:   * timers canceled.
        -:   76:   */
        -:   77:  virtual int expire (const ACE_Time_Value &current_time) = 0;
        -:   78:
        -:   79:  /**
        -:   80:   * Run the <functor> for all timers whose values are <=
        -:   81:   * <ACE_OS::gettimeofday>.  Also accounts for <timer_skew>.
        -:   82:   *
        -:   83:   * Depending on the resolution of the underlying OS the system calls
        -:   84:   * like select()/poll() might return at time different than that is
        -:   85:   * specified in the timeout. Suppose the OS guarantees a resolution of t ms.
        -:   86:   * The timeline will look like
        -:   87:   *
        -:   88:   *             A                   B
        -:   89:   *             |                   |
        -:   90:   *             V                   V
        -:   91:   *  |-------------|-------------|-------------|-------------|
        -:   92:   *  t             t             t             t             t
        -:   93:   *
        -:   94:   *
        -:   95:   * If you specify a timeout value of A, then the timeout will not occur
        -:   96:   * at A but at the next interval of the timer, which is later than
        -:   97:   * that is expected. Similarly, if your timeout value is equal to B,
        -:   98:   * then the timeout will occur at interval after B. Now depending upon the
        -:   99:   * resolution of your timeouts and the accuracy of the timeouts
        -:  100:   * needed for your application, you should set the value of
        -:  101:   * <timer_skew>. In the above case, if you want the timeout A to fire
        -:  102:   * no later than A, then you should specify your <timer_skew> to be
        -:  103:   * A % t.
        -:  104:   *
        -:  105:   * The timeout value should be specified via the macro ACE_TIMER_SKEW
        -:  106:   * in your config.h file. The default value is zero.
        -:  107:   *
        -:  108:   * Things get interesting if the t before the timeout value B is zero
        -:  109:   * i.e your timeout is less than the interval. In that case, you are
        -:  110:   * almost sure of not getting the desired timeout behaviour. Maybe you
        -:  111:   * should look for a better OS :-)
        -:  112:   *
        -:  113:   *  Returns the number of timers canceled.
        -:  114:   */
        -:  115:  virtual int expire (void) = 0;
        -:  116:
        -:  117:  /**
        -:  118:   * A couple of classes using Timer_Queues need to dispatch a single
        -:  119:   * event at a time.  But before they dispatch the event they need to
        -:  120:   * release a lock, signal other threads, etc.
        -:  121:   *
        -:  122:   * This member function should be used in that case.  The additional
        -:  123:   * operations to be called just before dispatching the event, and
        -:  124:   * only if an event will be dispatched, are encapsulated in the
        -:  125:   * ACE_Command_Base object.
        -:  126:   */
        -:  127:  virtual int expire_single(ACE_Command_Base & pre_dispatch_command) = 0;
        -:  128:
        -:  129:  /**
        -:  130:   * Resets the interval of the timer represented by @a timer_id to
        -:  131:   * @a interval, which is specified in relative time to the current
        -:  132:   * <gettimeofday>.  If @a interval is equal to
        -:  133:   * ACE_Time_Value::zero, the timer will become a non-rescheduling
        -:  134:   * timer.  Returns 0 if successful, -1 if not.
        -:  135:   */
        -:  136:  virtual int reset_interval (long timer_id,
        -:  137:                              const ACE_Time_Value &interval) = 0;
        -:  138:
        -:  139:  /**
        -:  140:   * Cancel all timer associated with @a type.  If
        -:  141:   * @a dont_call_handle_close is 0 then the <functor> will be invoked,
        -:  142:   * which typically invokes the <handle_close> hook.  Returns number
        -:  143:   * of timers cancelled.
        -:  144:   */
        -:  145:  virtual int cancel (const TYPE &type,
        -:  146:                      int dont_call_handle_close = 1) = 0;
        -:  147:
        -:  148:  /**
        -:  149:   * Cancel the single timer that matches the @a timer_id value (which
        -:  150:   * was returned from the <schedule> method).  If act is non-NULL
        -:  151:   * then it will be set to point to the ``magic cookie'' argument
        -:  152:   * passed in when the timer was registered.  This makes it possible
        -:  153:   * to free up the memory and avoid memory leaks.  If
        -:  154:   * @a dont_call_handle_close is 0 then the <functor> will be invoked,
        -:  155:   * which typically calls the <handle_close> hook.  Returns 1 if
        -:  156:   * cancellation succeeded and 0 if the @a timer_id wasn't found.
        -:  157:   */
        -:  158:  virtual int cancel (long timer_id,
        -:  159:                      const void **act = 0,
        -:  160:                      int dont_call_handle_close = 1) = 0;
        -:  161:
        -:  162:  /**
        -:  163:   * Close timer queue. Cancels all timers.
        -:  164:   */
        -:  165:  virtual int close (void) = 0;
        -:  166:
        -:  167:  /**
        -:  168:   * Returns the current time of day.  This method allows different
        -:  169:   * implementations of the timer queue to use special high resolution
        -:  170:   * timers.
        -:  171:   */
        -:  172:  virtual ACE_Time_Value gettimeofday (void) = 0;
        -:  173:
        -:  174:  /**
        -:  175:   * Allows applications to control how the timer queue gets the time
        -:  176:   * of day.
        -:  177:   * @deprecated Use TIME_POLICY support instead. See Timer_Queue_T.h
        -:  178:   */
        -:  179:  virtual void gettimeofday (ACE_Time_Value (*gettimeofday)(void)) = 0;
        -:  180:
        -:  181:  /// Determine the next event to timeout.  Returns @a max if there are
        -:  182:  /// no pending timers or if all pending timers are longer than max.
        -:  183:  /// This method acquires a lock internally since it modifies internal state.
        -:  184:  virtual ACE_Time_Value *calculate_timeout (ACE_Time_Value *max) = 0;
        -:  185:
        -:  186:  /**
        -:  187:   * Determine the next event to timeout.  Returns @a max if there are
        -:  188:   * no pending timers or if all pending timers are longer than max.
        -:  189:   * <the_timeout> should be a pointer to storage for the timeout value,
        -:  190:   * and this value is also returned.  This method does not acquire a
        -:  191:   * lock internally since it doesn't modify internal state.  If you
        -:  192:   * need to call this method when the queue is being modified
        -:  193:   * concurrently, however, you should make sure to acquire the <mutex()>
        -:  194:   * externally before making the call.
        -:  195:   */
        -:  196:  virtual ACE_Time_Value *calculate_timeout (ACE_Time_Value *max,
        -:  197:                                             ACE_Time_Value *the_timeout) = 0;
        -:  198:
        -:  199:  /**
        -:  200:   * Return the current time, using the right time policy and any
        -:  201:   * timer skew defined in derived classes.
        -:  202:   */
        -:  203:  virtual ACE_Time_Value current_time() = 0;
        -:  204:
        -:  205:  /// Type of Iterator.
        -:  206:  typedef ACE_Timer_Queue_Iterator_T<TYPE> ITERATOR;
        -:  207:
        -:  208:  /// Returns a pointer to this ACE_Timer_Queue's iterator.
        -:  209:  virtual ITERATOR & iter (void) = 0;
        -:  210:
        -:  211:  /// Removes the earliest node from the queue and returns it
        -:  212:  virtual ACE_Timer_Node_T<TYPE> *remove_first (void) = 0;
        -:  213:
        -:  214:  /// Reads the earliest node from the queue and returns it.
        -:  215:  virtual ACE_Timer_Node_T<TYPE> *get_first (void) = 0;
        -:  216:
        -:  217:  /// Dump the state of a object.
        -:  218:  virtual void dump (void) const = 0;
        -:  219:};
        -:  220:
        -:  221:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  222:
        -:  223:#if defined (ACE_TEMPLATES_REQUIRE_SOURCE)
        -:  224:#include "ace/Abstract_Timer_Queue.cpp"
        -:  225:#endif /* ACE_TEMPLATES_REQUIRE_SOURCE */
        -:  226:
        -:  227:#if defined (ACE_TEMPLATES_REQUIRE_PRAGMA)
        -:  228:#pragma implementation ("Abstract_Timer_Queue.cpp")
        -:  229:#endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */
        -:  230:
        -:  231:#include /**/ "ace/post.h"
        -:  232:#endif /* ACE_ABSTRACT_TIMER_QUEUE_H */
