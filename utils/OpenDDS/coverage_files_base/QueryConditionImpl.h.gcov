        -:    0:Source:../dds/DCPS/QueryConditionImpl.h
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#ifndef OPENDDS_DCPS_QUERYCONDITIONIMPL_H
        -:    9:#define OPENDDS_DCPS_QUERYCONDITIONIMPL_H
        -:   10:
        -:   11:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:   12:
        -:   13:#include "dds/DdsDcpsSubscriptionC.h"
        -:   14:#include "dds/DCPS/ReadConditionImpl.h"
        -:   15:#include "dds/DCPS/FilterEvaluator.h"
        -:   16:#include "dds/DCPS/PoolAllocator.h"
        -:   17:
        -:   18:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   19:#pragma once
        -:   20:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   21:
        -:   22:#include <vector>
        -:   23:
        -:   24:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   25:
        -:   26:namespace OpenDDS {
        -:   27:namespace DCPS {
        -:   28:
        -:   29:class DataReaderImpl;
        -:   30:
        -:   31:class OpenDDS_Dcps_Export QueryConditionImpl
        -:   32:  : public virtual OpenDDS::DCPS::LocalObject<DDS::QueryCondition>
        -:   33:  , public virtual ReadConditionImpl {
        -:   34:public:
        -:   35:  QueryConditionImpl(DataReaderImpl* dr, DDS::SampleStateMask sample_states,
        -:   36:                     DDS::ViewStateMask view_states, DDS::InstanceStateMask instance_states,
        -:   37:                     const char* query_expression);
        -:   38:
        -:   39:  virtual ~QueryConditionImpl() {}
        -:   40:
        -:   41:  char* get_query_expression();
        -:   42:
        -:   43:  DDS::ReturnCode_t get_query_parameters(DDS::StringSeq& query_parameters);
        -:   44:
        -:   45:  DDS::ReturnCode_t set_query_parameters(
        -:   46:    const DDS::StringSeq& query_parameters);
        -:   47:
        -:   48:  CORBA::Boolean get_trigger_value();
        -:   49:
        -:   50:  std::vector<OPENDDS_STRING> getOrderBys() const;
        -:   51:
        -:   52:  bool hasFilter() const;
        -:   53:
        -:   54:  /**
        -:   55:   * Returns true if the sample matches the query.
        -:   56:   */
        -:   57:  template<typename Sample>
    #####:   58:  bool filter(const Sample& s, bool sample_only_has_key_fields) const
        -:   59:  {
    #####:   60:    ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, lock_, false);
    #####:   61:    const MetaStruct& meta = getMetaStruct<Sample>();
        -:   62:    /*
        -:   63:     * Omit the sample from results if the query references non-key fields
        -:   64:     * and the sample only has key fields.
        -:   65:     */
    #####:   66:    if (sample_only_has_key_fields && evaluator_.has_non_key_fields(meta)) {
    #####:   67:      if (DCPS_debug_level > 8) {
    #####:   68:        ACE_DEBUG((LM_DEBUG,
        -:   69:          ACE_TEXT("(%P|%t) QueryConditionImpl::filter: ")
        -:   70:          ACE_TEXT("Sample has been filtered because the query ")
        -:   71:          ACE_TEXT("references fields that are not readable\n")
        -:   72:        ));
        -:   73:      }
    #####:   74:      return false;
        -:   75:    }
    #####:   76:    return evaluator_.eval(s, query_parameters_);
        -:   77:  }
        -:   78:
        -:   79:private:
        -:   80:  CORBA::String_var query_expression_;
        -:   81:  DDS::StringSeq query_parameters_;
        -:   82:  FilterEvaluator evaluator_;
        -:   83:  /// Concurrent access to query_parameters_
        -:   84:  mutable ACE_Recursive_Thread_Mutex lock_;
        -:   85:};
        -:   86:
        -:   87:} // namespace DCPS
        -:   88:} // namespace OpenDDS
        -:   89:
        -:   90:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:   91:
        -:   92:#endif // OPENDDS_NO_QUERY_CONDITION
        -:   93:
        -:   94:#endif
