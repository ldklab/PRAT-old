        -:    0:Source:../dds/DCPS/DataSampleHeader.h
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#ifndef OPENDDS_DCPS_DATASAMPLEHEADER_H
        -:    9:#define OPENDDS_DCPS_DATASAMPLEHEADER_H
        -:   10:
        -:   11:#include "Definitions.h"
        -:   12:#include "GuidUtils.h"
        -:   13:#include "PoolAllocationBase.h"
        -:   14:#include "SequenceNumber.h"
        -:   15:#include "RepoIdTypes.h"
        -:   16:#include "Message_Block_Ptr.h"
        -:   17:#include <iosfwd>
        -:   18:
        -:   19:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   20:#pragma once
        -:   21:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   22:
        -:   23:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   24:
        -:   25:namespace OpenDDS {
        -:   26:namespace DCPS {
        -:   27:
        -:   28:class ReceivedDataSample;
        -:   29:
        -:   30:/// One byte message id (<256)
        -:   31:enum MessageId {
        -:   32:  SAMPLE_DATA,
        -:   33:  DATAWRITER_LIVELINESS,
        -:   34:  INSTANCE_REGISTRATION,
        -:   35:  UNREGISTER_INSTANCE,
        -:   36:  DISPOSE_INSTANCE,
        -:   37:  GRACEFUL_DISCONNECT,
        -:   38:  REQUEST_ACK,
        -:   39:  SAMPLE_ACK,
        -:   40:  END_COHERENT_CHANGES,
        -:   41:  TRANSPORT_CONTROL,
        -:   42:  DISPOSE_UNREGISTER_INSTANCE,
        -:   43:  END_HISTORIC_SAMPLES,
        -:   44:  MESSAGE_ID_MAX // must be the last enumerator
        -:   45:};
        -:   46:
        -:   47:enum SubMessageId {
        -:   48:  SUBMESSAGE_NONE,
        -:   49:  MULTICAST_SYN,
        -:   50:  MULTICAST_SYNACK,
        -:   51:  MULTICAST_NAK,
        -:   52:  MULTICAST_NAKACK,
        -:   53:  SUBMESSAGE_ID_MAX // must be the last enumerator
        -:   54:};
        -:   55:
        -:   56:enum DataSampleHeaderFlag {
        -:   57:  BYTE_ORDER_FLAG,
        -:   58:  COHERENT_CHANGE_FLAG,
        -:   59:  HISTORIC_SAMPLE_FLAG,
        -:   60:  LIFESPAN_DURATION_FLAG,
        -:   61:  GROUP_COHERENT_FLAG,
        -:   62:  CONTENT_FILTER_FLAG,
        -:   63:  SEQUENCE_REPAIR_FLAG,
        -:   64:  MORE_FRAGMENTS_FLAG
        -:   65:};
        -:   66:
        -:   67:enum DataSampleHeaderFlag2 {
        -:   68:  CDR_ENCAP_FLAG,
        -:   69:  KEY_ONLY_FLAG
        -:   70:};
        -:   71:
        -:   72:/// The header message of a data sample.
        -:   73:/// This header and the data sample are in different
        -:   74:/// message block and will be chained together.
      126:   75:struct OpenDDS_Dcps_Export DataSampleHeader : public PoolAllocationBase {
        -:   76:  enum {
        -:   77:    MESSAGE_ID_OFFSET = 0,
        -:   78:    SUBMESSAGE_ID_OFFSET = 1,
        -:   79:    FLAGS_OFFSET = 2 // message_id_ + submessage_id_
        -:   80:  };
        -:   81:
        -:   82:  /// The enum MessageId.
        -:   83:  char message_id_;
        -:   84:
        -:   85:  /// Implementation-specific sub-message Ids.
        -:   86:  char submessage_id_;
        -:   87:
        -:   88:  /// 0 -  Message encoded using big-endian byte order. (see ace/CDR_Base.h)
        -:   89:  /// 1 -  Message encoded using little-endian byte order.
        -:   90:  bool byte_order_ : 1;
        -:   91:
        -:   92:  /// The flag indicates the sample belongs to a coherent
        -:   93:  /// change set (i.e. PRESENTATION coherent_access == true).
        -:   94:  bool coherent_change_ : 1;
        -:   95:
        -:   96:  /// This flag indicates a sample has been resent from a
        -:   97:  /// non-VOLATILE DataWriter.
        -:   98:  bool historic_sample_ : 1;
        -:   99:
        -:  100:  /// This flag indicates the sample header contains non-default
        -:  101:  /// LIFESPAN duration fields.
        -:  102:  bool lifespan_duration_ : 1;
        -:  103:
        -:  104:  bool group_coherent_ : 1;
        -:  105:
        -:  106:  /// The publishing side has applied content filtering, and the optional
        -:  107:  /// content_filter_entries_ field is present in the marshaled header.
        -:  108:  bool content_filter_ : 1;
        -:  109:
        -:  110:  /// Due to content filtering, a gap in the sequence numbers may be an
        -:  111:  /// expected condition.  If this bit is set, assume prior sequence numbers
        -:  112:  /// were filtered-out and are not missing.
        -:  113:  bool sequence_repair_ : 1;
        -:  114:
        -:  115:  /// The current "Data Sample" needs reassembly before further processing.
        -:  116:  bool more_fragments_ : 1;
        -:  117:
        -:  118:  // bools above this line are in the first flags byte, below this line are
        -:  119:  // in the second flags byte.  To avoid complicating the implementation of
        -:  120:  // partial(), flags that impact the size of serialized DataSampleHeader
        -:  121:  // should go in the first flags byte.
        -:  122:
        -:  123:  /// The data payload uses CDR encapsulation and alignment rules, as defined
        -:  124:  /// by the RTPS specification formal/2010-11-01.
        -:  125:  bool cdr_encapsulation_ : 1;
        -:  126:
        -:  127:  /// Only the key fields of the data sample are present in the payload.
        -:  128:  bool key_fields_only_ : 1;
        -:  129:
        -:  130:  bool reserved_1 : 1;
        -:  131:  bool reserved_2 : 1;
        -:  132:  bool reserved_3 : 1;
        -:  133:  bool reserved_4 : 1;
        -:  134:  bool reserved_5 : 1;
        -:  135:  bool reserved_6 : 1;
        -:  136:
        -:  137:  /// The size of the data sample (without header).  After this header is
        -:  138:  /// demarshaled, the transport expects to see this many bytes in the stream
        -:  139:  /// before the start of the next header (or end of the Transport PDU).
        -:  140:  ACE_UINT32 message_length_;
        -:  141:
        -:  142:  /// The sequence number is obtained from the Publisher
        -:  143:  /// associated with the DataWriter based on the PRESENTATION
        -:  144:  /// requirement for the sequence value (access_scope == GROUP).
        -:  145:  SequenceNumber sequence_;
        -:  146:
        -:  147:  //{@
        -:  148:  /// The SOURCE_TIMESTAMP field is generated from the DataWriter
        -:  149:  /// or supplied by the application at the time of the write.
        -:  150:  /// This value is derived from the local hosts system clock,
        -:  151:  /// which is assumed to be synchronized with the clocks on other
        -:  152:  /// hosts within the domain.  This field is required for
        -:  153:  /// DESTINATION_ORDER and LIFESPAN policy behaviors of subscriptions.
        -:  154:  /// It is also required to be present for all data in the
        -:  155:  /// SampleInfo structure supplied along with each data sample.
        -:  156:  ACE_INT32 source_timestamp_sec_;
        -:  157:  ACE_UINT32 source_timestamp_nanosec_; // Corresponding IDL is unsigned.
        -:  158:  //@}
        -:  159:
        -:  160:  //{@
        -:  161:  /// The LIFESPAN duration field is generated from the DataWriter
        -:  162:  /// or supplied by the application at the time of the write. This
        -:  163:  /// field is used to determine if a given sample is considered
        -:  164:  /// 'stale' and should be discarded by associated DataReader.
        -:  165:  /// These fields are optional and are controlled by the
        -:  166:  /// lifespan_duration_ flag.
        -:  167:  ACE_INT32 lifespan_duration_sec_;
        -:  168:  ACE_UINT32 lifespan_duration_nanosec_;  // Corresponding IDL is unsigned.
        -:  169:  //@}
        -:  170:
        -:  171:  /// Identify the DataWriter that produced the sample data being
        -:  172:  /// sent.
        -:  173:  PublicationId publication_id_;
        -:  174:
        -:  175:  /// Id representing the coherent group.  Optional field that's only present if
        -:  176:  /// the flag for group_coherent_ is set.
        -:  177:  RepoId publisher_id_;
        -:  178:
        -:  179:  /// Optional field present if the content_filter_ flag bit is set.
        -:  180:  /// Indicates which readers should not receive the data.
        -:  181:  GUIDSeq content_filter_entries_;
        -:  182:
        -:  183:  static ACE_UINT8 mask_flag(DataSampleHeaderFlag  flag) { return 1 << flag; }
        -:  184:  static ACE_UINT8 mask_flag(DataSampleHeaderFlag2 flag) { return 1 << flag; }
        -:  185:
        -:  186:  static void clear_flag(DataSampleHeaderFlag flag,
        -:  187:                         ACE_Message_Block* buffer);
        -:  188:
        -:  189:  static void set_flag(DataSampleHeaderFlag flag,
        -:  190:                       ACE_Message_Block* buffer);
        -:  191:
        -:  192:  static bool test_flag(DataSampleHeaderFlag flag,
        -:  193:                        const ACE_Message_Block* buffer);
        -:  194:
        -:  195:  /// Does the data in this mb constitute a partial Sample Header?
        -:  196:  static bool partial(const ACE_Message_Block& mb);
        -:  197:
        -:  198:  /// Marshal the "guids" as an optional header chained as to the continuation
        -:  199:  /// of "mb" (which must already be a valid DataSampleHeader serialization).
        -:  200:  /// Any existing payload of "mb" (its continuation) will be chained after the
        -:  201:  /// new optional header part.  "guids" may be null, same serialization as 0.
        -:  202:  static void add_cfentries(const GUIDSeq* guids, ACE_Message_Block* mb);
        -:  203:
        -:  204:  /// Create two new serialized headers (owned by caller), the "head" having at
        -:  205:  /// most "size" bytes (header + data) and the "tail" having the rest.
        -:  206:  static void split(const ACE_Message_Block& orig, size_t size,
        -:  207:                    Message_Block_Ptr& head, Message_Block_Ptr& tail);
        -:  208:
        -:  209:  /// If "first" and "second" are two fragments of the same original message
        -:  210:  /// (as created by split()), return true and set up the "result" header to
        -:  211:  /// match the original header.  Joining the data payload is the
        -:  212:  /// responsibility of the caller (manipulate the continuation chain).
        -:  213:  static bool join(const DataSampleHeader& first,
        -:  214:                   const DataSampleHeader& second, DataSampleHeader& result);
        -:  215:
        -:  216:  DataSampleHeader();
        -:  217:
        -:  218:  /// Construct with values extracted from a buffer.
        -:  219:  explicit DataSampleHeader(ACE_Message_Block& buffer);
        -:  220:
        -:  221:  /// Assignment from an ACE_Message_Block.
        -:  222:  DataSampleHeader& operator=(ACE_Message_Block& buffer);
        -:  223:
        -:  224:  /// Amount of data read when initializing from a buffer.
        -:  225:  size_t marshaled_size() const;
        -:  226:
        -:  227:  /// Similar to IDL compiler generated methods.
        -:  228:  static size_t max_marshaled_size();
        -:  229:
        -:  230:  /// Implement load from buffer.
        -:  231:  void init(ACE_Message_Block* buffer);
        -:  232:
        -:  233:  bool into_received_data_sample(ReceivedDataSample& rds);
        -:  234:
        -:  235:  ACE_UINT32 message_length() const { return this->message_length_; }
        -:  236:
        -:  237:  bool more_fragments() const { return this->more_fragments_; }
        -:  238:
        -:  239:  void pdu_remaining(size_t) { /* ignored, only RTPS uses this */ }
        -:  240:
        -:  241:  static ACE_Message_Block* alloc_msgblock(const ACE_Message_Block& mb,
        -:  242:                                           size_t size, bool use_data_alloc);
        -:  243:
        -:  244:  static void split_payload(const ACE_Message_Block& orig, size_t size,
        -:  245:                            Message_Block_Ptr& head, Message_Block_Ptr& tail);
        -:  246:
        -:  247:  /// Returns false if the sample is dispose and/or unregister,
        -:  248:  bool valid_data() const;
        -:  249:
        -:  250:private:
        -:  251:  /// Keep track of the amount of data read from a buffer.
        -:  252:  size_t marshaled_size_;
        -:  253:};
        -:  254:
        -:  255:const char* to_string(const MessageId value);
        -:  256:const char* to_string(const SubMessageId value);
        -:  257:OPENDDS_STRING to_string(const DataSampleHeader& value);
        -:  258:
        -:  259:/// Marshal/Insertion into a buffer.
        -:  260:OpenDDS_Dcps_Export
        -:  261:bool operator<<(ACE_Message_Block&, const DataSampleHeader& value);
        -:  262:
        -:  263:#ifndef OPENDDS_SAFETY_PROFILE
        -:  264:/// Message Id enumeration insertion onto an ostream.
        -:  265:OpenDDS_Dcps_Export
        -:  266:std::ostream& operator<<(std::ostream& str, const MessageId value);
        -:  267:
        -:  268:/// Sub-Message Id enumeration insertion onto an ostream.
        -:  269:OpenDDS_Dcps_Export
        -:  270:std::ostream& operator<<(std::ostream& os, const SubMessageId rhs);
        -:  271:
        -:  272:/// Message header insertion onto an ostream.
        -:  273:OpenDDS_Dcps_Export
        -:  274:std::ostream& operator<<(std::ostream& str, const DataSampleHeader& value);
        -:  275:#endif //OPENDDS_SAFETY_PROFILE
        -:  276:
        -:  277:} // namespace DCPS
        -:  278:} // namespace OpenDDS
        -:  279:
        -:  280:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  281:
        -:  282:#if defined(__ACE_INLINE__)
        -:  283:#include "DataSampleHeader.inl"
        -:  284:#endif /* __ACE_INLINE__ */
        -:  285:
        -:  286:#endif  /* OPENDDS_DCPS_DATASAMPLEHEADER_H */
