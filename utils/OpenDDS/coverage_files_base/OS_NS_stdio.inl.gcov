        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/OS_NS_stdio.inl
        -:    0:Programs:70
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id: OS_NS_stdio.inl 2673 2015-09-24 21:52:54Z mitza $
        -:    4:
        -:    5:#include "ace/OS_NS_unistd.h"
        -:    6:#include "ace/OS_NS_stdlib.h"
        -:    7:#include "ace/OS_NS_fcntl.h"
        -:    8:#include "ace/OS_NS_errno.h"
        -:    9:#include "ace/OS_NS_string.h"
        -:   10:#include "ace/OS_NS_pwd.h"
        -:   11:#include "ace/OS_NS_macros.h"
        -:   12:#include "ace/OS_NS_sys_stat.h"
        -:   13:#include "ace/OS_Memory.h"
        -:   14:
        -:   15:#if defined (ACE_HAS_TRIO)
        -:   16:#  include <trio.h>
        -:   17:#endif /* ACE_HAS_TRIO */
        -:   18:
        -:   19:#if defined (ACE_HAS_ALLOC_HOOKS)
        -:   20:# include "ace/Malloc_Base.h"
        -:   21:#endif /* ACE_HAS_ALLOC_HOOKS */
        -:   22:
        -:   23:/*****************************************************************************/
        -:   24:
        -:   25:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   26:
        -:   27:#if defined (ACE_WIN32)
        -:   28:ACE_INLINE void
        -:   29:ACE_OS::flock_adjust_params (ACE_OS::ace_flock_t *lock,
        -:   30:                             short whence,
        -:   31:                             ACE_OFF_T &start,
        -:   32:                             ACE_OFF_T &len)
        -:   33:{
        -:   34:  switch (whence)
        -:   35:    {
        -:   36:    case SEEK_SET:
        -:   37:      break;
        -:   38:    case SEEK_CUR:
        -:   39:      {
        -:   40:        LARGE_INTEGER offset;
        -:   41:# if !defined (ACE_LACKS_WIN32_SETFILEPOINTEREX)
        -:   42:        LARGE_INTEGER distance;
        -:   43:        distance.QuadPart = 0;
        -:   44:        if (!::SetFilePointerEx (lock->handle_,
        -:   45:                                 distance,
        -:   46:                                 &offset,
        -:   47:                                 FILE_CURRENT))
        -:   48:          {
        -:   49:            ACE_OS::set_errno_to_last_error ();
        -:   50:            return;
        -:   51:          }
        -:   52:# else
        -:   53:        offset.LowPart = ::SetFilePointer (lock->handle_,
        -:   54:                                           0,
        -:   55:                                           &offset.HighPart,
        -:   56:                                           FILE_CURRENT);
        -:   57:        if (offset.LowPart == INVALID_SET_FILE_POINTER &&
        -:   58:            ::GetLastError() != NO_ERROR)
        -:   59:          {
        -:   60:            ACE_OS::set_errno_to_last_error ();
        -:   61:            return;
        -:   62:          }
        -:   63:# endif /* ACE_LACKS_WIN32_SETFILEPOINTEREX */
        -:   64:
        -:   65:# if defined (_FILE_OFFSET_BITS) && _FILE_OFFSET_BITS == 64
        -:   66:        start += offset.QuadPart;
        -:   67:# else
        -:   68:        start += offset.LowPart;
        -:   69:# endif /* _FILE_OFFSET_BITS == 64 */
        -:   70:      }
        -:   71:      break;
        -:   72:    case SEEK_END:
        -:   73:      {
        -:   74:        ACE_OFF_T const size = ACE_OS::filesize (lock->handle_);
        -:   75:        if (size == -1)
        -:   76:          return;
        -:   77:
        -:   78:        start += size;
        -:   79:      }
        -:   80:      break;
        -:   81:    }
        -:   82:  lock->overlapped_.Offset = ACE_LOW_PART (start);
        -:   83:  lock->overlapped_.OffsetHigh = ACE_HIGH_PART (start);
        -:   84:  if (len == 0)
        -:   85:    {
        -:   86:      ACE_OFF_T const tlen = ACE_OS::filesize (lock->handle_);
        -:   87:      if (tlen != -1)
        -:   88:        len = tlen - start;
        -:   89:    }
        -:   90:}
        -:   91:#endif /* ACE_WIN32 */
        -:   92:
        -:   93:ACE_INLINE int
        -:   94:ACE_OS::flock_init (ACE_OS::ace_flock_t *lock,
        -:   95:                    int flags,
        -:   96:                    const ACE_TCHAR *name,
        -:   97:                    mode_t perms)
        -:   98:{
        -:   99:  ACE_OS_TRACE ("ACE_OS::flock_init");
        -:  100:#if defined (ACE_WIN32)
        -:  101:  // Once initialized, these values are never changed.
        -:  102:  lock->overlapped_.Internal = 0;
        -:  103:  lock->overlapped_.InternalHigh = 0;
        -:  104:  lock->overlapped_.OffsetHigh = 0;
        -:  105:  lock->overlapped_.hEvent = 0;
        -:  106:#endif /* ACE_WIN32 */
        -:  107:  lock->handle_ = ACE_INVALID_HANDLE;
        -:  108:  lock->lockname_ = 0;
        -:  109:
        -:  110:  if (name != 0)
        -:  111:    {
        -:  112:      ACE_OSCALL (ACE_OS::open (name, flags, perms),
        -:  113:                  ACE_HANDLE,
        -:  114:                  ACE_INVALID_HANDLE,
        -:  115:                  lock->handle_);
        -:  116:      if (lock->handle_ != ACE_INVALID_HANDLE)
        -:  117:        lock->lockname_ = ACE_OS::strdup (name);
        -:  118:      return lock->handle_ == ACE_INVALID_HANDLE ? -1 : 0;
        -:  119:    }
        -:  120:  else
        -:  121:    return 0;
        -:  122:}
        -:  123:
        -:  124:ACE_INLINE int
        -:  125:ACE_OS::flock_unlock (ACE_OS::ace_flock_t *lock,
        -:  126:                      short whence,
        -:  127:                      ACE_OFF_T start,
        -:  128:                      ACE_OFF_T len)
        -:  129:{
        -:  130:  ACE_OS_TRACE ("ACE_OS::flock_unlock");
        -:  131:#if defined (ACE_LACKS_FILELOCKS)
        -:  132:  ACE_UNUSED_ARG (lock);
        -:  133:  ACE_UNUSED_ARG (whence);
        -:  134:  ACE_UNUSED_ARG (start);
        -:  135:  ACE_UNUSED_ARG (len);
        -:  136:  ACE_NOTSUP_RETURN (-1);
        -:  137:#elif defined (ACE_WIN32)
        -:  138:  ACE_OS::flock_adjust_params (lock, whence, start, len);
        -:  139:  DWORD low_len = ACE_LOW_PART (len);
        -:  140:  DWORD high_len = ACE_HIGH_PART (len);
        -:  141:  ACE_WIN32CALL_RETURN (
        -:  142:    ACE_ADAPT_RETVAL (::UnlockFileEx (lock->handle_,
        -:  143:                                      0,
        -:  144:                                      low_len,
        -:  145:                                      high_len,
        -:  146:                                      &lock->overlapped_),
        -:  147:                      ace_result_), int, -1);
        -:  148:#else
        -:  149:  lock->lock_.l_whence = whence;
        -:  150:  lock->lock_.l_start = start;
        -:  151:  lock->lock_.l_len = len;
        -:  152:  lock->lock_.l_type = F_UNLCK;   // Unlock file.
        -:  153:
        -:  154:  // release lock
        -:  155:  ACE_OSCALL_RETURN (ACE_OS::fcntl (lock->handle_, F_SETLK,
        -:  156:                                    reinterpret_cast<long> (&lock->lock_)),
        -:  157:                     int, -1);
        -:  158:#endif /* ACE_WIN32 */
        -:  159:}
        -:  160:
        -:  161:ACE_INLINE int
        -:  162:ACE_OS::flock_destroy (ACE_OS::ace_flock_t *lock,
        -:  163:                       int unlink_file)
        -:  164:{
        -:  165:  ACE_OS_TRACE ("ACE_OS::flock_destroy");
        -:  166:  if (lock->handle_ != ACE_INVALID_HANDLE)
        -:  167:    {
        -:  168:      ACE_OS::flock_unlock (lock);
        -:  169:      // Close the handle.
        -:  170:      ACE_OS::close (lock->handle_);
        -:  171:      lock->handle_ = ACE_INVALID_HANDLE;
        -:  172:      if (lock->lockname_ != 0)
        -:  173:        {
        -:  174:          if (unlink_file)
        -:  175:            ACE_OS::unlink (lock->lockname_);
        -:  176:#if defined (ACE_HAS_ALLOC_HOOKS)
        -:  177:          ACE_Allocator::instance()->free (
        -:  178:            static_cast<void *> (const_cast<ACE_TCHAR *> (lock->lockname_)));
        -:  179:#else
        -:  180:          ACE_OS::free (
        -:  181:            static_cast<void *> (const_cast<ACE_TCHAR *> (lock->lockname_)));
        -:  182:#endif /* ACE_HAS_ALLOC_HOOKS */
        -:  183:        }
        -:  184:      lock->lockname_ = 0;
        -:  185:    }
        -:  186:  return 0;
        -:  187:}
        -:  188:
        -:  189:ACE_INLINE int
        -:  190:ACE_OS::flock_rdlock (ACE_OS::ace_flock_t *lock,
        -:  191:                      short whence,
        -:  192:                      ACE_OFF_T start,
        -:  193:                      ACE_OFF_T len)
        -:  194:{
        -:  195:  ACE_OS_TRACE ("ACE_OS::flock_rdlock");
        -:  196:#if defined (ACE_LACKS_FILELOCKS)
        -:  197:  ACE_UNUSED_ARG (lock);
        -:  198:  ACE_UNUSED_ARG (whence);
        -:  199:  ACE_UNUSED_ARG (start);
        -:  200:  ACE_UNUSED_ARG (len);
        -:  201:  ACE_NOTSUP_RETURN (-1);
        -:  202:#elif defined (ACE_WIN32)
        -:  203:  ACE_OS::flock_adjust_params (lock, whence, start, len);
        -:  204:  DWORD low_len = ACE_LOW_PART (len);
        -:  205:  DWORD high_len = ACE_HIGH_PART (len);
        -:  206:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::LockFileEx (lock->handle_,
        -:  207:                                                        0,
        -:  208:                                                        0,
        -:  209:                                                        low_len,
        -:  210:                                                        high_len,
        -:  211:                                                        &lock->overlapped_),
        -:  212:                                          ace_result_), int, -1);
        -:  213:#else
        -:  214:  lock->lock_.l_whence = whence;
        -:  215:  lock->lock_.l_start = start;
        -:  216:  lock->lock_.l_len = len;
        -:  217:  lock->lock_.l_type = F_RDLCK;         // set read lock
        -:  218:  // block, if no access
        -:  219:  ACE_OSCALL_RETURN (ACE_OS::fcntl (lock->handle_, F_SETLKW,
        -:  220:                                    reinterpret_cast<long> (&lock->lock_)),
        -:  221:                     int, -1);
        -:  222:#endif /* ACE_WIN32 */
        -:  223:}
        -:  224:
        -:  225:ACE_INLINE int
        -:  226:ACE_OS::flock_tryrdlock (ACE_OS::ace_flock_t *lock,
        -:  227:                         short whence,
        -:  228:                         ACE_OFF_T start,
        -:  229:                         ACE_OFF_T len)
        -:  230:{
        -:  231:  ACE_OS_TRACE ("ACE_OS::ace_flock_tryrdlock");
        -:  232:#if defined (ACE_LACKS_FILELOCKS)
        -:  233:  ACE_UNUSED_ARG (lock);
        -:  234:  ACE_UNUSED_ARG (whence);
        -:  235:  ACE_UNUSED_ARG (start);
        -:  236:  ACE_UNUSED_ARG (len);
        -:  237:  ACE_NOTSUP_RETURN (-1);
        -:  238:#elif defined (ACE_WIN32)
        -:  239:  ACE_OS::flock_adjust_params (lock, whence, start, len);
        -:  240:  DWORD low_len = ACE_LOW_PART (len);
        -:  241:  DWORD high_len = ACE_HIGH_PART (len);
        -:  242:  ACE_WIN32CALL_RETURN (
        -:  243:    ACE_ADAPT_RETVAL (::LockFileEx (lock->handle_,
        -:  244:                                    LOCKFILE_FAIL_IMMEDIATELY,
        -:  245:                                    0,
        -:  246:                                    low_len,
        -:  247:                                    high_len,
        -:  248:                                    &lock->overlapped_),
        -:  249:                      ace_result_), int, -1);
        -:  250:#else
        -:  251:  lock->lock_.l_whence = whence;
        -:  252:  lock->lock_.l_start = start;
        -:  253:  lock->lock_.l_len = len;
        -:  254:  lock->lock_.l_type = F_RDLCK;         // set read lock
        -:  255:
        -:  256:  int result = 0;
        -:  257:  // Does not block, if no access, returns -1 and set errno = EBUSY;
        -:  258:  ACE_OSCALL (ACE_OS::fcntl (lock->handle_, F_SETLK,
        -:  259:                             reinterpret_cast<long> (&lock->lock_)),
        -:  260:              int, -1, result);
        -:  261:
        -:  262:  if (result == -1 && (errno == EACCES || errno == EAGAIN))
        -:  263:    errno = EBUSY;
        -:  264:
        -:  265:  return result;
        -:  266:#endif /* ACE_WIN32 */
        -:  267:}
        -:  268:
        -:  269:ACE_INLINE int
        -:  270:ACE_OS::flock_trywrlock (ACE_OS::ace_flock_t *lock,
        -:  271:                         short whence,
        -:  272:                         ACE_OFF_T start,
        -:  273:                         ACE_OFF_T len)
        -:  274:{
        -:  275:  ACE_OS_TRACE ("ACE_OS::ace_flock_trywrlock");
        -:  276:#if defined (ACE_LACKS_FILELOCKS)
        -:  277:  ACE_UNUSED_ARG (lock);
        -:  278:  ACE_UNUSED_ARG (whence);
        -:  279:  ACE_UNUSED_ARG (start);
        -:  280:  ACE_UNUSED_ARG (len);
        -:  281:  ACE_NOTSUP_RETURN (-1);
        -:  282:#elif defined (ACE_WIN32)
        -:  283:  ACE_OS::flock_adjust_params (lock, whence, start, len);
        -:  284:  DWORD low_len = ACE_LOW_PART (len);
        -:  285:  DWORD high_len = ACE_HIGH_PART (len);
        -:  286:  ACE_WIN32CALL_RETURN (
        -:  287:    ACE_ADAPT_RETVAL (::LockFileEx (lock->handle_,
        -:  288:                                    LOCKFILE_FAIL_IMMEDIATELY | LOCKFILE_EXCLUSIVE_LOCK,
        -:  289:                                    0,
        -:  290:                                    low_len,
        -:  291:                                    high_len,
        -:  292:                                    &lock->overlapped_),
        -:  293:                      ace_result_), int, -1);
        -:  294:#else
        -:  295:  lock->lock_.l_whence = whence;
        -:  296:  lock->lock_.l_start = start;
        -:  297:  lock->lock_.l_len = len;
        -:  298:  lock->lock_.l_type = F_WRLCK;         // set write lock
        -:  299:
        -:  300:  int result = 0;
        -:  301:  // Does not block, if no access, returns -1 and set errno = EBUSY;
        -:  302:  ACE_OSCALL (ACE_OS::fcntl (lock->handle_,
        -:  303:                             F_SETLK,
        -:  304:                             reinterpret_cast<long> (&lock->lock_)),
        -:  305:              int, -1, result);
        -:  306:
        -:  307:  if (result == -1 && (errno == EACCES || errno == EAGAIN))
        -:  308:    errno = EBUSY;
        -:  309:
        -:  310:  return result;
        -:  311:#endif /* ACE_WIN32 */
        -:  312:}
        -:  313:
        -:  314:ACE_INLINE int
        -:  315:ACE_OS::flock_wrlock (ACE_OS::ace_flock_t *lock,
        -:  316:                      short whence,
        -:  317:                      ACE_OFF_T start,
        -:  318:                      ACE_OFF_T len)
        -:  319:{
        -:  320:  ACE_OS_TRACE ("ACE_OS::flock_wrlock");
        -:  321:#if defined (ACE_LACKS_FILELOCKS)
        -:  322:  ACE_UNUSED_ARG (lock);
        -:  323:  ACE_UNUSED_ARG (whence);
        -:  324:  ACE_UNUSED_ARG (start);
        -:  325:  ACE_UNUSED_ARG (len);
        -:  326:  ACE_NOTSUP_RETURN (-1);
        -:  327:#elif defined (ACE_WIN32)
        -:  328:  ACE_OS::flock_adjust_params (lock, whence, start, len);
        -:  329:  DWORD low_len = ACE_LOW_PART (len);
        -:  330:  DWORD high_len = ACE_HIGH_PART (len);
        -:  331:  ACE_WIN32CALL_RETURN (
        -:  332:    ACE_ADAPT_RETVAL (::LockFileEx (lock->handle_,
        -:  333:                                    LOCKFILE_EXCLUSIVE_LOCK,
        -:  334:                                    0,
        -:  335:                                    low_len,
        -:  336:                                    high_len,
        -:  337:                                    &lock->overlapped_),
        -:  338:                      ace_result_), int, -1);
        -:  339:#else
        -:  340:  lock->lock_.l_whence = whence;
        -:  341:  lock->lock_.l_start = start;
        -:  342:  lock->lock_.l_len = len;
        -:  343:  lock->lock_.l_type = F_WRLCK;         // set write lock
        -:  344:  // block, if no access
        -:  345:  ACE_OSCALL_RETURN (ACE_OS::fcntl (lock->handle_, F_SETLKW,
        -:  346:                                    reinterpret_cast<long> (&lock->lock_)),
        -:  347:                     int, -1);
        -:  348:#endif /* ACE_WIN32 */
        -:  349:}
        -:  350:
        -:  351:ACE_INLINE void
        -:  352:ACE_OS::clearerr (FILE* fp)
        -:  353:{
        -:  354:  ace_clearerr_helper (fp);
        -:  355:}
        -:  356:
        -:  357:#if !defined (ACE_LACKS_CUSERID)
        -:  358:ACE_INLINE char *
        -:  359:ACE_OS::cuserid (char *user, size_t maxlen)
        -:  360:{
        -:  361:  ACE_OS_TRACE ("ACE_OS::cuserid");
        -:  362:#if defined (ACE_VXWORKS)
        -:  363:  ACE_UNUSED_ARG (maxlen);
        -:  364:  if (user == 0)
        -:  365:    {
        -:  366:      // Require that the user field be non-null, i.e., don't
        -:  367:      // allocate or use static storage.
        -:  368:      ACE_NOTSUP_RETURN (0);
        -:  369:    }
        -:  370:  else
        -:  371:    {
        -:  372:      ::remCurIdGet (user, 0);
        -:  373:      return user;
        -:  374:    }
        -:  375:#elif defined (ACE_HAS_PHARLAP) || defined (ACE_HAS_WINCE)
        -:  376:  ACE_UNUSED_ARG (user);
        -:  377:  ACE_UNUSED_ARG (maxlen);
        -:  378:  ACE_NOTSUP_RETURN (0);
        -:  379:#elif defined (ACE_WIN32)
        -:  380:  BOOL const result = GetUserNameA (user, (u_long *) &maxlen);
        -:  381:  if (result == FALSE)
        -:  382:    ACE_FAIL_RETURN (0);
        -:  383:  else
        -:  384:    return user;
        -:  385:#elif defined (ACE_HAS_ALT_CUSERID)
        -:  386:#  if defined (ACE_LACKS_PWD_FUNCTIONS)
        -:  387:  ACE_UNUSED_ARG (user);
        -:  388:  ACE_UNUSED_ARG (maxlen);
        -:  389:  ACE_NOTSUP_RETURN (0);
        -:  390:  //#    error Cannot use alternate cuserid() without POSIX password functions!
        -:  391:#  endif  /* ACE_LACKS_PWD_FUNCTIONS */
        -:  392:
        -:  393:  // POSIX.1 dropped the cuserid() function.
        -:  394:  // GNU GLIBC and other platforms correctly deprecate the cuserid()
        -:  395:  // function.
        -:  396:
        -:  397:  if (maxlen == 0)
        -:  398:    {
        -:  399:      // It doesn't make sense to have a zero length user ID.
        -:  400:      errno = EINVAL;
        -:  401:      return 0;
        -:  402:    }
        -:  403:
        -:  404:  struct passwd *pw = 0;
        -:  405:
        -:  406:  // Make sure the file pointer is at the beginning of the password file
        -:  407:  ACE_OS::setpwent ();
        -:  408:  // Should use ACE_OS::setpwent() but I didn't want to move this
        -:  409:  // method after it.
        -:  410:
        -:  411:  // Use the effective user ID to determine the user name.
        -:  412:  pw = ::getpwuid (ACE_OS::geteuid ());
        -:  413:
        -:  414:  // Make sure the password file is closed.
        -:  415:  ACE_OS::endpwent ();
        -:  416:
        -:  417:  if (pw == 0)
        -:  418:    {
        -:  419:      errno = ENOENT;
        -:  420:      return 0;
        -:  421:    }
        -:  422:
        -:  423:  size_t max_length = 0;
        -:  424:  char *userid = 0;
        -:  425:
        -:  426:  if (user == 0)
        -:  427:    {
        -:  428:      // Not reentrant/thread-safe, but nothing else can be done if a
        -:  429:      // zero pointer was passed in as the destination.
        -:  430:
        -:  431:#if defined (_POSIX_SOURCE) && defined (L_cuserid)
        -:  432:      const size_t ACE_L_cuserid = L_cuserid;
        -:  433:#else
        -:  434:      const size_t ACE_L_cuserid = 9;  // 8 character user ID + NULL
        -:  435:#endif  /* _POSIX_SOURCE */
        -:  436:
        -:  437:      static char tmp[ACE_L_cuserid] = { '\0' };
        -:  438:      max_length = ACE_L_cuserid - 1; // Do not include NULL in length
        -:  439:
        -:  440:      userid = tmp;
        -:  441:    }
        -:  442:  else
        -:  443:    {
        -:  444:      max_length = maxlen;
        -:  445:      userid = user;
        -:  446:    }
        -:  447:
        -:  448:  // Extract the user name from the passwd structure.
        -:  449:  if (ACE_OS::strlen (pw->pw_name) <= max_length)
        -:  450:    {
        -:  451:      return ACE_OS::strcpy (userid, pw->pw_name);
        -:  452:    }
        -:  453:  else
        -:  454:    {
        -:  455:      errno = ENOSPC;  // Buffer is not large enough.
        -:  456:      return 0;
        -:  457:    }
        -:  458:#else
        -:  459:  // Hackish because of missing buffer size!
        -:  460:  ACE_UNUSED_ARG (maxlen);
        -:  461:  ACE_OSCALL_RETURN (::ace_cuserid(user), char*, 0);
        -:  462:#endif /* ACE_VXWORKS */
        -:  463:}
        -:  464:
        -:  465:#if defined (ACE_HAS_WCHAR)
        -:  466:ACE_INLINE wchar_t *
        -:  467:ACE_OS::cuserid (wchar_t *user, size_t maxlen)
        -:  468:{
        -:  469:# if defined (ACE_HAS_WINCE)
        -:  470:  ACE_UNUSED_ARG (user);
        -:  471:  ACE_UNUSED_ARG (maxlen);
        -:  472:  ACE_NOTSUP_RETURN (0);
        -:  473:# elif defined (ACE_WIN32)
        -:  474:  BOOL const result = GetUserNameW (user, (u_long *) &maxlen);
        -:  475:  if (result == FALSE)
        -:  476:    ACE_FAIL_RETURN (0);
        -:  477:  else
        -:  478:    return user;
        -:  479:# else /* ACE_WIN32 */
        -:  480:  char *char_user;
        -:  481:  wchar_t *result = 0;
        -:  482:
        -:  483:  ACE_NEW_RETURN (char_user, char[maxlen + 1], 0);
        -:  484:
        -:  485:  if (ACE_OS::cuserid (char_user, maxlen))
        -:  486:    {
        -:  487:      ACE_OS::strcpy (user, ACE_Ascii_To_Wide (char_user).wchar_rep ());
        -:  488:      result = user;
        -:  489:    }
        -:  490:
        -:  491:  delete [] char_user;
        -:  492:
        -:  493:  return result;
        -:  494:# endif /* ACE_WIN32 */
        -:  495:}
        -:  496:#endif /* ACE_HAS_WCHAR  */
        -:  497:#endif /* ACE_LACKS_CUSERID */
        -:  498:
        -:  499:ACE_INLINE int
       10:  500:ACE_OS::fclose (FILE *fp)
        -:  501:{
        -:  502:  ACE_OS_TRACE ("ACE_OS::fclose");
       10:  503:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fclose (fp), int, -1);
        -:  504:}
        -:  505:
        -:  506:ACE_INLINE FILE *
        -:  507:ACE_OS::fdopen (ACE_HANDLE handle, const ACE_TCHAR *mode)
        -:  508:{
        -:  509:  ACE_OS_TRACE ("ACE_OS::fdopen");
        -:  510:#if defined (ACE_HAS_WINCE)
        -:  511:# if defined (ACE_HAS_NONCONST_WFDOPEN)
        -:  512:  ACE_OSCALL_RETURN (::_wfdopen ((int)handle, const_cast <ACE_TCHAR*> (ACE_TEXT_ALWAYS_WCHAR (mode))),
        -:  513:                     FILE*,
        -:  514:                     0);
        -:  515:# else
        -:  516:  ACE_OSCALL_RETURN (::_wfdopen (handle, ACE_TEXT_ALWAYS_WCHAR (mode)),
        -:  517:                     FILE*,
        -:  518:                     0);
        -:  519:# endif
        -:  520:#elif defined (ACE_WIN32)
        -:  521:  // kernel file handle -> FILE* conversion...
        -:  522:  // Options: _O_APPEND, _O_RDONLY and _O_TEXT are lost
        -:  523:
        -:  524:  FILE * file = 0;
        -:  525:
        -:  526:  int const crt_handle = ::_open_osfhandle (intptr_t (handle), 0);
        -:  527:
        -:  528:  if (crt_handle != -1)
        -:  529:    {
        -:  530:#   if defined (ACE_USES_WCHAR)
        -:  531:      file = ::_wfdopen (crt_handle, mode);
        -:  532:#   else
        -:  533:      file = ::_fdopen (crt_handle, mode);
        -:  534:#   endif /* ACE_USES_WCHAR */
        -:  535:
        -:  536:      if (!file)
        -:  537:        {
        -:  538:          ::_close (crt_handle);
        -:  539:        }
        -:  540:    }
        -:  541:
        -:  542:  return file;
        -:  543:#elif defined (ACE_LACKS_FDOPEN)
        -:  544:  ACE_UNUSED_ARG (handle);
        -:  545:  ACE_UNUSED_ARG (mode);
        -:  546:  ACE_NOTSUP_RETURN (0);
        -:  547:#else
        -:  548:  ACE_OSCALL_RETURN
        -:  549:    (::fdopen (handle, ACE_TEXT_ALWAYS_CHAR (mode)), FILE *, 0);
        -:  550:#endif /* ACE_HAS_WINCE */
        -:  551:}
        -:  552:
        -:  553:ACE_INLINE int
        -:  554:ACE_OS::fflush (FILE *fp)
        -:  555:{
        -:  556:  ACE_OS_TRACE ("ACE_OS::fflush");
        -:  557:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fflush (fp), int, -1);
        -:  558:}
        -:  559:
        -:  560:ACE_INLINE int
        -:  561:ACE_OS::fgetc (FILE *fp)
        -:  562:{
        -:  563:  return ace_fgetc_helper (fp);
        -:  564:}
        -:  565:
        -:  566:ACE_INLINE int
        -:  567:ACE_OS::getc (FILE *fp)
        -:  568:{
        -:  569:#ifdef ACE_LACKS_GETC
        -:  570:  ACE_UNUSED_ARG (fp);
        -:  571:  ACE_NOTSUP_RETURN (-1);
        -:  572:#else
        -:  573:  return ace_getc_helper (fp);
        -:  574:#endif
        -:  575:}
        -:  576:
        -:  577:ACE_INLINE int
        -:  578:ACE_OS::fgetpos (FILE *fp, fpos_t *pos)
        -:  579:{
        -:  580:#ifdef ACE_LACKS_FGETPOS
        -:  581:  ACE_UNUSED_ARG (fp);
        -:  582:  ACE_UNUSED_ARG (pos);
        -:  583:  ACE_NOTSUP_RETURN (-1);
        -:  584:#else
        -:  585:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fgetpos (fp, pos), int, -1);
        -:  586:#endif
        -:  587:}
        -:  588:
        -:  589:ACE_INLINE char *
        -:  590:ACE_OS::fgets (char *buf, int size, FILE *fp)
        -:  591:{
        -:  592:  ACE_OS_TRACE ("ACE_OS::fgets");
        -:  593:#if defined (ACE_LACKS_FGETS)
        -:  594:  char *iter = buf;
        -:  595:  int c = EOF;
        -:  596:  for (int i = 0; i < size - 1 && c != '\n'; ++i)
        -:  597:    {
        -:  598:      c = ACE_STD_NAMESPACE::fgetc (fp);
        -:  599:      if (c != EOF)
        -:  600:        *iter++ = static_cast<char> (c);
        -:  601:    }
        -:  602:  *iter = '\0';
        -:  603:  return c == EOF ? 0 : buf;
        -:  604:#else
        -:  605:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fgets (buf, size, fp), char *, 0);
        -:  606:#endif /* ACE_LACKS_FGETS */
        -:  607:}
        -:  608:
        -:  609:#if defined (ACE_HAS_WCHAR) && !defined(ACE_LACKS_FGETWS)
        -:  610:ACE_INLINE wchar_t *
        -:  611:ACE_OS::fgets (wchar_t *buf, int size, FILE *fp)
        -:  612:{
        -:  613:  ACE_OS_TRACE ("ACE_OS::fgets");
        -:  614:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fgetws (buf, size, fp), wchar_t *, 0);
        -:  615:}
        -:  616:#endif /* ACE_HAS_WCHAR && !ACE_LACKS_FGETWS */
        -:  617:
        -:  618:ACE_INLINE ACE_HANDLE
        -:  619:ACE_OS::fileno (FILE *stream)
        -:  620:{
        -:  621:#if defined ACE_FILENO_EQUIVALENT
        -:  622:  return (ACE_HANDLE)((intptr_t)ACE_FILENO_EQUIVALENT (stream));
        -:  623:#else
        -:  624:  return ace_fileno_helper (stream);
        -:  625:#endif
        -:  626:}
        -:  627:
        -:  628:#if !(defined (ACE_WIN32) && !defined (ACE_HAS_WINCE))
        -:  629:// Win32 PC implementation of fopen () is in OS_NS_stdio.cpp.
        -:  630:ACE_INLINE FILE *
       14:  631:ACE_OS::fopen (const char *filename, const char *mode)
        -:  632:{
        -:  633:  ACE_OS_TRACE ("ACE_OS::fopen");
       14:  634:  ACE_OSCALL_RETURN (::fopen (filename, mode), FILE *, 0);
        -:  635:}
        -:  636:
        -:  637:#if defined (ACE_HAS_WCHAR)
        -:  638:// Win32 PC implementation of fopen () is in OS_NS_stdio.cpp.
        -:  639:ACE_INLINE FILE *
        -:  640:ACE_OS::fopen (const char *filename, const wchar_t *mode)
        -:  641:{
        -:  642:  ACE_OS_TRACE ("ACE_OS::fopen");
        -:  643:  ACE_Wide_To_Ascii n_mode (mode);
        -:  644:  ACE_OSCALL_RETURN (::fopen (filename, n_mode.char_rep ()), FILE *, 0);
        -:  645:}
        -:  646:
        -:  647:// Win32 PC implementation of fopen () is in OS_NS_stdio.cpp.
        -:  648:ACE_INLINE FILE *
        -:  649:ACE_OS::fopen (const wchar_t *filename, const wchar_t *mode)
        -:  650:{
        -:  651:  ACE_OS_TRACE ("ACE_OS::fopen");
        -:  652:#if defined (ACE_HAS_WINCE)
        -:  653:  ACE_OSCALL_RETURN (::_wfopen (filename, mode), FILE *, 0);
        -:  654:#else
        -:  655:  // Non-Windows doesn't use wchar_t file systems.
        -:  656:  ACE_Wide_To_Ascii n_filename (filename);
        -:  657:  ACE_Wide_To_Ascii n_mode (mode);
        -:  658:  ACE_OSCALL_RETURN
        -:  659:    (::fopen (n_filename.char_rep (), n_mode.char_rep ()), FILE*, 0);
        -:  660:#endif /* ACE_HAS_WINCE */
        -:  661:}
        -:  662:// Win32 PC implementation of fopen () is in OS_NS_stdio.cpp.
        -:  663:ACE_INLINE FILE *
        -:  664:ACE_OS::fopen (const wchar_t *filename, const char *mode)
        -:  665:{
        -:  666:  ACE_OS_TRACE ("ACE_OS::fopen");
        -:  667:#if defined (ACE_HAS_WINCE)
        -:  668:  ACE_Ascii_To_Wide n_mode (mode);
        -:  669:  ACE_OSCALL_RETURN
        -:  670:    (::_wfopen (filename, n_mode.wchar_rep ()), FILE *, 0);
        -:  671:#else
        -:  672:  // Non-Windows doesn't use wchar_t file systems.
        -:  673:  ACE_Wide_To_Ascii n_filename (filename);
        -:  674:  ACE_OSCALL_RETURN
        -:  675:    (::fopen (n_filename.char_rep (), mode), FILE*, 0);
        -:  676:#endif /* ACE_HAS_WINCE */
        -:  677:}
        -:  678:#endif /* ACE_HAS_WCHAR */
        -:  679:
        -:  680:#endif /* ACE_WIN32 */
        -:  681:
        -:  682:ACE_INLINE int
        -:  683:ACE_OS::ungetc (int c, FILE *fp)
        -:  684:{
        -:  685:#ifdef ACE_LACKS_UNGETC
        -:  686:  ACE_UNUSED_ARG (c);
        -:  687:  ACE_UNUSED_ARG (fp);
        -:  688:  ACE_NOTSUP_RETURN (-1);
        -:  689:#else
        -:  690:  return ace_ungetc_helper (c, fp);
        -:  691:#endif
        -:  692:}
        -:  693:
        -:  694:ACE_INLINE int
        -:  695:ACE_OS::fputc (int c, FILE *fp)
        -:  696:{
        -:  697:#ifdef ACE_LACKS_FPUTC
        -:  698:  ACE_UNUSED_ARG (c);
        -:  699:  ACE_UNUSED_ARG (fp);
        -:  700:  ACE_NOTSUP_RETURN (-1);
        -:  701:#else
        -:  702:  return ace_fputc_helper (c, fp);
        -:  703:#endif
        -:  704:}
        -:  705:
        -:  706:ACE_INLINE int
        -:  707:ACE_OS::putc (int c, FILE *fp)
        -:  708:{
        -:  709:#ifdef ACE_LACKS_PUTC
        -:  710:  ACE_UNUSED_ARG (c);
        -:  711:  ACE_UNUSED_ARG (fp);
        -:  712:  ACE_NOTSUP_RETURN (-1);
        -:  713:#else
        -:  714:  return ace_putc_helper (c, fp);
        -:  715:#endif
        -:  716:}
        -:  717:
        -:  718:ACE_INLINE int
        -:  719:ACE_OS::fputs (const char *s, FILE *stream)
        -:  720:{
        -:  721:  ACE_OS_TRACE ("ACE_OS::fputs");
        -:  722:#ifdef ACE_LACKS_FPUTS
        -:  723:  ACE_UNUSED_ARG (s);
        -:  724:  ACE_UNUSED_ARG (stream);
        -:  725:  ACE_NOTSUP_RETURN (-1);
        -:  726:#else
        -:  727:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fputs (s, stream), int, -1);
        -:  728:#endif
        -:  729:}
        -:  730:
        -:  731:#if defined (ACE_HAS_WCHAR) && !defined(ACE_LACKS_FPUTWS)
        -:  732:ACE_INLINE int
        -:  733:ACE_OS::fputs (const wchar_t *s, FILE *stream)
        -:  734:{
        -:  735:  ACE_OS_TRACE ("ACE_OS::fputs");
        -:  736:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fputws (s, stream), int, -1);
        -:  737:}
        -:  738:#endif /* ACE_HAS_WCHAR && !ACE_LACKS_FPUTWS */
        -:  739:
        -:  740:ACE_INLINE size_t
        -:  741:ACE_OS::fread (void *ptr, size_t size, size_t nelems, FILE *fp)
        -:  742:{
        -:  743:  ACE_OS_TRACE ("ACE_OS::fread");
        -:  744:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fread (ptr, size, nelems, fp),
        -:  745:                     size_t,
        -:  746:                     0);
        -:  747:}
        -:  748:
        -:  749:ACE_INLINE FILE *
        -:  750:ACE_OS::freopen (const ACE_TCHAR *filename, const ACE_TCHAR *mode, FILE* stream)
        -:  751:{
        -:  752:  ACE_OS_TRACE ("ACE_OS::freopen");
        -:  753:#if defined (ACE_WIN32) && defined(ACE_USES_WCHAR)
        -:  754:  ACE_OSCALL_RETURN (::_wfreopen (ACE_TEXT_ALWAYS_WCHAR (filename),
        -:  755:                                  ACE_TEXT_ALWAYS_WCHAR (mode),
        -:  756:                                  stream),
        -:  757:                     FILE *, 0);
        -:  758:#else
        -:  759:  ACE_OSCALL_RETURN
        -:  760:    (ACE_STD_NAMESPACE::freopen (ACE_TEXT_ALWAYS_CHAR (filename),
        -:  761:                                 ACE_TEXT_ALWAYS_CHAR (mode),
        -:  762:                                 stream),
        -:  763:     FILE *, 0);
        -:  764:#endif /* ACE_WIN32 && ACE_USES_WCHAR */
        -:  765:}
        -:  766:
        -:  767:ACE_INLINE int
        -:  768:ACE_OS::fseek (FILE *fp, long offset, int whence)
        -:  769:{
        -:  770:#if defined (ACE_WIN32)
        -:  771:# if SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END
        -:  772:  //#error Windows NT is evil AND rude!
        -:  773:  switch (whence)
        -:  774:    {
        -:  775:    case SEEK_SET:
        -:  776:      whence = FILE_BEGIN;
        -:  777:      break;
        -:  778:    case SEEK_CUR:
        -:  779:      whence = FILE_CURRENT;
        -:  780:      break;
        -:  781:    case SEEK_END:
        -:  782:      whence = FILE_END;
        -:  783:      break;
        -:  784:    default:
        -:  785:      errno = EINVAL;
        -:  786:      return -1; // rather safe than sorry
        -:  787:    }
        -:  788:# endif  /* SEEK_SET != FILE_BEGIN || SEEK_CUR != FILE_CURRENT || SEEK_END != FILE_END */
        -:  789:#endif   /* ACE_WIN32 */
        -:  790:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fseek (fp, offset, whence), int, -1);
        -:  791:}
        -:  792:
        -:  793:ACE_INLINE int
        -:  794:ACE_OS::fsetpos (FILE* fp, fpos_t* pos)
        -:  795:{
        -:  796:#if defined (ACE_LACKS_FSETPOS)
        -:  797:  ACE_UNUSED_ARG (fp);
        -:  798:  ACE_UNUSED_ARG (pos);
        -:  799:  ACE_NOTSUP_RETURN (-1);
        -:  800:#else
        -:  801:  ACE_OSCALL_RETURN (::fsetpos (fp, pos), int, -1);
        -:  802:#endif /* ACE_LACKS_FSETPOS */
        -:  803:}
        -:  804:
        -:  805:ACE_INLINE long
        -:  806:ACE_OS::ftell (FILE* fp)
        -:  807:{
        -:  808:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::ftell (fp), long, -1);
        -:  809:}
        -:  810:
        -:  811:ACE_INLINE size_t
        -:  812:ACE_OS::fwrite (const void *ptr, size_t size, size_t nitems, FILE *fp)
        -:  813:{
        -:  814:  ACE_OS_TRACE ("ACE_OS::fwrite");
        -:  815:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::fwrite (ptr, size, nitems, fp),
        -:  816:                     size_t,
        -:  817:                     0);
        -:  818:}
        -:  819:
        -:  820:ACE_INLINE void
        -:  821:ACE_OS::perror (const char *s)
        -:  822:{
        -:  823:  ACE_OS_TRACE ("ACE_OS::perror");
        -:  824:#if defined (ACE_LACKS_PERROR)
        -:  825:  ACE_UNUSED_ARG (s);
        -:  826:#else
        -:  827:  ::perror (s);
        -:  828:#endif /* ACE_HAS_WINCE */
        -:  829:}
        -:  830:
        -:  831:#if defined (ACE_HAS_WCHAR)
        -:  832:ACE_INLINE void
        -:  833:ACE_OS::perror (const wchar_t *s)
        -:  834:{
        -:  835:  ACE_OS_TRACE ("ACE_OS::perror");
        -:  836:#if defined (ACE_LACKS_PERROR)
        -:  837:  ACE_UNUSED_ARG (s);
        -:  838:#elif defined (ACE_WIN32)
        -:  839:  ::_wperror (s);
        -:  840:#else
        -:  841:  ACE_Wide_To_Ascii n_s (s);
        -:  842:  ::perror (n_s.char_rep ());
        -:  843:#endif /* ACE_LACKS_PERROR */
        -:  844:}
        -:  845:#endif /* ACE_HAS_WCHAR */
        -:  846:
        -:  847:ACE_INLINE int
        -:  848:ACE_OS::puts (const char *s)
        -:  849:{
        -:  850:  ACE_OS_TRACE ("ACE_OS::puts");
        -:  851:#if defined (ACE_LACKS_PUTS)
        -:  852:  ACE_UNUSED_ARG (s);
        -:  853:  ACE_NOTSUP_RETURN (-1);
        -:  854:#else
        -:  855:  ACE_OSCALL_RETURN (::puts (s), int, -1);
        -:  856:#endif /* ACE_LACKS_PUTS */
        -:  857:}
        -:  858:
        -:  859:#if defined (ACE_HAS_WCHAR)
        -:  860:ACE_INLINE int
        -:  861:ACE_OS::puts (const wchar_t *s)
        -:  862:{
        -:  863:  ACE_OS_TRACE ("ACE_OS::puts");
        -:  864:#if defined (ACE_WIN32)
        -:  865:  ACE_OSCALL_RETURN (::_putws (s), int, -1);
        -:  866:#else /* ACE_WIN32 */
        -:  867:  // There's no putws()...
        -:  868:  ACE_Wide_To_Ascii n_s (s);
        -:  869:  ACE_OSCALL_RETURN (::puts (n_s.char_rep ()), int, -1);
        -:  870:#endif /* ACE_WIN32 */
        -:  871:}
        -:  872:#endif /* ACE_HAS_WCHAR */
        -:  873:
        -:  874:ACE_INLINE int
        -:  875:ACE_OS::rename (const char *old_name,
        -:  876:                const char *new_name,
        -:  877:                int flags)
        -:  878:{
        -:  879:# if defined (ACE_LACKS_RENAME)
        -:  880:  ACE_UNUSED_ARG (old_name);
        -:  881:  ACE_UNUSED_ARG (new_name);
        -:  882:  ACE_UNUSED_ARG (flags);
        -:  883:  ACE_NOTSUP_RETURN (-1);
        -:  884:# elif defined (ACE_HAS_WINCE)
        -:  885:  // Win CE is always wide-char.
        -:  886:  ACE_UNUSED_ARG (flags);
        -:  887:  if (0 == ::MoveFile (ACE_TEXT_CHAR_TO_TCHAR (old_name),
        -:  888:                       ACE_TEXT_CHAR_TO_TCHAR (new_name)))
        -:  889:    ACE_FAIL_RETURN (-1);
        -:  890:  return 0;
        -:  891:# elif defined (ACE_WIN32) && !defined (ACE_LACKS_WIN32_MOVEFILEEX)
        -:  892:  // NT4 (and up) provides a way to rename/move a file with similar semantics
        -:  893:  // to what's usually done on UNIX - if there's an existing file with
        -:  894:  // <new_name> it is removed before the file is renamed/moved. The
        -:  895:  // MOVEFILE_COPY_ALLOWED is specified to allow such a rename across drives.
        -:  896:  if (flags == -1)
        -:  897:    flags = MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING;
        -:  898:  if (::MoveFileExA (old_name, new_name, flags) == 0)
        -:  899:    ACE_FAIL_RETURN (-1);
        -:  900:  return 0;
        -:  901:# else
        -:  902:  ACE_UNUSED_ARG (flags);
        -:  903:  ACE_OSCALL_RETURN (::rename (old_name, new_name), int, -1);
        -:  904:# endif /* ACE_HAS_WINCE */
        -:  905:}
        -:  906:
        -:  907:#if defined (ACE_HAS_WCHAR)
        -:  908:ACE_INLINE int
        -:  909:ACE_OS::rename (const wchar_t *old_name,
        -:  910:                const wchar_t *new_name,
        -:  911:                int flags)
        -:  912:{
        -:  913:# if defined (ACE_LACKS_RENAME)
        -:  914:  ACE_UNUSED_ARG (old_name);
        -:  915:  ACE_UNUSED_ARG (new_name);
        -:  916:  ACE_UNUSED_ARG (flags);
        -:  917:  ACE_NOTSUP_RETURN (-1);
        -:  918:# elif defined (ACE_HAS_WINCE)
        -:  919:  ACE_UNUSED_ARG (flags);
        -:  920:  if (::MoveFileW (old_name, new_name) == 0)
        -:  921:    ACE_FAIL_RETURN (-1);
        -:  922:  return 0;
        -:  923:# elif defined (ACE_WIN32) && !defined (ACE_LACKS_WIN32_MOVEFILEEX)
        -:  924:  // NT4 (and up) provides a way to rename/move a file with similar semantics
        -:  925:  // to what's usually done on UNIX - if there's an existing file with
        -:  926:  // <new_name> it is removed before the file is renamed/moved. The
        -:  927:  // MOVEFILE_COPY_ALLOWED is specified to allow such a rename across drives.
        -:  928:  if (flags == -1)
        -:  929:    flags = MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING;
        -:  930:  if (::MoveFileExW (old_name, new_name, flags) == 0)
        -:  931:    ACE_FAIL_RETURN (-1);
        -:  932:  return 0;
        -:  933:# elif defined (ACE_WIN32)
        -:  934:  ACE_UNUSED_ARG (flags);
        -:  935:  ACE_OSCALL_RETURN (::_wrename (old_name, new_name), int, -1);
        -:  936:# else
        -:  937:  ACE_Wide_To_Ascii nold_name (old_name);
        -:  938:  ACE_Wide_To_Ascii nnew_name (new_name);
        -:  939:  return ACE_OS::rename (nold_name.char_rep (), nnew_name.char_rep (), flags);
        -:  940:# endif /* ACE_HAS_WINCE */
        -:  941:}
        -:  942:#endif /* ACE_HAS_WCHAR */
        -:  943:
        -:  944:ACE_INLINE void
        -:  945:ACE_OS::rewind (FILE *fp)
        -:  946:{
        -:  947:#if !defined (ACE_HAS_WINCE)
        -:  948:  ACE_OS_TRACE ("ACE_OS::rewind");
        -:  949:# if defined (ACE_LACKS_REWIND)
        -:  950:  ACE_UNUSED_ARG (fp);
        -:  951:# else
        -:  952:  ::rewind (fp);
        -:  953:# endif /* ACE_LACKS_REWIND */
        -:  954:#else
        -:  955:  // This isn't perfect since it doesn't reset EOF, but it's probably
        -:  956:  // the closest we can get on WINCE.
        -:  957:  (void) ::fseek (fp, 0L, SEEK_SET);
        -:  958:#endif /* ACE_HAS_WINCE */
        -:  959:}
        -:  960:
        -:  961:ACE_INLINE char *
        -:  962:ACE_OS::tempnam (const char *dir, const char *pfx)
        -:  963:{
        -:  964:  ACE_OS_TRACE ("ACE_OS::tempnam");
        -:  965:#if defined (ACE_LACKS_TEMPNAM)
        -:  966:  ACE_UNUSED_ARG (dir);
        -:  967:  ACE_UNUSED_ARG (pfx);
        -:  968:  ACE_NOTSUP_RETURN (0);
        -:  969:#elif defined (ACE_HAS_NONCONST_TEMPNAM)
        -:  970:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::tempnam (const_cast <char *> (dir), const_cast<char *> (pfx)), char *, 0);
        -:  971:#else /* ACE_LACKS_TEMPNAM */
        -:  972:  ACE_OSCALL_RETURN (ACE_STD_NAMESPACE::tempnam (dir, pfx), char *, 0);
        -:  973:#endif /* ACE_LACKS_TEMPNAM */
        -:  974:}
        -:  975:
        -:  976:#if defined (ACE_HAS_WCHAR)
        -:  977:ACE_INLINE wchar_t *
        -:  978:ACE_OS::tempnam (const wchar_t *dir, const wchar_t *pfx)
        -:  979:{
        -:  980:  ACE_OS_TRACE ("ACE_OS::tempnam");
        -:  981:#if defined (ACE_LACKS_TEMPNAM)
        -:  982:  ACE_UNUSED_ARG (dir);
        -:  983:  ACE_UNUSED_ARG (pfx);
        -:  984:  ACE_NOTSUP_RETURN (0);
        -:  985:#elif defined(ACE_WIN32)
        -:  986:#  if defined (ACE_HAS_NONCONST_TEMPNAM)
        -:  987:  ACE_OSCALL_RETURN (::_wtempnam (const_cast <wchar_t*> (dir), const_cast <wchar_t*> (pfx)), wchar_t *, 0);
        -:  988:#  else
        -:  989:  ACE_OSCALL_RETURN (::_wtempnam (dir, pfx), wchar_t *, 0);
        -:  990:#  endif /* ACE_HAS_NONCONST_TEMPNAM */
        -:  991:#else /* ACE_LACKS_TEMPNAM */
        -:  992:  // No native wide-char support; convert to narrow and call the char* variant.
        -:  993:  char *ndir = ACE_Wide_To_Ascii (dir).char_rep ();
        -:  994:  char *npfx = ACE_Wide_To_Ascii (pfx).char_rep ();
        -:  995:  char *name = ACE_OS::tempnam (ndir, npfx);
        -:  996:  // ACE_OS::tempnam returns a pointer to a malloc()-allocated space.
        -:  997:  // Convert that string to wide-char and free() the original.
        -:  998:  wchar_t *wname = 0;
        -:  999:  if (name != 0)
        -: 1000:    {
        -: 1001:      size_t namelen = ACE_OS::strlen (name) + 1;
        -: 1002:      wname = reinterpret_cast<wchar_t *>
        -: 1003:        (ACE_OS::malloc (namelen * sizeof (wchar_t)));
        -: 1004:      if (wname != 0)
        -: 1005:        ACE_OS::strcpy (wname, ACE_Ascii_To_Wide (name).wchar_rep ());
        -: 1006:      ACE_OS::free (name);
        -: 1007:    }
        -: 1008:  return wname;
        -: 1009:#endif /* ACE_LACKS_TEMPNAM */
        -: 1010:}
        -: 1011:#endif /* ACE_HAS_WCHAR */
        -: 1012:
        -: 1013:ACE_INLINE int
        -: 1014:ACE_OS::vasprintf (char **bufp, const char* format, va_list argptr)
        -: 1015:{
        -: 1016:#if defined (ACE_HAS_VASPRINTF)
        -: 1017:  return ::vasprintf (bufp, format, argptr);
        -: 1018:#elif defined (ACE_LACKS_VA_COPY)
        -: 1019:  ACE_UNUSED_ARG (bufp);
        -: 1020:  ACE_UNUSED_ARG (format);
        -: 1021:  ACE_UNUSED_ARG (argptr);
        -: 1022:  ACE_NOTSUP_RETURN (-1);
        -: 1023:#else
        -: 1024:  return ACE_OS::vasprintf_emulation (bufp, format, argptr);
        -: 1025:#endif /* ACE_HAS_VASPRINTF */
        -: 1026:}
        -: 1027:
        -: 1028:#if defined (ACE_HAS_WCHAR)
        -: 1029:ACE_INLINE int
        -: 1030:ACE_OS::vasprintf (wchar_t **bufp, const wchar_t* format, va_list argptr)
        -: 1031:{
        -: 1032:#if defined (ACE_HAS_VASWPRINTF)
        -: 1033:  return ::vaswprintf (bufp, format, argptr);
        -: 1034:#elif defined (ACE_LACKS_VA_COPY)
        -: 1035:  ACE_UNUSED_ARG (bufp);
        -: 1036:  ACE_UNUSED_ARG (format);
        -: 1037:  ACE_UNUSED_ARG (argptr);
        -: 1038:  ACE_NOTSUP_RETURN (-1);
        -: 1039:#else
        -: 1040:  return ACE_OS::vaswprintf_emulation (bufp, format, argptr);
        -: 1041:#endif /* ACE_HAS_VASWPRINTF */
        -: 1042:}
        -: 1043:#endif /* ACE_HAS_WCHAR */
        -: 1044:
        -: 1045:ACE_INLINE int
        -: 1046:ACE_OS::vprintf (const char *format, va_list argptr)
        -: 1047:{
        -: 1048:#if defined (ACE_LACKS_VPRINTF)
        -: 1049:  ACE_UNUSED_ARG (format);
        -: 1050:  ACE_UNUSED_ARG (argptr);
        -: 1051:  ACE_NOTSUP_RETURN (-1);
        -: 1052:#else
        -: 1053:  return ::vprintf (format, argptr);
        -: 1054:#endif /* ACE_LACKS_VPRINTF */
        -: 1055:}
        -: 1056:
        -: 1057:#if defined (ACE_HAS_WCHAR)
        -: 1058:ACE_INLINE int
        -: 1059:ACE_OS::vprintf (const wchar_t *format, va_list argptr)
        -: 1060:{
        -: 1061:#if defined (ACE_HAS_VWPRINTF)
        -: 1062:  return ::vwprintf (format, argptr);
        -: 1063:#else
        -: 1064:  ACE_UNUSED_ARG (format);
        -: 1065:  ACE_UNUSED_ARG (argptr);
        -: 1066:  ACE_NOTSUP_RETURN (-1);
        -: 1067:#endif /* ACE_HAS_VWPRINTF */
        -: 1068:}
        -: 1069:#endif /* ACE_HAS_WCHAR */
        -: 1070:
        -: 1071:ACE_INLINE int
        -: 1072:ACE_OS::vfprintf (FILE *fp, const char *format, va_list argptr)
        -: 1073:{
        -: 1074:#ifdef ACE_LACKS_VFPRINTF
        -: 1075:  ACE_UNUSED_ARG (fp);
        -: 1076:  ACE_UNUSED_ARG (format);
        -: 1077:  ACE_UNUSED_ARG (argptr);
        -: 1078:  ACE_NOTSUP_RETURN (-1);
        -: 1079:#else
        -: 1080:  return ACE_STD_NAMESPACE::vfprintf (fp, format, argptr);
        -: 1081:#endif
        -: 1082:}
        -: 1083:
        -: 1084:#if defined (ACE_HAS_WCHAR)
        -: 1085:ACE_INLINE int
        -: 1086:ACE_OS::vfprintf (FILE *fp, const wchar_t *format, va_list argptr)
        -: 1087:{
        -: 1088:#if defined (ACE_HAS_VFWPRINTF)
        -: 1089:  return ::vfwprintf (fp, format, argptr);
        -: 1090:#else
        -: 1091:  ACE_UNUSED_ARG (fp);
        -: 1092:  ACE_UNUSED_ARG (format);
        -: 1093:  ACE_UNUSED_ARG (argptr);
        -: 1094:  ACE_NOTSUP_RETURN (-1);
        -: 1095:#endif /* ACE_HAS_VFWPRINTF */
        -: 1096:}
        -: 1097:#endif /* ACE_HAS_WCHAR */
        -: 1098:
        -: 1099:ACE_INLINE int
        -: 1100:ACE_OS::vsprintf (char *buffer, const char *format, va_list argptr)
        -: 1101:{
        -: 1102:#ifdef ACE_LACKS_VSPRINTF
        -: 1103:  ACE_UNUSED_ARG (buffer);
        -: 1104:  ACE_UNUSED_ARG (format);
        -: 1105:  ACE_UNUSED_ARG (argptr);
        -: 1106:  ACE_NOTSUP_RETURN (-1);
        -: 1107:#else
        -: 1108:  return ::vsprintf (buffer, format, argptr);
        -: 1109:#endif /* ACE_LACKS_VSPRINTF */
        -: 1110:}
        -: 1111:
        -: 1112:#if defined (ACE_HAS_WCHAR)
        -: 1113:ACE_INLINE int
        -: 1114:ACE_OS::vsprintf (wchar_t *buffer, const wchar_t *format, va_list argptr)
        -: 1115:{
        -: 1116:# if (defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) >= 500) || \
        -: 1117:     (defined (sun) && !(defined(_XOPEN_SOURCE) && (_XOPEN_VERSION-0==4))) || \
        -: 1118:      defined (ACE_HAS_DINKUM_STL) || defined (__DMC__) || \
        -: 1119:      defined (ACE_HAS_VSWPRINTF) || \
        -: 1120:      (defined (ACE_WIN32_VC10) && !defined (ACE_HAS_WINCE)) || \
        -: 1121:      (defined (ACE_WIN32_VC9) && !defined (ACE_HAS_WINCE)) || \
        -: 1122:      (defined (ACE_WIN32_VC8) && !defined (ACE_HAS_WINCE) && \
        -: 1123:      _MSC_FULL_VER > 140050000)
        -: 1124:
        -: 1125:  // The XPG4/UNIX98/C99 signature of the wide-char sprintf has a
        -: 1126:  // maxlen argument. Since this method doesn't supply one, pass in
        -: 1127:  // a length that works (ULONG_MAX doesn't on all platform since some check
        -: 1128:  // to see if the operation will remain in bounds). If this isn't ok, use
        -: 1129:  // ACE_OS::snprintf().
        -: 1130:  return vswprintf (buffer, 4096, format, argptr);
        -: 1131:
        -: 1132:# elif defined (__MINGW64_VERSION_MAJOR) && !defined (WIN64)
        -: 1133:  // the MingW64 32bit version causes link errors when using the
        -: 1134:  // 'standard' vswprint(). Luckily they have a mingw special.
        -: 1135:
        -: 1136:  return __mingw_vswprintf (buffer, format, argptr);
        -: 1137:
        -: 1138:# elif defined (ACE_WIN32)
        -: 1139:  // Windows has vswprintf, but the pre-VC8 signature is from the older
        -: 1140:  // ISO C standard. Also see ACE_OS::snprintf() for more info on this.
        -: 1141:
        -: 1142:  return vswprintf (buffer, format, argptr);
        -: 1143:
        -: 1144:# else
        -: 1145:  ACE_UNUSED_ARG (buffer);
        -: 1146:  ACE_UNUSED_ARG (format);
        -: 1147:  ACE_UNUSED_ARG (argptr);
        -: 1148:  ACE_NOTSUP_RETURN (-1);
        -: 1149:
        -: 1150:# endif /* XPG5 || ACE_HAS_DINKUM_STL */
        -: 1151:}
        -: 1152:#endif /* ACE_HAS_WCHAR */
        -: 1153:
        -: 1154:ACE_INLINE int
        -: 1155:ACE_OS::vsnprintf (char *buffer, size_t maxlen, const char *format, va_list ap)
        -: 1156:{
        -: 1157:#if !defined (ACE_LACKS_VSNPRINTF)
        -: 1158:  int result;
        -: 1159:# if defined (ACE_WIN32) && !defined (ACE_HAS_C99_VSNPRINTF)
        -: 1160:  result = ::_vsnprintf (buffer, maxlen, format, ap);
        -: 1161:
        -: 1162:  // Win32 doesn't regard a full buffer with no 0-terminate as an overrun.
        -: 1163:  if (result == static_cast<int> (maxlen) && maxlen > 0)
        -: 1164:    buffer[maxlen-1] = '\0';
        -: 1165:
        -: 1166:  // Win32 doesn't 0-terminate the string if it overruns maxlen.
        -: 1167:  if (result == -1 && maxlen > 0)
        -: 1168:    buffer[maxlen-1] = '\0';
        -: 1169:# else
        -: 1170:  result = ::vsnprintf (buffer, maxlen, format, ap);
        -: 1171:# endif
        -: 1172:  // In out-of-range conditions, C99 defines vsnprintf() to return the number
        -: 1173:  // of characters that would have been written if enough space was available.
        -: 1174:  // Earlier variants of the vsnprintf() (e.g. UNIX98) defined it to return
        -: 1175:  // -1. This method follows the C99 standard, but needs to guess at the
        -: 1176:  // value; uses maxlen + 1.
        -: 1177:  if (result == -1)
        -: 1178:    {
        -: 1179:      result = static_cast <int> (maxlen + 1);
        -: 1180:    }
        -: 1181:
        -: 1182:  return result;
        -: 1183:#elif defined (ACE_HAS_TRIO)
        -: 1184:  return trio_vsnprintf (buffer, maxlen, format, ap);
        -: 1185:#elif !defined ACE_LACKS_VA_FUNCTIONS
        -: 1186:  return vsnprintf_emulation (buffer, maxlen, format, ap);
        -: 1187:#else
        -: 1188:  ACE_UNUSED_ARG (buffer);
        -: 1189:  ACE_UNUSED_ARG (maxlen);
        -: 1190:  ACE_UNUSED_ARG (format);
        -: 1191:  ACE_UNUSED_ARG (ap);
        -: 1192:  ACE_NOTSUP_RETURN (-1);
        -: 1193:#endif /* ACE_LACKS_VSNPRINTF */
        -: 1194:}
        -: 1195:
        -: 1196:#if defined (ACE_HAS_WCHAR)
        -: 1197:ACE_INLINE int
        -: 1198:ACE_OS::vsnprintf (wchar_t *buffer, size_t maxlen, const wchar_t *format, va_list ap)
        -: 1199:{
        -: 1200:# if (defined _XOPEN_SOURCE && (_XOPEN_SOURCE - 0) >= 500) || \
        -: 1201:     (defined (sun) && !(defined(_XOPEN_SOURCE) && (_XOPEN_VERSION-0==4))) || \
        -: 1202:     (defined (ACE_HAS_DINKUM_STL) || defined (__DMC__)) || \
        -: 1203:      defined (ACE_HAS_VSWPRINTF) || \
        -: 1204:      defined (ACE_WIN32)
        -: 1205:
        -: 1206:  int result;
        -: 1207:
        -: 1208:# if defined (ACE_WIN32) && !defined (ACE_HAS_C99_VSNWPRINTF)
        -: 1209:  // Microsoft's vswprintf() doesn't have the maxlen argument that
        -: 1210:  // XPG4/UNIX98 define. They do, however, recommend use of _vsnwprintf()
        -: 1211:  // as a substitute, which does have the same signature as the UNIX98 one.
        -: 1212:  result = ::_vsnwprintf (buffer, maxlen, format, ap);
        -: 1213:
        -: 1214:  // Win32 doesn't regard a full buffer with no 0-terminate as an overrun.
        -: 1215:  if (result == static_cast<int> (maxlen) && maxlen > 0)
        -: 1216:    buffer[maxlen-1] = '\0';
        -: 1217:
        -: 1218:  // Win32 doesn't 0-terminate the string if it overruns maxlen.
        -: 1219:  if (result == -1 && maxlen > 0)
        -: 1220:    buffer[maxlen-1] = '\0';
        -: 1221:# else
        -: 1222:  result = vswprintf (buffer, maxlen, format, ap);
        -: 1223:#endif
        -: 1224:
        -: 1225:  // In out-of-range conditions, C99 defines vsnprintf() to return the
        -: 1226:  // number of characters that would have been written if enough space
        -: 1227:  // was available.  Earlier variants of the vsnprintf() (e.g. UNIX98)
        -: 1228:  // defined it to return -1. This method follows the C99 standard,
        -: 1229:  // but needs to guess at the value; uses maxlen + 1.
        -: 1230:  if (result == -1)
        -: 1231:    result = static_cast <int> (maxlen + 1);
        -: 1232:
        -: 1233:  return result;
        -: 1234:# else
        -: 1235:  ACE_UNUSED_ARG (buffer);
        -: 1236:  ACE_UNUSED_ARG (maxlen);
        -: 1237:  ACE_UNUSED_ARG (format);
        -: 1238:  ACE_UNUSED_ARG (ap);
        -: 1239:  ACE_NOTSUP_RETURN (-1);
        -: 1240:# endif /* platforms with a variant of vswprintf */
        -: 1241:}
        -: 1242:#endif /* ACE_HAS_WCHAR */
        -: 1243:
        -: 1244:#if defined (ACE_MT_SAFE) && (ACE_MT_SAFE != 0)
        -: 1245:#if defined (ACE_WIN32)
        -: 1246:ACE_INLINE const ACE_TEXT_OSVERSIONINFO &
        -: 1247:ACE_OS::get_win32_versioninfo ()
        -: 1248:{
        -: 1249:  return ACE_OS::win32_versioninfo_;
        -: 1250:}
        -: 1251:
        -: 1252:ACE_INLINE HINSTANCE
        -: 1253:ACE_OS::get_win32_resource_module ()
        -: 1254:{
        -: 1255:  return ACE_OS::win32_resource_module_;
        -: 1256:}
        -: 1257:
        -: 1258:ACE_INLINE void
        -: 1259:ACE_OS::set_win32_resource_module (HINSTANCE instance)
        -: 1260:{
        -: 1261:  ACE_OS::win32_resource_module_ = instance;
        -: 1262:}
        -: 1263:
        -: 1264:ACE_INLINE LPSECURITY_ATTRIBUTES
        -: 1265:ACE_OS::default_win32_security_attributes (LPSECURITY_ATTRIBUTES sa)
        -: 1266:{
        -: 1267:#if defined (ACE_DEFINES_DEFAULT_WIN32_SECURITY_ATTRIBUTES)
        -: 1268:  if (sa == 0)
        -: 1269:    {
        -: 1270:      // @@ This is a good place to use pthread_once.
        -: 1271:      static SECURITY_ATTRIBUTES default_sa;
        -: 1272:      static SECURITY_DESCRIPTOR sd;
        -: 1273:      InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
        -: 1274:      SetSecurityDescriptorDacl(&sd, TRUE, 0, FALSE);
        -: 1275:      default_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        -: 1276:      default_sa.lpSecurityDescriptor = &sd;
        -: 1277:      default_sa.bInheritHandle       = TRUE;
        -: 1278:      sa = &default_sa;
        -: 1279:    }
        -: 1280:  return sa;
        -: 1281:#else /* !ACE_DEFINES_DEFAULT_WIN32_SECURITY_ATTRIBUTES */
        -: 1282:  return sa;
        -: 1283:#endif /* ACE_DEFINES_DEFAULT_WIN32_SECURITY_ATTRIBUTES */
        -: 1284:}
        -: 1285:
        -: 1286:ACE_INLINE LPSECURITY_ATTRIBUTES
        -: 1287:ACE_OS::default_win32_security_attributes_r (LPSECURITY_ATTRIBUTES sa,
        -: 1288:                                             LPSECURITY_ATTRIBUTES sa_buffer,
        -: 1289:                                             SECURITY_DESCRIPTOR* sd_buffer)
        -: 1290:{
        -: 1291:#if defined (ACE_DEFINES_DEFAULT_WIN32_SECURITY_ATTRIBUTES)
        -: 1292:  if (sa == 0)
        -: 1293:    {
        -: 1294:      if (sa_buffer != 0 && sd_buffer != 0)
        -: 1295:        {
        -: 1296:          InitializeSecurityDescriptor
        -: 1297:            (sd_buffer, SECURITY_DESCRIPTOR_REVISION);
        -: 1298:          SetSecurityDescriptorDacl (sd_buffer, TRUE, 0, FALSE);
        -: 1299:          sa_buffer->nLength = sizeof(SECURITY_ATTRIBUTES);
        -: 1300:          sa_buffer->lpSecurityDescriptor = sd_buffer;
        -: 1301:          sa_buffer->bInheritHandle       = TRUE;
        -: 1302:          sa = sa_buffer;
        -: 1303:        }
        -: 1304:    }
        -: 1305:  return sa;
        -: 1306:#else /* !ACE_DEFINES_DEFAULT_WIN32_SECURITY_ATTRIBUTES */
        -: 1307:  ACE_UNUSED_ARG(sa_buffer);
        -: 1308:  ACE_UNUSED_ARG(sd_buffer);
        -: 1309:  return sa;
        -: 1310:#endif /* ACE_DEFINES_DEFAULT_WIN32_SECURITY_ATTRIBUTES */
        -: 1311:}
        -: 1312:
        -: 1313:#endif /* ACE_WIN32 */
        -: 1314:#endif
        -: 1315:
        -: 1316:ACE_END_VERSIONED_NAMESPACE_DECL
