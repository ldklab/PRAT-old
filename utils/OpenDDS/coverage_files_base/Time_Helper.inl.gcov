        -:    0:Source:../dds/DCPS/Time_Helper.inl
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#include "ace/OS_NS_string.h"
        -:    9:#include "ace/Truncate.h"
        -:   10:
        -:   11:#include <cstring>
        -:   12:
        -:   13:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   14:
        -:   15:namespace OpenDDS {
        -:   16:namespace DCPS {
        -:   17:
        -:   18:// These operators are used in some inline functions below.  Some
        -:   19:// compilers require the inline definition to appear before its use.
        -:   20:#ifndef OPENDDS_SAFETY_PROFILE
        -:   21:ACE_INLINE
      261:   22:bool operator==(const DDS::Duration_t& t1, const DDS::Duration_t& t2)
        -:   23:{
      261:   24:  return t1.sec == t2.sec && t1.nanosec == t2.nanosec;
        -:   25:}
        -:   26:
        -:   27:ACE_INLINE
      108:   28:bool operator!=(const DDS::Duration_t& t1, const DDS::Duration_t& t2)
        -:   29:{
      108:   30:  return !(t1 == t2);
        -:   31:}
        -:   32:#endif
        -:   33:
        -:   34:ACE_INLINE
        -:   35:bool operator<(const DDS::Duration_t& t1, const DDS::Duration_t& t2)
        -:   36:{
        -:   37:  // @note We wouldn't have to handle the case for INFINITY explicitly
        -:   38:  //       if both the Duration_t sec and nanosec fields were the
        -:   39:  //       maximum values for their corresponding types.
        -:   40:  //       Unfortunately, the OMG DDS specification defines the
        -:   41:  //       infinite nanosec value to be somewhere in the middle.
        -:   42:  DDS::Duration_t const DDS_DURATION_INFINITY = {
        -:   43:    DDS::DURATION_INFINITE_SEC,
        -:   44:    DDS::DURATION_INFINITE_NSEC
        -:   45:  };
        -:   46:
        -:   47:  // We assume that either both the DDS::Duration_t::sec and
        -:   48:  // DDS::Duration_t::nanosec fields are INFINITY or neither of them
        -:   49:  // are.  It doesn't make sense for only one of the fields to be
        -:   50:  // INFINITY.
        -:   51:  return
        -:   52:    t1 != DDS_DURATION_INFINITY
        -:   53:    && (t2 == DDS_DURATION_INFINITY
        -:   54:        || t1.sec < t2.sec
        -:   55:        || (t1.sec == t2.sec && t1.nanosec < t2.nanosec));
        -:   56:}
        -:   57:
        -:   58:ACE_INLINE
        -:   59:bool operator<=(const DDS::Duration_t& t1, const DDS::Duration_t& t2)
        -:   60:{
        -:   61:  // If t2 is *not* less than t1, t1 must be less than
        -:   62:  // or equal to t2.
        -:   63:  // This is more concise than:
        -:   64:  //   t1 < t2 || t1 == t2
        -:   65:  return !(t2 < t1);
        -:   66:}
        -:   67:
        -:   68:ACE_INLINE
        -:   69:bool operator>(const DDS::Duration_t& t1, const DDS::Duration_t& t2)
        -:   70:{
        -:   71:  return t2 < t1;
        -:   72:}
        -:   73:
        -:   74:ACE_INLINE
        -:   75:bool operator>=(const DDS::Duration_t& t1, const DDS::Duration_t& t2)
        -:   76:{
        -:   77:  return t2 <= t1;
        -:   78:}
        -:   79:
        -:   80:ACE_INLINE
    #####:   81:bool operator!(const DDS::Time_t& t)
        -:   82:{
    #####:   83:  return t.sec == DDS::TIME_INVALID_SEC
    #####:   84:         || t.nanosec == DDS::TIME_INVALID_NSEC;
        -:   85:}
        -:   86:
        -:   87:#ifndef OPENDDS_SAFETY_PROFILE
        -:   88:ACE_INLINE bool
        -:   89:operator==(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:   90:{
        -:   91:  return !(t1 < t2) && !(t2 < t1);
        -:   92:}
        -:   93:
        -:   94:ACE_INLINE bool
        -:   95:operator!=(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:   96:{
        -:   97:  return !(t1 == t2);
        -:   98:}
        -:   99:#endif
        -:  100:
        -:  101:ACE_INLINE bool
    #####:  102:operator<(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:  103:{
    #####:  104:  if (!t1 || !t2) return false;
        -:  105:
    #####:  106:  return t1.sec < t2.sec
    #####:  107:         || (t1.sec == t2.sec && t1.nanosec < t2.nanosec);
        -:  108:}
        -:  109:
        -:  110:ACE_INLINE bool
        -:  111:operator<=(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:  112:{
        -:  113:  return !(t2 < t1);
        -:  114:}
        -:  115:
        -:  116:ACE_INLINE bool
        -:  117:operator>(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:  118:{
        -:  119:  return t2 < t1;
        -:  120:}
        -:  121:
        -:  122:ACE_INLINE bool
        -:  123:operator>=(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:  124:{
        -:  125:  return t2 <= t1;
        -:  126:}
        -:  127:
        -:  128:ACE_INLINE DDS::Time_t
        -:  129:operator-(const DDS::Time_t& t1, const DDS::Time_t& t2)
        -:  130:{
        -:  131:  DDS::Time_t t = { t1.sec - t2.sec, t1.nanosec - t2.nanosec };
        -:  132:
        -:  133:  if (t2.nanosec > t1.nanosec)
        -:  134:    {
        -:  135:      t.nanosec = (t1.nanosec + ACE_ONE_SECOND_IN_NSECS) - t2.nanosec;
        -:  136:      t.sec = (t1.sec - 1) - t2.sec;
        -:  137:    }
        -:  138:
        -:  139:  return t;
        -:  140:}
        -:  141:
        -:  142:ACE_INLINE
        -:  143:ACE_Time_Value time_to_time_value(const DDS::Time_t& t)
        -:  144:{
        -:  145:  ACE_Time_Value tv(t.sec, t.nanosec / 1000);
        -:  146:  return tv;
        -:  147:}
        -:  148:
        -:  149:ACE_INLINE
       60:  150:DDS::Time_t time_value_to_time(const ACE_Time_Value& tv)
        -:  151:{
        -:  152:  DDS::Time_t t;
       60:  153:  t.sec = ACE_Utils::truncate_cast<CORBA::Long>(tv.sec());
       60:  154:  t.nanosec = tv.usec() * 1000;
       60:  155:  return t;
        -:  156:}
        -:  157:
        -:  158:
        -:  159:ACE_INLINE
    #####:  160:ACE_Time_Value duration_to_time_value(const DDS::Duration_t& t)
        -:  161:{
    #####:  162:  CORBA::LongLong sec = t.sec + t.nanosec/1000/ACE_ONE_SECOND_IN_USECS;
    #####:  163:  CORBA::ULong usec = t.nanosec/1000 % ACE_ONE_SECOND_IN_USECS;
        -:  164:
    #####:  165:  if (sec > ACE_Time_Value::max_time.sec()) {
    #####:  166:    return ACE_Time_Value::max_time;
        -:  167:  }
        -:  168:  else {
    #####:  169:    return ACE_Time_Value(ACE_Utils::truncate_cast<time_t>(sec), usec);
        -:  170:  }
        -:  171:}
        -:  172:
        -:  173:
        -:  174:ACE_INLINE
        -:  175:ACE_Time_Value duration_to_absolute_time_value(const DDS::Duration_t& t,
        -:  176:                                               const ACE_Time_Value& now)
        -:  177:{
        -:  178:  CORBA::LongLong sec
        -:  179:    = t.sec + now.sec() + (t.nanosec/1000 + now.usec())/ACE_ONE_SECOND_IN_USECS;
        -:  180:  CORBA::ULong usec = (t.nanosec/1000 + now.usec()) % ACE_ONE_SECOND_IN_USECS;
        -:  181:
        -:  182:  if (sec > ACE_Time_Value::max_time.sec()) {
        -:  183:    return ACE_Time_Value::max_time;
        -:  184:  }
        -:  185:  else {
        -:  186:    return ACE_Time_Value(ACE_Utils::truncate_cast<time_t>(sec), usec);
        -:  187:  }
        -:  188:}
        -:  189:
        -:  190:
        -:  191:ACE_INLINE
        -:  192:DDS::Duration_t time_value_to_duration(const ACE_Time_Value& tv)
        -:  193:{
        -:  194:  DDS::Duration_t t;
        -:  195:  t.sec = ACE_Utils::truncate_cast<CORBA::Long>(tv.sec());
        -:  196:  t.nanosec = tv.usec() * 1000;
        -:  197:  return t;
        -:  198:}
        -:  199:
        -:  200:ACE_INLINE
        -:  201:DDS::Duration_t time_to_duration(const DDS::Time_t& t)
        -:  202:{
        -:  203:  DDS::Duration_t d = { t.sec, t.nanosec };
        -:  204:  return d;
        -:  205:}
        -:  206:
        -:  207:ACE_INLINE
        -:  208:bool valid_duration(const DDS::Duration_t& t)
        -:  209:{
        -:  210:  DDS::Duration_t const DDS_DURATION_INFINITY = {
        -:  211:    DDS::DURATION_INFINITE_SEC,
        -:  212:    DDS::DURATION_INFINITE_NSEC
        -:  213:  };
        -:  214:
        -:  215:  // Only accept infinite or positive finite durations.  (Zero
        -:  216:  // excluded).
        -:  217:  //
        -:  218:  // Note that it doesn't make much sense for users to set
        -:  219:  // durations less than 10 milliseconds since the underlying
        -:  220:  // timer resolution is generally no better than that.
        -:  221:  return
        -:  222:    t == DDS_DURATION_INFINITY
        -:  223:    || t.sec > 0
        -:  224:    || (t.sec >= 0 && t.nanosec > 0);
        -:  225:}
        -:  226:
        -:  227:ACE_INLINE
        -:  228:bool non_negative_duration(const DDS::Duration_t& t)
        -:  229:{
        -:  230:  return
        -:  231:    (t.sec == DDS::DURATION_ZERO_SEC  // Allow zero duration.
        -:  232:     && t.nanosec == DDS::DURATION_ZERO_NSEC)
        -:  233:    || valid_duration(t);
        -:  234:}
        -:  235:
        -:  236:} // namespace DCPS
        -:  237:} // namespace OpenDDS
        -:  238:
        -:  239:OPENDDS_END_VERSIONED_NAMESPACE_DECL
