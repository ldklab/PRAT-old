        -:    0:Source:../dds/DCPS/DataReaderImpl_T.h
        -:    0:Programs:72
        -:    1:#ifndef dds_DCPS_DataReaderImpl_T_h
        -:    2:#define dds_DCPS_DataReaderImpl_T_h
        -:    3:#include "dds/DCPS/MultiTopicImpl.h"
        -:    4:#include "dds/DCPS/RakeResults_T.h"
        -:    5:#include "dds/DCPS/SubscriberImpl.h"
        -:    6:#include "dds/DCPS/BuiltInTopicUtils.h"
        -:    7:#include "dds/DCPS/Util.h"
        -:    8:#include "dds/DCPS/TypeSupportImpl.h"
        -:    9:#include "dds/DCPS/Watchdog.h"
        -:   10:#include "dcps_export.h"
        -:   11:#include "dds/DCPS/GuidConverter.h"
        -:   12:
        -:   13:#include "ace/Bound_Ptr.h"
        -:   14:#include "ace/Time_Value.h"
        -:   15:
        -:   16:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   17:
        -:   18:namespace OpenDDS {
        -:   19:  namespace DCPS {
        -:   20:
        -:   21:  /** Servant for DataReader interface of Traits::MessageType data type.
        -:   22:   *
        -:   23:   * See the DDS specification, OMG formal/04-12-02, for a description of
        -:   24:   * this interface.
        -:   25:   *
        -:   26:   */
        -:   27:  template <typename MessageType>
        -:   28:    class
        -:   29:#if ( __GNUC__ == 4 && __GNUC_MINOR__ == 1)
        -:   30:    OpenDDS_Dcps_Export
        -:   31:#endif
        -:   32:    DataReaderImpl_T
        -:   33:    : public virtual OpenDDS::DCPS::LocalObject<typename DDSTraits<MessageType>::DataReaderType>,
        -:   34:      public virtual OpenDDS::DCPS::DataReaderImpl
        -:   35:  {
        -:   36:  public:
        -:   37:    typedef DDSTraits<MessageType> TraitsType;
        -:   38:    typedef typename TraitsType::MessageSequenceType MessageSequenceType;
        -:   39:
        -:   40:    typedef OPENDDS_MAP_CMP_T(MessageType, DDS::InstanceHandle_t,
        -:   41:                              typename TraitsType::LessThanType) InstanceMap;
        -:   42:
    #####:   43:    class SharedInstanceMap
        -:   44:      : public RcObject
        -:   45:      , public InstanceMap
        -:   46:    {
        -:   47:    };
        -:   48:
        -:   49:    typedef RcHandle<SharedInstanceMap> SharedInstanceMap_rch;
        -:   50:
    #####:   51:    class MessageTypeWithAllocator
        -:   52:      : public MessageType
        -:   53:      , public EnableContainerSupportedUniquePtr<MessageTypeWithAllocator>
        -:   54:    {
        -:   55:    public:
        -:   56:      void* operator new(size_t size, ACE_New_Allocator& pool);
        -:   57:      void operator delete(void* memory, ACE_New_Allocator& pool);
        -:   58:      void operator delete(void* memory);
        -:   59:
    #####:   60:      MessageTypeWithAllocator(){}
    #####:   61:      MessageTypeWithAllocator(const MessageType& other)
    #####:   62:        : MessageType(other)
        -:   63:      {
    #####:   64:      }
        -:   65:    };
        -:   66:
        -:   67:    struct MessageTypeMemoryBlock {
        -:   68:      MessageTypeWithAllocator element_;
        -:   69:      ACE_New_Allocator* allocator_;
        -:   70:    };
        -:   71:
        -:   72:    typedef OpenDDS::DCPS::Cached_Allocator_With_Overflow<MessageTypeMemoryBlock, ACE_Null_Mutex>  DataAllocator;
        -:   73:
        -:   74:    typedef typename TraitsType::DataReaderType Interface;
        -:   75:
    #####:   76:    DataReaderImpl_T (void)
    #####:   77:    : filter_delayed_handler_(make_rch<FilterDelayedHandler>(ref(*this)))
        -:   78:    {
    #####:   79:    }
        -:   80:
    #####:   81:    virtual ~DataReaderImpl_T (void)
        -:   82:    {
    #####:   83:      for (typename InstanceMap::iterator it = instance_map_.begin();
    #####:   84:           it != instance_map_.end(); ++it)
        -:   85:        {
    #####:   86:          OpenDDS::DCPS::SubscriptionInstance_rch ptr = get_handle_instance(it->second);
    #####:   87:          this->purge_data(ptr);
        -:   88:        }
        -:   89:      //X SHH release the data samples in the instance_map_.
    #####:   90:    }
        -:   91:
        -:   92:    /**
        -:   93:     * Do parts of enable specific to the datatype.
        -:   94:     * Called by DataReaderImpl::enable().
        -:   95:     */
    #####:   96:    virtual DDS::ReturnCode_t enable_specific ()
        -:   97:    {
    #####:   98:      data_allocator().reset(new DataAllocator(get_n_chunks ()));
    #####:   99:      if (OpenDDS::DCPS::DCPS_debug_level >= 2)
    #####:  100:        ACE_DEBUG((LM_DEBUG,
        -:  101:                   ACE_TEXT("(%P|%t) %CDataReaderImpl::")
        -:  102:                   ACE_TEXT("enable_specific-data")
        -:  103:                   ACE_TEXT(" Cached_Allocator_With_Overflow ")
        -:  104:                   ACE_TEXT("%x with %d chunks\n"),
        -:  105:                   TraitsType::type_name(),
        -:  106:                   data_allocator().get(),
        -:  107:                   this->get_n_chunks ()));
        -:  108:
    #####:  109:      return DDS::RETCODE_OK;
        -:  110:    }
        -:  111:
    #####:  112:    virtual DDS::ReturnCode_t read (
        -:  113:                                    MessageSequenceType & received_data,
        -:  114:                                    DDS::SampleInfoSeq & info_seq,
        -:  115:                                    ::CORBA::Long max_samples,
        -:  116:                                    DDS::SampleStateMask sample_states,
        -:  117:                                    DDS::ViewStateMask view_states,
        -:  118:                                    DDS::InstanceStateMask instance_states)
        -:  119:    {
    #####:  120:      DDS::ReturnCode_t const precond =
        -:  121:        check_inputs("read", received_data, info_seq, max_samples);
    #####:  122:      if (DDS::RETCODE_OK != precond)
        -:  123:        {
    #####:  124:          return precond;
        -:  125:        }
        -:  126:
    #####:  127:      ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  128:                        guard,
        -:  129:                        this->sample_lock_,
        -:  130:                        DDS::RETCODE_ERROR);
        -:  131:
        -:  132:      return read_i(received_data, info_seq, max_samples, sample_states,
    #####:  133:                    view_states, instance_states, 0);
        -:  134:    }
        -:  135:
    #####:  136:    virtual DDS::ReturnCode_t take (
        -:  137:                                      MessageSequenceType & received_data,
        -:  138:                                      DDS::SampleInfoSeq & info_seq,
        -:  139:                                      ::CORBA::Long max_samples,
        -:  140:                                      DDS::SampleStateMask sample_states,
        -:  141:                                      DDS::ViewStateMask view_states,
        -:  142:                                      DDS::InstanceStateMask instance_states)
        -:  143:    {
    #####:  144:      DDS::ReturnCode_t const precond =
        -:  145:        check_inputs("take", received_data, info_seq, max_samples);
    #####:  146:      if (DDS::RETCODE_OK != precond)
        -:  147:        {
    #####:  148:          return precond;
        -:  149:        }
        -:  150:
    #####:  151:      ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  152:                        guard,
        -:  153:                        this->sample_lock_,
        -:  154:                        DDS::RETCODE_ERROR);
        -:  155:
        -:  156:      return take_i(received_data, info_seq, max_samples, sample_states,
    #####:  157:                    view_states, instance_states, 0);
        -:  158:    }
        -:  159:
    #####:  160:    virtual DDS::ReturnCode_t read_w_condition (
        -:  161:                                                  MessageSequenceType & received_data,
        -:  162:                                                  DDS::SampleInfoSeq & sample_info,
        -:  163:                                                  ::CORBA::Long max_samples,
        -:  164:                                                  DDS::ReadCondition_ptr a_condition)
        -:  165:    {
    #####:  166:      DDS::ReturnCode_t const precond =
        -:  167:        check_inputs("read_w_condition", received_data, sample_info, max_samples);
    #####:  168:      if (DDS::RETCODE_OK != precond)
        -:  169:        {
    #####:  170:          return precond;
        -:  171:        }
        -:  172:
    #####:  173:      ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
        -:  174:                        DDS::RETCODE_ERROR);
        -:  175:
    #####:  176:      if (!has_readcondition(a_condition))
        -:  177:        {
    #####:  178:          return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  179:        }
        -:  180:
    #####:  181:      return read_i(received_data, sample_info, max_samples,
    #####:  182:                    a_condition->get_sample_state_mask(),
    #####:  183:                    a_condition->get_view_state_mask(),
    #####:  184:                    a_condition->get_instance_state_mask(),
        -:  185:#ifndef OPENDDS_NO_QUERY_CONDITION
    #####:  186:                    dynamic_cast< DDS::QueryCondition_ptr >(a_condition));
        -:  187:#else
        -:  188:      0);
        -:  189:#endif
        -:  190:  }
        -:  191:
    #####:  192:    virtual DDS::ReturnCode_t take_w_condition (
        -:  193:                                                  MessageSequenceType & received_data,
        -:  194:                                                  DDS::SampleInfoSeq & sample_info,
        -:  195:                                                  ::CORBA::Long max_samples,
        -:  196:                                                  DDS::ReadCondition_ptr a_condition)
        -:  197:    {
    #####:  198:      DDS::ReturnCode_t const precond =
        -:  199:        check_inputs("take_w_condition", received_data, sample_info, max_samples);
    #####:  200:      if (DDS::RETCODE_OK != precond)
        -:  201:        {
    #####:  202:          return precond;
        -:  203:        }
        -:  204:
    #####:  205:      ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
        -:  206:                        DDS::RETCODE_ERROR);
        -:  207:
    #####:  208:      if (!has_readcondition(a_condition))
        -:  209:        {
    #####:  210:          return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  211:        }
        -:  212:
    #####:  213:      return take_i(received_data, sample_info, max_samples,
    #####:  214:                    a_condition->get_sample_state_mask(),
    #####:  215:                    a_condition->get_view_state_mask(),
    #####:  216:                    a_condition->get_instance_state_mask(),
        -:  217:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:  218:                    dynamic_cast< DDS::QueryCondition_ptr >(a_condition)
        -:  219:#else
        -:  220:                    0
        -:  221:#endif
    #####:  222:                    );
        -:  223:    }
        -:  224:
    #####:  225:  virtual DDS::ReturnCode_t read_next_sample (
        -:  226:                                                MessageType & received_data,
        -:  227:                                                DDS::SampleInfo & sample_info)
        -:  228:  {
        -:  229:
    #####:  230:    bool found_data = false;
        -:  231:
    #####:  232:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  233:                      guard,
        -:  234:                      this->sample_lock_,
        -:  235:                      DDS::RETCODE_ERROR);
        -:  236:
    #####:  237:    typename InstanceMap::iterator const the_end = instance_map_.end ();
    #####:  238:    for (typename InstanceMap::iterator it = instance_map_.begin ();
    #####:  239:         it != the_end;
        -:  240:         ++it)
        -:  241:      {
    #####:  242:        DDS::InstanceHandle_t handle = it->second;
    #####:  243:        OpenDDS::DCPS::SubscriptionInstance_rch ptr = get_handle_instance(handle);
        -:  244:
    #####:  245:        bool mrg = false; //most_recent_generation
        -:  246:
    #####:  247:        if ((ptr->instance_state_.view_state() & DDS::ANY_VIEW_STATE) &&
    #####:  248:            (ptr->instance_state_.instance_state() & DDS::ANY_INSTANCE_STATE))
        -:  249:          {
    #####:  250:            for (OpenDDS::DCPS::ReceivedDataElement* item = ptr->rcvd_samples_.head_;
    #####:  251:                 item != 0;
        -:  252:                 item = item->next_data_sample_)
        -:  253:              {
        -:  254:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####:  255:                if (item->coherent_change_) continue;
        -:  256:#endif
        -:  257:
    #####:  258:                if (item->sample_state_ & DDS::NOT_READ_SAMPLE_STATE)
        -:  259:                  {
    #####:  260:                    if (item->registered_data_ != 0)
        -:  261:                      {
    #####:  262:                        received_data =
    #####:  263:                          *static_cast< MessageType *> (item->registered_data_);
        -:  264:                      }
    #####:  265:                    ptr->instance_state_.sample_info(sample_info, item);
        -:  266:
    #####:  267:                    item->sample_state_ = DDS::READ_SAMPLE_STATE;
        -:  268:
        -:  269:
    #####:  270:                    if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);
        -:  271:
    #####:  272:                    found_data = true;
        -:  273:                  }
    #####:  274:                if (found_data)
        -:  275:                  {
    #####:  276:                    break;
        -:  277:                  }
        -:  278:              }
        -:  279:          }
        -:  280:
    #####:  281:        if (found_data)
        -:  282:          {
    #####:  283:            if (mrg) ptr->instance_state_.accessed();
        -:  284:
        -:  285:            // Get the sample_ranks, generation_ranks, and
        -:  286:            // absolute_generation_ranks for this info_seq
    #####:  287:            this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
        -:  288:
    #####:  289:            break;
        -:  290:          }
        -:  291:      }
    #####:  292:    post_read_or_take();
    #####:  293:    return found_data ? DDS::RETCODE_OK : DDS::RETCODE_NO_DATA;
        -:  294:  }
        -:  295:
    #####:  296:  virtual DDS::ReturnCode_t take_next_sample (
        -:  297:                                                MessageType & received_data,
        -:  298:                                                DDS::SampleInfo & sample_info)
        -:  299:  {
    #####:  300:    bool found_data = false;
        -:  301:
        -:  302:
    #####:  303:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  304:                      guard,
        -:  305:                      this->sample_lock_,
        -:  306:                      DDS::RETCODE_ERROR);
        -:  307:
    #####:  308:    typename InstanceMap::iterator const the_end = instance_map_.end ();
    #####:  309:    for (typename InstanceMap::iterator it = instance_map_.begin ();
    #####:  310:         it != the_end;
        -:  311:         ++it)
        -:  312:      {
    #####:  313:        DDS::InstanceHandle_t handle = it->second;
    #####:  314:        OpenDDS::DCPS::SubscriptionInstance_rch ptr = get_handle_instance(handle);
        -:  315:
    #####:  316:        bool mrg = false; //most_recent_generation
        -:  317:
    #####:  318:        OpenDDS::DCPS::ReceivedDataElement *tail = 0;
    #####:  319:        if ((ptr->instance_state_.view_state() & DDS::ANY_VIEW_STATE) &&
    #####:  320:            (ptr->instance_state_.instance_state() & DDS::ANY_INSTANCE_STATE))
        -:  321:          {
        -:  322:
        -:  323:            OpenDDS::DCPS::ReceivedDataElement *next;
    #####:  324:            tail = 0;
    #####:  325:            OpenDDS::DCPS::ReceivedDataElement *item = ptr->rcvd_samples_.head_;
    #####:  326:            while (item)
        -:  327:              {
        -:  328:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####:  329:                if (item->coherent_change_)
        -:  330:                  {
    #####:  331:                    item = item->next_data_sample_;
    #####:  332:                    continue;
        -:  333:                  }
        -:  334:#endif
    #####:  335:                if (item->sample_state_ & DDS::NOT_READ_SAMPLE_STATE)
        -:  336:                  {
    #####:  337:                    if (item->registered_data_ != 0)
        -:  338:                      {
    #####:  339:                        received_data =
    #####:  340:                          *static_cast< MessageType *> (item->registered_data_);
        -:  341:                      }
    #####:  342:                    ptr->instance_state_.sample_info(sample_info, item);
        -:  343:
    #####:  344:                    item->sample_state_ = DDS::READ_SAMPLE_STATE;
        -:  345:
    #####:  346:                    if (!mrg) mrg = ptr->instance_state_.most_recent_generation(item);
        -:  347:
    #####:  348:                    if (item == ptr->rcvd_samples_.tail_)
        -:  349:                      {
    #####:  350:                        tail = ptr->rcvd_samples_.tail_;
    #####:  351:                        item = item->next_data_sample_;
        -:  352:                      }
        -:  353:                    else
        -:  354:                      {
    #####:  355:                        next = item->next_data_sample_;
        -:  356:
    #####:  357:                        ptr->rcvd_samples_.remove(item);
    #####:  358:                        item->dec_ref();
        -:  359:
    #####:  360:                        item = next;
        -:  361:                      }
        -:  362:
    #####:  363:                    found_data = true;
        -:  364:                  }
    #####:  365:                if (found_data)
        -:  366:                  {
    #####:  367:                    break;
        -:  368:                  }
        -:  369:              }
        -:  370:          }
        -:  371:
    #####:  372:        if (found_data)
        -:  373:          {
    #####:  374:            if (mrg) ptr->instance_state_.accessed();
        -:  375:
        -:  376:            //
        -:  377:            // Get the sample_ranks, generation_ranks, and
        -:  378:            // absolute_generation_ranks for this info_seq
        -:  379:            //
    #####:  380:            if (tail)
        -:  381:              {
    #####:  382:                this->sample_info(sample_info, tail);
        -:  383:
    #####:  384:                ptr->rcvd_samples_.remove(tail);
    #####:  385:                tail->dec_ref();
        -:  386:              }
        -:  387:            else
        -:  388:              {
    #####:  389:                this->sample_info(sample_info, ptr->rcvd_samples_.tail_);
        -:  390:              }
        -:  391:
    #####:  392:            break;
        -:  393:          }
        -:  394:      }
    #####:  395:    post_read_or_take();
    #####:  396:    return found_data ? DDS::RETCODE_OK : DDS::RETCODE_NO_DATA;
        -:  397:  }
        -:  398:
    #####:  399:  virtual DDS::ReturnCode_t read_instance (
        -:  400:                                             MessageSequenceType & received_data,
        -:  401:                                             DDS::SampleInfoSeq & info_seq,
        -:  402:                                             ::CORBA::Long max_samples,
        -:  403:                                             DDS::InstanceHandle_t a_handle,
        -:  404:                                             DDS::SampleStateMask sample_states,
        -:  405:                                             DDS::ViewStateMask view_states,
        -:  406:                                             DDS::InstanceStateMask instance_states)
        -:  407:  {
    #####:  408:    DDS::ReturnCode_t const precond =
        -:  409:      check_inputs("read_instance", received_data, info_seq, max_samples);
    #####:  410:    if (DDS::RETCODE_OK != precond)
        -:  411:      {
    #####:  412:        return precond;
        -:  413:      }
        -:  414:
    #####:  415:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  416:                      guard,
        -:  417:                      this->sample_lock_,
        -:  418:                      DDS::RETCODE_ERROR);
        -:  419:    return read_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  420:                           sample_states, view_states, instance_states, 0);
        -:  421:  }
        -:  422:
    #####:  423:  virtual DDS::ReturnCode_t take_instance (
        -:  424:                                             MessageSequenceType & received_data,
        -:  425:                                             DDS::SampleInfoSeq & info_seq,
        -:  426:                                             ::CORBA::Long max_samples,
        -:  427:                                             DDS::InstanceHandle_t a_handle,
        -:  428:                                             DDS::SampleStateMask sample_states,
        -:  429:                                             DDS::ViewStateMask view_states,
        -:  430:                                             DDS::InstanceStateMask instance_states)
        -:  431:  {
    #####:  432:    DDS::ReturnCode_t const precond =
        -:  433:      check_inputs("take_instance", received_data, info_seq, max_samples);
    #####:  434:    if (DDS::RETCODE_OK != precond)
        -:  435:      {
    #####:  436:        return precond;
        -:  437:      }
        -:  438:
    #####:  439:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  440:                      guard,
        -:  441:                      this->sample_lock_,
        -:  442:                      DDS::RETCODE_ERROR);
        -:  443:    return take_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  444:                           sample_states, view_states, instance_states, 0);
        -:  445:  }
        -:  446:
    #####:  447:  virtual DDS::ReturnCode_t read_instance_w_condition (
        -:  448:                                                       MessageSequenceType & received_data,
        -:  449:                                                       DDS::SampleInfoSeq & info_seq,
        -:  450:                                                       ::CORBA::Long max_samples,
        -:  451:                                                       DDS::InstanceHandle_t a_handle,
        -:  452:                                                       DDS::ReadCondition_ptr a_condition)
        -:  453:  {
    #####:  454:    DDS::ReturnCode_t const precond =
        -:  455:      check_inputs("read_instance_w_condition", received_data, info_seq,
        -:  456:                   max_samples);
    #####:  457:    if (DDS::RETCODE_OK != precond)
        -:  458:      {
    #####:  459:        return precond;
        -:  460:      }
        -:  461:
    #####:  462:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
        -:  463:                      DDS::RETCODE_ERROR);
        -:  464:
    #####:  465:    if (!has_readcondition(a_condition))
        -:  466:      {
    #####:  467:        return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  468:      }
        -:  469:
        -:  470:#ifndef OPENDDS_NO_QUERY_CONDITION
    #####:  471:    DDS::QueryCondition_ptr query_condition =
        -:  472:        dynamic_cast< DDS::QueryCondition_ptr >(a_condition);
        -:  473:#endif
        -:  474:
    #####:  475:    return read_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  476:                           a_condition->get_sample_state_mask(),
    #####:  477:                           a_condition->get_view_state_mask(),
    #####:  478:                           a_condition->get_instance_state_mask(),
        -:  479:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:  480:                           query_condition
        -:  481:#else
        -:  482:                           0
        -:  483:#endif
    #####:  484:                           );
        -:  485:  }
        -:  486:
    #####:  487:  virtual DDS::ReturnCode_t take_instance_w_condition (
        -:  488:                                                       MessageSequenceType & received_data,
        -:  489:                                                       DDS::SampleInfoSeq & info_seq,
        -:  490:                                                       ::CORBA::Long max_samples,
        -:  491:                                                       DDS::InstanceHandle_t a_handle,
        -:  492:                                                       DDS::ReadCondition_ptr a_condition)
        -:  493:  {
    #####:  494:    DDS::ReturnCode_t const precond =
        -:  495:      check_inputs("take_instance_w_condition", received_data, info_seq,
        -:  496:                   max_samples);
    #####:  497:    if (DDS::RETCODE_OK != precond)
        -:  498:      {
    #####:  499:        return precond;
        -:  500:      }
        -:  501:
    #####:  502:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
        -:  503:                      DDS::RETCODE_ERROR);
        -:  504:
    #####:  505:    if (!has_readcondition(a_condition))
        -:  506:      {
    #####:  507:        return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  508:      }
        -:  509:
        -:  510:#ifndef OPENDDS_NO_QUERY_CONDITION
    #####:  511:    DDS::QueryCondition_ptr query_condition =
        -:  512:        dynamic_cast< DDS::QueryCondition_ptr >(a_condition);
        -:  513:#endif
        -:  514:
    #####:  515:    return take_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  516:                           a_condition->get_sample_state_mask(),
    #####:  517:                           a_condition->get_view_state_mask(),
    #####:  518:                           a_condition->get_instance_state_mask(),
        -:  519:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:  520:                           query_condition
        -:  521:#else
        -:  522:                           0
        -:  523:#endif
    #####:  524:                           );
        -:  525:  }
        -:  526:
    #####:  527:  virtual DDS::ReturnCode_t read_next_instance (
        -:  528:                                                  MessageSequenceType & received_data,
        -:  529:                                                  DDS::SampleInfoSeq & info_seq,
        -:  530:                                                  ::CORBA::Long max_samples,
        -:  531:                                                  DDS::InstanceHandle_t a_handle,
        -:  532:                                                  DDS::SampleStateMask sample_states,
        -:  533:                                                  DDS::ViewStateMask view_states,
        -:  534:                                                  DDS::InstanceStateMask instance_states)
        -:  535:  {
    #####:  536:    DDS::ReturnCode_t const precond =
        -:  537:      check_inputs("read_next_instance", received_data, info_seq, max_samples);
    #####:  538:    if (DDS::RETCODE_OK != precond)
        -:  539:      {
    #####:  540:        return precond;
        -:  541:      }
        -:  542:
        -:  543:    return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  544:                                sample_states, view_states, instance_states, 0);
        -:  545:  }
        -:  546:
    #####:  547:  virtual DDS::ReturnCode_t take_next_instance (
        -:  548:                                                  MessageSequenceType & received_data,
        -:  549:                                                  DDS::SampleInfoSeq & info_seq,
        -:  550:                                                  ::CORBA::Long max_samples,
        -:  551:                                                  DDS::InstanceHandle_t a_handle,
        -:  552:                                                  DDS::SampleStateMask sample_states,
        -:  553:                                                  DDS::ViewStateMask view_states,
        -:  554:                                                  DDS::InstanceStateMask instance_states)
        -:  555:  {
    #####:  556:    DDS::ReturnCode_t const precond =
        -:  557:      check_inputs("take_next_instance", received_data, info_seq, max_samples);
    #####:  558:    if (DDS::RETCODE_OK != precond)
        -:  559:      {
    #####:  560:        return precond;
        -:  561:      }
        -:  562:
        -:  563:    return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  564:                                sample_states, view_states, instance_states, 0);
        -:  565:  }
        -:  566:
    #####:  567:  virtual DDS::ReturnCode_t read_next_instance_w_condition (
        -:  568:                                                              MessageSequenceType & received_data,
        -:  569:                                                              DDS::SampleInfoSeq & info_seq,
        -:  570:                                                              ::CORBA::Long max_samples,
        -:  571:                                                              DDS::InstanceHandle_t a_handle,
        -:  572:                                                              DDS::ReadCondition_ptr a_condition)
        -:  573:  {
    #####:  574:    DDS::ReturnCode_t const precond =
        -:  575:      check_inputs("read_next_instance_w_condition", received_data, info_seq,
        -:  576:                   max_samples);
    #####:  577:    if (DDS::RETCODE_OK != precond)
        -:  578:      {
    #####:  579:        return precond;
        -:  580:      }
        -:  581:
    #####:  582:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
        -:  583:                      DDS::RETCODE_ERROR);
        -:  584:
    #####:  585:    if (!has_readcondition(a_condition))
        -:  586:      {
    #####:  587:        return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  588:      }
        -:  589:
        -:  590:#ifndef OPENDDS_NO_QUERY_CONDITION
    #####:  591:    DDS::QueryCondition_ptr query_condition =
        -:  592:        dynamic_cast< DDS::QueryCondition_ptr >(a_condition);
        -:  593:#endif
        -:  594:
    #####:  595:    return read_next_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  596:                                a_condition->get_sample_state_mask(),
    #####:  597:                                a_condition->get_view_state_mask(),
    #####:  598:                                a_condition->get_instance_state_mask(),
        -:  599:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:  600:                                query_condition
        -:  601:#else
        -:  602:                                0
        -:  603:#endif
    #####:  604:                                );
        -:  605:  }
        -:  606:
    #####:  607:  virtual DDS::ReturnCode_t take_next_instance_w_condition (
        -:  608:                                                              MessageSequenceType & received_data,
        -:  609:                                                              DDS::SampleInfoSeq & info_seq,
        -:  610:                                                              ::CORBA::Long max_samples,
        -:  611:                                                              DDS::InstanceHandle_t a_handle,
        -:  612:                                                              DDS::ReadCondition_ptr a_condition)
        -:  613:  {
    #####:  614:    DDS::ReturnCode_t const precond =
        -:  615:      check_inputs("take_next_instance_w_condition", received_data, info_seq,
        -:  616:                   max_samples);
    #####:  617:    if (DDS::RETCODE_OK != precond)
        -:  618:      {
    #####:  619:        return precond;
        -:  620:      }
        -:  621:
    #####:  622:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex, guard, this->sample_lock_,
        -:  623:                      DDS::RETCODE_ERROR);
        -:  624:
    #####:  625:    if (!has_readcondition(a_condition))
        -:  626:      {
    #####:  627:        return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  628:      }
        -:  629:
        -:  630:#ifndef OPENDDS_NO_QUERY_CONDITION
    #####:  631:    DDS::QueryCondition_ptr query_condition =
        -:  632:        dynamic_cast< DDS::QueryCondition_ptr >(a_condition);
        -:  633:#endif
        -:  634:
    #####:  635:    return take_next_instance_i(received_data, info_seq, max_samples, a_handle,
    #####:  636:                                a_condition->get_sample_state_mask(),
    #####:  637:                                a_condition->get_view_state_mask(),
    #####:  638:                                a_condition->get_instance_state_mask(),
        -:  639:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:  640:                                query_condition
        -:  641:#else
        -:  642:                                0
        -:  643:#endif
    #####:  644:                                );
        -:  645:  }
        -:  646:
    #####:  647:  virtual DDS::ReturnCode_t return_loan (
        -:  648:                                           MessageSequenceType & received_data,
        -:  649:                                           DDS::SampleInfoSeq & info_seq)
        -:  650:  {
        -:  651:    // Some incomplete tests to see that the data and info are from the
        -:  652:    // same read.
    #####:  653:    if (received_data.length() != info_seq.length())
        -:  654:      {
    #####:  655:        return DDS::RETCODE_PRECONDITION_NOT_MET;
        -:  656:      }
        -:  657:
    #####:  658:    if (received_data.release())
        -:  659:      {
        -:  660:        // nothing to do because this is not zero-copy data
    #####:  661:        return DDS::RETCODE_OK;
        -:  662:      }
        -:  663:    else
        -:  664:      {
    #####:  665:        info_seq.length(0);
    #####:  666:        received_data.length(0);
        -:  667:      }
    #####:  668:    return DDS::RETCODE_OK;
        -:  669:  }
        -:  670:
    #####:  671:  virtual DDS::ReturnCode_t get_key_value (
        -:  672:                                             MessageType & key_holder,
        -:  673:                                             DDS::InstanceHandle_t handle)
        -:  674:  {
    #####:  675:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  676:                      guard,
        -:  677:                      this->sample_lock_,
        -:  678:                      DDS::RETCODE_ERROR);
        -:  679:
    #####:  680:    typename InstanceMap::iterator const the_end = instance_map_.end ();
    #####:  681:    for (typename InstanceMap::iterator it = instance_map_.begin ();
    #####:  682:         it != the_end;
        -:  683:         ++it)
        -:  684:      {
    #####:  685:        if (it->second == handle)
        -:  686:          {
    #####:  687:            key_holder = it->first;
    #####:  688:            return DDS::RETCODE_OK;
        -:  689:          }
        -:  690:      }
        -:  691:
    #####:  692:    return DDS::RETCODE_BAD_PARAMETER;
        -:  693:  }
        -:  694:
    #####:  695:  virtual DDS::InstanceHandle_t lookup_instance (const MessageType & instance_data)
        -:  696:  {
    #####:  697:    typename InstanceMap::const_iterator const it = instance_map_.find(instance_data);
        -:  698:
    #####:  699:    if (it == instance_map_.end())
        -:  700:      {
    #####:  701:        return DDS::HANDLE_NIL;
        -:  702:      }
        -:  703:    else
        -:  704:      {
    #####:  705:        return it->second;
        -:  706:      }
        -:  707:  }
        -:  708:
    #####:  709:  virtual DDS::ReturnCode_t auto_return_loan(void* seq)
        -:  710:  {
    #####:  711:    MessageSequenceType& received_data =
        -:  712:      *static_cast< MessageSequenceType*> (seq);
        -:  713:
    #####:  714:    if (!received_data.release())
        -:  715:      {
        -:  716:        // this->release_loan(received_data);
    #####:  717:        received_data.length(0);
        -:  718:      }
    #####:  719:    return DDS::RETCODE_OK;
        -:  720:  }
        -:  721:
        -:  722:  void release_loan (MessageSequenceType & received_data)
        -:  723:  {
        -:  724:    received_data.length(0);
        -:  725:  }
        -:  726:
        -:  727:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
    #####:  728:  bool contains_sample_filtered(DDS::SampleStateMask sample_states,
        -:  729:                                DDS::ViewStateMask view_states,
        -:  730:                                DDS::InstanceStateMask instance_states,
        -:  731:                                const OpenDDS::DCPS::FilterEvaluator& evaluator,
        -:  732:                                const DDS::StringSeq& params)
        -:  733:  {
        -:  734:    using namespace OpenDDS::DCPS;
    #####:  735:    ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_, false);
    #####:  736:    ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_, false);
        -:  737:
    #####:  738:    const bool filter_has_non_key_fields =
        -:  739:      evaluator.has_non_key_fields(getMetaStruct<MessageType>());
        -:  740:
    #####:  741:    for (SubscriptionInstanceMapType::iterator iter = instances_.begin(),
    #####:  742:           end = instances_.end(); iter != end; ++iter) {
    #####:  743:      SubscriptionInstance& inst = *iter->second;
        -:  744:
    #####:  745:      if ((inst.instance_state_.view_state() & view_states) &&
    #####:  746:          (inst.instance_state_.instance_state() & instance_states)) {
    #####:  747:        for (ReceivedDataElement* item = inst.rcvd_samples_.head_; item != 0;
        -:  748:             item = item->next_data_sample_) {
    #####:  749:          if (item->sample_state_ & sample_states
        -:  750:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####:  751:              && !item->coherent_change_
        -:  752:#endif
    #####:  753:              && item->registered_data_) {
    #####:  754:            if (!item->valid_data_ && filter_has_non_key_fields) {
    #####:  755:              continue;
        -:  756:            }
    #####:  757:            if (evaluator.eval(*static_cast< MessageType* >(item->registered_data_), params)) {
    #####:  758:              return true;
        -:  759:            }
        -:  760:          }
        -:  761:        }
        -:  762:      }
        -:  763:    }
        -:  764:
    #####:  765:    return false;
        -:  766:  }
        -:  767:
    #####:  768:  DDS::ReturnCode_t read_generic(
        -:  769:                                   OpenDDS::DCPS::DataReaderImpl::GenericBundle& gen,
        -:  770:                                   DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  771:                                   DDS::InstanceStateMask instance_states,
        -:  772:                                   bool adjust_ref_count=false)
        -:  773:  {
        -:  774:
    #####:  775:    MessageSequenceType data;
        -:  776:    DDS::ReturnCode_t rc;
    #####:  777:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  778:                      guard,
        -:  779:                      this->sample_lock_,
        -:  780:                      DDS::RETCODE_ERROR);
        -:  781:    {
    #####:  782:      rc = read_i(data, gen.info_,
        -:  783:                  DDS::LENGTH_UNLIMITED,
        -:  784:                  sample_states, view_states, instance_states, 0);
    #####:  785:      if (true == adjust_ref_count ) {
    #####:  786:        data.increment_references();
        -:  787:      }
        -:  788:    }
    #####:  789:    gen.samples_.reserve(data.length());
    #####:  790:    for (CORBA::ULong i = 0; i < data.length(); ++i) {
    #####:  791:      gen.samples_.push_back(&data[i]);
        -:  792:    }
    #####:  793:    return rc;
        -:  794:
        -:  795:  }
        -:  796:
    #####:  797:  DDS::InstanceHandle_t lookup_instance_generic(const void* data)
        -:  798:  {
    #####:  799:    return lookup_instance(*static_cast<const MessageType*>(data));
        -:  800:  }
        -:  801:
    #####:  802:  virtual DDS::ReturnCode_t take(
        -:  803:                                 OpenDDS::DCPS::AbstractSamples& samples,
        -:  804:                                 DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  805:                                 DDS::InstanceStateMask instance_states)
        -:  806:  {
        -:  807:
    #####:  808:    ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -:  809:                      guard,
        -:  810:                      this->sample_lock_,
        -:  811:                      DDS::RETCODE_ERROR);
        -:  812:
    #####:  813:    MessageSequenceType data;
    #####:  814:    DDS::SampleInfoSeq infos;
    #####:  815:    DDS::ReturnCode_t rc = take_i(data, infos, DDS::LENGTH_UNLIMITED,
        -:  816:                                  sample_states, view_states, instance_states, 0);
        -:  817:
    #####:  818:    samples.reserve(data.length());
        -:  819:
    #####:  820:    for (CORBA::ULong i = 0; i < data.length(); ++i) {
    #####:  821:      samples.push_back(infos[i], &data[i]);
        -:  822:    }
        -:  823:
    #####:  824:    return rc;
        -:  825:  }
        -:  826:
    #####:  827:  DDS::ReturnCode_t read_instance_generic(void*& data,
        -:  828:                                          DDS::SampleInfo& info, DDS::InstanceHandle_t instance,
        -:  829:                                          DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  830:                                          DDS::InstanceStateMask instance_states)
        -:  831:  {
    #####:  832:    MessageSequenceType dataseq;
    #####:  833:    DDS::SampleInfoSeq infoseq;
    #####:  834:    const DDS::ReturnCode_t rc = read_instance_i(dataseq, infoseq,
        -:  835:                                                 DDS::LENGTH_UNLIMITED, instance, sample_states, view_states,
        -:  836:                                                 instance_states, 0);
    #####:  837:    if (rc != DDS::RETCODE_NO_DATA)
        -:  838:      {
    #####:  839:        const CORBA::ULong last = dataseq.length() - 1;
    #####:  840:        data = new MessageType(dataseq[last]);
    #####:  841:        info = infoseq[last];
        -:  842:      }
    #####:  843:    return rc;
        -:  844:  }
        -:  845:
    #####:  846:  DDS::ReturnCode_t read_next_instance_generic(void*& data,
        -:  847:                                               DDS::SampleInfo& info, DDS::InstanceHandle_t previous_instance,
        -:  848:                                               DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  849:                                               DDS::InstanceStateMask instance_states)
        -:  850:  {
    #####:  851:    MessageSequenceType dataseq;
    #####:  852:    DDS::SampleInfoSeq infoseq;
    #####:  853:    const DDS::ReturnCode_t rc = read_next_instance_i(dataseq, infoseq,
        -:  854:                                                      DDS::LENGTH_UNLIMITED, previous_instance, sample_states, view_states,
        -:  855:                                                      instance_states, 0);
    #####:  856:    if (rc != DDS::RETCODE_NO_DATA)
        -:  857:      {
    #####:  858:        const CORBA::ULong last = dataseq.length() - 1;
    #####:  859:        data = new MessageType(dataseq[last]);
    #####:  860:        info = infoseq[last];
        -:  861:      }
    #####:  862:    return rc;
        -:  863:  }
        -:  864:
        -:  865:#endif
        -:  866:
    #####:  867:  DDS::InstanceHandle_t store_synthetic_data(const MessageType& sample,
        -:  868:                                             DDS::ViewStateKind view)
        -:  869:  {
        -:  870:    using namespace OpenDDS::DCPS;
    #####:  871:    ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, sample_lock_,
        -:  872:                     DDS::HANDLE_NIL);
        -:  873:
        -:  874:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  875:    DDS::TopicDescription_var descr = get_topicdescription();
    #####:  876:    if (MultiTopicImpl* mt = dynamic_cast<MultiTopicImpl*>(descr.in())) {
    #####:  877:      if (!mt->filter(sample)) {
    #####:  878:        return DDS::HANDLE_NIL;
        -:  879:      }
        -:  880:    }
        -:  881:#endif
        -:  882:
    #####:  883:    get_subscriber_servant()->data_received(this);
        -:  884:
    #####:  885:    DDS::InstanceHandle_t inst = lookup_instance(sample);
    #####:  886:    bool filtered = false;
    #####:  887:    SubscriptionInstance_rch instance;
        -:  888:
        -:  889:    // Call store_instance_data() once or twice, depending on if we need to
        -:  890:    // process the INSTANCE_REGISTRATION.  In either case, store_instance_data()
        -:  891:    // owns the memory for the sample and it must come from the correct allocator.
    #####:  892:    for (int i = 0; i < 2; ++i) {
    #####:  893:      if (i == 0 && inst != DDS::HANDLE_NIL) continue;
        -:  894:
    #####:  895:      DataSampleHeader header;
    #####:  896:      const int msg = i ? SAMPLE_DATA : INSTANCE_REGISTRATION;
    #####:  897:      header.message_id_ = static_cast<char>(msg);
        -:  898:      bool just_registered;
    #####:  899:      unique_ptr<MessageTypeWithAllocator> data(new (*data_allocator()) MessageTypeWithAllocator(sample));
    #####:  900:      store_instance_data(move(data), header, instance, just_registered, filtered);
    #####:  901:      if (instance) inst = instance->instance_handle_;
        -:  902:    }
        -:  903:
    #####:  904:    if (!filtered) {
    #####:  905:      if (view == DDS::NOT_NEW_VIEW_STATE) {
    #####:  906:        if (instance) instance->instance_state_.accessed();
        -:  907:      }
    #####:  908:      notify_read_conditions();
        -:  909:    }
    #####:  910:    return inst;
        -:  911:  }
        -:  912:
    #####:  913:  void set_instance_state(DDS::InstanceHandle_t instance,
        -:  914:                          DDS::InstanceStateKind state)
        -:  915:  {
        -:  916:    using namespace OpenDDS::DCPS;
    #####:  917:    ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, sample_lock_);
        -:  918:
    #####:  919:    SubscriptionInstance_rch si = get_handle_instance(instance);
    #####:  920:    if (si && state != DDS::ALIVE_INSTANCE_STATE) {
    #####:  921:      DataSampleHeader header;
    #####:  922:      const int msg = (state == DDS::NOT_ALIVE_DISPOSED_INSTANCE_STATE)
        -:  923:        ? DISPOSE_INSTANCE : UNREGISTER_INSTANCE;
    #####:  924:      header.message_id_ = static_cast<char>(msg);
        -:  925:      bool just_registered, filtered;
    #####:  926:      unique_ptr<MessageTypeWithAllocator> data(new (*data_allocator()) MessageTypeWithAllocator);
    #####:  927:      get_key_value(*data, instance);
    #####:  928:      store_instance_data(move(data), header, si, just_registered, filtered);
    #####:  929:      if (!filtered)
        -:  930:      {
    #####:  931:        notify_read_conditions();
        -:  932:      }
        -:  933:    }
        -:  934:  }
        -:  935:
    #####:  936:  virtual void lookup_instance(const OpenDDS::DCPS::ReceivedDataSample& sample,
        -:  937:                               OpenDDS::DCPS::SubscriptionInstance_rch& instance)
        -:  938:  {
        -:  939:    //!!! caller should already have the sample_lock_
        -:  940:
    #####:  941:    MessageType data;
        -:  942:
    #####:  943:    const bool cdr = sample.header_.cdr_encapsulation_;
        -:  944:
    #####:  945:    OpenDDS::DCPS::Serializer ser(
        -:  946:      sample.sample_.get(),
    #####:  947:      sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
        -:  948:      cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR
        -:  949:          : OpenDDS::DCPS::Serializer::ALIGN_NONE);
        -:  950:
    #####:  951:    if (cdr) {
        -:  952:      ACE_CDR::ULong header;
    #####:  953:      if (!(ser >> header)) {
    #####:  954:        ACE_ERROR((LM_ERROR, ACE_TEXT("(%P|%t) %CDataReaderImpl::lookup_instance ")
        -:  955:                  ACE_TEXT("deserialization header failed.\n"),
        -:  956:                  TraitsType::type_name()));
    #####:  957:        return;
        -:  958:      }
        -:  959:
    #####:  960:      if (Serializer::use_rti_serialization()) {
        -:  961:        // Start counting byte-offset AFTER header
    #####:  962:        ser.reset_alignment();
        -:  963:      }
        -:  964:    }
        -:  965:
    #####:  966:    if (sample.header_.key_fields_only_) {
    #####:  967:      ser >> OpenDDS::DCPS::KeyOnly< MessageType>(data);
        -:  968:    } else {
    #####:  969:      ser >> data;
        -:  970:    }
        -:  971:
    #####:  972:    if (!ser.good_bit()) {
    #####:  973:      ACE_ERROR((LM_ERROR, ACE_TEXT("(%P|%t) %CDataReaderImpl::lookup_instance ")
        -:  974:                 ACE_TEXT("deserialization failed.\n"),
        -:  975:                 TraitsType::type_name()));
    #####:  976:      return;
        -:  977:    }
        -:  978:
    #####:  979:    DDS::InstanceHandle_t handle(DDS::HANDLE_NIL);
    #####:  980:    typename InstanceMap::const_iterator const it = instance_map_.find(data);
    #####:  981:    if (it != instance_map_.end()) {
    #####:  982:      handle = it->second;
        -:  983:    }
        -:  984:
    #####:  985:    if (handle == DDS::HANDLE_NIL) {
    #####:  986:      instance.reset();
        -:  987:    } else {
    #####:  988:      instance = get_handle_instance(handle);
        -:  989:    }
        -:  990:  }
        -:  991:
    #####:  992:  virtual void qos_change(const DDS::DataReaderQos& qos)
        -:  993:  {
        -:  994:    // reliability is not changeable, just time_based_filter
    #####:  995:    if (qos.reliability.kind == DDS::RELIABLE_RELIABILITY_QOS) {
    #####:  996:      if (qos.time_based_filter.minimum_separation != qos_.time_based_filter.minimum_separation) {
    #####:  997:        const DDS::Duration_t zero = { DDS::DURATION_ZERO_SEC, DDS::DURATION_ZERO_NSEC };
    #####:  998:        if (qos_.time_based_filter.minimum_separation != zero) {
    #####:  999:          if (qos.time_based_filter.minimum_separation != zero) {
    #####: 1000:            const ACE_Time_Value new_interval = duration_to_time_value(qos.time_based_filter.minimum_separation);
    #####: 1001:            filter_delayed_handler_->reset_interval(new_interval);
        -: 1002:          } else {
    #####: 1003:            filter_delayed_handler_->cancel();
        -: 1004:          }
        -: 1005:        }
        -: 1006:        // else no existing timers to change/cancel
        -: 1007:      }
        -: 1008:      // else no qos change so nothing to change
        -: 1009:    }
        -: 1010:
    #####: 1011:    DataReaderImpl::qos_change(qos);
    #####: 1012:  }
        -: 1013:
        -: 1014:protected:
        -: 1015:
    #####: 1016:  virtual void dds_demarshal(const OpenDDS::DCPS::ReceivedDataSample& sample,
        -: 1017:                             OpenDDS::DCPS::SubscriptionInstance_rch& instance,
        -: 1018:                             bool& just_registered,
        -: 1019:                             bool& filtered,
        -: 1020:                             OpenDDS::DCPS::MarshalingType marshaling_type)
        -: 1021:  {
    #####: 1022:    unique_ptr<MessageTypeWithAllocator> data(new (*data_allocator()) MessageTypeWithAllocator);
    #####: 1023:    const bool cdr = sample.header_.cdr_encapsulation_;
        -: 1024:
    #####: 1025:    OpenDDS::DCPS::Serializer ser(
        -: 1026:                                  sample.sample_.get(),
    #####: 1027:                                  sample.header_.byte_order_ != ACE_CDR_BYTE_ORDER,
        -: 1028:                                  cdr ? OpenDDS::DCPS::Serializer::ALIGN_CDR : OpenDDS::DCPS::Serializer::ALIGN_NONE);
        -: 1029:
    #####: 1030:    if (cdr) {
        -: 1031:      ACE_CDR::ULong header;
    #####: 1032:      if (!(ser >> header)) {
    #####: 1033:        ACE_ERROR((LM_ERROR, ACE_TEXT("(%P|%t) %CDataReaderImpl::dds_demarshal ")
        -: 1034:                  ACE_TEXT("deserialization header failed, dropping sample.\n"),
        -: 1035:                  TraitsType::type_name()));
    #####: 1036:        return;
        -: 1037:      }
        -: 1038:
    #####: 1039:      if (Serializer::use_rti_serialization()) {
        -: 1040:        // Start counting byte-offset AFTER header
    #####: 1041:        ser.reset_alignment();
        -: 1042:      }
        -: 1043:    }
        -: 1044:
    #####: 1045:    if (marshaling_type == OpenDDS::DCPS::KEY_ONLY_MARSHALING) {
    #####: 1046:      ser >> OpenDDS::DCPS::KeyOnly< MessageType>(*data);
        -: 1047:    } else {
    #####: 1048:      ser >> *data;
        -: 1049:    }
        -: 1050:
    #####: 1051:    if (!ser.good_bit()) {
    #####: 1052:      ACE_ERROR((LM_ERROR, ACE_TEXT("(%P|%t) %CDataReaderImpl::dds_demarshal ")
        -: 1053:                 ACE_TEXT("deserialization failed, dropping sample.\n"),
        -: 1054:                 TraitsType::type_name()));
    #####: 1055:      return;
        -: 1056:    }
        -: 1057:
        -: 1058:#ifndef OPENDDS_NO_CONTENT_FILTERED_TOPIC
    #####: 1059:    if (!sample.header_.content_filter_) { // if this is true, the writer has already filtered
        -: 1060:      using OpenDDS::DCPS::ContentFilteredTopicImpl;
    #####: 1061:      if (content_filtered_topic_) {
    #####: 1062:        const bool sample_only_has_key_fields = !sample.header_.valid_data();
    #####: 1063:        const MessageType& type = static_cast<MessageType&>(*data);
    #####: 1064:        if (!content_filtered_topic_->filter(type, sample_only_has_key_fields)) {
    #####: 1065:          filtered = true;
    #####: 1066:          return;
        -: 1067:        }
        -: 1068:      }
        -: 1069:    }
        -: 1070:#endif
        -: 1071:
    #####: 1072:    store_instance_data(move(data), sample.header_, instance, just_registered, filtered);
        -: 1073:  }
        -: 1074:
    #####: 1075:  virtual void dispose_unregister(const OpenDDS::DCPS::ReceivedDataSample& sample,
        -: 1076:                                  OpenDDS::DCPS::SubscriptionInstance_rch& instance)
        -: 1077:  {
        -: 1078:    //!!! caller should already have the sample_lock_
        -: 1079:
        -: 1080:    // The data sample in this dispose message does not contain any valid data.
        -: 1081:    // What it needs here is the key value to identify the instance to dispose.
        -: 1082:    // The demarshal push this "sample" to received sample list so the user
        -: 1083:    // can be notified the dispose event.
    #####: 1084:    bool just_registered = false;
    #####: 1085:    bool filtered = false;
    #####: 1086:    OpenDDS::DCPS::MarshalingType marshaling = OpenDDS::DCPS::FULL_MARSHALING;
    #####: 1087:    if (sample.header_.key_fields_only_) {
    #####: 1088:      marshaling = OpenDDS::DCPS::KEY_ONLY_MARSHALING;
        -: 1089:    }
    #####: 1090:    this->dds_demarshal(sample, instance, just_registered, filtered, marshaling);
    #####: 1091:  }
        -: 1092:
    #####: 1093:  virtual void purge_data(OpenDDS::DCPS::SubscriptionInstance_rch instance)
        -: 1094:  {
    #####: 1095:    filter_delayed_handler_->drop_sample(instance->instance_handle_);
        -: 1096:
        -: 1097:
    #####: 1098:    instance->instance_state_.cancel_release();
        -: 1099:
    #####: 1100:    while (instance->rcvd_samples_.size_ > 0)
        -: 1101:      {
    #####: 1102:        OpenDDS::DCPS::ReceivedDataElement* head =
    #####: 1103:          instance->rcvd_samples_.remove_head();
    #####: 1104:        head->dec_ref();
        -: 1105:      }
    #####: 1106:  }
        -: 1107:
    #####: 1108:  virtual void release_instance_i (DDS::InstanceHandle_t handle)
        -: 1109:  {
    #####: 1110:    typename InstanceMap::iterator const the_end = instance_map_.end ();
    #####: 1111:    typename InstanceMap::iterator it = instance_map_.begin ();
    #####: 1112:    while (it != the_end)
        -: 1113:      {
    #####: 1114:        if (it->second == handle)
        -: 1115:          {
    #####: 1116:            typename InstanceMap::iterator curIt = it;
    #####: 1117:            ++ it;
    #####: 1118:            instance_map_.erase (curIt);
        -: 1119:          }
        -: 1120:        else
    #####: 1121:          ++ it;
        -: 1122:      }
    #####: 1123:  }
        -: 1124:
        -: 1125:private:
        -: 1126:
    #####: 1127:  DDS::ReturnCode_t read_i (
        -: 1128:                              MessageSequenceType & received_data,
        -: 1129:                              DDS::SampleInfoSeq & info_seq,
        -: 1130:                              ::CORBA::Long max_samples,
        -: 1131:                              DDS::SampleStateMask sample_states,
        -: 1132:                              DDS::ViewStateMask view_states,
        -: 1133:                              DDS::InstanceStateMask instance_states,
        -: 1134:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1135:                              DDS::QueryCondition_ptr a_condition)
        -: 1136:#else
        -: 1137:  int ignored)
        -: 1138:#endif
        -: 1139:{
        -: 1140:#ifdef OPENDDS_NO_QUERY_CONDITION
        -: 1141:  ACE_UNUSED_ARG(ignored);
        -: 1142:#endif
        -: 1143:
    #####: 1144:  typename MessageSequenceType::PrivateMemberAccess received_data_p(received_data);
        -: 1145:
        -: 1146:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1147:  if (this->subqos_.presentation.access_scope == DDS::GROUP_PRESENTATION_QOS
    #####: 1148:      && ! this->coherent_) {
    #####: 1149:    return DDS::RETCODE_PRECONDITION_NOT_MET;
        -: 1150:  }
        -: 1151:
    #####: 1152:  bool group_coherent_ordered
    #####: 1153:    = this->subqos_.presentation.access_scope == DDS::GROUP_PRESENTATION_QOS
    #####: 1154:    && this->subqos_.presentation.coherent_access
    #####: 1155:    && this->subqos_.presentation.ordered_access;
        -: 1156:
    #####: 1157:  if (group_coherent_ordered && this->coherent_) {
    #####: 1158:    max_samples = 1;
        -: 1159:  }
        -: 1160:#endif
        -: 1161:
        -: 1162:  OpenDDS::DCPS::RakeResults< MessageSequenceType >
    #####: 1163:    results(this, received_data, info_seq, max_samples,
        -: 1164:            this->subqos_.presentation,
        -: 1165:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1166:            a_condition,
        -: 1167:#endif
        -: 1168:            OpenDDS::DCPS::DDS_OPERATION_READ);
        -: 1169:
        -: 1170:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1171:  if (! group_coherent_ordered) {
        -: 1172:#endif
    #####: 1173:    for (typename InstanceMap::iterator it = instance_map_.begin(),
    #####: 1174:           the_end = instance_map_.end(); it != the_end; ++it)
        -: 1175:      {
    #####: 1176:        DDS::InstanceHandle_t handle = it->second;
        -: 1177:
    #####: 1178:        OpenDDS::DCPS::SubscriptionInstance_rch inst = get_handle_instance(handle);
        -: 1179:
    #####: 1180:        if ((inst->instance_state_.view_state() & view_states) &&
    #####: 1181:            (inst->instance_state_.instance_state() & instance_states))
        -: 1182:          {
    #####: 1183:            size_t i(0);
    #####: 1184:            for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
    #####: 1185:                 item != 0; item = item->next_data_sample_)
        -: 1186:              {
    #####: 1187:                if (item->sample_state_ & sample_states
        -: 1188:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1189:                    && !item->coherent_change_
        -: 1190:#endif
        -: 1191:                    )
        -: 1192:                  {
    #####: 1193:                    results.insert_sample(item, inst, ++i);
        -: 1194:                  }
        -: 1195:              }
        -: 1196:          }
        -: 1197:      }
        -: 1198:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        -: 1199:  }
        -: 1200:  else {
    #####: 1201:    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    #####: 1202:    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
        -: 1203:  }
        -: 1204:#endif
        -: 1205:
    #####: 1206:  results.copy_to_user();
        -: 1207:
    #####: 1208:  DDS::ReturnCode_t ret = DDS::RETCODE_NO_DATA;
    #####: 1209:  if (received_data.length())
        -: 1210:    {
    #####: 1211:      ret = DDS::RETCODE_OK;
    #####: 1212:      if (received_data.maximum() == 0) //using ZeroCopy
        -: 1213:        {
    #####: 1214:          received_data_p.set_loaner(this);
        -: 1215:        }
        -: 1216:    }
        -: 1217:
    #####: 1218:  post_read_or_take();
        -: 1219:
    #####: 1220:  return ret;
        -: 1221:}
        -: 1222:
    #####: 1223:DDS::ReturnCode_t take_i (
        -: 1224:                            MessageSequenceType & received_data,
        -: 1225:                            DDS::SampleInfoSeq & info_seq,
        -: 1226:                            ::CORBA::Long max_samples,
        -: 1227:                            DDS::SampleStateMask sample_states,
        -: 1228:                            DDS::ViewStateMask view_states,
        -: 1229:                            DDS::InstanceStateMask instance_states,
        -: 1230:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1231:                            DDS::QueryCondition_ptr a_condition)
        -: 1232:#else
        -: 1233:  int ignored)
        -: 1234:#endif
        -: 1235:{
        -: 1236:#ifdef OPENDDS_NO_QUERY_CONDITION
        -: 1237:  ACE_UNUSED_ARG(ignored);
        -: 1238:#endif
        -: 1239:
    #####: 1240:  typename MessageSequenceType::PrivateMemberAccess received_data_p(received_data);
        -: 1241:
        -: 1242:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1243:  if (this->subqos_.presentation.access_scope == DDS::GROUP_PRESENTATION_QOS
    #####: 1244:      && ! this->coherent_) {
    #####: 1245:    return DDS::RETCODE_PRECONDITION_NOT_MET;
        -: 1246:  }
        -: 1247:
    #####: 1248:  bool group_coherent_ordered
    #####: 1249:    = this->subqos_.presentation.access_scope == DDS::GROUP_PRESENTATION_QOS
    #####: 1250:    && this->subqos_.presentation.coherent_access
    #####: 1251:    && this->subqos_.presentation.ordered_access;
        -: 1252:
    #####: 1253:  if (group_coherent_ordered && this->coherent_) {
    #####: 1254:    max_samples = 1;
        -: 1255:  }
        -: 1256:#endif
        -: 1257:
        -: 1258:  OpenDDS::DCPS::RakeResults< MessageSequenceType >
    #####: 1259:    results(this, received_data, info_seq, max_samples,
        -: 1260:            this->subqos_.presentation,
        -: 1261:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1262:            a_condition,
        -: 1263:#endif
        -: 1264:            OpenDDS::DCPS::DDS_OPERATION_TAKE);
        -: 1265:
        -: 1266:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1267:  if (! group_coherent_ordered) {
        -: 1268:#endif
        -: 1269:
    #####: 1270:    for (typename InstanceMap::iterator it = instance_map_.begin(),
    #####: 1271:           the_end = instance_map_.end(); it != the_end; ++it)
        -: 1272:      {
    #####: 1273:        DDS::InstanceHandle_t handle = it->second;
        -: 1274:
    #####: 1275:        OpenDDS::DCPS::SubscriptionInstance_rch inst = get_handle_instance(handle);
        -: 1276:
    #####: 1277:        if ((inst->instance_state_.view_state() & view_states) &&
    #####: 1278:            (inst->instance_state_.instance_state() & instance_states))
        -: 1279:          {
    #####: 1280:            size_t i(0);
    #####: 1281:            for (OpenDDS::DCPS::ReceivedDataElement *item = inst->rcvd_samples_.head_;
    #####: 1282:                 item != 0; item = item->next_data_sample_)
        -: 1283:              {
    #####: 1284:                if (item->sample_state_ & sample_states
        -: 1285:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1286:                    && !item->coherent_change_
        -: 1287:#endif
        -: 1288:                    )
        -: 1289:                  {
    #####: 1290:                    results.insert_sample(item, inst, ++i);
        -: 1291:                  }
        -: 1292:              }
        -: 1293:          }
        -: 1294:      }
        -: 1295:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        -: 1296:  }
        -: 1297:  else {
    #####: 1298:    OpenDDS::DCPS::RakeData item = this->group_coherent_ordered_data_.get_data();
    #####: 1299:    results.insert_sample(item.rde_, item.si_, item.index_in_instance_);
        -: 1300:  }
        -: 1301:#endif
        -: 1302:
    #####: 1303:  results.copy_to_user();
        -: 1304:
    #####: 1305:  DDS::ReturnCode_t ret = DDS::RETCODE_NO_DATA;
    #####: 1306:  if (received_data.length())
        -: 1307:    {
    #####: 1308:      ret = DDS::RETCODE_OK;
    #####: 1309:      if (received_data.maximum() == 0) //using ZeroCopy
        -: 1310:        {
    #####: 1311:          received_data_p.set_loaner(this);
        -: 1312:        }
        -: 1313:    }
        -: 1314:
    #####: 1315:  post_read_or_take();
    #####: 1316:  return ret;
        -: 1317:}
        -: 1318:
    #####: 1319:DDS::ReturnCode_t read_instance_i (
        -: 1320:                                     MessageSequenceType & received_data,
        -: 1321:                                     DDS::SampleInfoSeq & info_seq,
        -: 1322:                                     ::CORBA::Long max_samples,
        -: 1323:                                     DDS::InstanceHandle_t a_handle,
        -: 1324:                                     DDS::SampleStateMask sample_states,
        -: 1325:                                     DDS::ViewStateMask view_states,
        -: 1326:                                     DDS::InstanceStateMask instance_states,
        -: 1327:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1328:                                     DDS::QueryCondition_ptr a_condition)
        -: 1329:#else
        -: 1330:int ignored)
        -: 1331:#endif
        -: 1332:{
        -: 1333:#ifdef OPENDDS_NO_QUERY_CONDITION
        -: 1334:  ACE_UNUSED_ARG(ignored);
        -: 1335:#endif
        -: 1336:
    #####: 1337:  typename MessageSequenceType::PrivateMemberAccess received_data_p(received_data);
        -: 1338:
        -: 1339:  OpenDDS::DCPS::RakeResults< MessageSequenceType >
    #####: 1340:    results(this, received_data, info_seq, max_samples,
        -: 1341:            this->subqos_.presentation,
        -: 1342:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1343:            a_condition,
        -: 1344:#endif
        -: 1345:            OpenDDS::DCPS::DDS_OPERATION_READ);
        -: 1346:
    #####: 1347:  OpenDDS::DCPS::SubscriptionInstance_rch inst = get_handle_instance(a_handle);
    #####: 1348:  if (!inst) return DDS::RETCODE_BAD_PARAMETER;
        -: 1349:
    #####: 1350:  InstanceState& state_obj = inst->instance_state_;
    #####: 1351:  bool valid_view_state = state_obj.view_state() & view_states;
    #####: 1352:  bool valid_instance_state = state_obj.instance_state() & instance_states;
    #####: 1353:  if (valid_view_state && valid_instance_state)
        -: 1354:    {
    #####: 1355:      size_t i(0);
    #####: 1356:      for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
        -: 1357:           item; item = item->next_data_sample_)
        -: 1358:        {
    #####: 1359:          if (item->sample_state_ & sample_states
        -: 1360:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1361:              && !item->coherent_change_
        -: 1362:#endif
        -: 1363:              )
        -: 1364:            {
    #####: 1365:              results.insert_sample(item, inst, ++i);
        -: 1366:            }
    #####: 1367:        }
        -: 1368:      }
        -: 1369:    else
        -: 1370:      {
    #####: 1371:        if (OpenDDS::DCPS::DCPS_debug_level >= 8) {
    #####: 1372:          OPENDDS_STRING msg;
    #####: 1373:          if (!valid_view_state) {
    #####: 1374:            msg += "view state is not valid";
    #####: 1375:            if (!valid_instance_state) {
    #####: 1376:              msg += " and ";
        -: 1377:            }
        -: 1378:          }
    #####: 1379:          if (!valid_instance_state) {
    #####: 1380:            msg = msg
        -: 1381:              + "instance state is "
        -: 1382:              + state_obj.instance_state_string()
        -: 1383:              + " while the validity mask is "
        -: 1384:              + InstanceState::instance_state_string(instance_states);
        -: 1385:          }
    #####: 1386:          GuidConverter conv(get_subscription_id());
    #####: 1387:          ACE_DEBUG((LM_DEBUG,
        -: 1388:            ACE_TEXT("(%P|%t) DataReaderImpl_T::read_instance_i: ")
        -: 1389:            ACE_TEXT("will return no data reading sub %C because:\n  %C\n"),
        -: 1390:            OPENDDS_STRING(conv).c_str(), msg.c_str()
        -: 1391:          ));
        -: 1392:        }
        -: 1393:      }
        -: 1394:
    #####: 1395:  results.copy_to_user();
        -: 1396:
    #####: 1397:  DDS::ReturnCode_t ret = DDS::RETCODE_NO_DATA;
    #####: 1398:  if (received_data.length())
        -: 1399:    {
    #####: 1400:      ret = DDS::RETCODE_OK;
    #####: 1401:      if (received_data.maximum() == 0) //using ZeroCopy
        -: 1402:        {
    #####: 1403:          received_data_p.set_loaner(this);
        -: 1404:        }
        -: 1405:    }
        -: 1406:
    #####: 1407:  post_read_or_take();
    #####: 1408:  return ret;
        -: 1409:}
        -: 1410:
    #####: 1411:DDS::ReturnCode_t take_instance_i (
        -: 1412:                                   MessageSequenceType & received_data,
        -: 1413:                                   DDS::SampleInfoSeq & info_seq,
        -: 1414:                                   ::CORBA::Long max_samples,
        -: 1415:                                   DDS::InstanceHandle_t a_handle,
        -: 1416:                                   DDS::SampleStateMask sample_states,
        -: 1417:                                   DDS::ViewStateMask view_states,
        -: 1418:                                   DDS::InstanceStateMask instance_states,
        -: 1419:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1420:                                   DDS::QueryCondition_ptr a_condition)
        -: 1421:#else
        -: 1422:                                   int ignored)
        -: 1423:#endif
        -: 1424:{
        -: 1425:#ifdef OPENDDS_NO_QUERY_CONDITION
        -: 1426:  ACE_UNUSED_ARG(ignored);
        -: 1427:#endif
        -: 1428:
    #####: 1429:  typename MessageSequenceType::PrivateMemberAccess received_data_p(received_data);
        -: 1430:
        -: 1431:  OpenDDS::DCPS::RakeResults< MessageSequenceType >
    #####: 1432:    results(this, received_data, info_seq, max_samples,
        -: 1433:            this->subqos_.presentation,
        -: 1434:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1435:            a_condition,
        -: 1436:#endif
        -: 1437:            OpenDDS::DCPS::DDS_OPERATION_TAKE);
        -: 1438:
    #####: 1439:  OpenDDS::DCPS::SubscriptionInstance_rch inst = get_handle_instance(a_handle);
    #####: 1440:  if (!inst) return DDS::RETCODE_BAD_PARAMETER;
        -: 1441:
    #####: 1442:  if ((inst->instance_state_.view_state() & view_states) &&
    #####: 1443:      (inst->instance_state_.instance_state() & instance_states))
        -: 1444:    {
    #####: 1445:      size_t i(0);
    #####: 1446:      for (OpenDDS::DCPS::ReceivedDataElement* item = inst->rcvd_samples_.head_;
        -: 1447:           item; item = item->next_data_sample_)
        -: 1448:        {
    #####: 1449:          if (item->sample_state_ & sample_states
        -: 1450:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1451:              && !item->coherent_change_
        -: 1452:#endif
        -: 1453:              )
        -: 1454:            {
    #####: 1455:              results.insert_sample(item, inst, ++i);
        -: 1456:            }
        -: 1457:        }
        -: 1458:    }
        -: 1459:
    #####: 1460:  results.copy_to_user();
        -: 1461:
    #####: 1462:  DDS::ReturnCode_t ret = DDS::RETCODE_NO_DATA;
    #####: 1463:  if (received_data.length())
        -: 1464:    {
    #####: 1465:      ret = DDS::RETCODE_OK;
    #####: 1466:      if (received_data.maximum() == 0) //using ZeroCopy
        -: 1467:        {
    #####: 1468:          received_data_p.set_loaner(this);
        -: 1469:        }
        -: 1470:    }
        -: 1471:
    #####: 1472:  post_read_or_take();
    #####: 1473:  return ret;
        -: 1474:}
        -: 1475:
    #####: 1476:DDS::ReturnCode_t read_next_instance_i (
        -: 1477:                                        MessageSequenceType & received_data,
        -: 1478:                                        DDS::SampleInfoSeq & info_seq,
        -: 1479:                                        ::CORBA::Long max_samples,
        -: 1480:                                        DDS::InstanceHandle_t a_handle,
        -: 1481:                                        DDS::SampleStateMask sample_states,
        -: 1482:                                        DDS::ViewStateMask view_states,
        -: 1483:                                        DDS::InstanceStateMask instance_states,
        -: 1484:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1485:                                        DDS::QueryCondition_ptr a_condition)
        -: 1486:#else
        -: 1487:                                        int ignored)
        -: 1488:#endif
        -: 1489:{
        -: 1490:#ifdef OPENDDS_NO_QUERY_CONDITION
        -: 1491:  ACE_UNUSED_ARG(ignored);
        -: 1492:#endif
        -: 1493:
    #####: 1494:  DDS::InstanceHandle_t handle(DDS::HANDLE_NIL);
        -: 1495:
    #####: 1496:  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -: 1497:                    guard,
        -: 1498:                    this->sample_lock_,
        -: 1499:                    DDS::RETCODE_ERROR);
        -: 1500:
    #####: 1501:  typename InstanceMap::iterator it;
    #####: 1502:  typename InstanceMap::iterator const the_end = instance_map_.end ();
        -: 1503:
    #####: 1504:  if (a_handle == DDS::HANDLE_NIL)
        -: 1505:    {
    #####: 1506:      it = instance_map_.begin ();
        -: 1507:    }
        -: 1508:  else
        -: 1509:    {
    #####: 1510:      for (it = instance_map_.begin ();
    #####: 1511:           it != the_end;
        -: 1512:           ++it)
        -: 1513:        {
    #####: 1514:          if (a_handle == it->second)
        -: 1515:            {
    #####: 1516:              ++it;
    #####: 1517:              break;
        -: 1518:            }
        -: 1519:        }
        -: 1520:    }
        -: 1521:
    #####: 1522:  for (; it != the_end; ++it)
        -: 1523:    {
    #####: 1524:      handle = it->second;
    #####: 1525:      DDS::ReturnCode_t const status =
        -: 1526:          read_instance_i(received_data, info_seq, max_samples, handle,
        -: 1527:                          sample_states, view_states, instance_states,
        -: 1528:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1529:                          a_condition);
        -: 1530:#else
        -: 1531:      0);
        -: 1532:#endif
    #####: 1533:  if (status != DDS::RETCODE_NO_DATA)
        -: 1534:    {
    #####: 1535:      post_read_or_take();
    #####: 1536:      return status;
        -: 1537:    }
        -: 1538:}
        -: 1539:
    #####: 1540:post_read_or_take();
    #####: 1541:return DDS::RETCODE_NO_DATA;
        -: 1542:}
        -: 1543:
    #####: 1544:DDS::ReturnCode_t take_next_instance_i (
        -: 1545:                                        MessageSequenceType & received_data,
        -: 1546:                                        DDS::SampleInfoSeq & info_seq,
        -: 1547:                                        ::CORBA::Long max_samples,
        -: 1548:                                        DDS::InstanceHandle_t a_handle,
        -: 1549:                                        DDS::SampleStateMask sample_states,
        -: 1550:                                        DDS::ViewStateMask view_states,
        -: 1551:                                        DDS::InstanceStateMask instance_states,
        -: 1552:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1553:                                        DDS::QueryCondition_ptr a_condition)
        -: 1554:#else
        -: 1555:                                        int ignored)
        -: 1556:#endif
        -: 1557:{
        -: 1558:#ifdef OPENDDS_NO_QUERY_CONDITION
        -: 1559:  ACE_UNUSED_ARG(ignored);
        -: 1560:#endif
        -: 1561:
    #####: 1562:  DDS::InstanceHandle_t handle(DDS::HANDLE_NIL);
        -: 1563:
    #####: 1564:  ACE_GUARD_RETURN (ACE_Recursive_Thread_Mutex,
        -: 1565:                    guard,
        -: 1566:                    this->sample_lock_,
        -: 1567:                    DDS::RETCODE_ERROR);
        -: 1568:
    #####: 1569:  typename InstanceMap::iterator it;
    #####: 1570:  typename InstanceMap::iterator const the_end = instance_map_.end ();
        -: 1571:
    #####: 1572:  if (a_handle == DDS::HANDLE_NIL)
        -: 1573:    {
    #####: 1574:      it = instance_map_.begin ();
        -: 1575:    }
        -: 1576:  else
        -: 1577:    {
    #####: 1578:      for (it = instance_map_.begin (); it != the_end; ++it)
        -: 1579:        {
    #####: 1580:          if (a_handle == it->second)
        -: 1581:            {
    #####: 1582:              ++it;
    #####: 1583:              break;
        -: 1584:            }
        -: 1585:        }
        -: 1586:    }
        -: 1587:
    #####: 1588:  for (; it != the_end; ++it)
        -: 1589:    {
    #####: 1590:      handle = it->second;
    #####: 1591:      DDS::ReturnCode_t const status =
        -: 1592:          take_instance_i(received_data, info_seq, max_samples, handle,
        -: 1593:                          sample_states, view_states, instance_states,
        -: 1594:#ifndef OPENDDS_NO_QUERY_CONDITION
        -: 1595:                          a_condition);
        -: 1596:#else
        -: 1597:      0);
        -: 1598:#endif
    #####: 1599:    if (status != DDS::RETCODE_NO_DATA)
        -: 1600:      {
    #####: 1601:        total_samples();  // see if we are empty
    #####: 1602:        post_read_or_take();
    #####: 1603:        return status;
        -: 1604:      }
        -: 1605:  }
    #####: 1606:  post_read_or_take();
    #####: 1607:  return DDS::RETCODE_NO_DATA;
        -: 1608:}
        -: 1609:
    #####: 1610:void store_instance_data(
        -: 1611:                         unique_ptr<MessageTypeWithAllocator> instance_data,
        -: 1612:                         const OpenDDS::DCPS::DataSampleHeader& header,
        -: 1613:                         OpenDDS::DCPS::SubscriptionInstance_rch& instance_ptr,
        -: 1614:                         bool& just_registered,
        -: 1615:                         bool& filtered)
        -: 1616:{
    #####: 1617:  const bool is_dispose_msg =
    #####: 1618:    header.message_id_ == OpenDDS::DCPS::DISPOSE_INSTANCE ||
    #####: 1619:    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
    #####: 1620:  const bool is_unregister_msg =
    #####: 1621:    header.message_id_ == OpenDDS::DCPS::UNREGISTER_INSTANCE ||
    #####: 1622:    header.message_id_ == OpenDDS::DCPS::DISPOSE_UNREGISTER_INSTANCE;
        -: 1623:
        -: 1624:  // not filtering any data, except what is specifically identified as filtered below
    #####: 1625:  filtered = false;
        -: 1626:
    #####: 1627:  DDS::InstanceHandle_t handle(DDS::HANDLE_NIL);
        -: 1628:
        -: 1629:  //!!! caller should already have the sample_lock_
        -: 1630:  //We will unlock it before calling into listeners
        -: 1631:
    #####: 1632:  typename InstanceMap::const_iterator const it = instance_map_.find(*instance_data);
        -: 1633:
    #####: 1634:  if ((is_dispose_msg || is_unregister_msg) && it == instance_map_.end())
        -: 1635:  {
    #####: 1636:    return;
        -: 1637:  }
        -: 1638:
    #####: 1639:  if (it == instance_map_.end())
        -: 1640:  {
    #####: 1641:    std::size_t instances_size = 0;
        -: 1642:    {
    #####: 1643:      ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, instances_lock_);
    #####: 1644:      instances_size = instances_.size();
        -: 1645:    }
    #####: 1646:    if ((this->qos_.resource_limits.max_instances != DDS::LENGTH_UNLIMITED) &&
    #####: 1647:      ((::CORBA::Long) instances_size >= this->qos_.resource_limits.max_instances))
        -: 1648:    {
    #####: 1649:      DDS::DataReaderListener_var listener
        -: 1650:        = listener_for (DDS::SAMPLE_REJECTED_STATUS);
        -: 1651:
    #####: 1652:      set_status_changed_flag (DDS::SAMPLE_REJECTED_STATUS, true);
        -: 1653:
    #####: 1654:      sample_rejected_status_.last_reason = DDS::REJECTED_BY_INSTANCES_LIMIT;
    #####: 1655:      ++sample_rejected_status_.total_count;
    #####: 1656:      ++sample_rejected_status_.total_count_change;
    #####: 1657:      sample_rejected_status_.last_instance_handle = handle;
        -: 1658:
    #####: 1659:      if (!CORBA::is_nil(listener.in()))
        -: 1660:      {
    #####: 1661:        ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
        -: 1662:
    #####: 1663:        listener->on_sample_rejected(this, sample_rejected_status_);
    #####: 1664:        sample_rejected_status_.total_count_change = 0;
        -: 1665:      }  // do we want to do something if listener is nil???
    #####: 1666:      notify_status_condition_no_sample_lock();
        -: 1667:
    #####: 1668:      return;
        -: 1669:    }
        -: 1670:
        -: 1671:#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    #####: 1672:    SharedInstanceMap_rch inst;
    #####: 1673:    bool new_handle = true;
    #####: 1674:    if (this->is_exclusive_ownership_) {
    #####: 1675:      OwnershipManagerPtr owner_manager = this->ownership_manager();
        -: 1676:
    #####: 1677:      if (!owner_manager || owner_manager->instance_lock_acquire () != 0) {
    #####: 1678:        ACE_ERROR ((LM_ERROR,
        -: 1679:                    ACE_TEXT("(%P|%t) ")
        -: 1680:                    ACE_TEXT("%CDataReaderImpl::")
        -: 1681:                    ACE_TEXT("store_instance_data, ")
        -: 1682:                    ACE_TEXT("acquire instance_lock failed. \n"), TraitsType::type_name()));
    #####: 1683:        return;
        -: 1684:      }
        -: 1685:
    #####: 1686:      inst = dynamic_rchandle_cast<SharedInstanceMap>(
    #####: 1687:        owner_manager->get_instance_map(this->topic_servant_->type_name(), this));
    #####: 1688:      if (inst != 0) {
    #####: 1689:        typename InstanceMap::const_iterator const iter = inst->find(*instance_data);
    #####: 1690:        if (iter != inst->end ()) {
    #####: 1691:          handle = iter->second;
    #####: 1692:          new_handle = false;
        -: 1693:        }
        -: 1694:      }
        -: 1695:    }
        -: 1696:#endif
        -: 1697:
    #####: 1698:    just_registered = true;
    #####: 1699:    DDS::BuiltinTopicKey_t key = OpenDDS::DCPS::keyFromSample(static_cast<MessageType*>(instance_data.get()));
    #####: 1700:    handle = handle == DDS::HANDLE_NIL ? this->get_next_handle( key) : handle;
    #####: 1701:    OpenDDS::DCPS::SubscriptionInstance_rch instance =
        -: 1702:      OpenDDS::DCPS::make_rch<OpenDDS::DCPS::SubscriptionInstance>(
        -: 1703:        this,
    #####: 1704:        this->qos_,
    #####: 1705:        ref(this->instances_lock_),
        -: 1706:        handle);
        -: 1707:
    #####: 1708:    instance->instance_handle_ = handle;
        -: 1709:
        -: 1710:    {
    #####: 1711:      ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, instances_lock_);
    #####: 1712:      int ret = OpenDDS::DCPS::bind(instances_, handle, instance);
        -: 1713:
    #####: 1714:      if (ret != 0)
        -: 1715:      {
    #####: 1716:        ACE_ERROR ((LM_ERROR,
        -: 1717:                    ACE_TEXT("(%P|%t) ")
        -: 1718:                    ACE_TEXT("%CDataReaderImpl::")
        -: 1719:                    ACE_TEXT("store_instance_data, ")
        -: 1720:                    ACE_TEXT("insert handle failed. \n"), TraitsType::type_name()));
    #####: 1721:        return;
        -: 1722:      }
        -: 1723:    }
        -: 1724:
        -: 1725:#ifndef OPENDDS_NO_OWNERSHIP_KIND_EXCLUSIVE
    #####: 1726:    OwnershipManagerPtr owner_manager = this->ownership_manager();
        -: 1727:
    #####: 1728:    if (owner_manager) {
    #####: 1729:      if (!inst) {
    #####: 1730:        inst = make_rch<SharedInstanceMap>();
    #####: 1731:        owner_manager->set_instance_map(
    #####: 1732:          this->topic_servant_->type_name(),
        -: 1733:          inst,
        -: 1734:          this);
        -: 1735:      }
        -: 1736:
    #####: 1737:      if (new_handle) {
    #####: 1738:        std::pair<typename InstanceMap::iterator, bool> bpair =
    #####: 1739:          inst->insert(typename InstanceMap::value_type(*instance_data,
        -: 1740:            handle));
    #####: 1741:        if (bpair.second == false)
        -: 1742:        {
    #####: 1743:          ACE_ERROR ((LM_ERROR,
        -: 1744:                      ACE_TEXT("(%P|%t) ")
        -: 1745:                      ACE_TEXT("%CDataReaderImpl::")
        -: 1746:                      ACE_TEXT("store_instance_data, ")
        -: 1747:                      ACE_TEXT("insert to participant scope %C failed. \n"), TraitsType::type_name(), TraitsType::type_name()));
    #####: 1748:          return;
        -: 1749:        }
        -: 1750:      }
        -: 1751:
    #####: 1752:      if (owner_manager->instance_lock_release () != 0) {
    #####: 1753:        ACE_ERROR ((LM_ERROR,
        -: 1754:                    ACE_TEXT("(%P|%t) ")
        -: 1755:                    ACE_TEXT("%CDataReaderImpl::")
        -: 1756:                    ACE_TEXT("store_instance_data, ")
        -: 1757:                    ACE_TEXT("release instance_lock failed. \n"), TraitsType::type_name()));
    #####: 1758:        return;
        -: 1759:      }
        -: 1760:    }
        -: 1761:#endif
        -: 1762:
    #####: 1763:    std::pair<typename InstanceMap::iterator, bool> bpair =
    #####: 1764:      instance_map_.insert(typename InstanceMap::value_type(*instance_data,
        -: 1765:        handle));
    #####: 1766:    if (bpair.second == false)
        -: 1767:    {
    #####: 1768:      ACE_ERROR ((LM_ERROR,
        -: 1769:                  ACE_TEXT("(%P|%t) ")
        -: 1770:                  ACE_TEXT("%CDataReaderImpl::")
        -: 1771:                  ACE_TEXT("store_instance_data, ")
        -: 1772:                  ACE_TEXT("insert %C failed. \n"), TraitsType::type_name(), TraitsType::type_name()));
    #####: 1773:      return;
        -: 1774:    }
        -: 1775:  }
        -: 1776:  else
        -: 1777:  {
    #####: 1778:    just_registered = false;
    #####: 1779:    handle = it->second;
        -: 1780:  }
        -: 1781:
    #####: 1782:  if (header.message_id_ != OpenDDS::DCPS::INSTANCE_REGISTRATION)
        -: 1783:  {
    #####: 1784:    instance_ptr = get_handle_instance(handle);
        -: 1785:
    #####: 1786:    if (header.message_id_ == OpenDDS::DCPS::SAMPLE_DATA)
        -: 1787:    {
    #####: 1788:      filtered = ownership_filter_instance(instance_ptr, header.publication_id_);
        -: 1789:
    #####: 1790:      ACE_Time_Value filter_time_expired;
    #####: 1791:      if (!filtered &&
    #####: 1792:          time_based_filter_instance(instance_ptr, filter_time_expired)) {
    #####: 1793:        filtered = true;
    #####: 1794:        if (this->qos_.reliability.kind == DDS::RELIABLE_RELIABILITY_QOS) {
    #####: 1795:          filter_delayed_handler_->delay_sample(handle, move(instance_data), header, just_registered, filter_time_expired);
        -: 1796:
        -: 1797:        }
        -: 1798:      } else {
        -: 1799:        // nothing time based filtered now
    #####: 1800:        filter_delayed_handler_->clear_sample(handle);
        -: 1801:
        -: 1802:      }
        -: 1803:
    #####: 1804:      if (filtered)
        -: 1805:      {
    #####: 1806:        return;
        -: 1807:      }
        -: 1808:    }
        -: 1809:
    #####: 1810:    finish_store_instance_data(move(instance_data), header, instance_ptr, is_dispose_msg, is_unregister_msg);
        -: 1811:  }
        -: 1812:  else
        -: 1813:  {
    #####: 1814:    instance_ptr = this->get_handle_instance(handle);
    #####: 1815:    instance_ptr->instance_state_.lively(header.publication_id_);
        -: 1816:  }
        -: 1817:}
        -: 1818:
    #####: 1819:void finish_store_instance_data(unique_ptr<MessageTypeWithAllocator> instance_data, const DataSampleHeader& header,
        -: 1820:  SubscriptionInstance_rch instance_ptr, bool is_dispose_msg, bool is_unregister_msg )
        -: 1821:{
    #####: 1822:  if ((this->qos_.resource_limits.max_samples_per_instance !=
    #####: 1823:        DDS::LENGTH_UNLIMITED) &&
    #####: 1824:      (instance_ptr->rcvd_samples_.size_ >=
    #####: 1825:        this->qos_.resource_limits.max_samples_per_instance)) {
        -: 1826:
        -: 1827:    // According to spec 1.2, Samples that contain no data do not
        -: 1828:    // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        -: 1829:    // so do not remove the oldest sample when unregister/dispose
        -: 1830:    // message arrives.
        -: 1831:
    #####: 1832:    if (!is_dispose_msg && !is_unregister_msg
    #####: 1833:      && instance_ptr->rcvd_samples_.head_->sample_state_
        -: 1834:      == DDS::NOT_READ_SAMPLE_STATE)
        -: 1835:    {
        -: 1836:      // for now the implemented QoS means that if the head sample
        -: 1837:      // is NOT_READ then none are read.
        -: 1838:      // TBD - in future we will reads may not read in order so
        -: 1839:      //       just looking at the head will not be enough.
    #####: 1840:      DDS::DataReaderListener_var listener
        -: 1841:        = listener_for(DDS::SAMPLE_REJECTED_STATUS);
        -: 1842:
    #####: 1843:      set_status_changed_flag(DDS::SAMPLE_REJECTED_STATUS, true);
        -: 1844:
    #####: 1845:      sample_rejected_status_.last_reason =
        -: 1846:        DDS::REJECTED_BY_SAMPLES_PER_INSTANCE_LIMIT;
    #####: 1847:      ++sample_rejected_status_.total_count;
    #####: 1848:      ++sample_rejected_status_.total_count_change;
    #####: 1849:      sample_rejected_status_.last_instance_handle = instance_ptr->instance_handle_;
        -: 1850:
    #####: 1851:      if (!CORBA::is_nil(listener.in()))
        -: 1852:      {
    #####: 1853:        ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
        -: 1854:
    #####: 1855:        listener->on_sample_rejected(this, sample_rejected_status_);
    #####: 1856:        sample_rejected_status_.total_count_change = 0;
        -: 1857:      }  // do we want to do something if listener is nil???
    #####: 1858:      notify_status_condition_no_sample_lock();
    #####: 1859:      return;
        -: 1860:    }
    #####: 1861:    else if (!is_dispose_msg && !is_unregister_msg)
        -: 1862:    {
        -: 1863:      // Discard the oldest previously-read sample
    #####: 1864:      OpenDDS::DCPS::ReceivedDataElement *item =
    #####: 1865:        instance_ptr->rcvd_samples_.head_;
    #####: 1866:      instance_ptr->rcvd_samples_.remove(item);
    #####: 1867:      item->dec_ref();
        -: 1868:    }
        -: 1869:  }
    #####: 1870:  else if (this->qos_.resource_limits.max_samples != DDS::LENGTH_UNLIMITED)
        -: 1871:  {
    #####: 1872:    CORBA::Long total_samples = 0;
        -: 1873:    {
    #####: 1874:      ACE_GUARD(ACE_Recursive_Thread_Mutex, instance_guard, this->instances_lock_);
    #####: 1875:      for (OpenDDS::DCPS::DataReaderImpl::SubscriptionInstanceMapType::iterator iter = instances_.begin();
    #####: 1876:        iter != instances_.end();
        -: 1877:        ++iter) {
    #####: 1878:        OpenDDS::DCPS::SubscriptionInstance_rch ptr = iter->second;
        -: 1879:
    #####: 1880:        total_samples += (CORBA::Long) ptr->rcvd_samples_.size_;
        -: 1881:      }
        -: 1882:    }
        -: 1883:
    #####: 1884:    if (total_samples >= this->qos_.resource_limits.max_samples)
        -: 1885:    {
        -: 1886:      // According to spec 1.2, Samples that contain no data do not
        -: 1887:      // count towards the limits imposed by the RESOURCE_LIMITS QoS policy
        -: 1888:      // so do not remove the oldest sample when unregister/dispose
        -: 1889:      // message arrives.
        -: 1890:
    #####: 1891:      if (!is_dispose_msg && !is_unregister_msg
    #####: 1892:        && instance_ptr->rcvd_samples_.head_->sample_state_
        -: 1893:        == DDS::NOT_READ_SAMPLE_STATE)
        -: 1894:      {
        -: 1895:        // for now the implemented QoS means that if the head sample
        -: 1896:        // is NOT_READ then none are read.
        -: 1897:        // TBD - in future we will reads may not read in order so
        -: 1898:        //       just looking at the head will not be enough.
    #####: 1899:        DDS::DataReaderListener_var listener
        -: 1900:          = listener_for(DDS::SAMPLE_REJECTED_STATUS);
        -: 1901:
    #####: 1902:        set_status_changed_flag(DDS::SAMPLE_REJECTED_STATUS, true);
        -: 1903:
    #####: 1904:        sample_rejected_status_.last_reason =
        -: 1905:          DDS::REJECTED_BY_SAMPLES_LIMIT;
    #####: 1906:        ++sample_rejected_status_.total_count;
    #####: 1907:        ++sample_rejected_status_.total_count_change;
    #####: 1908:        sample_rejected_status_.last_instance_handle = instance_ptr->instance_handle_;
    #####: 1909:        if (!CORBA::is_nil(listener.in()))
        -: 1910:        {
    #####: 1911:          ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
        -: 1912:
    #####: 1913:          listener->on_sample_rejected(this, sample_rejected_status_);
    #####: 1914:          sample_rejected_status_.total_count_change = 0;
        -: 1915:        }  // do we want to do something if listener is nil???
    #####: 1916:        notify_status_condition_no_sample_lock();
        -: 1917:
    #####: 1918:        return;
        -: 1919:      }
    #####: 1920:      else if (!is_dispose_msg && !is_unregister_msg)
        -: 1921:      {
        -: 1922:        // Discard the oldest previously-read sample
    #####: 1923:        OpenDDS::DCPS::ReceivedDataElement *item =
    #####: 1924:          instance_ptr->rcvd_samples_.head_;
    #####: 1925:        instance_ptr->rcvd_samples_.remove(item);
    #####: 1926:        item->dec_ref();
        -: 1927:      }
        -: 1928:    }
        -: 1929:  }
        -: 1930:
    #####: 1931:  bool event_notify = false;
        -: 1932:
    #####: 1933:  if (is_dispose_msg) {
    #####: 1934:    event_notify = instance_ptr->instance_state_.dispose_was_received(header.publication_id_);
        -: 1935:  }
        -: 1936:
    #####: 1937:  if (is_unregister_msg) {
    #####: 1938:    if (instance_ptr->instance_state_.unregister_was_received(header.publication_id_)) {
    #####: 1939:      event_notify = true;
        -: 1940:    }
        -: 1941:  }
        -: 1942:
    #####: 1943:  if (!is_dispose_msg && !is_unregister_msg) {
    #####: 1944:    event_notify = true;
    #####: 1945:    instance_ptr->instance_state_.data_was_received(header.publication_id_);
        -: 1946:  }
        -: 1947:
    #####: 1948:  if (!event_notify) {
    #####: 1949:    return;
        -: 1950:  }
        -: 1951:
    #####: 1952:  OpenDDS::DCPS::ReceivedDataElement *ptr =
    #####: 1953:    new (*rd_allocator_.get()) OpenDDS::DCPS::ReceivedDataElementWithType<MessageTypeWithAllocator>(header,instance_data.release(), &this->sample_lock_);
        -: 1954:
    #####: 1955:  ptr->disposed_generation_count_ =
    #####: 1956:    instance_ptr->instance_state_.disposed_generation_count();
    #####: 1957:  ptr->no_writers_generation_count_ =
    #####: 1958:    instance_ptr->instance_state_.no_writers_generation_count();
        -: 1959:
    #####: 1960:  instance_ptr->last_sequence_ = header.sequence_;
        -: 1961:
    #####: 1962:  instance_ptr->rcvd_strategy_->add(ptr);
        -: 1963:
    #####: 1964:  if (! is_dispose_msg  && ! is_unregister_msg
    #####: 1965:      && instance_ptr->rcvd_samples_.size_ > get_depth())
        -: 1966:    {
    #####: 1967:      OpenDDS::DCPS::ReceivedDataElement* head_ptr =
    #####: 1968:        instance_ptr->rcvd_samples_.head_;
        -: 1969:
    #####: 1970:      instance_ptr->rcvd_samples_.remove(head_ptr);
        -: 1971:
    #####: 1972:      if (head_ptr->sample_state_ == DDS::NOT_READ_SAMPLE_STATE)
        -: 1973:        {
    #####: 1974:          DDS::DataReaderListener_var listener
        -: 1975:            = listener_for (DDS::SAMPLE_LOST_STATUS);
        -: 1976:
    #####: 1977:          ++sample_lost_status_.total_count;
    #####: 1978:          ++sample_lost_status_.total_count_change;
        -: 1979:
    #####: 1980:          set_status_changed_flag(DDS::SAMPLE_LOST_STATUS, true);
        -: 1981:
    #####: 1982:          if (!CORBA::is_nil(listener.in()))
        -: 1983:            {
    #####: 1984:              ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
        -: 1985:
    #####: 1986:              listener->on_sample_lost(this, sample_lost_status_);
        -: 1987:
    #####: 1988:              sample_lost_status_.total_count_change = 0;
        -: 1989:            }
        -: 1990:
    #####: 1991:          notify_status_condition_no_sample_lock();
        -: 1992:        }
        -: 1993:
    #####: 1994:      head_ptr->dec_ref();
        -: 1995:    }
        -: 1996:
        -: 1997:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
    #####: 1998:  if (! ptr->coherent_change_) {
        -: 1999:#endif
    #####: 2000:    RcHandle<OpenDDS::DCPS::SubscriberImpl> sub = get_subscriber_servant ();
    #####: 2001:    if (!sub)
    #####: 2002:      return;
        -: 2003:
    #####: 2004:    sub->set_status_changed_flag(DDS::DATA_ON_READERS_STATUS, true);
        -: 2005:
    #####: 2006:    set_status_changed_flag(DDS::DATA_AVAILABLE_STATUS, true);
        -: 2007:
    #####: 2008:    DDS::SubscriberListener_var sub_listener =
        -: 2009:        sub->listener_for(DDS::DATA_ON_READERS_STATUS);
    #####: 2010:    if (!CORBA::is_nil(sub_listener.in()) && !this->coherent_)
        -: 2011:      {
    #####: 2012:        ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
        -: 2013:
    #####: 2014:        sub_listener->on_data_on_readers(sub.in());
    #####: 2015:        sub->set_status_changed_flag(DDS::DATA_ON_READERS_STATUS, false);
        -: 2016:      }
        -: 2017:    else
        -: 2018:      {
    #####: 2019:        sub->notify_status_condition();
        -: 2020:
    #####: 2021:        DDS::DataReaderListener_var listener =
        -: 2022:            listener_for (DDS::DATA_AVAILABLE_STATUS);
        -: 2023:
    #####: 2024:        if (!CORBA::is_nil(listener.in()))
        -: 2025:          {
    #####: 2026:            ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
        -: 2027:
    #####: 2028:            listener->on_data_available(this);
    #####: 2029:            set_status_changed_flag(DDS::DATA_AVAILABLE_STATUS, false);
    #####: 2030:            sub->set_status_changed_flag(DDS::DATA_ON_READERS_STATUS, false);
        -: 2031:          }
        -: 2032:        else
        -: 2033:          {
    #####: 2034:            notify_status_condition_no_sample_lock();
        -: 2035:          }
        -: 2036:      }
        -: 2037:#ifndef OPENDDS_NO_OBJECT_MODEL_PROFILE
        -: 2038:  }
        -: 2039:#endif
        -: 2040:}
        -: 2041:
        -: 2042:/// Release sample_lock_ during status notifications in store_instance_data()
        -: 2043:/// as the lock is not needed and could cause deadlock condition.
        -: 2044:/// See comments in member function implementation for details.
    #####: 2045:void notify_status_condition_no_sample_lock()
        -: 2046:{
        -: 2047:  // This member function avoids a deadlock condition which otherwise
        -: 2048:  // could occur as follows:
        -: 2049:  // Thread 1: Call to WaitSet::wait() causes WaitSet::lock_ to lock and
        -: 2050:  // eventually DataReaderImpl::sample_lock_ to lock in call to
        -: 2051:  // DataReaderImpl::contains_samples().
        -: 2052:  // Thread2: Call to DataReaderImpl::data_received()
        -: 2053:  // causes DataReaderImpl::sample_lock_ to lock and eventually
        -: 2054:  // during notify of status condition a call to WaitSet::signal()
        -: 2055:  // causes WaitSet::lock_ to lock.
        -: 2056:  // Because the DataReaderImpl::sample_lock_ is not needed during
        -: 2057:  // status notification this member function is used in
        -: 2058:  // store_instance_data() to release sample_lock_ before making
        -: 2059:  // the notification.
    #####: 2060:  ACE_GUARD(typename DataReaderImpl::Reverse_Lock_t, unlock_guard, reverse_sample_lock_);
    #####: 2061:  notify_status_condition();
        -: 2062:}
        -: 2063:
        -: 2064:
        -: 2065:/// Common input read* & take* input processing and precondition checks
    #####: 2066:DDS::ReturnCode_t check_inputs (
        -: 2067:                                const char* method_name,
        -: 2068:                                MessageSequenceType & received_data,
        -: 2069:                                DDS::SampleInfoSeq & info_seq,
        -: 2070:                                ::CORBA::Long max_samples)
        -: 2071:{
    #####: 2072:  typename MessageSequenceType::PrivateMemberAccess received_data_p (received_data);
        -: 2073:
        -: 2074:  // ---- start of preconditions common to read and take -----
        -: 2075:  // SPEC ref v1.2 7.1.2.5.3.8 #1
        -: 2076:  // NOTE: We can't check maximum() or release() here since those are
        -: 2077:  //       implementation details of the sequences.  In general, the
        -: 2078:  //       info_seq will have release() == true and maximum() == 0.
        -: 2079:  //       If we're in zero-copy mode, the received_data will have
        -: 2080:  //       release() == false and maximum() == 0.  If it's not
        -: 2081:  //       zero-copy then received_data will have release == true()
        -: 2082:  //       and maximum() == anything.
    #####: 2083:  if (received_data.length() != info_seq.length())
        -: 2084:    {
    #####: 2085:      ACE_DEBUG((LM_DEBUG,
        -: 2086:                 ACE_TEXT("(%P|%t) %CDataReaderImpl::%C ")
        -: 2087:                 ACE_TEXT("PRECONDITION_NOT_MET sample and info input ")
        -: 2088:                 ACE_TEXT("sequences do not match.\n"),
        -: 2089:                 TraitsType::type_name(),
        -: 2090:                 method_name ));
    #####: 2091:      return DDS::RETCODE_PRECONDITION_NOT_MET;
        -: 2092:    }
        -: 2093:
        -: 2094:  //SPEC ref v1.2 7.1.2.5.3.8 #4
    #####: 2095:  if ((received_data.maximum() > 0) && (received_data.release() == false))
        -: 2096:    {
    #####: 2097:      ACE_DEBUG((LM_DEBUG,
        -: 2098:                 ACE_TEXT("(%P|%t) %CDataReaderImpl::%C ")
        -: 2099:                 ACE_TEXT("PRECONDITION_NOT_MET mismatch of ")
        -: 2100:                 ACE_TEXT("maximum %d and owns %d\n"),
        -: 2101:                 TraitsType::type_name(),
        -: 2102:                 method_name,
        -: 2103:                 received_data.maximum(),
        -: 2104:                 received_data.release() ));
        -: 2105:
    #####: 2106:      return DDS::RETCODE_PRECONDITION_NOT_MET;
        -: 2107:    }
        -: 2108:
    #####: 2109:  if (received_data.maximum() == 0)
        -: 2110:    {
        -: 2111:      // not in SPEC but needed.
    #####: 2112:      if (max_samples == DDS::LENGTH_UNLIMITED)
        -: 2113:        {
    #####: 2114:          max_samples =
    #####: 2115:            static_cast< ::CORBA::Long> (received_data_p.max_slots());
        -: 2116:        }
        -: 2117:    }
        -: 2118:  else
        -: 2119:    {
    #####: 2120:      if (max_samples == DDS::LENGTH_UNLIMITED)
        -: 2121:        {
        -: 2122:          //SPEC ref v1.2 7.1.2.5.3.8 #5a
    #####: 2123:          max_samples = received_data.maximum();
        -: 2124:        }
    #####: 2125:      else if (
    #####: 2126:               max_samples > static_cast< ::CORBA::Long> (received_data.maximum()))
        -: 2127:        {
        -: 2128:          //SPEC ref v1.2 7.1.2.5.3.8 #5c
    #####: 2129:          ACE_DEBUG((LM_DEBUG,
        -: 2130:                     ACE_TEXT("(%P|%t) %CDataReaderImpl::%C ")
        -: 2131:                     ACE_TEXT("PRECONDITION_NOT_MET max_samples %d > maximum %d\n"),
        -: 2132:                     TraitsType::type_name(),
        -: 2133:                     method_name,
        -: 2134:                     max_samples,
        -: 2135:                     received_data.maximum()));
    #####: 2136:          return DDS::RETCODE_PRECONDITION_NOT_MET;
        -: 2137:        }
        -: 2138:      //else
        -: 2139:      //SPEC ref v1.2 7.1.2.5.3.8 #5b - is true by impl below.
        -: 2140:    }
        -: 2141:
        -: 2142:  // The spec does not say what to do in this case but it appears to be a good thing.
        -: 2143:  // Note: max_slots is the greater of the sequence's maximum and init_size.
    #####: 2144:  if (static_cast< ::CORBA::Long> (received_data_p.max_slots()) < max_samples)
        -: 2145:    {
    #####: 2146:      max_samples = static_cast< ::CORBA::Long> (received_data_p.max_slots());
        -: 2147:    }
        -: 2148:  //---- end of preconditions common to read and take -----
        -: 2149:
    #####: 2150:  return DDS::RETCODE_OK;
        -: 2151:}
        -: 2152:
        -: 2153:class FilterDelayedHandler : public Watchdog {
        -: 2154:public:
    #####: 2155:  FilterDelayedHandler(DataReaderImpl_T<MessageType>& data_reader_impl)
        -: 2156:  // Watchdog's interval_ only used for resetting current intervals
        -: 2157:  : Watchdog(ACE_Time_Value(0))
    #####: 2158:  , data_reader_impl_(data_reader_impl)
        -: 2159:  {
    #####: 2160:  }
        -: 2161:
    #####: 2162:  virtual ~FilterDelayedHandler()
        -: 2163:  {
    #####: 2164:  }
        -: 2165:
    #####: 2166:  void cancel()
        -: 2167:  {
    #####: 2168:    cancel_all();
    #####: 2169:    cleanup();
    #####: 2170:  }
        -: 2171:
    #####: 2172:  void delay_sample(DDS::InstanceHandle_t handle,
        -: 2173:                    unique_ptr<MessageTypeWithAllocator> data,
        -: 2174:                    const OpenDDS::DCPS::DataSampleHeader& header,
        -: 2175:                    const bool just_registered,
        -: 2176:                    const ACE_Time_Value& filter_time_expired)
        -: 2177:  {
        -: 2178:    // sample_lock_ should already be held
    #####: 2179:    RcHandle<DataReaderImpl_T<MessageType> > data_reader_impl(data_reader_impl_.lock());
        -: 2180:
    #####: 2181:    if (!data_reader_impl) {
    #####: 2182:      return;
        -: 2183:    }
        -: 2184:
    #####: 2185:    MessageTypeWithAllocator* instance_data = data.get();
        -: 2186:
    #####: 2187:    DataSampleHeader_ptr hdr(new OpenDDS::DCPS::DataSampleHeader(header));
        -: 2188:
    #####: 2189:    typename FilterDelayedSampleMap::iterator i = map_.find(handle);
    #####: 2190:    if (i == map_.end()) {
        -: 2191:
        -: 2192:      // emplace()/insert() only if the sample is going to be
        -: 2193:      // new (otherwise we call move(data) twice).
    #####: 2194:      std::pair<typename FilterDelayedSampleMap::iterator, bool> result =
        -: 2195:#ifdef ACE_HAS_CPP11
        -: 2196:      map_.emplace(std::piecewise_construct,
        -: 2197:                   std::forward_as_tuple(handle),
    #####: 2198:                   std::forward_as_tuple(move(data), hdr, just_registered));
        -: 2199:#else
        -: 2200:      map_.insert(std::make_pair(handle, FilterDelayedSample(move(data), hdr, just_registered)));
        -: 2201:#endif
    #####: 2202:      FilterDelayedSample& sample = result.first->second;
        -: 2203:
    #####: 2204:      const ACE_Time_Value interval = duration_to_time_value(
    #####: 2205:        data_reader_impl->qos_.time_based_filter.minimum_separation);
        -: 2206:
    #####: 2207:      const ACE_Time_Value filter_time_remaining = duration_to_time_value(
    #####: 2208:        data_reader_impl->qos_.time_based_filter.minimum_separation) - filter_time_expired;
        -: 2209:
    #####: 2210:      long timer_id = -1;
        -: 2211:
        -: 2212:      {
    #####: 2213:        ACE_GUARD(Reverse_Lock_t, unlock_guard, data_reader_impl->reverse_sample_lock_);
    #####: 2214:        timer_id = schedule_timer(reinterpret_cast<const void*>(intptr_t(handle)),
        -: 2215:          filter_time_remaining, interval);
        -: 2216:      }
        -: 2217:
        -: 2218:      // ensure that another sample has not replaced this while the lock was released
    #####: 2219:      if (instance_data == sample.message.get()) {
    #####: 2220:        sample.timer_id = timer_id;
        -: 2221:      }
        -: 2222:    } else {
    #####: 2223:      FilterDelayedSample& sample = i->second;
        -: 2224:      // we only care about the most recently filtered sample, so clean up the last one
        -: 2225:
    #####: 2226:      sample.message = move(data);
    #####: 2227:      sample.header = hdr;
    #####: 2228:      sample.new_instance = just_registered;
        -: 2229:      // already scheduled for timeout at the desired time
        -: 2230:    }
        -: 2231:  }
        -: 2232:
    #####: 2233:  void clear_sample(DDS::InstanceHandle_t handle)
        -: 2234:  {
        -: 2235:    // sample_lock_ should already be held
        -: 2236:
    #####: 2237:    typename FilterDelayedSampleMap::iterator sample = map_.find(handle);
    #####: 2238:    if (sample != map_.end()) {
        -: 2239:      // leave the entry in the container, so that the key remains valid if the reactor is waiting on this lock while this is occurring
    #####: 2240:      sample->second.message.reset();
        -: 2241:    }
    #####: 2242:  }
        -: 2243:
    #####: 2244:  void drop_sample(DDS::InstanceHandle_t handle)
        -: 2245:  {
        -: 2246:    // sample_lock_ should already be held
        -: 2247:
    #####: 2248:    typename FilterDelayedSampleMap::iterator sample = map_.find(handle);
    #####: 2249:    if (sample != map_.end()) {
        -: 2250:      {
    #####: 2251:        RcHandle<DataReaderImpl_T<MessageType> > data_reader_impl(data_reader_impl_.lock());
    #####: 2252:        if (data_reader_impl) {
    #####: 2253:          ACE_GUARD(Reverse_Lock_t, unlock_guard, data_reader_impl->reverse_sample_lock_);
    #####: 2254:          cancel_timer(sample->second.timer_id);
        -: 2255:        }
        -: 2256:      }
        -: 2257:
        -: 2258:      // use the handle to erase, since the sample lock was released
    #####: 2259:      map_.erase(handle);
        -: 2260:    }
        -: 2261:  }
        -: 2262:
        -: 2263:private:
        -: 2264:
        -: 2265:
        -: 2266:
    #####: 2267:  int handle_timeout(const ACE_Time_Value&, const void* act)
        -: 2268:  {
    #####: 2269:    DDS::InstanceHandle_t handle = static_cast<DDS::InstanceHandle_t>(reinterpret_cast<intptr_t>(act));
        -: 2270:
    #####: 2271:    RcHandle<DataReaderImpl_T<MessageType> > data_reader_impl(data_reader_impl_.lock());
    #####: 2272:    if (!data_reader_impl)
    #####: 2273:      return -1;
        -: 2274:
    #####: 2275:    SubscriptionInstance_rch instance = data_reader_impl->get_handle_instance(handle);
        -: 2276:
    #####: 2277:    if (!instance)
    #####: 2278:      return 0;
        -: 2279:
    #####: 2280:    long cancel_timer_id = -1;
        -: 2281:
        -: 2282:    {
    #####: 2283:      ACE_GUARD_RETURN(ACE_Recursive_Thread_Mutex, guard, data_reader_impl->sample_lock_, -1);
        -: 2284:
    #####: 2285:      typename FilterDelayedSampleMap::iterator data = map_.find(handle);
    #####: 2286:      if (data == map_.end()) {
    #####: 2287:        return 0;
        -: 2288:      }
        -: 2289:
    #####: 2290:      if (data->second.message) {
    #####: 2291:        const bool NOT_DISPOSE_MSG = false;
    #####: 2292:        const bool NOT_UNREGISTER_MSG = false;
        -: 2293:        // clear the message, since ownership is being transfered to finish_store_instance_data.
        -: 2294:
    #####: 2295:        instance->last_accepted_ = ACE_OS::gettimeofday();
    #####: 2296:        const DataSampleHeader_ptr header = data->second.header;
    #####: 2297:        const bool new_instance = data->second.new_instance;
        -: 2298:
        -: 2299:        // should not use data iterator anymore, since finish_store_instance_data releases sample_lock_
    #####: 2300:        data_reader_impl->finish_store_instance_data(
    #####: 2301:          move(data->second.message),
        -: 2302:          *header,
        -: 2303:          instance,
        -: 2304:          NOT_DISPOSE_MSG,
        -: 2305:          NOT_UNREGISTER_MSG);
        -: 2306:
    #####: 2307:        data_reader_impl->accept_sample_processing(instance, *header, new_instance);
        -: 2308:      } else {
        -: 2309:        // this check is performed to handle the corner case where store_instance_data received and delivered a sample, while this
        -: 2310:        // method was waiting for the lock
    #####: 2311:        const ACE_Time_Value interval = duration_to_time_value(data_reader_impl->qos_.time_based_filter.minimum_separation);
    #####: 2312:        if (ACE_OS::gettimeofday() - instance->last_sample_tv_ >= interval) {
        -: 2313:          // nothing to process, so unregister this handle for timeout
    #####: 2314:          cancel_timer_id = data->second.timer_id;
        -: 2315:          // no new data to process, so remove from container
    #####: 2316:          map_.erase(data);
        -: 2317:        }
        -: 2318:      }
        -: 2319:    }
        -: 2320:
    #####: 2321:    if (cancel_timer_id != -1) {
    #####: 2322:      cancel_timer(cancel_timer_id);
        -: 2323:    }
    #####: 2324:    return 0;
        -: 2325:  }
        -: 2326:
    #####: 2327:  virtual void reschedule_deadline()
        -: 2328:  {
    #####: 2329:    RcHandle<DataReaderImpl_T<MessageType> > data_reader_impl(data_reader_impl_.lock());
        -: 2330:
    #####: 2331:    if (data_reader_impl) {
    #####: 2332:      ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, data_reader_impl->sample_lock_);
        -: 2333:
    #####: 2334:      for (typename FilterDelayedSampleMap::iterator sample = map_.begin(); sample != map_.end(); ++sample) {
    #####: 2335:        reset_timer_interval(sample->second.timer_id);
        -: 2336:      }
        -: 2337:    }
        -: 2338:  }
        -: 2339:
    #####: 2340:  void cleanup()
        -: 2341:  {
    #####: 2342:    RcHandle<DataReaderImpl_T<MessageType> > data_reader_impl(data_reader_impl_.lock());
    #####: 2343:    if (data_reader_impl) {
    #####: 2344:      ACE_GUARD(ACE_Recursive_Thread_Mutex, guard, data_reader_impl->sample_lock_);
        -: 2345:      // insure instance_ptrs get freed
    #####: 2346:      map_.clear();
        -: 2347:    }
        -: 2348:  }
        -: 2349:
        -: 2350:  WeakRcHandle<DataReaderImpl_T<MessageType> > data_reader_impl_;
        -: 2351:
        -: 2352:  typedef ACE_Strong_Bound_Ptr<const OpenDDS::DCPS::DataSampleHeader, ACE_Null_Mutex> DataSampleHeader_ptr;
        -: 2353:
    #####: 2354:  struct FilterDelayedSample {
        -: 2355:
    #####: 2356:    FilterDelayedSample(unique_ptr<MessageTypeWithAllocator> msg, DataSampleHeader_ptr hdr, bool new_inst)
    #####: 2357:    : message(move(msg))
        -: 2358:    , header(hdr)
        -: 2359:    , new_instance(new_inst)
    #####: 2360:    , timer_id(-1) {
    #####: 2361:    }
        -: 2362:
        -: 2363:    container_supported_unique_ptr<MessageTypeWithAllocator> message;
        -: 2364:    DataSampleHeader_ptr header;
        -: 2365:    bool new_instance;
        -: 2366:    long timer_id;
        -: 2367:  };
        -: 2368:
        -: 2369:
        -: 2370:  typedef OPENDDS_MAP(DDS::InstanceHandle_t, FilterDelayedSample) FilterDelayedSampleMap;
        -: 2371:
        -: 2372:  FilterDelayedSampleMap map_;
        -: 2373:public:
        -: 2374:  typedef typename DataReaderImpl_T<MessageType>::DataAllocator DataAllocator;
        -: 2375:  //We put the data_allocator_ inside FilterDelayedHandler because the reactor thread in FilterDelayedHandler may be still alive
        -: 2376:  // after the containing DataReaderImpl is destroyed. This avoids access violation during cleanup.
        -: 2377:  unique_ptr<DataAllocator> data_allocator_;
        -: 2378:};
        -: 2379:
    #####: 2380:unique_ptr<DataAllocator>& data_allocator() { return filter_delayed_handler_->data_allocator_; }
        -: 2381:
        -: 2382:RcHandle<FilterDelayedHandler> filter_delayed_handler_;
        -: 2383:
        -: 2384:InstanceMap  instance_map_;
        -: 2385:};
        -: 2386:
        -: 2387:template <typename MessageType>
    #####: 2388:void* DataReaderImpl_T<MessageType>::MessageTypeWithAllocator::operator new(size_t , ACE_New_Allocator& pool)
        -: 2389:{
        -: 2390:  typedef typename DataReaderImpl_T<MessageType>::MessageTypeMemoryBlock MessageTypeMemoryBlock;
    #####: 2391:  MessageTypeMemoryBlock* block =
    #####: 2392:    static_cast<MessageTypeMemoryBlock*>(pool.malloc(sizeof(MessageTypeMemoryBlock)));
    #####: 2393:  block->allocator_ = &pool;
    #####: 2394:  return block;
        -: 2395:}
        -: 2396:
        -: 2397:template <typename MessageType>
    #####: 2398:void DataReaderImpl_T<MessageType>::MessageTypeWithAllocator::operator delete(void* memory)
        -: 2399:{
    #####: 2400:  if (memory) {
    #####: 2401:    MessageTypeMemoryBlock* block = static_cast<MessageTypeMemoryBlock*>(memory);
    #####: 2402:    block->allocator_->free(block);
        -: 2403:  }
    #####: 2404:}
        -: 2405:
        -: 2406:template <typename MessageType>
    #####: 2407:void DataReaderImpl_T<MessageType>::MessageTypeWithAllocator::operator delete(void* memory, ACE_New_Allocator&)
        -: 2408:{
    #####: 2409:  operator delete(memory);
    #####: 2410:}
        -: 2411:
        -: 2412:}
        -: 2413:}
        -: 2414:
        -: 2415:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2416:
        -: 2417:#endif /* dds_DCPS_DataReaderImpl_T_h */
