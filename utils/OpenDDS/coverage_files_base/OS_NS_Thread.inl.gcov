        -:    0:Source:/home/ryan/git/TARGETS/OpenDDS-debloat/ACE_wrappers/ace/OS_NS_Thread.inl
        -:    0:Programs:51
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id$
        -:    4:
        -:    5:#include "ace/OS_NS_macros.h"
        -:    6:// for timespec_t, perhaps move it to os_time.h
        -:    7:#include "ace/Time_Value.h"
        -:    8:#include "ace/OS_NS_sys_mman.h"
        -:    9:#include "ace/OS_NS_sys_time.h"
        -:   10:#include "ace/OS_NS_string.h"
        -:   11:#include "ace/OS_NS_unistd.h"
        -:   12:#include "ace/OS_NS_stdio.h"
        -:   13:#include "ace/OS_NS_errno.h"
        -:   14:
        -:   15:#if defined (ACE_USES_FIFO_SEM)
        -:   16:#  include "ace/OS_NS_sys_stat.h"
        -:   17:#  include "ace/OS_NS_sys_select.h"
        -:   18:#  include "ace/OS_NS_fcntl.h"
        -:   19:#  include "ace/Handle_Set.h"
        -:   20:# endif /* ACE_USES_FIFO_SEM */
        -:   21:
        -:   22:#if defined (ACE_HAS_PRIOCNTL)
        -:   23:#  include /**/ <sys/priocntl.h>
        -:   24:#endif /* ACE_HAS_PRIOCNTL */
        -:   25:
        -:   26:#if defined (ACE_HAS_ALLOC_HOOKS)
        -:   27:# include "ace/Malloc_Base.h"
        -:   28:#endif /* ACE_HAS_ALLOC_HOOKS */
        -:   29:
        -:   30:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   31:
        -:   32:/*****************************************************************************/
        -:   33:
        -:   34:#if defined (ACE_LACKS_COND_T) && defined (ACE_HAS_THREADS)
        -:   35:ACE_INLINE long
        -:   36:ACE_cond_t::waiters (void) const
        -:   37:{
        -:   38:  return this->waiters_;
        -:   39:}
        -:   40:#endif /* ACE_LACKS_COND_T && ACE_HAS_THREADS */
        -:   41:
        -:   42:/*****************************************************************************/
        -:   43:
        -:   44:#if defined (ACE_HAS_TSS_EMULATION)
        -:   45:
        -:   46:#  if !defined (ACE_HAS_THREAD_SPECIFIC_STORAGE)
        -:   47:ACE_INLINE
        -:   48:void **&
        -:   49:ACE_TSS_Emulation::tss_base ()
        -:   50:{
        -:   51:#    if defined (ACE_HAS_VXTHREADS)
        -:   52:  #if (ACE_VXWORKS <= 0x680)
        -:   53:  int &spare = taskIdCurrent->ACE_VXWORKS_SPARE;
        -:   54:  #else // VxWorks 6.9 updated datatype (WIND00241209) see taskLib.h
        -:   55:  long  &spare = taskIdCurrent->ACE_VXWORKS_SPARE;
        -:   56:  #endif
        -:   57:  return reinterpret_cast <void **&> (spare);
        -:   58:#    else
        -:   59:  // Uh oh.
        -:   60:  ACE_NOTSUP_RETURN (0);
        -:   61:#    endif /* ACE_HAS_VXTHREADS */
        -:   62:}
        -:   63:#  endif /* ! ACE_HAS_THREAD_SPECIFIC_STORAGE */
        -:   64:
        -:   65:ACE_INLINE
        -:   66:ACE_TSS_Emulation::ACE_TSS_DESTRUCTOR
        -:   67:ACE_TSS_Emulation::tss_destructor (const ACE_thread_key_t key)
        -:   68:{
        -:   69:  return tss_destructor_ [key];
        -:   70:}
        -:   71:
        -:   72:ACE_INLINE
        -:   73:void
        -:   74:ACE_TSS_Emulation::tss_destructor (const ACE_thread_key_t key,
        -:   75:                                   ACE_TSS_DESTRUCTOR destructor)
        -:   76:{
        -:   77:  tss_destructor_ [key] = destructor;
        -:   78:}
        -:   79:
        -:   80:ACE_INLINE
        -:   81:void *&
        -:   82:ACE_TSS_Emulation::ts_object (const ACE_thread_key_t key)
        -:   83:{
        -:   84:#    if defined (ACE_HAS_VXTHREADS)
        -:   85:    /* If someone wants tss_base make sure they get one.  This
        -:   86:       gets used if someone spawns a VxWorks task directly, not
        -:   87:       through ACE.  The allocated array will never be deleted! */
        -:   88:    if (0 == taskIdCurrent->ACE_VXWORKS_SPARE)
        -:   89:      {
        -:   90:        taskIdCurrent->ACE_VXWORKS_SPARE =
        -:   91:          reinterpret_cast<int> (new void *[ACE_TSS_THREAD_KEYS_MAX]);
        -:   92:
        -:   93:        // Zero the entire TSS array.  Do it manually instead of using
        -:   94:        // memset, for optimum speed.  Though, memset may be faster :-)
        -:   95:        void **tss_base_p =
        -:   96:          reinterpret_cast<void **> (taskIdCurrent->ACE_VXWORKS_SPARE);
        -:   97:        for (u_int i = 0; i < ACE_TSS_THREAD_KEYS_MAX; ++i, ++tss_base_p)
        -:   98:          {
        -:   99:            *tss_base_p = 0;
        -:  100:          }
        -:  101:      }
        -:  102:#    endif /* ACE_HAS_VXTHREADS */
        -:  103:
        -:  104:  return tss_base ()[key];
        -:  105:}
        -:  106:
        -:  107:#endif /* ACE_HAS_TSS_EMULATION */
        -:  108:
        -:  109:/*****************************************************************************/
        -:  110:
        -:  111:ACE_INLINE int
    #####:  112:ACE_OS::thr_equal (ACE_thread_t t1, ACE_thread_t t2)
        -:  113:{
        -:  114:#if defined (ACE_HAS_PTHREADS)
        -:  115:# if defined (pthread_equal)
        -:  116:  // If it's a macro we can't say "pthread_equal"...
        -:  117:  return pthread_equal (t1, t2);
        -:  118:# else
    #####:  119:  return pthread_equal (t1, t2);
        -:  120:# endif /* pthread_equal */
        -:  121:#else /* For both STHREADS and WTHREADS... */
        -:  122:  // Hum, Do we need to treat WTHREAD differently?
        -:  123:  // levine 13 oct 98 % I don't think so, ACE_thread_t is a DWORD.
        -:  124:  return t1 == t2;
        -:  125:#endif /* ACE_HAS_PTHREADS */
        -:  126:}
------------------
_ZN6ACE_OS9thr_equalEmm:
    #####:  112:ACE_OS::thr_equal (ACE_thread_t t1, ACE_thread_t t2)
        -:  113:{
        -:  114:#if defined (ACE_HAS_PTHREADS)
        -:  115:# if defined (pthread_equal)
        -:  116:  // If it's a macro we can't say "pthread_equal"...
        -:  117:  return pthread_equal (t1, t2);
        -:  118:# else
    #####:  119:  return pthread_equal (t1, t2);
        -:  120:# endif /* pthread_equal */
        -:  121:#else /* For both STHREADS and WTHREADS... */
        -:  122:  // Hum, Do we need to treat WTHREAD differently?
        -:  123:  // levine 13 oct 98 % I don't think so, ACE_thread_t is a DWORD.
        -:  124:  return t1 == t2;
        -:  125:#endif /* ACE_HAS_PTHREADS */
        -:  126:}
------------------
_ZN6ACE_OS9thr_equalEmm:
    #####:  112:ACE_OS::thr_equal (ACE_thread_t t1, ACE_thread_t t2)
        -:  113:{
        -:  114:#if defined (ACE_HAS_PTHREADS)
        -:  115:# if defined (pthread_equal)
        -:  116:  // If it's a macro we can't say "pthread_equal"...
        -:  117:  return pthread_equal (t1, t2);
        -:  118:# else
    #####:  119:  return pthread_equal (t1, t2);
        -:  120:# endif /* pthread_equal */
        -:  121:#else /* For both STHREADS and WTHREADS... */
        -:  122:  // Hum, Do we need to treat WTHREAD differently?
        -:  123:  // levine 13 oct 98 % I don't think so, ACE_thread_t is a DWORD.
        -:  124:  return t1 == t2;
        -:  125:#endif /* ACE_HAS_PTHREADS */
        -:  126:}
------------------
_ZN6ACE_OS9thr_equalEmm:
    #####:  112:ACE_OS::thr_equal (ACE_thread_t t1, ACE_thread_t t2)
        -:  113:{
        -:  114:#if defined (ACE_HAS_PTHREADS)
        -:  115:# if defined (pthread_equal)
        -:  116:  // If it's a macro we can't say "pthread_equal"...
        -:  117:  return pthread_equal (t1, t2);
        -:  118:# else
    #####:  119:  return pthread_equal (t1, t2);
        -:  120:# endif /* pthread_equal */
        -:  121:#else /* For both STHREADS and WTHREADS... */
        -:  122:  // Hum, Do we need to treat WTHREAD differently?
        -:  123:  // levine 13 oct 98 % I don't think so, ACE_thread_t is a DWORD.
        -:  124:  return t1 == t2;
        -:  125:#endif /* ACE_HAS_PTHREADS */
        -:  126:}
------------------
_ZN6ACE_OS9thr_equalEmm:
    #####:  112:ACE_OS::thr_equal (ACE_thread_t t1, ACE_thread_t t2)
        -:  113:{
        -:  114:#if defined (ACE_HAS_PTHREADS)
        -:  115:# if defined (pthread_equal)
        -:  116:  // If it's a macro we can't say "pthread_equal"...
        -:  117:  return pthread_equal (t1, t2);
        -:  118:# else
    #####:  119:  return pthread_equal (t1, t2);
        -:  120:# endif /* pthread_equal */
        -:  121:#else /* For both STHREADS and WTHREADS... */
        -:  122:  // Hum, Do we need to treat WTHREAD differently?
        -:  123:  // levine 13 oct 98 % I don't think so, ACE_thread_t is a DWORD.
        -:  124:  return t1 == t2;
        -:  125:#endif /* ACE_HAS_PTHREADS */
        -:  126:}
------------------
        -:  127:
        -:  128:ACE_INLINE int
        -:  129:ACE_OS::condattr_destroy (ACE_condattr_t &attributes)
        -:  130:{
        -:  131:#if defined (ACE_HAS_THREADS) && !defined (ACE_LACKS_CONDATTR)
        -:  132:#   if defined (ACE_HAS_PTHREADS)
        -:  133:  pthread_condattr_destroy (&attributes);
        -:  134:#   else
        -:  135:  attributes.type = 0;
        -:  136:#   endif /* ACE_HAS_PTHREADS */
        -:  137:  return 0;
        -:  138:# else
        -:  139:  ACE_UNUSED_ARG (attributes);
        -:  140:  return 0;
        -:  141:# endif /* ACE_HAS_THREADS  */
        -:  142:}
        -:  143:
        -:  144:ACE_INLINE int
        -:  145:ACE_OS::condattr_init (ACE_condattr_t &attributes, int type)
        -:  146:{
        -:  147:  ACE_UNUSED_ARG (type);
        -:  148:# if defined (ACE_HAS_THREADS)
        -:  149:#   if defined (ACE_HAS_PTHREADS)
        -:  150:  int result = -1;
        -:  151:
        -:  152:#   if !defined (ACE_LACKS_CONDATTR)
        -:  153:#     if defined (ACE_PTHREAD_CONDATTR_T_INITIALIZE)
        -:  154:  /* Tests show that VxWorks 6.x pthread lib does not only
        -:  155:    * require zeroing of mutex/condition objects to function correctly
        -:  156:    * but also of the attribute objects.
        -:  157:    */
        -:  158:  ACE_OS::memset (&attributes, 0, sizeof (attributes));
        -:  159:#     endif
        -:  160:  if (
        -:  161:      ACE_ADAPT_RETVAL (pthread_condattr_init (&attributes), result) == 0
        -:  162:#     if defined (_POSIX_THREAD_PROCESS_SHARED) && !defined (ACE_LACKS_CONDATTR_PSHARED)
        -:  163:      && ACE_ADAPT_RETVAL (pthread_condattr_setpshared (&attributes, type),
        -:  164:                           result) == 0
        -:  165:#     endif /* _POSIX_THREAD_PROCESS_SHARED && ! ACE_LACKS_CONDATTR_PSHARED */
        -:  166:      )
        -:  167:#   else
        -:  168:  if (type == USYNC_THREAD)
        -:  169:#   endif /* !ACE_LACKS_CONDATTR */
        -:  170:     result = 0;
        -:  171:  else
        -:  172:    {
        -:  173:      ACE_UNUSED_ARG (attributes);
        -:  174:      result = -1;       // ACE_ADAPT_RETVAL used it for intermediate status
        -:  175:    }
        -:  176:
        -:  177:  return result;
        -:  178:#   else
        -:  179:  attributes.type = type;
        -:  180:  return 0;
        -:  181:#   endif /* ACE_HAS_PTHREADS */
        -:  182:
        -:  183:# else
        -:  184:  ACE_UNUSED_ARG (attributes);
        -:  185:  ACE_UNUSED_ARG (type);
        -:  186:  ACE_NOTSUP_RETURN (-1);
        -:  187:# endif /* ACE_HAS_THREADS */
        -:  188:}
        -:  189:
        -:  190:ACE_INLINE int
        -:  191:ACE_OS::condattr_synctype (ACE_condattr_t &attributes, int& type)
        -:  192:{
        -:  193:# if defined (ACE_HAS_THREADS)
        -:  194:#   if defined (ACE_HAS_PTHREADS)
        -:  195:#   if !defined (ACE_LACKS_CONDATTR) && defined (_POSIX_THREAD_PROCESS_SHARED) && !defined (ACE_LACKS_CONDATTR_PSHARED)
        -:  196:  int result = -1;
        -:  197:
        -:  198:  if (
        -:  199:      ACE_ADAPT_RETVAL (pthread_condattr_getpshared (&attributes, &type),
        -:  200:                           result) == 0
        -:  201:     )
        -:  202:    {
        -:  203:      result = 0;
        -:  204:    }
        -:  205:#   else
        -:  206:  ACE_UNUSED_ARG (attributes);
        -:  207:  int result = 0;
        -:  208:  type = USYNC_THREAD;
        -:  209:#   endif /* !ACE_LACKS_CONDATTR && _POSIX_THREAD_PROCESS_SHARED && ! ACE_LACKS_CONDATTR_PSHARED */
        -:  210:
        -:  211:  return result;
        -:  212:#   else
        -:  213:  type = attributes.type;
        -:  214:  return 0;
        -:  215:#   endif /* ACE_HAS_PTHREADS */
        -:  216:
        -:  217:# else
        -:  218:  ACE_UNUSED_ARG (attributes);
        -:  219:  ACE_UNUSED_ARG (type);
        -:  220:  ACE_NOTSUP_RETURN (-1);
        -:  221:# endif /* ACE_HAS_THREADS */
        -:  222:}
        -:  223:
        -:  224:ACE_INLINE int
        -:  225:ACE_OS::condattr_setclock (ACE_condattr_t &attributes, clockid_t clock_id)
        -:  226:{
        -:  227:# if defined (ACE_HAS_THREADS)
        -:  228:#   if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_CONDATTR)
        -:  229:  int result = -1;
        -:  230:
        -:  231:#   if defined (_POSIX_CLOCK_SELECTION) && !defined (ACE_LACKS_CONDATTR_SETCLOCK)
        -:  232:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_condattr_setclock (&attributes, clock_id),
        -:  233:                                       result),
        -:  234:                     int, -1);
        -:  235:#   else
        -:  236:  ACE_UNUSED_ARG (clock_id);
        -:  237:  ACE_UNUSED_ARG (attributes);
        -:  238:#   endif /* _POSIX_CLOCK_SELECTION) && !ACE_LACKS_CONDATTR_SETCLOCK */
        -:  239:
        -:  240:  return result;
        -:  241:#   else
        -:  242:  ACE_UNUSED_ARG (clock_id);
        -:  243:  ACE_UNUSED_ARG (attributes);
        -:  244:  ACE_NOTSUP_RETURN (-1);
        -:  245:#   endif /* ACE_HAS_PTHREADS && !ACE_LACKS_CONDATTR */
        -:  246:
        -:  247:# else
        -:  248:  ACE_UNUSED_ARG (clock_id);
        -:  249:  ACE_UNUSED_ARG (attributes);
        -:  250:  ACE_NOTSUP_RETURN (-1);
        -:  251:# endif /* ACE_HAS_THREADS */
        -:  252:}
        -:  253:
        -:  254:#if !defined (ACE_LACKS_COND_T)
        -:  255:// NOTE: The ACE_OS::cond_* functions for Unix platforms are defined
        -:  256:// here because the ACE_OS::sema_* functions below need them.
        -:  257:// However, ACE_WIN32 and VXWORKS define the ACE_OS::cond_* functions
        -:  258:// using the ACE_OS::sema_* functions.  So, they are defined in OS_NS_Tread.cpp.
        -:  259:
        -:  260:ACE_INLINE int
        -:  261:ACE_OS::cond_broadcast (ACE_cond_t *cv)
        -:  262:{
        -:  263:  ACE_OS_TRACE ("ACE_OS::cond_broadcast");
        -:  264:# if defined (ACE_HAS_THREADS)
        -:  265:#   if defined (ACE_HAS_PTHREADS)
        -:  266:  int result;
        -:  267:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_broadcast (cv),
        -:  268:                                       result),
        -:  269:                     int, -1);
        -:  270:#   elif defined (ACE_HAS_STHREADS)
        -:  271:  int result;
        -:  272:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_broadcast (cv),
        -:  273:                                       result),
        -:  274:                     int, -1);
        -:  275:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  276:  ::WakeAllConditionVariable  (cv);
        -:  277:  return 0;
        -:  278:#   endif /* ACE_HAS_STHREADS */
        -:  279:# else
        -:  280:  ACE_UNUSED_ARG (cv);
        -:  281:  ACE_NOTSUP_RETURN (-1);
        -:  282:# endif /* ACE_HAS_THREADS */
        -:  283:}
        -:  284:
        -:  285:ACE_INLINE int
        -:  286:ACE_OS::cond_destroy (ACE_cond_t *cv)
        -:  287:{
        -:  288:  ACE_OS_TRACE ("ACE_OS::cond_destroy");
        -:  289:# if defined (ACE_HAS_THREADS)
        -:  290:#   if defined (ACE_HAS_PTHREADS)
        -:  291:  int result;
        -:  292:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_destroy (cv), result), int, -1);
        -:  293:#   elif defined (ACE_HAS_STHREADS)
        -:  294:  int result;
        -:  295:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_destroy (cv), result), int, -1);
        -:  296:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  297:  // Windows doesn't have a destroy
        -:  298:  return 0;
        -:  299:#   endif /* ACE_HAS_STHREADS */
        -:  300:# else
        -:  301:  ACE_UNUSED_ARG (cv);
        -:  302:  ACE_NOTSUP_RETURN (-1);
        -:  303:# endif /* ACE_HAS_THREADS */
        -:  304:}
        -:  305:
        -:  306:ACE_INLINE int
        -:  307:ACE_OS::cond_init (ACE_cond_t *cv,
        -:  308:                   ACE_condattr_t &attributes,
        -:  309:                   const char *name,
        -:  310:                   void *arg)
        -:  311:{
        -:  312:  // ACE_OS_TRACE ("ACE_OS::cond_init");
        -:  313:  ACE_UNUSED_ARG (name);
        -:  314:  ACE_UNUSED_ARG (arg);
        -:  315:# if defined (ACE_HAS_THREADS)
        -:  316:#   if defined (ACE_HAS_PTHREADS)
        -:  317:  int result = -1;
        -:  318:
        -:  319:#     if defined (ACE_PTHREAD_COND_T_INITIALIZE)
        -:  320:  /* VxWorks 6.x API reference states:
        -:  321:   *   If the memory for the condition variable object has been allocated
        -:  322:   *   dynamically, it is a good policy to always zero out the
        -:  323:   *   block of memory so as to avoid spurious EBUSY return code
        -:  324:   *   when calling this routine.
        -:  325:   */
        -:  326:  ACE_OS::memset (cv, 0, sizeof (*cv));
        -:  327:#     endif
        -:  328:
        -:  329:  if (ACE_ADAPT_RETVAL (pthread_cond_init (cv, &attributes), result) == 0)
        -:  330:     result = 0;
        -:  331:  else
        -:  332:     result = -1;       // ACE_ADAPT_RETVAL used it for intermediate status
        -:  333:
        -:  334:  return result;
        -:  335:#   elif defined (ACE_HAS_STHREADS)
        -:  336:  int result;
        -:  337:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_init (cv,
        -:  338:                                                    attributes.type,
        -:  339:                                                    arg),
        -:  340:                                       result),
        -:  341:                     int, -1);
        -:  342:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  343:    ::InitializeConditionVariable (cv);
        -:  344:    return 0;
        -:  345:#   endif /* ACE_HAS_PTHREADS vs. ACE_HAS_STHREADS */
        -:  346:# else
        -:  347:  ACE_UNUSED_ARG (cv);
        -:  348:  ACE_UNUSED_ARG (attributes);
        -:  349:  ACE_UNUSED_ARG (name);
        -:  350:  ACE_UNUSED_ARG (arg);
        -:  351:  ACE_NOTSUP_RETURN (-1);
        -:  352:# endif /* ACE_HAS_THREADS */
        -:  353:}
        -:  354:
        -:  355:#if defined (ACE_HAS_WCHAR)
        -:  356:ACE_INLINE int
        -:  357:ACE_OS::cond_init (ACE_cond_t *cv,
        -:  358:                   ACE_condattr_t &attributes,
        -:  359:                   const wchar_t *name,
        -:  360:                   void *arg)
        -:  361:{
        -:  362:  return ACE_OS::cond_init (cv, attributes, ACE_Wide_To_Ascii (name).char_rep (), arg);
        -:  363:}
        -:  364:#endif /* ACE_HAS_WCHAR */
        -:  365:
        -:  366:#if defined (ACE_HAS_WCHAR)
        -:  367:ACE_INLINE int
        -:  368:ACE_OS::cond_init (ACE_cond_t *cv, short type, const wchar_t *name, void *arg)
        -:  369:{
        -:  370:  return ACE_OS::cond_init (cv, type, ACE_Wide_To_Ascii (name).char_rep (), arg);
        -:  371:}
        -:  372:#endif /* ACE_HAS_WCHAR */
        -:  373:
        -:  374:ACE_INLINE int
        -:  375:ACE_OS::cond_signal (ACE_cond_t *cv)
        -:  376:{
        -:  377:  ACE_OS_TRACE ("ACE_OS::cond_signal");
        -:  378:# if defined (ACE_HAS_THREADS)
        -:  379:#   if defined (ACE_HAS_PTHREADS)
        -:  380:  int result;
        -:  381:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_signal (cv), result),
        -:  382:                     int, -1);
        -:  383:#   elif defined (ACE_HAS_STHREADS)
        -:  384:  int result;
        -:  385:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_signal (cv), result), int, -1);
        -:  386:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  387:  ::WakeConditionVariable (cv);
        -:  388:  return 0;
        -:  389:#   endif /* ACE_HAS_STHREADS */
        -:  390:# else
        -:  391:  ACE_UNUSED_ARG (cv);
        -:  392:  ACE_NOTSUP_RETURN (-1);
        -:  393:# endif /* ACE_HAS_THREADS */
        -:  394:}
        -:  395:
        -:  396:ACE_INLINE int
        -:  397:ACE_OS::cond_wait (ACE_cond_t *cv,
        -:  398:                   ACE_mutex_t *external_mutex)
        -:  399:{
        -:  400:  ACE_OS_TRACE ("ACE_OS::cond_wait");
        -:  401:# if defined (ACE_HAS_THREADS)
        -:  402:#   if defined (ACE_HAS_PTHREADS)
        -:  403:  int result;
        -:  404:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_wait (cv, external_mutex), result),
        -:  405:                     int, -1);
        -:  406:#   elif defined (ACE_HAS_STHREADS)
        -:  407:  int result;
        -:  408:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_wait (cv, external_mutex), result),
        -:  409:                     int, -1);
        -:  410:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  411:  int result;
        -:  412:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::SleepConditionVariableCS (cv, &external_mutex->thr_mutex_, INFINITE), result),
        -:  413:                     int, -1);
        -:  414:#   endif /* ACE_HAS_PTHREADS */
        -:  415:# else
        -:  416:  ACE_UNUSED_ARG (cv);
        -:  417:  ACE_UNUSED_ARG (external_mutex);
        -:  418:  ACE_NOTSUP_RETURN (-1);
        -:  419:# endif /* ACE_HAS_THREADS */
        -:  420:}
        -:  421:
        -:  422:ACE_INLINE int
        -:  423:ACE_OS::cond_timedwait (ACE_cond_t *cv,
        -:  424:                        ACE_mutex_t *external_mutex,
        -:  425:                        ACE_Time_Value *timeout)
        -:  426:{
        -:  427:  ACE_OS_TRACE ("ACE_OS::cond_timedwait");
        -:  428:# if defined (ACE_HAS_THREADS)
        -:  429:  int result = 0;
        -:  430:  timespec_t ts;
        -:  431:
        -:  432:  if (timeout != 0)
        -:  433:    ts = *timeout; // Calls ACE_Time_Value::operator timespec_t().
        -:  434:
        -:  435:#   if defined (ACE_HAS_PTHREADS)
        -:  436:
        -:  437:  ACE_OSCALL (ACE_ADAPT_RETVAL (timeout == 0
        -:  438:                                ? pthread_cond_wait (cv, external_mutex)
        -:  439:                                : pthread_cond_timedwait (cv, external_mutex,
        -:  440:                                                            (ACE_TIMESPEC_PTR) &ts),
        -:  441:                                result),
        -:  442:              int, -1, result);
        -:  443:  // We need to adjust this to make the POSIX and Solaris return
        -:  444:  // values consistent.  EAGAIN is from Pthreads DRAFT4 (HP-UX 10.20 and down)
        -:  445:  if (result == -1 &&
        -:  446:      (errno == ETIMEDOUT || errno == EAGAIN))
        -:  447:    errno = ETIME;
        -:  448:
        -:  449:#   elif defined (ACE_HAS_STHREADS)
        -:  450:  ACE_OSCALL (ACE_ADAPT_RETVAL (timeout == 0
        -:  451:                                ? ::cond_wait (cv, external_mutex)
        -:  452:                                : ::cond_timedwait (cv,
        -:  453:                                                    external_mutex,
        -:  454:                                                    (timestruc_t*)&ts),
        -:  455:                                result),
        -:  456:              int, -1, result);
        -:  457:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  458:  int msec_timeout = 0;
        -:  459:  if (timeout != 0)
        -:  460:    {
        -:  461:      ACE_Time_Value relative_time = timeout->to_relative_time ();
        -:  462:      // Watchout for situations where a context switch has caused the
        -:  463:      // current time to be > the timeout.
        -:  464:      if (relative_time > ACE_Time_Value::zero)
        -:  465:        msec_timeout = relative_time.msec ();
        -:  466:    }
        -:  467:
        -:  468:  ACE_OSCALL (ACE_ADAPT_RETVAL (::SleepConditionVariableCS (cv, &external_mutex->thr_mutex_, msec_timeout),
        -:  469:                                result),
        -:  470:              int, -1, result);
        -:  471:
        -:  472:  return result;
        -:  473:#   endif /* ACE_HAS_STHREADS */
        -:  474:  if (timeout != 0)
        -:  475:    timeout->set (ts); // Update the time value before returning.
        -:  476:
        -:  477:  return result;
        -:  478:# else
        -:  479:  ACE_UNUSED_ARG (cv);
        -:  480:  ACE_UNUSED_ARG (external_mutex);
        -:  481:  ACE_UNUSED_ARG (timeout);
        -:  482:  ACE_NOTSUP_RETURN (-1);
        -:  483:# endif /* ACE_HAS_THREADS */
        -:  484:}
        -:  485:#endif /* !ACE_LACKS_COND_T */
        -:  486:
        -:  487:ACE_INLINE int
        -:  488:ACE_OS::mutex_lock (ACE_mutex_t *m,
        -:  489:                    const ACE_Time_Value *timeout)
        -:  490:{
        -:  491:  return timeout == 0 ? ACE_OS::mutex_lock (m) : ACE_OS::mutex_lock (m, *timeout);
        -:  492:}
        -:  493:
        -:  494:ACE_INLINE int
        -:  495:ACE_OS::event_wait (ACE_event_t *event)
        -:  496:{
        -:  497:  return ACE_OS::event_timedwait (event, 0);
        -:  498:}
        -:  499:
        -:  500:ACE_INLINE int
        -:  501:ACE_OS::event_init (ACE_event_t *event,
        -:  502:                    int manual_reset,
        -:  503:                    int initial_state,
        -:  504:                    int type,
        -:  505:                    const char *name,
        -:  506:                    void *arg,
        -:  507:                    LPSECURITY_ATTRIBUTES sa)
        -:  508:{
        -:  509:  ACE_condattr_t *pattr = 0;
        -:  510:  return ACE_OS::event_init (event, type, pattr, manual_reset, initial_state, name, arg, sa);
        -:  511:}
        -:  512:
        -:  513:#if defined (ACE_HAS_WCHAR)
        -:  514:ACE_INLINE int
        -:  515:ACE_OS::event_init (ACE_event_t *event,
        -:  516:                    int manual_reset,
        -:  517:                    int initial_state,
        -:  518:                    int type,
        -:  519:                    const wchar_t *name,
        -:  520:                    void *arg,
        -:  521:                    LPSECURITY_ATTRIBUTES sa)
        -:  522:{
        -:  523:#if defined (ACE_WIN32)
        -:  524:  ACE_UNUSED_ARG (type);
        -:  525:  ACE_UNUSED_ARG (arg);
        -:  526:  SECURITY_ATTRIBUTES sa_buffer;
        -:  527:  SECURITY_DESCRIPTOR sd_buffer;
        -:  528:  *event = ::CreateEventW (ACE_OS::default_win32_security_attributes_r
        -:  529:      (sa, &sa_buffer, &sd_buffer),
        -:  530:  manual_reset,
        -:  531:  initial_state,
        -:  532:  name);
        -:  533:  if (*event == 0)
        -:  534:    ACE_FAIL_RETURN (-1);
        -:  535:
        -:  536:  // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -:  537:  ACE_OS::set_errno_to_last_error ();
        -:  538:  return 0;
        -:  539:#else  /* ACE_WIN32 */
        -:  540:  return ACE_OS::event_init (event,
        -:  541:                             manual_reset,
        -:  542:                             initial_state,
        -:  543:                             type,
        -:  544:                             ACE_Wide_To_Ascii (name).char_rep (),
        -:  545:                             arg,
        -:  546:                             sa);
        -:  547:#endif /* ACE_WIN32 */
        -:  548:}
        -:  549:
        -:  550:ACE_INLINE int
        -:  551:ACE_OS::event_init (ACE_event_t *event,
        -:  552:                    int type,
        -:  553:                    ACE_condattr_t *attributes,
        -:  554:                    int manual_reset,
        -:  555:                    int initial_state,
        -:  556:                    const wchar_t *name,
        -:  557:                    void *arg,
        -:  558:                    LPSECURITY_ATTRIBUTES sa)
        -:  559:{
        -:  560:#if defined (ACE_WIN32)
        -:  561:  ACE_UNUSED_ARG (type);
        -:  562:  ACE_UNUSED_ARG (attributes);
        -:  563:  ACE_UNUSED_ARG (arg);
        -:  564:  SECURITY_ATTRIBUTES sa_buffer;
        -:  565:  SECURITY_DESCRIPTOR sd_buffer;
        -:  566:  *event = ::CreateEventW (ACE_OS::default_win32_security_attributes_r
        -:  567:      (sa, &sa_buffer, &sd_buffer),
        -:  568:  manual_reset,
        -:  569:  initial_state,
        -:  570:  name);
        -:  571:  if (*event == 0)
        -:  572:    ACE_FAIL_RETURN (-1);
        -:  573:
        -:  574:  // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -:  575:  ACE_OS::set_errno_to_last_error ();
        -:  576:  return 0;
        -:  577:#else  /* ACE_WIN32 */
        -:  578:  return ACE_OS::event_init (event,
        -:  579:                             type,
        -:  580:                             attributes,
        -:  581:                             manual_reset,
        -:  582:                             initial_state,
        -:  583:                             ACE_Wide_To_Ascii (name).char_rep (),
        -:  584:                             arg,
        -:  585:                             sa);
        -:  586:#endif /* ACE_WIN32 */
        -:  587:}
        -:  588:#endif /* ACE_HAS_WCHAR */
        -:  589:
        -:  590:ACE_INLINE long
        -:  591:ACE_OS::priority_control (ACE_idtype_t idtype, ACE_id_t identifier, int cmd, void *arg)
        -:  592:{
        -:  593:  ACE_OS_TRACE ("ACE_OS::priority_control");
        -:  594:#if defined (ACE_HAS_PRIOCNTL)
        -:  595:  ACE_OSCALL_RETURN (priocntl (idtype, identifier, cmd, static_cast<caddr_t> (arg)),
        -:  596:                     long, -1);
        -:  597:#else  /* ! ACE_HAS_PRIOCNTL*/
        -:  598:  ACE_UNUSED_ARG (idtype);
        -:  599:  ACE_UNUSED_ARG (identifier);
        -:  600:  ACE_UNUSED_ARG (cmd);
        -:  601:  ACE_UNUSED_ARG (arg);
        -:  602:  ACE_NOTSUP_RETURN (-1);
        -:  603:#endif /* ! ACE_HAS_PRIOCNTL*/
        -:  604:}
        -:  605:
        -:  606:// This method is used to prepare the recursive mutex for releasing
        -:  607:// when waiting on a condition variable. If the platform doesn't have
        -:  608:// native recursive mutex and condition variable support, then ACE needs
        -:  609:// to save the recursion state around the wait and also ensure that the
        -:  610:// wait and lock release are atomic. recursive_mutex_cond_relock()
        -:  611:// is the inverse of this method.
        -:  612:ACE_INLINE int
        -:  613:ACE_OS::recursive_mutex_cond_unlock (ACE_recursive_thread_mutex_t *m,
        -:  614:                                     ACE_recursive_mutex_state &state)
        -:  615:{
        -:  616:#if defined (ACE_HAS_THREADS)
        -:  617:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_cond_unlock");
        -:  618:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  619:  // Windows need special handling since it has recursive mutexes, but
        -:  620:  // does not integrate them into a condition variable.
        -:  621:#    if defined (ACE_WIN32)
        -:  622:  // For Windows, the OS takes care of the mutex and its recursion. We just
        -:  623:  // need to release the lock one fewer times than this thread has acquired
        -:  624:  // it. Remember how many times, and reacquire it that many more times when
        -:  625:  // the condition is signaled.
        -:  626:
        -:  627:  // We're using undocumented fields in the CRITICAL_SECTION structure
        -:  628:  // and they've been known to change across Windows variants and versions./
        -:  629:  // So be careful if you need to change these - there may be other
        -:  630:  // Windows variants that depend on existing values and limits.
        -:  631:
        -:  632:  state.relock_count_ = 0;
        -:  633:  while (
        -:  634:#      if !defined (ACE_HAS_WINCE)
        -:  635:         m->LockCount > 0 && m->RecursionCount > 1
        -:  636:#      else
        -:  637:         // WinCE doesn't have RecursionCount and the LockCount semantic
        -:  638:         // Mobile 5 has it 1-indexed.
        -:  639:         m->LockCount > 1
        -:  640:#      endif /* ACE_HAS_WINCE */
        -:  641:         )
        -:  642:    {
        -:  643:      // This may fail if the current thread doesn't own the mutex. If it
        -:  644:      // does fail, it'll be on the first try, so don't worry about resetting
        -:  645:      // the state.
        -:  646:      if (ACE_OS::recursive_mutex_unlock (m) == -1)
        -:  647:        return -1;
        -:  648:      ++state.relock_count_;
        -:  649:    }
        -:  650:#    else /* not ACE_WIN32 */
        -:  651:    // prevent warnings for unused variables
        -:  652:    ACE_UNUSED_ARG (state);
        -:  653:    ACE_UNUSED_ARG (m);
        -:  654:#    endif /* ACE_WIN32 */
        -:  655:  return 0;
        -:  656:#  else /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  657:  // For platforms without recursive mutexes, we obtain the nesting mutex
        -:  658:  // to gain control over the mutex internals. Then set the internals to say
        -:  659:  // the mutex is available. If there are waiters, signal the condition
        -:  660:  // to notify them (this is mostly like the recursive_mutex_unlock() method).
        -:  661:  // Then, return with the nesting mutex still held. The condition wait
        -:  662:  // will release it atomically, allowing mutex waiters to continue.
        -:  663:  // Note that this arrangement relies on the fact that on return from
        -:  664:  // the condition wait, this thread will again own the nesting mutex
        -:  665:  // and can either set the mutex internals directly or get in line for
        -:  666:  // the mutex... this part is handled in recursive_mutex_cond_relock().
        -:  667:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  668:    return -1;
        -:  669:
        -:  670:#    if !defined (ACE_NDEBUG)
        -:  671:  if (m->nesting_level_ == 0
        -:  672:      || ACE_OS::thr_equal (ACE_OS::thr_self (), m->owner_id_) == 0)
        -:  673:    {
        -:  674:      ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  675:      errno = EINVAL;
        -:  676:      return -1;
        -:  677:    }
        -:  678:#    endif /* ACE_NDEBUG */
        -:  679:
        -:  680:  // To make error recovery a bit easier, signal the condition now. Any
        -:  681:  // waiter won't regain control until the mutex is released, which won't
        -:  682:  // be until the caller returns and does the wait on the condition.
        -:  683:  if (ACE_OS::cond_signal (&m->lock_available_) == -1)
        -:  684:    {
        -:  685:      // Save/restore errno.
        -:  686:      ACE_Errno_Guard error (errno);
        -:  687:      ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  688:      return -1;
        -:  689:    }
        -:  690:
        -:  691:  // Ok, the nesting_mutex_ lock is still held, the condition has been
        -:  692:  // signaled... reset the nesting info and return _WITH_ the lock
        -:  693:  // held. The lock will be released when the condition waits, in the
        -:  694:  // caller.
        -:  695:  state.nesting_level_ = m->nesting_level_;
        -:  696:  state.owner_id_ = m->owner_id_;
        -:  697:  m->nesting_level_ = 0;
        -:  698:  m->owner_id_ = ACE_OS::NULL_thread;
        -:  699:  return 0;
        -:  700:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  701:#else
        -:  702:  ACE_UNUSED_ARG (m);
        -:  703:  ACE_UNUSED_ARG (state);
        -:  704:  ACE_NOTSUP_RETURN (-1);
        -:  705:#endif /* ACE_HAS_THREADS */
        -:  706:}
        -:  707:
        -:  708:
        -:  709:// This method is called after waiting on a condition variable when a
        -:  710:// recursive mutex must be reacquired. If the platform doesn't natively
        -:  711:// integrate recursive mutexes and condition variables, it's taken care
        -:  712:// of here (inverse of ACE_OS::recursive_mutex_cond_unlock).
        -:  713:ACE_INLINE void
        -:  714:ACE_OS::recursive_mutex_cond_relock (ACE_recursive_thread_mutex_t *m,
        -:  715:                                     ACE_recursive_mutex_state &state)
        -:  716:{
        -:  717:#if defined (ACE_HAS_THREADS)
        -:  718:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_cond_relock");
        -:  719:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  720:  // Windows need special handling since it has recursive mutexes, but
        -:  721:  // does not integrate them into a condition variable.
        -:  722:  // On entry, the OS has already reacquired the lock for us. Just
        -:  723:  // reacquire it the proper number of times so the recursion is the same as
        -:  724:  // before waiting on the condition.
        -:  725:#    if defined (ACE_WIN32)
        -:  726:  while (state.relock_count_ > 0)
        -:  727:    {
        -:  728:      ACE_OS::recursive_mutex_lock (m);
        -:  729:      --state.relock_count_;
        -:  730:    }
        -:  731:  return;
        -:  732:#    else /* not ACE_WIN32 */
        -:  733:    // prevent warnings for unused variables
        -:  734:    ACE_UNUSED_ARG (state);
        -:  735:    ACE_UNUSED_ARG (m);
        -:  736:
        -:  737:#    endif /* ACE_WIN32 */
        -:  738:#  else
        -:  739:  // Without recursive mutex support, it's somewhat trickier. On entry,
        -:  740:  // the current thread holds the nesting_mutex_, but another thread may
        -:  741:  // still be holding the ACE_recursive_mutex_t. If so, mimic the code
        -:  742:  // in ACE_OS::recursive_mutex_lock that waits to acquire the mutex.
        -:  743:  // After acquiring it, restore the nesting counts and release the
        -:  744:  // nesting mutex. This will restore the conditions to what they were
        -:  745:  // before calling ACE_OS::recursive_mutex_cond_unlock().
        -:  746:  while (m->nesting_level_ > 0)
        -:  747:    ACE_OS::cond_wait (&m->lock_available_, &m->nesting_mutex_);
        -:  748:
        -:  749:  // At this point, we still have nesting_mutex_ and the mutex is free.
        -:  750:  m->nesting_level_ = state.nesting_level_;
        -:  751:  m->owner_id_ = state.owner_id_;
        -:  752:  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  753:  return;
        -:  754:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  755:#else
        -:  756:  ACE_UNUSED_ARG (m);
        -:  757:  ACE_UNUSED_ARG (state);
        -:  758:  return;
        -:  759:#endif /* ACE_HAS_THREADS */
        -:  760:}
        -:  761:
        -:  762:ACE_INLINE int
        -:  763:ACE_OS::recursive_mutex_destroy (ACE_recursive_thread_mutex_t *m)
        -:  764:{
        -:  765:#if defined (ACE_HAS_THREADS)
        -:  766:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  767:  return ACE_OS::thread_mutex_destroy (m);
        -:  768:#else
        -:  769:  if (ACE_OS::cond_destroy (&m->lock_available_) == -1
        -:  770:      || ACE_OS::thread_mutex_destroy (&m->nesting_mutex_) == -1)
        -:  771:    return -1;
        -:  772:  return 0;
        -:  773:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  774:#else
        -:  775:  ACE_UNUSED_ARG (m);
        -:  776:  ACE_NOTSUP_RETURN (-1);
        -:  777:#endif /* ACE_HAS_THREADS */
        -:  778:}
        -:  779:
        -:  780:ACE_INLINE int
        -:  781:ACE_OS::recursive_mutex_init (ACE_recursive_thread_mutex_t *m,
        -:  782:                              const ACE_TCHAR *name,
        -:  783:                              ACE_mutexattr_t *arg,
        -:  784:                              LPSECURITY_ATTRIBUTES sa)
        -:  785:{
        -:  786:  ACE_UNUSED_ARG (sa);
        -:  787:#if defined (ACE_HAS_THREADS)
        -:  788:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  789:#    if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -:  790:  return ACE_OS::thread_mutex_init (m, PTHREAD_MUTEX_RECURSIVE, name, arg);
        -:  791:#    else
        -:  792:  return ACE_OS::thread_mutex_init (m, 0, name, arg);
        -:  793:#    endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -:  794:#  else
        -:  795:  if (ACE_OS::thread_mutex_init (&m->nesting_mutex_, 0, name, arg) == -1)
        -:  796:    return -1;
        -:  797:  else if (ACE_OS::cond_init (&m->lock_available_,
        -:  798:                              (short) USYNC_THREAD,
        -:  799:                              name,
        -:  800:                              0) == -1)
        -:  801:    return -1;
        -:  802:  else
        -:  803:    {
        -:  804:      m->nesting_level_ = 0;
        -:  805:      m->owner_id_ = ACE_OS::NULL_thread;
        -:  806:      return 0;
        -:  807:    }
        -:  808:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  809:#else
        -:  810:  ACE_UNUSED_ARG (m);
        -:  811:  ACE_UNUSED_ARG (name);
        -:  812:  ACE_UNUSED_ARG (arg);
        -:  813:  ACE_NOTSUP_RETURN (-1);
        -:  814:#endif /* ACE_HAS_THREADS */
        -:  815:}
        -:  816:
        -:  817:ACE_INLINE int
    #####:  818:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m)
        -:  819:{
        -:  820:#if defined (ACE_HAS_THREADS)
        -:  821:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
    #####:  822:  return ACE_OS::thread_mutex_lock (m);
        -:  823:#else
        -:  824:  ACE_thread_t const t_id = ACE_OS::thr_self ();
        -:  825:  int result = 0;
        -:  826:
        -:  827:  // Acquire the guard.
        -:  828:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  829:    result = -1;
        -:  830:  else
        -:  831:  {
        -:  832:    // If there's no contention, just grab the lock immediately
        -:  833:    // (since this is the common case we'll optimize for it).
        -:  834:    if (m->nesting_level_ == 0)
        -:  835:      m->owner_id_ = t_id;
        -:  836:      // If we already own the lock, then increment the nesting level
        -:  837:      // and return.
        -:  838:    else if (ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -:  839:    {
        -:  840:          // Wait until the nesting level has dropped to zero, at
        -:  841:          // which point we can acquire the lock.
        -:  842:      while (m->nesting_level_ > 0)
        -:  843:        ACE_OS::cond_wait (&m->lock_available_,
        -:  844:                            &m->nesting_mutex_);
        -:  845:
        -:  846:          // At this point the nesting_mutex_ is held...
        -:  847:      m->owner_id_ = t_id;
        -:  848:    }
        -:  849:
        -:  850:    // At this point, we can safely increment the nesting_level_ no
        -:  851:    // matter how we got here!
        -:  852:    ++m->nesting_level_;
        -:  853:  }
        -:  854:
        -:  855:  {
        -:  856:    // Save/restore errno.
        -:  857:    ACE_Errno_Guard error (errno);
        -:  858:    ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  859:  }
        -:  860:  return result;
        -:  861:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  862:#else
        -:  863:  ACE_UNUSED_ARG (m);
        -:  864:  ACE_NOTSUP_RETURN (-1);
        -:  865:#endif /* ACE_HAS_THREADS */
        -:  866:}
------------------
_ZN6ACE_OS20recursive_mutex_lockEP15pthread_mutex_t:
    #####:  818:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m)
        -:  819:{
        -:  820:#if defined (ACE_HAS_THREADS)
        -:  821:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
    #####:  822:  return ACE_OS::thread_mutex_lock (m);
        -:  823:#else
        -:  824:  ACE_thread_t const t_id = ACE_OS::thr_self ();
        -:  825:  int result = 0;
        -:  826:
        -:  827:  // Acquire the guard.
        -:  828:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  829:    result = -1;
        -:  830:  else
        -:  831:  {
        -:  832:    // If there's no contention, just grab the lock immediately
        -:  833:    // (since this is the common case we'll optimize for it).
        -:  834:    if (m->nesting_level_ == 0)
        -:  835:      m->owner_id_ = t_id;
        -:  836:      // If we already own the lock, then increment the nesting level
        -:  837:      // and return.
        -:  838:    else if (ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -:  839:    {
        -:  840:          // Wait until the nesting level has dropped to zero, at
        -:  841:          // which point we can acquire the lock.
        -:  842:      while (m->nesting_level_ > 0)
        -:  843:        ACE_OS::cond_wait (&m->lock_available_,
        -:  844:                            &m->nesting_mutex_);
        -:  845:
        -:  846:          // At this point the nesting_mutex_ is held...
        -:  847:      m->owner_id_ = t_id;
        -:  848:    }
        -:  849:
        -:  850:    // At this point, we can safely increment the nesting_level_ no
        -:  851:    // matter how we got here!
        -:  852:    ++m->nesting_level_;
        -:  853:  }
        -:  854:
        -:  855:  {
        -:  856:    // Save/restore errno.
        -:  857:    ACE_Errno_Guard error (errno);
        -:  858:    ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  859:  }
        -:  860:  return result;
        -:  861:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  862:#else
        -:  863:  ACE_UNUSED_ARG (m);
        -:  864:  ACE_NOTSUP_RETURN (-1);
        -:  865:#endif /* ACE_HAS_THREADS */
        -:  866:}
------------------
_ZN6ACE_OS20recursive_mutex_lockEP15pthread_mutex_t:
    #####:  818:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m)
        -:  819:{
        -:  820:#if defined (ACE_HAS_THREADS)
        -:  821:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
    #####:  822:  return ACE_OS::thread_mutex_lock (m);
        -:  823:#else
        -:  824:  ACE_thread_t const t_id = ACE_OS::thr_self ();
        -:  825:  int result = 0;
        -:  826:
        -:  827:  // Acquire the guard.
        -:  828:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  829:    result = -1;
        -:  830:  else
        -:  831:  {
        -:  832:    // If there's no contention, just grab the lock immediately
        -:  833:    // (since this is the common case we'll optimize for it).
        -:  834:    if (m->nesting_level_ == 0)
        -:  835:      m->owner_id_ = t_id;
        -:  836:      // If we already own the lock, then increment the nesting level
        -:  837:      // and return.
        -:  838:    else if (ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -:  839:    {
        -:  840:          // Wait until the nesting level has dropped to zero, at
        -:  841:          // which point we can acquire the lock.
        -:  842:      while (m->nesting_level_ > 0)
        -:  843:        ACE_OS::cond_wait (&m->lock_available_,
        -:  844:                            &m->nesting_mutex_);
        -:  845:
        -:  846:          // At this point the nesting_mutex_ is held...
        -:  847:      m->owner_id_ = t_id;
        -:  848:    }
        -:  849:
        -:  850:    // At this point, we can safely increment the nesting_level_ no
        -:  851:    // matter how we got here!
        -:  852:    ++m->nesting_level_;
        -:  853:  }
        -:  854:
        -:  855:  {
        -:  856:    // Save/restore errno.
        -:  857:    ACE_Errno_Guard error (errno);
        -:  858:    ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  859:  }
        -:  860:  return result;
        -:  861:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  862:#else
        -:  863:  ACE_UNUSED_ARG (m);
        -:  864:  ACE_NOTSUP_RETURN (-1);
        -:  865:#endif /* ACE_HAS_THREADS */
        -:  866:}
------------------
        -:  867:
        -:  868:ACE_INLINE int
        -:  869:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m,
        -:  870:                              const ACE_Time_Value &timeout)
        -:  871:{
        -:  872:#if defined (ACE_HAS_THREADS)
        -:  873:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  874:  return ACE_OS::thread_mutex_lock (m, timeout);
        -:  875:#else
        -:  876:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  877:  int result = 0;
        -:  878:
        -:  879:  // Try to acquire the guard.
        -:  880:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_, timeout) == -1)
        -:  881:    result = -1;
        -:  882:  else
        -:  883:    {
        -:  884:      // If there's no contention, just grab the lock immediately
        -:  885:      // (since this is the common case we'll optimize for it).
        -:  886:      if (m->nesting_level_ == 0)
        -:  887:        m->owner_id_ = t_id;
        -:  888:      // If we already own the lock, then increment the nesting level
        -:  889:      // and return.
        -:  890:      else if (ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -:  891:        {
        -:  892:          // Wait until the nesting level has dropped to zero, at
        -:  893:          // which point we can acquire the lock.
        -:  894:          while (m->nesting_level_ > 0)
        -:  895:            {
        -:  896:              result = ACE_OS::cond_timedwait (&m->lock_available_,
        -:  897:                                               &m->nesting_mutex_,
        -:  898:                                               const_cast <ACE_Time_Value *> (&timeout));
        -:  899:
        -:  900:              // The mutex is reacquired even in the case of a timeout
        -:  901:              // release the mutex to prevent a deadlock
        -:  902:              if (result == -1)
        -:  903:                {
        -:  904:                  // Save/restore errno.
        -:  905:                  ACE_Errno_Guard error (errno);
        -:  906:                  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  907:
        -:  908:                  return result;
        -:  909:                }
        -:  910:            }
        -:  911:
        -:  912:          // At this point the nesting_mutex_ is held...
        -:  913:          m->owner_id_ = t_id;
        -:  914:        }
        -:  915:
        -:  916:      // At this point, we can safely increment the nesting_level_ no
        -:  917:      // matter how we got here!
        -:  918:      m->nesting_level_++;
        -:  919:
        -:  920:      // Save/restore errno.
        -:  921:      ACE_Errno_Guard error (errno);
        -:  922:      ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  923:    }
        -:  924:  return result;
        -:  925:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  926:#else
        -:  927:  ACE_UNUSED_ARG (m);
        -:  928:  ACE_UNUSED_ARG (timeout);
        -:  929:  ACE_NOTSUP_RETURN (-1);
        -:  930:#endif /* ACE_HAS_THREADS */
        -:  931:}
        -:  932:
        -:  933:ACE_INLINE int
        -:  934:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m,
        -:  935:                              const ACE_Time_Value *timeout)
        -:  936:{
        -:  937:  return timeout == 0
        -:  938:    ? ACE_OS::recursive_mutex_lock (m)
        -:  939:    : ACE_OS::recursive_mutex_lock (m, *timeout);
        -:  940:}
        -:  941:
        -:  942:ACE_INLINE int
        -:  943:ACE_OS::recursive_mutex_trylock (ACE_recursive_thread_mutex_t *m)
        -:  944:{
        -:  945:#if defined (ACE_HAS_THREADS)
        -:  946:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  947:  return ACE_OS::thread_mutex_trylock (m);
        -:  948:#else
        -:  949:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  950:  int result = 0;
        -:  951:
        -:  952:  // Acquire the guard.
        -:  953:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  954:    result = -1;
        -:  955:  else
        -:  956:  {
        -:  957:      // If there's no contention, just grab the lock immediately.
        -:  958:    if (m->nesting_level_ == 0)
        -:  959:    {
        -:  960:      m->owner_id_ = t_id;
        -:  961:      m->nesting_level_ = 1;
        -:  962:    }
        -:  963:      // If we already own the lock, then increment the nesting level
        -:  964:      // and proceed.
        -:  965:    else if (ACE_OS::thr_equal (t_id, m->owner_id_))
        -:  966:      m->nesting_level_++;
        -:  967:    else
        -:  968:    {
        -:  969:      errno = EBUSY;
        -:  970:      result = -1;
        -:  971:    }
        -:  972:  }
        -:  973:
        -:  974:  {
        -:  975:    // Save/restore errno.
        -:  976:    ACE_Errno_Guard error (errno);
        -:  977:    ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  978:  }
        -:  979:  return result;
        -:  980:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  981:#else
        -:  982:  ACE_UNUSED_ARG (m);
        -:  983:  ACE_NOTSUP_RETURN (-1);
        -:  984:#endif /* ACE_HAS_THREADS */
        -:  985:}
        -:  986:
        -:  987:ACE_INLINE int
    #####:  988:ACE_OS::recursive_mutex_unlock (ACE_recursive_thread_mutex_t *m)
        -:  989:{
        -:  990:#if defined (ACE_HAS_THREADS)
        -:  991:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
    #####:  992:  return ACE_OS::thread_mutex_unlock (m);
        -:  993:#  else
        -:  994:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_unlock");
        -:  995:#    if !defined (ACE_NDEBUG)
        -:  996:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  997:#    endif /* ACE_NDEBUG */
        -:  998:  int result = 0;
        -:  999:
        -: 1000:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -: 1001:    result = -1;
        -: 1002:  else
        -: 1003:  {
        -: 1004:#    if !defined (ACE_NDEBUG)
        -: 1005:      if (m->nesting_level_ == 0
        -: 1006:          || ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -: 1007:{
        -: 1008:  errno = EINVAL;
        -: 1009:  result = -1;
        -: 1010:}
        -: 1011:      else
        -: 1012:#    endif /* ACE_NDEBUG */
        -: 1013:{
        -: 1014:  m->nesting_level_--;
        -: 1015:  if (m->nesting_level_ == 0)
        -: 1016:  {
        -: 1017:              // This may not be strictly necessary, but it does put
        -: 1018:              // the mutex into a known state...
        -: 1019:    m->owner_id_ = ACE_OS::NULL_thread;
        -: 1020:
        -: 1021:              // Inform a waiter that the lock is free.
        -: 1022:    if (ACE_OS::cond_signal (&m->lock_available_) == -1)
        -: 1023:      result = -1;
        -: 1024:  }
        -: 1025:}
        -: 1026:  }
        -: 1027:
        -: 1028:{
        -: 1029:    // Save/restore errno.
        -: 1030:  ACE_Errno_Guard error (errno);
        -: 1031:  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -: 1032:}
        -: 1033:  return result;
        -: 1034:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -: 1035:#else
        -: 1036:  ACE_UNUSED_ARG (m);
        -: 1037:  ACE_NOTSUP_RETURN (-1);
        -: 1038:#endif /* ACE_HAS_THREADS */
        -: 1039:}
------------------
_ZN6ACE_OS22recursive_mutex_unlockEP15pthread_mutex_t:
    #####:  988:ACE_OS::recursive_mutex_unlock (ACE_recursive_thread_mutex_t *m)
        -:  989:{
        -:  990:#if defined (ACE_HAS_THREADS)
        -:  991:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
    #####:  992:  return ACE_OS::thread_mutex_unlock (m);
        -:  993:#  else
        -:  994:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_unlock");
        -:  995:#    if !defined (ACE_NDEBUG)
        -:  996:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  997:#    endif /* ACE_NDEBUG */
        -:  998:  int result = 0;
        -:  999:
        -: 1000:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -: 1001:    result = -1;
        -: 1002:  else
        -: 1003:  {
        -: 1004:#    if !defined (ACE_NDEBUG)
        -: 1005:      if (m->nesting_level_ == 0
        -: 1006:          || ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -: 1007:{
        -: 1008:  errno = EINVAL;
        -: 1009:  result = -1;
        -: 1010:}
        -: 1011:      else
        -: 1012:#    endif /* ACE_NDEBUG */
        -: 1013:{
        -: 1014:  m->nesting_level_--;
        -: 1015:  if (m->nesting_level_ == 0)
        -: 1016:  {
        -: 1017:              // This may not be strictly necessary, but it does put
        -: 1018:              // the mutex into a known state...
        -: 1019:    m->owner_id_ = ACE_OS::NULL_thread;
        -: 1020:
        -: 1021:              // Inform a waiter that the lock is free.
        -: 1022:    if (ACE_OS::cond_signal (&m->lock_available_) == -1)
        -: 1023:      result = -1;
        -: 1024:  }
        -: 1025:}
        -: 1026:  }
        -: 1027:
        -: 1028:{
        -: 1029:    // Save/restore errno.
        -: 1030:  ACE_Errno_Guard error (errno);
        -: 1031:  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -: 1032:}
        -: 1033:  return result;
        -: 1034:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -: 1035:#else
        -: 1036:  ACE_UNUSED_ARG (m);
        -: 1037:  ACE_NOTSUP_RETURN (-1);
        -: 1038:#endif /* ACE_HAS_THREADS */
        -: 1039:}
------------------
_ZN6ACE_OS22recursive_mutex_unlockEP15pthread_mutex_t:
    #####:  988:ACE_OS::recursive_mutex_unlock (ACE_recursive_thread_mutex_t *m)
        -:  989:{
        -:  990:#if defined (ACE_HAS_THREADS)
        -:  991:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
    #####:  992:  return ACE_OS::thread_mutex_unlock (m);
        -:  993:#  else
        -:  994:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_unlock");
        -:  995:#    if !defined (ACE_NDEBUG)
        -:  996:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  997:#    endif /* ACE_NDEBUG */
        -:  998:  int result = 0;
        -:  999:
        -: 1000:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -: 1001:    result = -1;
        -: 1002:  else
        -: 1003:  {
        -: 1004:#    if !defined (ACE_NDEBUG)
        -: 1005:      if (m->nesting_level_ == 0
        -: 1006:          || ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -: 1007:{
        -: 1008:  errno = EINVAL;
        -: 1009:  result = -1;
        -: 1010:}
        -: 1011:      else
        -: 1012:#    endif /* ACE_NDEBUG */
        -: 1013:{
        -: 1014:  m->nesting_level_--;
        -: 1015:  if (m->nesting_level_ == 0)
        -: 1016:  {
        -: 1017:              // This may not be strictly necessary, but it does put
        -: 1018:              // the mutex into a known state...
        -: 1019:    m->owner_id_ = ACE_OS::NULL_thread;
        -: 1020:
        -: 1021:              // Inform a waiter that the lock is free.
        -: 1022:    if (ACE_OS::cond_signal (&m->lock_available_) == -1)
        -: 1023:      result = -1;
        -: 1024:  }
        -: 1025:}
        -: 1026:  }
        -: 1027:
        -: 1028:{
        -: 1029:    // Save/restore errno.
        -: 1030:  ACE_Errno_Guard error (errno);
        -: 1031:  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -: 1032:}
        -: 1033:  return result;
        -: 1034:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -: 1035:#else
        -: 1036:  ACE_UNUSED_ARG (m);
        -: 1037:  ACE_NOTSUP_RETURN (-1);
        -: 1038:#endif /* ACE_HAS_THREADS */
        -: 1039:}
------------------
        -: 1040:
        -: 1041:ACE_INLINE int
        -: 1042:ACE_OS::rw_rdlock (ACE_rwlock_t *rw)
        -: 1043:{
        -: 1044:  ACE_OS_TRACE ("ACE_OS::rw_rdlock");
        -: 1045:#if defined (ACE_HAS_THREADS)
        -: 1046:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1047:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1048:  int result;
        -: 1049:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_rdlock (rw),
        -: 1050:                                       result),
        -: 1051:                     int, -1);
        -: 1052:#  else /* Solaris */
        -: 1053:  int result;
        -: 1054:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_rdlock (rw), result), int, -1);
        -: 1055:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1056:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1057:#   if defined (ACE_HAS_PTHREADS)
        -: 1058:  ACE_PTHREAD_CLEANUP_PUSH (&rw->lock_);
        -: 1059:#   endif /* ACE_HAS_PTHREADS */
        -: 1060:  int result = 0;
        -: 1061:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1062:    result = -1; // -1 means didn't get the mutex.
        -: 1063:  else
        -: 1064:    {
        -: 1065:      // Give preference to writers who are waiting.
        -: 1066:      while (rw->ref_count_ < 0 || rw->num_waiting_writers_ > 0)
        -: 1067:        {
        -: 1068:          rw->num_waiting_readers_++;
        -: 1069:          if (ACE_OS::cond_wait (&rw->waiting_readers_, &rw->lock_) == -1)
        -: 1070:            {
        -: 1071:              result = -2; // -2 means that we need to release the mutex.
        -: 1072:              break;
        -: 1073:            }
        -: 1074:          rw->num_waiting_readers_--;
        -: 1075:        }
        -: 1076:    }
        -: 1077:  if (result == 0)
        -: 1078:    rw->ref_count_++;
        -: 1079:  if (result != -1)
        -: 1080:    ACE_OS::mutex_unlock (&rw->lock_);
        -: 1081:#   if defined (ACE_HAS_PTHREADS)
        -: 1082:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 1083:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1084:  return 0;
        -: 1085:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1086:#else
        -: 1087:  ACE_UNUSED_ARG (rw);
        -: 1088:  ACE_NOTSUP_RETURN (-1);
        -: 1089:#endif /* ACE_HAS_THREADS */
        -: 1090:}
        -: 1091:
        -: 1092:ACE_INLINE int
        -: 1093:ACE_OS::rw_tryrdlock (ACE_rwlock_t *rw)
        -: 1094:{
        -: 1095:  ACE_OS_TRACE ("ACE_OS::rw_tryrdlock");
        -: 1096:#if defined (ACE_HAS_THREADS)
        -: 1097:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1098:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1099:  int result;
        -: 1100:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_tryrdlock (rw),
        -: 1101:                                       result),
        -: 1102:                     int, -1);
        -: 1103:#  else /* Solaris */
        -: 1104:  int result;
        -: 1105:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_tryrdlock (rw), result), int, -1);
        -: 1106:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1107:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1108:  int result = -1;
        -: 1109:
        -: 1110:  if (ACE_OS::mutex_lock (&rw->lock_) != -1)
        -: 1111:    {
        -: 1112:      ACE_Errno_Guard error (errno);
        -: 1113:
        -: 1114:      if (rw->ref_count_ == -1 || rw->num_waiting_writers_ > 0)
        -: 1115:        {
        -: 1116:          error = EBUSY;
        -: 1117:          result = -1;
        -: 1118:        }
        -: 1119:      else
        -: 1120:        {
        -: 1121:          rw->ref_count_++;
        -: 1122:          result = 0;
        -: 1123:        }
        -: 1124:
        -: 1125:      ACE_OS::mutex_unlock (&rw->lock_);
        -: 1126:    }
        -: 1127:  return result;
        -: 1128:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1129:#else
        -: 1130:  ACE_UNUSED_ARG (rw);
        -: 1131:  ACE_NOTSUP_RETURN (-1);
        -: 1132:#endif /* ACE_HAS_THREADS */
        -: 1133:}
        -: 1134:
        -: 1135:ACE_INLINE int
        -: 1136:ACE_OS::rw_trywrlock (ACE_rwlock_t *rw)
        -: 1137:{
        -: 1138:  ACE_OS_TRACE ("ACE_OS::rw_trywrlock");
        -: 1139:#if defined (ACE_HAS_THREADS)
        -: 1140:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1141:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1142:  int result;
        -: 1143:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_trywrlock (rw),
        -: 1144:                                       result),
        -: 1145:                     int, -1);
        -: 1146:#  else /* Solaris */
        -: 1147:  int result;
        -: 1148:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_trywrlock (rw), result), int, -1);
        -: 1149:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1150:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1151:  int result = -1;
        -: 1152:
        -: 1153:  if (ACE_OS::mutex_lock (&rw->lock_) != -1)
        -: 1154:    {
        -: 1155:      ACE_Errno_Guard error (errno);
        -: 1156:
        -: 1157:      if (rw->ref_count_ != 0)
        -: 1158:        {
        -: 1159:          error = EBUSY;
        -: 1160:          result = -1;
        -: 1161:        }
        -: 1162:      else
        -: 1163:        {
        -: 1164:          rw->ref_count_ = -1;
        -: 1165:          result = 0;
        -: 1166:        }
        -: 1167:
        -: 1168:      ACE_OS::mutex_unlock (&rw->lock_);
        -: 1169:    }
        -: 1170:  return result;
        -: 1171:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1172:#else
        -: 1173:  ACE_UNUSED_ARG (rw);
        -: 1174:  ACE_NOTSUP_RETURN (-1);
        -: 1175:#endif /* ACE_HAS_THREADS */
        -: 1176:}
        -: 1177:
        -: 1178:// Note that the caller of this method *must* already possess this
        -: 1179:// lock as a read lock.
        -: 1180:// return {-1 and no errno set means: error,
        -: 1181://         -1 and errno==EBUSY set means: could not upgrade,
        -: 1182://         0 means: upgraded successfully}
        -: 1183:
        -: 1184:ACE_INLINE int
        -: 1185:ACE_OS::rw_trywrlock_upgrade (ACE_rwlock_t *rw)
        -: 1186:{
        -: 1187:  ACE_OS_TRACE ("ACE_OS::rw_trywrlock_upgrade");
        -: 1188:#if defined (ACE_HAS_THREADS)
        -: 1189:# if defined (ACE_HAS_PTHREADS_UNIX98_EXT) && !defined (ACE_LACKS_RWLOCK_T)
        -: 1190:  int result;
        -: 1191:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_trywrlock (rw),
        -: 1192:                                       result),
        -: 1193:                     int, -1);
        -: 1194:# elif !defined (ACE_LACKS_RWLOCK_T)
        -: 1195:  // Some native rwlocks, such as those on Solaris, don't
        -: 1196:  // support the upgrade feature . . .
        -: 1197:  ACE_UNUSED_ARG (rw);
        -: 1198:  ACE_NOTSUP_RETURN (-1);
        -: 1199:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1200:  // The ACE rwlock emulation does support upgrade . . .
        -: 1201:  int result = 0;
        -: 1202:
        -: 1203:#   if defined (ACE_HAS_PTHREADS)
        -: 1204:  ACE_PTHREAD_CLEANUP_PUSH (&rw->lock_);
        -: 1205:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1206:
        -: 1207:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1208:    return -1;
        -: 1209:    // -1 means didn't get the mutex, error
        -: 1210:  else if (rw->important_writer_)
        -: 1211:    // an other reader upgrades already
        -: 1212:    {
        -: 1213:      result = -1;
        -: 1214:      errno = EBUSY;
        -: 1215:    }
        -: 1216:  else
        -: 1217:    {
        -: 1218:      while (rw->ref_count_ > 1) // wait until only I am left
        -: 1219:        {
        -: 1220:          rw->num_waiting_writers_++; // prohibit any more readers
        -: 1221:          rw->important_writer_ = true;
        -: 1222:
        -: 1223:          if (ACE_OS::cond_wait (&rw->waiting_important_writer_, &rw->lock_) == -1)
        -: 1224:            {
        -: 1225:              result = -1;
        -: 1226:              // we know that we have the lock again, we have this guarantee,
        -: 1227:              // but something went wrong
        -: 1228:            }
        -: 1229:          rw->important_writer_ = false;
        -: 1230:          rw->num_waiting_writers_--;
        -: 1231:        }
        -: 1232:      if (result == 0)
        -: 1233:        {
        -: 1234:          // nothing bad happend
        -: 1235:          rw->ref_count_ = -1;
        -: 1236:          // now I am a writer
        -: 1237:          // everything is O.K.
        -: 1238:        }
        -: 1239:    }
        -: 1240:
        -: 1241:  ACE_OS::mutex_unlock (&rw->lock_);
        -: 1242:
        -: 1243:#   if defined (ACE_HAS_PTHREADS)
        -: 1244:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 1245:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1246:
        -: 1247:  return result;
        -: 1248:
        -: 1249:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1250:#else
        -: 1251:  ACE_UNUSED_ARG (rw);
        -: 1252:  ACE_NOTSUP_RETURN (-1);
        -: 1253:#endif /* ACE_HAS_THREADS */
        -: 1254:}
        -: 1255:
        -: 1256:ACE_INLINE int
        -: 1257:ACE_OS::rw_unlock (ACE_rwlock_t *rw)
        -: 1258:{
        -: 1259:  ACE_OS_TRACE ("ACE_OS::rw_unlock");
        -: 1260:#if defined (ACE_HAS_THREADS)
        -: 1261:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1262:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1263:  int result;
        -: 1264:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_unlock (rw),
        -: 1265:                                       result),
        -: 1266:                     int, -1);
        -: 1267:#  else /* Solaris */
        -: 1268:  int result;
        -: 1269:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_unlock (rw), result), int, -1);
        -: 1270:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1271:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1272:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1273:    return -1;
        -: 1274:
        -: 1275:  if (rw->ref_count_ > 0) // Releasing a reader.
        -: 1276:    rw->ref_count_--;
        -: 1277:  else if (rw->ref_count_ == -1) // Releasing a writer.
        -: 1278:    rw->ref_count_ = 0;
        -: 1279:  else
        -: 1280:    {
        -: 1281:      (void) ACE_OS::mutex_unlock (&rw->lock_);
        -: 1282:      return -1; // @@ ACE_ASSERT (!"count should not be 0!\n");
        -: 1283:    }
        -: 1284:
        -: 1285:  int result = 0;
        -: 1286:  ACE_Errno_Guard error (errno);
        -: 1287:
        -: 1288:  if (rw->important_writer_ && rw->ref_count_ == 1)
        -: 1289:    // only the reader requesting to upgrade its lock is left over.
        -: 1290:    {
        -: 1291:      result = ACE_OS::cond_signal (&rw->waiting_important_writer_);
        -: 1292:      error = errno;
        -: 1293:    }
        -: 1294:  else if (rw->num_waiting_writers_ > 0 && rw->ref_count_ == 0)
        -: 1295:    // give preference to writers over readers...
        -: 1296:    {
        -: 1297:      result = ACE_OS::cond_signal (&rw->waiting_writers_);
        -: 1298:      error =  errno;
        -: 1299:    }
        -: 1300:  else if (rw->num_waiting_readers_ > 0 && rw->num_waiting_writers_ == 0)
        -: 1301:    {
        -: 1302:      result = ACE_OS::cond_broadcast (&rw->waiting_readers_);
        -: 1303:      error = errno;
        -: 1304:    }
        -: 1305:
        -: 1306:  (void) ACE_OS::mutex_unlock (&rw->lock_);
        -: 1307:  return result;
        -: 1308:# endif /* ! ace_lacks_rwlock_t */
        -: 1309:#else
        -: 1310:  ACE_UNUSED_ARG (rw);
        -: 1311:  ACE_NOTSUP_RETURN (-1);
        -: 1312:#endif /* ace_has_threads */
        -: 1313:}
        -: 1314:
        -: 1315:ACE_INLINE int
        -: 1316:ACE_OS::rw_wrlock (ACE_rwlock_t *rw)
        -: 1317:{
        -: 1318:  ACE_OS_TRACE ("ACE_OS::rw_wrlock");
        -: 1319:#if defined (ACE_HAS_THREADS)
        -: 1320:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1321:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1322:  int result;
        -: 1323:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_wrlock (rw),
        -: 1324:                                       result),
        -: 1325:                     int, -1);
        -: 1326:#  else /* Solaris */
        -: 1327:  int result;
        -: 1328:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_wrlock (rw), result), int, -1);
        -: 1329:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1330:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1331:#   if defined (ACE_HAS_PTHREADS)
        -: 1332:  ACE_PTHREAD_CLEANUP_PUSH (&rw->lock_);
        -: 1333:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1334:  int result = 0;
        -: 1335:
        -: 1336:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1337:    result = -1; // -1 means didn't get the mutex.
        -: 1338:  else
        -: 1339:    {
        -: 1340:      while (rw->ref_count_ != 0)
        -: 1341:        {
        -: 1342:          rw->num_waiting_writers_++;
        -: 1343:
        -: 1344:          if (ACE_OS::cond_wait (&rw->waiting_writers_, &rw->lock_) == -1)
        -: 1345:            {
        -: 1346:              result = -2; // -2 means we need to release the mutex.
        -: 1347:              break;
        -: 1348:            }
        -: 1349:
        -: 1350:          rw->num_waiting_writers_--;
        -: 1351:        }
        -: 1352:    }
        -: 1353:  if (result == 0)
        -: 1354:    rw->ref_count_ = -1;
        -: 1355:  if (result != -1)
        -: 1356:    ACE_OS::mutex_unlock (&rw->lock_);
        -: 1357:#   if defined (ACE_HAS_PTHREADS)
        -: 1358:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 1359:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1360:  return 0;
        -: 1361:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1362:#else
        -: 1363:  ACE_UNUSED_ARG (rw);
        -: 1364:  ACE_NOTSUP_RETURN (-1);
        -: 1365:#endif /* ACE_HAS_THREADS */
        -: 1366:}
        -: 1367:
        -: 1368:ACE_INLINE int
        -: 1369:ACE_OS::rwlock_destroy (ACE_rwlock_t *rw)
        -: 1370:{
        -: 1371:  ACE_OS_TRACE ("ACE_OS::rwlock_destroy");
        -: 1372:#if defined (ACE_HAS_THREADS)
        -: 1373:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1374:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1375:  int result;
        -: 1376:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_destroy (rw),
        -: 1377:                                       result),
        -: 1378:                     int, -1);
        -: 1379:#  else /* Solaris */
        -: 1380:  int result;
        -: 1381:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rwlock_destroy (rw), result), int, -1);
        -: 1382:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1383:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1384:  ACE_OS::mutex_destroy (&rw->lock_);
        -: 1385:  ACE_OS::cond_destroy (&rw->waiting_readers_);
        -: 1386:  ACE_OS::cond_destroy (&rw->waiting_important_writer_);
        -: 1387:  return ACE_OS::cond_destroy (&rw->waiting_writers_);
        -: 1388:# endif /* ACE_HAS_STHREADS && !defined (ACE_LACKS_RWLOCK_T) */
        -: 1389:#else
        -: 1390:  ACE_UNUSED_ARG (rw);
        -: 1391:  ACE_NOTSUP_RETURN (-1);
        -: 1392:#endif /* ACE_HAS_THREADS */
        -: 1393:}
        -: 1394:
        -: 1395:#if defined (ACE_HAS_THREADS) && !defined (ACE_LACKS_RWLOCK_T)
        -: 1396:ACE_INLINE int
        -: 1397:ACE_OS::rwlock_init (ACE_rwlock_t *rw,
        -: 1398:                     int type,
        -: 1399:                     const ACE_TCHAR *name,
        -: 1400:                     void *arg)
        -: 1401:{
        -: 1402:  // ACE_OS_TRACE ("ACE_OS::rwlock_init");
        -: 1403:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1404:  ACE_UNUSED_ARG (name);
        -: 1405:  ACE_UNUSED_ARG (arg);
        -: 1406:
        -: 1407:  int status;
        -: 1408:  pthread_rwlockattr_t attr;
        -: 1409:  pthread_rwlockattr_init (&attr);
        -: 1410:#    if !defined (ACE_LACKS_RWLOCKATTR_PSHARED)
        -: 1411:  pthread_rwlockattr_setpshared (&attr, (type == USYNC_THREAD ?
        -: 1412:                                         PTHREAD_PROCESS_PRIVATE :
        -: 1413:                                         PTHREAD_PROCESS_SHARED));
        -: 1414:#    else
        -: 1415:  ACE_UNUSED_ARG (type);
        -: 1416:#    endif /* !ACE_LACKS_RWLOCKATTR_PSHARED */
        -: 1417:  status = ACE_ADAPT_RETVAL (pthread_rwlock_init (rw, &attr), status);
        -: 1418:  pthread_rwlockattr_destroy (&attr);
        -: 1419:
        -: 1420:  return status;
        -: 1421:
        -: 1422:#  else
        -: 1423:  type = type;
        -: 1424:  name = name;
        -: 1425:  int result;
        -: 1426:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rwlock_init (rw, type, arg), result), int, -1);
        -: 1427:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1428:}
        -: 1429:#endif /* ACE_HAS_THREADS && !defined (ACE_LACKS_RWLOCK_T) */
        -: 1430:
        -: 1431:ACE_INLINE int
        -: 1432:ACE_OS::sema_destroy (ACE_sema_t *s)
        -: 1433:{
        -: 1434:  ACE_OS_TRACE ("ACE_OS::sema_destroy");
        -: 1435:#if defined (ACE_HAS_POSIX_SEM)
        -: 1436:  int result = 0;
        -: 1437:# if !defined (ACE_HAS_POSIX_SEM_TIMEOUT) && !defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 1438:  ACE_OS::mutex_destroy (&s->lock_);
        -: 1439:  ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1440:# endif /* !ACE_HAS_POSIX_SEM_TIMEOUT && !ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION */
        -: 1441:# if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1442:  if (s->name_)
        -: 1443:    {
        -: 1444:      // Only destroy the semaphore if we're the ones who
        -: 1445:      // initialized it.
        -: 1446:#  if !defined (ACE_LACKS_SEM_DESTROY)
        -: 1447:      ACE_OSCALL (::sem_destroy (s->sema_),int, -1, result);
        -: 1448:#  endif /* ACE_LACKS_SEM_DESTROY */
        -: 1449:      ACE_OS::shm_unlink (s->name_);
        -: 1450:      delete s->name_;
        -: 1451:      return result;
        -: 1452:    }
        -: 1453:# else
        -: 1454:  if (s->name_)
        -: 1455:    {
        -: 1456:      if (!s->avoid_unlink_)
        -: 1457:        ACE_OS::sema_unlink (s->name_);
        -: 1458:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1459:      ACE_Allocator::instance()->free ((void *) s->name_);
        -: 1460:#else
        -: 1461:      ACE_OS::free ((void *) s->name_);
        -: 1462:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1463:      ACE_OSCALL_RETURN (::sem_close (s->sema_), int, -1);
        -: 1464:    }
        -: 1465:# endif /*  ACE_LACKS_NAMED_POSIX_SEM */
        -: 1466:  else
        -: 1467:    {
        -: 1468:# if !defined (ACE_LACKS_UNNAMED_SEMAPHORE) && !defined (ACE_LACKS_SEM_DESTROY)
        -: 1469:      ACE_OSCALL (::sem_destroy (s->sema_), int, -1, result);
        -: 1470:# endif /* !ACE_LACKS_UNNAMED_SEMAPHORE  && !ACE_LACKS_SEM_DESTROY */
        -: 1471:# if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1472:      if (s->new_sema_)
        -: 1473:# endif /* ACE_LACKS_NAMED_POSIX_SEM */
        -: 1474:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1475:        ACE_Allocator::instance()->free(s->sema_);
        -: 1476:#else
        -: 1477:        delete s->sema_;
        -: 1478:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1479:      s->sema_ = 0;
        -: 1480:      return result;
        -: 1481:    }
        -: 1482:#elif defined (ACE_USES_FIFO_SEM)
        -: 1483:  int r0 = 0;
        -: 1484:  if (s->name_)
        -: 1485:    {
        -: 1486:      r0 = ACE_OS::unlink (s->name_);
        -: 1487:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1488:      ACE_Allocator::instance()->free ((void *) s->name_);
        -: 1489:#else
        -: 1490:      ACE_OS::free ((void *) s->name_);
        -: 1491:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1492:      s->name_ = 0;
        -: 1493:    }
        -: 1494:  int r1 = ACE_OS::close (s->fd_[0]);      /* ignore error */
        -: 1495:  int r2 = ACE_OS::close (s->fd_[1]);      /* ignore error */
        -: 1496:  return r0 != 0 || r1 != 0 || r2 != 0 ? -1 : 0;
        -: 1497:#elif defined (ACE_HAS_THREADS)
        -: 1498:#  if defined (ACE_HAS_STHREADS)
        -: 1499:  int result;
        -: 1500:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_destroy (s), result), int, -1);
        -: 1501:#  elif defined (ACE_HAS_PTHREADS)
        -: 1502:  int r1 = ACE_OS::mutex_destroy (&s->lock_);
        -: 1503:  int r2 = ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1504:  return r1 != 0 || r2 != 0 ? -1 : 0;
        -: 1505:#  elif defined (ACE_HAS_WTHREADS)
        -: 1506:#    if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 1507:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::CloseHandle (*s), ace_result_), int, -1);
        -: 1508:#    else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1509:  // Free up underlying objects of the simulated semaphore.
        -: 1510:  int const r1 = ACE_OS::thread_mutex_destroy (&s->lock_);
        -: 1511:  int const r2 = ACE_OS::event_destroy (&s->count_nonzero_);
        -: 1512:  return r1 != 0 || r2 != 0 ? -1 : 0;
        -: 1513:#    endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1514:#  elif defined (ACE_VXWORKS)
        -: 1515:  int result;
        -: 1516:  ACE_OSCALL (::semDelete (s->sema_), int, -1, result);
        -: 1517:  s->sema_ = 0;
        -: 1518:  return result;
        -: 1519:#  endif /* ACE_HAS_STHREADS */
        -: 1520:#else
        -: 1521:  ACE_UNUSED_ARG (s);
        -: 1522:  ACE_NOTSUP_RETURN (-1);
        -: 1523:#endif /* ACE_HAS_POSIX_SEM */
        -: 1524:}
        -: 1525:
        -: 1526:// NOTE: The previous four function definitions must appear before
        -: 1527:// ACE_OS::sema_init ().
        -: 1528:
        -: 1529:ACE_INLINE int
        -: 1530:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1531:                   u_int count,
        -: 1532:                   int type,
        -: 1533:                   const char *name,
        -: 1534:                   void *arg,
        -: 1535:                   int max,
        -: 1536:                   LPSECURITY_ATTRIBUTES sa)
        -: 1537:{
        -: 1538:  ACE_condattr_t *pattr = 0;
        -: 1539:  return ACE_OS::sema_init (s, count, type, pattr, name, arg, max, sa);
        -: 1540:}
        -: 1541:
        -: 1542:ACE_INLINE int
        -: 1543:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1544:                   u_int count,
        -: 1545:                   int type,
        -: 1546:                   ACE_condattr_t *attributes,
        -: 1547:                   const char *name,
        -: 1548:                   void *arg,
        -: 1549:                   int max,
        -: 1550:                   LPSECURITY_ATTRIBUTES sa)
        -: 1551:{
        -: 1552:  ACE_OS_TRACE ("ACE_OS::sema_init");
        -: 1553:#if defined (ACE_HAS_POSIX_SEM)
        -: 1554:  ACE_UNUSED_ARG (max);
        -: 1555:  ACE_UNUSED_ARG (sa);
        -: 1556:
        -: 1557:  s->name_ = 0;
        -: 1558:  s->avoid_unlink_ = false;
        -: 1559:#  if defined (ACE_HAS_POSIX_SEM_TIMEOUT) || defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 1560:  ACE_UNUSED_ARG (arg);
        -: 1561:  ACE_UNUSED_ARG (attributes);
        -: 1562:#  else
        -: 1563:  int result = -1;
        -: 1564:
        -: 1565:  if (ACE_OS::mutex_init (&s->lock_, type, name,
        -: 1566:                          (ACE_mutexattr_t *) arg) == 0
        -: 1567:      && (attributes == 0 ?
        -: 1568:            ACE_OS::cond_init (&s->count_nonzero_, type, name, arg) :
        -: 1569:            ACE_OS::cond_init (&s->count_nonzero_, *attributes, name, arg)) == 0
        -: 1570:      && ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 1571:    {
        -: 1572:      if (ACE_OS::mutex_unlock (&s->lock_) == 0)
        -: 1573:        result = 0;
        -: 1574:    }
        -: 1575:
        -: 1576:  if (result == -1)
        -: 1577:    {
        -: 1578:      ACE_OS::mutex_destroy (&s->lock_);
        -: 1579:      ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1580:      return result;
        -: 1581:    }
        -: 1582:#  endif /* ACE_HAS_POSIX_SEM_TIMEOUT || ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION */
        -: 1583:
        -: 1584:#  if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1585:  s->new_sema_ = false;
        -: 1586:  if (type == USYNC_PROCESS)
        -: 1587:    {
        -: 1588:      // Let's see if it already exists.
        -: 1589:      ACE_HANDLE fd = ACE_OS::shm_open (ACE_TEXT_CHAR_TO_TCHAR (name),
        -: 1590:                                        O_RDWR | O_CREAT | O_EXCL,
        -: 1591:                                        ACE_DEFAULT_FILE_PERMS);
        -: 1592:      if (fd == ACE_INVALID_HANDLE)
        -: 1593:        {
        -: 1594:          if (errno == EEXIST)
        -: 1595:            fd = ACE_OS::shm_open (ACE_TEXT_CHAR_TO_TCHAR (name),
        -: 1596:                                   O_RDWR | O_CREAT,
        -: 1597:                                   ACE_DEFAULT_FILE_PERMS);
        -: 1598:          else
        -: 1599:            return -1;
        -: 1600:        }
        -: 1601:      else
        -: 1602:        {
        -: 1603:          // We own this shared memory object!  Let's set its
        -: 1604:          // size.
        -: 1605:          if (ACE_OS::ftruncate (fd,
        -: 1606:                                 sizeof (ACE_sema_t)) == -1)
        -: 1607:            return -1;
        -: 1608:          s->name_ = ACE_OS::strdup (name);
        -: 1609:          if (s->name_ == 0)
        -: 1610:            return -1;
        -: 1611:        }
        -: 1612:      if (fd == -1)
        -: 1613:        return -1;
        -: 1614:
        -: 1615:      s->sema_ = (sem_t *)
        -: 1616:        ACE_OS::mmap (0,
        -: 1617:                      sizeof (ACE_sema_t),
        -: 1618:                      PROT_RDWR,
        -: 1619:                      MAP_SHARED,
        -: 1620:                      fd,
        -: 1621:                      0);
        -: 1622:      ACE_OS::close (fd);
        -: 1623:      if (s->sema_ == (sem_t *) MAP_FAILED)
        -: 1624:        return -1;
        -: 1625:      if (s->name_
        -: 1626:          // @@ According UNIX Network Programming V2 by Stevens,
        -: 1627:          //    sem_init() is currently not required to return zero on
        -: 1628:          //    success, but it *does* return -1 upon failure.  For
        -: 1629:          //    this reason, check for failure by comparing to -1,
        -: 1630:          //    instead of checking for success by comparing to zero.
        -: 1631:          //        -Ossama
        -: 1632:          // Only initialize it if we're the one who created it.
        -: 1633:          && ::sem_init (s->sema_, type == USYNC_PROCESS, count) == -1)
        -: 1634:        return -1;
        -: 1635:      return 0;
        -: 1636:    }
        -: 1637:#  else
        -: 1638:  if (name)
        -: 1639:    {
        -: 1640:#    if defined (sun) || defined (HPUX)
        -: 1641:      // Solaris and HP-UX require the name to start with a slash. Solaris
        -: 1642:      // further requires that there be no other slashes than the first.
        -: 1643:      const char *last_slash = ACE_OS::strrchr (name, '/');
        -: 1644:      char name2[MAXPATHLEN];
        -: 1645:      if (0 == last_slash)
        -: 1646:        {
        -: 1647:          ACE_OS::strcpy (name2, "/");
        -: 1648:          ACE_OS::strcat (name2, name);
        -: 1649:          name = name2;
        -: 1650:        }
        -: 1651:#      if defined (sun)
        -: 1652:      else
        -: 1653:        name = last_slash;         // Chop off chars preceding last slash
        -: 1654:#      endif /* sun */
        -: 1655:#    endif /* sun || HPUX */
        -: 1656:
        -: 1657:      ACE_ALLOCATOR_RETURN (s->name_,
        -: 1658:                            ACE_OS::strdup (name),
        -: 1659:                            -1);
        -: 1660:      s->sema_ = ::sem_open (s->name_,
        -: 1661:                             O_CREAT,
        -: 1662:                             ACE_DEFAULT_FILE_PERMS,
        -: 1663:                             count);
        -: 1664:      if (s->sema_ == (sem_t *) SEM_FAILED)
        -: 1665:        return -1;
        -: 1666:      else
        -: 1667:        return 0;
        -: 1668:    }
        -: 1669:#  endif /* ACE_LACKS_NAMED_POSIX_SEM */
        -: 1670:  else
        -: 1671:    {
        -: 1672:#  if defined (ACE_LACKS_UNNAMED_SEMAPHORE)
        -: 1673:      ACE_NOTSUP_RETURN (-1);
        -: 1674:#  else
        -: 1675:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1676:      ACE_ALLOCATOR_RETURN (s->sema_,
        -: 1677:                            static_cast<sem_t*>(ACE_Allocator::instance()->malloc(sizeof(sem_t))),
        -: 1678:                            -1);
        -: 1679:#else
        -: 1680:      ACE_NEW_RETURN (s->sema_,
        -: 1681:                      sem_t,
        -: 1682:                      -1);
        -: 1683:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1684:
        -: 1685:#   if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1686:      s->new_sema_ = true;
        -: 1687:#   endif /* ACE_LACKS_NAMED_POSIX_SEM */
        -: 1688:      ACE_OS::memset(s->sema_, 0, sizeof(*s->sema_));
        -: 1689:      ACE_OSCALL_RETURN (::sem_init (s->sema_,
        -: 1690:                                     type != USYNC_THREAD,
        -: 1691:                                     count), int, -1);
        -: 1692:#  endif /* ACE_LACKS_UNNAMED_SEMAPHORE */
        -: 1693:    }
        -: 1694:
        -: 1695:#elif defined (ACE_USES_FIFO_SEM)
        -: 1696:  ACE_UNUSED_ARG (arg);
        -: 1697:  ACE_UNUSED_ARG (max);
        -: 1698:  ACE_UNUSED_ARG (sa);
        -: 1699:  int             flags = 0;
        -: 1700:  mode_t          mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
        -: 1701:
        -: 1702:  if (type == USYNC_THREAD)
        -: 1703:    {
        -: 1704:      // Create systemwide unique name for semaphore
        -: 1705:      char   uname[ACE_UNIQUE_NAME_LEN];
        -: 1706:      ACE_OS::unique_name ((const void *) s,
        -: 1707:                            uname,
        -: 1708:                            ACE_UNIQUE_NAME_LEN);
        -: 1709:      name = &uname[0];
        -: 1710:    }
        -: 1711:
        -: 1712:  s->name_ = 0;
        -: 1713:  s->fd_[0] = s->fd_[1] = ACE_INVALID_HANDLE;
        -: 1714:  bool creator = false;
        -: 1715:
        -: 1716:  if (ACE_OS::mkfifo (ACE_TEXT_CHAR_TO_TCHAR (name), mode) < 0)
        -: 1717:    {
        -: 1718:      if (errno != EEXIST)    /* already exists OK else ERR */
        -: 1719:        return -1;
        -: 1720:      // check if this is a real FIFO, not just some other existing file
        -: 1721:      ACE_stat fs;
        -: 1722:      if (ACE_OS::stat (name, &fs))
        -: 1723:        return -1;
        -: 1724:      if (!S_ISFIFO (fs.st_mode))
        -: 1725:        {
        -: 1726:          // existing file is not a FIFO
        -: 1727:          errno = EEXIST;
        -: 1728:          return -1;
        -: 1729:        }
        -: 1730:    }
        -: 1731:    else
        -: 1732:      creator = true; // remember we created it for initialization at end
        -: 1733:
        -: 1734:  // for processshared semaphores remember who we are to be able to remove
        -: 1735:  // the FIFO when we're done with it
        -: 1736:  if (type == USYNC_PROCESS)
        -: 1737:    {
        -: 1738:      s->name_ = ACE_OS::strdup (name);
        -: 1739:      if (s->name_ == 0)
        -: 1740:        {
        -: 1741:          if (creator)
        -: 1742:            ACE_OS::unlink (name);
        -: 1743:          return -1;
        -: 1744:        }
        -: 1745:    }
        -: 1746:
        -: 1747:  if ((s->fd_[0] = ACE_OS::open (name, O_RDONLY | O_NONBLOCK)) == ACE_INVALID_HANDLE
        -: 1748:      || (s->fd_[1] = ACE_OS::open (name, O_WRONLY | O_NONBLOCK)) == ACE_INVALID_HANDLE)
        -: 1749:    return -1;
        -: 1750:
        -: 1751:  /* turn off nonblocking for fd_[0] */
        -: 1752:  if ((flags = ACE_OS::fcntl (s->fd_[0], F_GETFL, 0)) < 0)
        -: 1753:    return -1;
        -: 1754:
        -: 1755:  flags &= ~O_NONBLOCK;
        -: 1756:  if (ACE_OS::fcntl (s->fd_[0], F_SETFL, flags) < 0)
        -: 1757:    return -1;
        -: 1758:
        -: 1759:  //if (s->name_ && count)
        -: 1760:  if (creator && count)
        -: 1761:    {
        -: 1762:      char    c = 1;
        -: 1763:      for (u_int i=0; i<count ;++i)
        -: 1764:        if (ACE_OS::write (s->fd_[1], &c, sizeof (char)) != 1)
        -: 1765:          return -1;
        -: 1766:    }
        -: 1767:
        -: 1768:  // In the case of process scope semaphores we can already unlink the FIFO now that
        -: 1769:  // we completely set it up (the opened handles will keep it active until we close
        -: 1770:  // thos down). This way we're protected against unexpected crashes as far as removal
        -: 1771:  // is concerned.
        -: 1772:  // Unfortunately this does not work for processshared FIFOs since as soon as we
        -: 1773:  // have unlinked the semaphore no other process will be able to open it anymore.
        -: 1774:  if (type == USYNC_THREAD)
        -: 1775:    {
        -: 1776:      ACE_OS::unlink (name);
        -: 1777:    }
        -: 1778:
        -: 1779:  return 0;
        -: 1780:#elif defined (ACE_HAS_THREADS)
        -: 1781:#  if defined (ACE_HAS_STHREADS)
        -: 1782:  ACE_UNUSED_ARG (name);
        -: 1783:  ACE_UNUSED_ARG (max);
        -: 1784:  ACE_UNUSED_ARG (sa);
        -: 1785:  ACE_UNUSED_ARG (attributes);
        -: 1786:  int result;
        -: 1787:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_init (s, count, type, arg), result),
        -: 1788:                     int, -1);
        -: 1789:#  elif defined (ACE_HAS_PTHREADS)
        -: 1790:  ACE_UNUSED_ARG (max);
        -: 1791:  ACE_UNUSED_ARG (sa);
        -: 1792:  int result = -1;
        -: 1793:
        -: 1794:  if (ACE_OS::mutex_init (&s->lock_, type, name,
        -: 1795:                          (ACE_mutexattr_t *) arg) == 0
        -: 1796:      && (attributes == 0 ?
        -: 1797:            ACE_OS::cond_init (&s->count_nonzero_, type, name, arg) :
        -: 1798:            ACE_OS::cond_init (&s->count_nonzero_, *attributes, name, arg)) == 0
        -: 1799:      && ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 1800:    {
        -: 1801:      s->count_ = count;
        -: 1802:      s->waiters_ = 0;
        -: 1803:
        -: 1804:      if (ACE_OS::mutex_unlock (&s->lock_) == 0)
        -: 1805:        result = 0;
        -: 1806:    }
        -: 1807:
        -: 1808:  if (result == -1)
        -: 1809:    {
        -: 1810:      ACE_OS::mutex_destroy (&s->lock_);
        -: 1811:      ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1812:    }
        -: 1813:  return result;
        -: 1814:#  elif defined (ACE_HAS_WTHREADS)
        -: 1815:  ACE_UNUSED_ARG (attributes);
        -: 1816:#    if ! defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 1817:  ACE_UNUSED_ARG (type);
        -: 1818:  ACE_UNUSED_ARG (arg);
        -: 1819:  // Create the semaphore with its value initialized to <count> and
        -: 1820:  // its maximum value initialized to <max>.
        -: 1821:  SECURITY_ATTRIBUTES sa_buffer;
        -: 1822:  SECURITY_DESCRIPTOR sd_buffer;
        -: 1823:  *s = ACE_TEXT_CreateSemaphore
        -: 1824:    (ACE_OS::default_win32_security_attributes_r (sa, &sa_buffer, &sd_buffer),
        -: 1825:     count,
        -: 1826:     max,
        -: 1827:     ACE_TEXT_CHAR_TO_TCHAR (name));
        -: 1828:
        -: 1829:  if (*s == 0)
        -: 1830:    ACE_FAIL_RETURN (-1);
        -: 1831:  /* NOTREACHED */
        -: 1832:  else
        -: 1833:    {
        -: 1834:      // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -: 1835:      ACE_OS::set_errno_to_last_error ();
        -: 1836:      return 0;
        -: 1837:    }
        -: 1838:#    else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1839:  int result = -1;
        -: 1840:
        -: 1841:  // Initialize internal object for semaphore simulation.
        -: 1842:  // Grab the lock as soon as possible when we initializing
        -: 1843:  // the semaphore count.  Notice that we initialize the
        -: 1844:  // event object as "manually reset" so we can amortize the
        -: 1845:  // cost for singling/reseting the event.
        -: 1846:  // @@ I changed the mutex type to thread_mutex.  Notice that this
        -: 1847:  // is basically a CriticalSection object and doesn't not has
        -: 1848:  // any security attribute whatsoever.  However, since this
        -: 1849:  // semaphore implementation only works within a process, there
        -: 1850:  // shouldn't any security issue at all.
        -: 1851:  if (ACE_OS::thread_mutex_init (&s->lock_, type, name, (ACE_mutexattr_t *)arg) == 0
        -: 1852:      && ACE_OS::event_init (&s->count_nonzero_, 1,
        -: 1853:                             count > 0, type, name, arg, sa) == 0
        -: 1854:      && ACE_OS::thread_mutex_lock (&s->lock_) == 0)
        -: 1855:    {
        -: 1856:      s->count_ = count;
        -: 1857:
        -: 1858:      if (ACE_OS::thread_mutex_unlock (&s->lock_) == 0)
        -: 1859:        result = 0;
        -: 1860:    }
        -: 1861:
        -: 1862:  // Destroy the internal objects if we didn't initialize
        -: 1863:  // either of them successfully.  Don't bother to check
        -: 1864:  // for errors.
        -: 1865:  if (result == -1)
        -: 1866:    {
        -: 1867:      ACE_OS::thread_mutex_destroy (&s->lock_);
        -: 1868:      ACE_OS::event_destroy (&s->count_nonzero_);
        -: 1869:    }
        -: 1870:  return result;
        -: 1871:#    endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1872:#  elif defined (ACE_VXWORKS)
        -: 1873:  ACE_UNUSED_ARG (name);
        -: 1874:  ACE_UNUSED_ARG (arg);
        -: 1875:  ACE_UNUSED_ARG (max);
        -: 1876:  ACE_UNUSED_ARG (sa);
        -: 1877:  s->name_ = 0;
        -: 1878:  s->sema_ = ::semCCreate (type, count);
        -: 1879:  return s->sema_ ? 0 : -1;
        -: 1880:#  endif /* ACE_HAS_STHREADS */
        -: 1881:#else
        -: 1882:  ACE_UNUSED_ARG (s);
        -: 1883:  ACE_UNUSED_ARG (count);
        -: 1884:  ACE_UNUSED_ARG (type);
        -: 1885:  ACE_UNUSED_ARG (attributes);
        -: 1886:  ACE_UNUSED_ARG (name);
        -: 1887:  ACE_UNUSED_ARG (arg);
        -: 1888:  ACE_UNUSED_ARG (max);
        -: 1889:  ACE_UNUSED_ARG (sa);
        -: 1890:  ACE_NOTSUP_RETURN (-1);
        -: 1891:#endif /* ACE_HAS_POSIX_SEM */
        -: 1892:}
        -: 1893:
        -: 1894:#if defined (ACE_HAS_WCHAR)
        -: 1895:ACE_INLINE int
        -: 1896:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1897:                   u_int count,
        -: 1898:                   int type,
        -: 1899:                   const wchar_t *name,
        -: 1900:                   void *arg,
        -: 1901:                   int max,
        -: 1902:                   LPSECURITY_ATTRIBUTES sa)
        -: 1903:{
        -: 1904:  ACE_condattr_t *pattr = 0;
        -: 1905:  return ACE_OS::sema_init (s, count, type, pattr, name, arg, max, sa);
        -: 1906:}
        -: 1907:
        -: 1908:ACE_INLINE int
        -: 1909:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1910:                   u_int count,
        -: 1911:                   int type,
        -: 1912:                   ACE_condattr_t *attributes,
        -: 1913:                   const wchar_t *name,
        -: 1914:                   void *arg,
        -: 1915:                   int max,
        -: 1916:                   LPSECURITY_ATTRIBUTES sa)
        -: 1917:{
        -: 1918:# if defined (ACE_HAS_WTHREADS)
        -: 1919:  ACE_UNUSED_ARG (attributes);
        -: 1920:#   if ! defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 1921:  ACE_UNUSED_ARG (type);
        -: 1922:  ACE_UNUSED_ARG (arg);
        -: 1923:  // Create the semaphore with its value initialized to <count> and
        -: 1924:  // its maximum value initialized to <max>.
        -: 1925:  SECURITY_ATTRIBUTES sa_buffer;
        -: 1926:  SECURITY_DESCRIPTOR sd_buffer;
        -: 1927:  *s = ::CreateSemaphoreW
        -: 1928:    (ACE_OS::default_win32_security_attributes_r (sa, &sa_buffer, &sd_buffer),
        -: 1929:     count,
        -: 1930:     max,
        -: 1931:     name);
        -: 1932:
        -: 1933:  if (*s == 0)
        -: 1934:    ACE_FAIL_RETURN (-1);
        -: 1935:  /* NOTREACHED */
        -: 1936:  else
        -: 1937:    {
        -: 1938:      // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -: 1939:      ACE_OS::set_errno_to_last_error ();
        -: 1940:      return 0;
        -: 1941:    }
        -: 1942:#   else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1943:  int result = -1;
        -: 1944:
        -: 1945:  // Initialize internal object for semaphore simulation.
        -: 1946:  // Grab the lock as soon as possible when we initializing
        -: 1947:  // the semaphore count.  Notice that we initialize the
        -: 1948:  // event object as "manually reset" so we can amortize the
        -: 1949:  // cost for singling/reseting the event.
        -: 1950:  // @@ I changed the mutex type to thread_mutex.  Notice that this
        -: 1951:  // is basically a CriticalSection object and doesn't not has
        -: 1952:  // any security attribute whatsoever.  However, since this
        -: 1953:  // semaphore implementation only works within a process, there
        -: 1954:  // shouldn't any security issue at all.
        -: 1955:  if (ACE_OS::thread_mutex_init (&s->lock_, type, name, (ACE_mutexattr_t *)arg) == 0
        -: 1956:      && ACE_OS::event_init (&s->count_nonzero_, 1,
        -: 1957:                             count > 0, type, name, arg, sa) == 0
        -: 1958:      && ACE_OS::thread_mutex_lock (&s->lock_) == 0)
        -: 1959:    {
        -: 1960:      s->count_ = count;
        -: 1961:
        -: 1962:      if (ACE_OS::thread_mutex_unlock (&s->lock_) == 0)
        -: 1963:        result = 0;
        -: 1964:    }
        -: 1965:
        -: 1966:  // Destroy the internal objects if we didn't initialize
        -: 1967:  // either of them successfully.  Don't bother to check
        -: 1968:  // for errors.
        -: 1969:  if (result == -1)
        -: 1970:    {
        -: 1971:      ACE_OS::thread_mutex_destroy (&s->lock_);
        -: 1972:      ACE_OS::event_destroy (&s->count_nonzero_);
        -: 1973:    }
        -: 1974:  return result;
        -: 1975:#   endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1976:# else /* ACE_HAS_WTHREADS */
        -: 1977:  // Just call the normal char version.
        -: 1978:  return ACE_OS::sema_init (s, count, type, attributes, ACE_Wide_To_Ascii (name).char_rep (), arg, max, sa);
        -: 1979:# endif /* ACE_HAS_WTHREADS */
        -: 1980:}
        -: 1981:#endif /* ACE_HAS_WCHAR */
        -: 1982:
        -: 1983:ACE_INLINE void
        -: 1984:ACE_OS::sema_avoid_unlink (ACE_sema_t *s, bool avoid_unlink)
        -: 1985:{
        -: 1986:#if defined (ACE_HAS_POSIX_SEM)
        -: 1987:  s->avoid_unlink_ = avoid_unlink;
        -: 1988:#else
        -: 1989:  ACE_UNUSED_ARG (s);
        -: 1990:  ACE_UNUSED_ARG (avoid_unlink);
        -: 1991:#endif
        -: 1992:}
        -: 1993:
        -: 1994:ACE_INLINE int
        -: 1995:ACE_OS::sema_unlink (const char *name)
        -: 1996:{
        -: 1997:#if defined (ACE_HAS_POSIX_SEM) && !defined (ACE_LACKS_SEM_UNLINK)
        -: 1998:  ACE_OSCALL_RETURN (::sem_unlink (name), int, -1);
        -: 1999:#else
        -: 2000:  ACE_UNUSED_ARG (name);
        -: 2001:  ACE_NOTSUP_RETURN (-1);
        -: 2002:#endif
        -: 2003:}
        -: 2004:
        -: 2005:ACE_INLINE int
        -: 2006:ACE_OS::sema_post (ACE_sema_t *s)
        -: 2007:{
        -: 2008:  ACE_OS_TRACE ("ACE_OS::sema_post");
        -: 2009:# if defined (ACE_HAS_POSIX_SEM)
        -: 2010:#   if defined (ACE_HAS_POSIX_SEM_TIMEOUT) || defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 2011:  ACE_OSCALL_RETURN (::sem_post (s->sema_), int, -1);
        -: 2012:#   else
        -: 2013:  int result = -1;
        -: 2014:
        -: 2015:  if (ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 2016:    {
        -: 2017:      if (::sem_post (s->sema_) == 0)
        -: 2018:        result = ACE_OS::cond_signal (&s->count_nonzero_);
        -: 2019:
        -: 2020:      ACE_OS::mutex_unlock (&s->lock_);
        -: 2021:    }
        -: 2022:  return result;
        -: 2023:#   endif /* ACE_HAS_POSIX_SEM_TIMEOUT || ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION */
        -: 2024:# elif defined (ACE_USES_FIFO_SEM)
        -: 2025:  char    c = 1;
        -: 2026:  if (ACE_OS::write (s->fd_[1], &c, sizeof (char)) == sizeof (char))
        -: 2027:    return 0;
        -: 2028:  return -1;
        -: 2029:# elif defined (ACE_HAS_THREADS)
        -: 2030:#   if defined (ACE_HAS_STHREADS)
        -: 2031:  int result;
        -: 2032:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_post (s), result), int, -1);
        -: 2033:#   elif defined (ACE_HAS_PTHREADS)
        -: 2034:  int result = -1;
        -: 2035:
        -: 2036:  if (ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 2037:    {
        -: 2038:      // Always allow a waiter to continue if there is one.
        -: 2039:      if (s->waiters_ > 0)
        -: 2040:        result = ACE_OS::cond_signal (&s->count_nonzero_);
        -: 2041:      else
        -: 2042:        result = 0;
        -: 2043:
        -: 2044:      s->count_++;
        -: 2045:      ACE_OS::mutex_unlock (&s->lock_);
        -: 2046:    }
        -: 2047:  return result;
        -: 2048:#   elif defined (ACE_HAS_WTHREADS)
        -: 2049:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2050:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::ReleaseSemaphore (*s, 1, 0),
        -: 2051:                                          ace_result_),
        -: 2052:                        int, -1);
        -: 2053:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2054:  int result = -1;
        -: 2055:
        -: 2056:  // Since we are simulating semaphores, we need to update semaphore
        -: 2057:  // count manually.  Grab the lock to prevent race condition first.
        -: 2058:  if (ACE_OS::thread_mutex_lock (&s->lock_) == 0)
        -: 2059:    {
        -: 2060:      // Check the original state of event object.  Single the event
        -: 2061:      // object in transition from semaphore not available to
        -: 2062:      // semaphore available.
        -: 2063:      if (s->count_++ <= 0)
        -: 2064:        result = ACE_OS::event_signal (&s->count_nonzero_);
        -: 2065:      else
        -: 2066:        result = 0;
        -: 2067:
        -: 2068:      ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2069:    }
        -: 2070:  return result;
        -: 2071:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2072:#   elif defined (ACE_VXWORKS)
        -: 2073:  ACE_OSCALL_RETURN (::semGive (s->sema_), int, -1);
        -: 2074:#   endif /* ACE_HAS_STHREADS */
        -: 2075:# else
        -: 2076:  ACE_UNUSED_ARG (s);
        -: 2077:  ACE_NOTSUP_RETURN (-1);
        -: 2078:# endif /* ACE_HAS_POSIX_SEM */
        -: 2079:}
        -: 2080:
        -: 2081:ACE_INLINE int
        -: 2082:ACE_OS::sema_post (ACE_sema_t *s, u_int release_count)
        -: 2083:{
        -: 2084:#if defined (ACE_WIN32) && !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2085:  // Win32 supports this natively.
        -: 2086:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::ReleaseSemaphore (*s, release_count, 0),
        -: 2087:                                          ace_result_), int, -1);
        -: 2088:#else
        -: 2089:  // On POSIX platforms we need to emulate this ourselves.
        -: 2090:  // @@ We can optimize on this implementation.  However,
        -: 2091:  // the semaphore promitive on Win32 doesn't allow one
        -: 2092:  // to increase a semaphore to more than the count it was
        -: 2093:  // first initialized.  Posix and solaris don't seem to have
        -: 2094:  // this restriction.  Should we impose the restriction in
        -: 2095:  // our semaphore simulation?
        -: 2096:  for (size_t i = 0; i < release_count; i++)
        -: 2097:    if (ACE_OS::sema_post (s) == -1)
        -: 2098:      return -1;
        -: 2099:
        -: 2100:  return 0;
        -: 2101:#endif /* ACE_WIN32 */
        -: 2102:}
        -: 2103:
        -: 2104:ACE_INLINE int
        -: 2105:ACE_OS::sema_trywait (ACE_sema_t *s)
        -: 2106:{
        -: 2107:  ACE_OS_TRACE ("ACE_OS::sema_trywait");
        -: 2108:# if defined (ACE_HAS_POSIX_SEM)
        -: 2109:  // POSIX semaphores set errno to EAGAIN if trywait fails
        -: 2110:  ACE_OSCALL_RETURN (::sem_trywait (s->sema_), int, -1);
        -: 2111:# elif defined (ACE_USES_FIFO_SEM)
        -: 2112:  char  c;
        -: 2113:  int     rc, flags;
        -: 2114:
        -: 2115:  /* turn on nonblocking for s->fd_[0] */
        -: 2116:  if ((flags = ACE_OS::fcntl (s->fd_[0], F_GETFL, 0)) < 0)
        -: 2117:    return -1;
        -: 2118:  flags |= O_NONBLOCK;
        -: 2119:  if (ACE_OS::fcntl (s->fd_[0], F_SETFL, flags) < 0)
        -: 2120:    return -1;
        -: 2121:
        -: 2122:  // read sets errno to EAGAIN if no input
        -: 2123:  rc = ACE_OS::read (s->fd_[0], &c, sizeof (char));
        -: 2124:
        -: 2125:  /* turn off nonblocking for fd_[0] */
        -: 2126:  if ((flags = ACE_OS::fcntl (s->fd_[0], F_GETFL, 0)) >= 0)
        -: 2127:  {
        -: 2128:    flags &= ~O_NONBLOCK;
        -: 2129:    ACE_OS::fcntl (s->fd_[0], F_SETFL, flags);
        -: 2130:  }
        -: 2131:
        -: 2132:  return rc == 1 ? 0 : (-1);
        -: 2133:# elif defined (ACE_HAS_THREADS)
        -: 2134:#   if defined (ACE_HAS_STHREADS)
        -: 2135:  // STHREADS semaphores set errno to EBUSY if trywait fails.
        -: 2136:  int result;
        -: 2137:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_trywait (s),
        -: 2138:                                       result),
        -: 2139:                     int, -1);
        -: 2140:#   elif defined (ACE_HAS_PTHREADS)
        -: 2141:
        -: 2142:  int result = -1;
        -: 2143:
        -: 2144:  if (ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 2145:    {
        -: 2146:      if (s->count_ > 0)
        -: 2147:        {
        -: 2148:          --s->count_;
        -: 2149:          result = 0;
        -: 2150:        }
        -: 2151:      else
        -: 2152:        errno = EBUSY;
        -: 2153:
        -: 2154:      ACE_OS::mutex_unlock (&s->lock_);
        -: 2155:    }
        -: 2156:  return result;
        -: 2157:#   elif defined (ACE_HAS_WTHREADS)
        -: 2158:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2159:  DWORD result = ::WaitForSingleObject (*s, 0);
        -: 2160:
        -: 2161:  if (result == WAIT_OBJECT_0)
        -: 2162:    return 0;
        -: 2163:  else
        -: 2164:    {
        -: 2165:      if (result == WAIT_TIMEOUT)
        -: 2166:        errno = EBUSY;
        -: 2167:      else
        -: 2168:        ACE_OS::set_errno_to_last_error ();
        -: 2169:      // This is a hack, we need to find an appropriate mapping...
        -: 2170:      return -1;
        -: 2171:    }
        -: 2172:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2173:  // Check the status of semaphore first.  Return immediately
        -: 2174:  // if the semaphore is not available and avoid grabing the
        -: 2175:  // lock.
        -: 2176:  DWORD result = ::WaitForSingleObject (s->count_nonzero_, 0);
        -: 2177:
        -: 2178:  if (result == WAIT_OBJECT_0)  // Proceed when it is available.
        -: 2179:    {
        -: 2180:      ACE_OS::thread_mutex_lock (&s->lock_);
        -: 2181:
        -: 2182:      // Need to double check if the semaphore is still available.
        -: 2183:      // The double checking scheme will slightly affect the
        -: 2184:      // efficiency if most of the time semaphores are not blocked.
        -: 2185:      result = ::WaitForSingleObject (s->count_nonzero_, 0);
        -: 2186:      if (result == WAIT_OBJECT_0)
        -: 2187:        {
        -: 2188:          // Adjust the semaphore count.  Only update the event
        -: 2189:          // object status when the state changed.
        -: 2190:          s->count_--;
        -: 2191:          if (s->count_ <= 0)
        -: 2192:            ACE_OS::event_reset (&s->count_nonzero_);
        -: 2193:          result = 0;
        -: 2194:        }
        -: 2195:
        -: 2196:      ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2197:    }
        -: 2198:
        -: 2199:  // Translate error message to errno used by ACE.
        -: 2200:  if (result == WAIT_TIMEOUT)
        -: 2201:    errno = EBUSY;
        -: 2202:  else
        -: 2203:    ACE_OS::set_errno_to_last_error ();
        -: 2204:  // This is taken from the hack above. ;)
        -: 2205:  return -1;
        -: 2206:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2207:#   elif defined (ACE_VXWORKS)
        -: 2208:  if (::semTake (s->sema_, NO_WAIT) == ERROR)
        -: 2209:    if (errno == S_objLib_OBJ_UNAVAILABLE)
        -: 2210:      {
        -: 2211:        // couldn't get the semaphore
        -: 2212:        errno = EBUSY;
        -: 2213:        return -1;
        -: 2214:      }
        -: 2215:    else
        -: 2216:      // error
        -: 2217:      return -1;
        -: 2218:  else
        -: 2219:    // got the semaphore
        -: 2220:    return 0;
        -: 2221:#   endif /* ACE_HAS_STHREADS */
        -: 2222:# else
        -: 2223:  ACE_UNUSED_ARG (s);
        -: 2224:  ACE_NOTSUP_RETURN (-1);
        -: 2225:# endif /* ACE_HAS_POSIX_SEM */
        -: 2226:}
        -: 2227:
        -: 2228:ACE_INLINE int
        -: 2229:ACE_OS::sema_wait (ACE_sema_t *s)
        -: 2230:{
        -: 2231:  ACE_OS_TRACE ("ACE_OS::sema_wait");
        -: 2232:# if defined (ACE_HAS_POSIX_SEM)
        -: 2233:  ACE_OSCALL_RETURN (::sem_wait (s->sema_), int, -1);
        -: 2234:# elif defined (ACE_USES_FIFO_SEM)
        -: 2235:  char c;
        -: 2236:  if (ACE_OS::read (s->fd_[0], &c, sizeof (char)) == 1)
        -: 2237:    return 0;
        -: 2238:  return -1;
        -: 2239:# elif defined (ACE_HAS_THREADS)
        -: 2240:#   if defined (ACE_HAS_STHREADS)
        -: 2241:  int result;
        -: 2242:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_wait (s), result), int, -1);
        -: 2243:#   elif defined (ACE_HAS_PTHREADS)
        -: 2244:  int result = 0;
        -: 2245:
        -: 2246:  ACE_PTHREAD_CLEANUP_PUSH (&s->lock_);
        -: 2247:
        -: 2248:  if (ACE_OS::mutex_lock (&s->lock_) != 0)
        -: 2249:    result = -1;
        -: 2250:  else
        -: 2251:    {
        -: 2252:      // Keep track of the number of waiters so that we can signal
        -: 2253:      // them properly in <ACE_OS::sema_post>.
        -: 2254:      s->waiters_++;
        -: 2255:
        -: 2256:      // Wait until the semaphore count is > 0.
        -: 2257:      while (s->count_ == 0)
        -: 2258:        if (ACE_OS::cond_wait (&s->count_nonzero_,
        -: 2259:                               &s->lock_) == -1)
        -: 2260:          {
        -: 2261:            result = -2; // -2 means that we need to release the mutex.
        -: 2262:            break;
        -: 2263:          }
        -: 2264:
        -: 2265:      --s->waiters_;
        -: 2266:    }
        -: 2267:
        -: 2268:  if (result == 0)
        -: 2269:    --s->count_;
        -: 2270:
        -: 2271:  if (result != -1)
        -: 2272:    ACE_OS::mutex_unlock (&s->lock_);
        -: 2273:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 2274:  return result < 0 ? -1 : result;
        -: 2275:
        -: 2276:#   elif defined (ACE_HAS_WTHREADS)
        -: 2277:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2278:  switch (::WaitForSingleObject (*s, INFINITE))
        -: 2279:    {
        -: 2280:    case WAIT_OBJECT_0:
        -: 2281:      return 0;
        -: 2282:    default:
        -: 2283:      // This is a hack, we need to find an appropriate mapping...
        -: 2284:      ACE_OS::set_errno_to_last_error ();
        -: 2285:      return -1;
        -: 2286:    }
        -: 2287:  /* NOTREACHED */
        -: 2288:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2289:  // Timed wait.
        -: 2290:  int result = -1;
        -: 2291:  for (;;)
        -: 2292:    // Check if the semaphore is avialable or not and wait forever.
        -: 2293:    // Don't bother to grab the lock if it is not available (to avoid
        -: 2294:    // deadlock.)
        -: 2295:    switch (::WaitForSingleObject (s->count_nonzero_, INFINITE))
        -: 2296:      {
        -: 2297:      case WAIT_OBJECT_0:
        -: 2298:        ACE_OS::thread_mutex_lock (&s->lock_);
        -: 2299:
        -: 2300:        // Need to double check if the semaphore is still available.
        -: 2301:        // This time, we shouldn't wait at all.
        -: 2302:        if (::WaitForSingleObject (s->count_nonzero_, 0) == WAIT_OBJECT_0)
        -: 2303:          {
        -: 2304:            // Decrease the internal counter.  Only update the event
        -: 2305:            // object's status when the state changed.
        -: 2306:            s->count_--;
        -: 2307:            if (s->count_ <= 0)
        -: 2308:              ACE_OS::event_reset (&s->count_nonzero_);
        -: 2309:            result = 0;
        -: 2310:          }
        -: 2311:
        -: 2312:        ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2313:        // if we didn't get a hold on the semaphore, the result won't
        -: 2314:        // be 0 and thus, we'll start from the beginning again.
        -: 2315:        if (result == 0)
        -: 2316:          return 0;
        -: 2317:        break;
        -: 2318:
        -: 2319:      default:
        -: 2320:        // Since we wait indefinitely, anything other than
        -: 2321:        // WAIT_OBJECT_O indicates an error.
        -: 2322:        ACE_OS::set_errno_to_last_error ();
        -: 2323:        // This is taken from the hack above. ;)
        -: 2324:        return -1;
        -: 2325:      }
        -: 2326:  /* NOTREACHED */
        -: 2327:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2328:#   elif defined (ACE_VXWORKS)
        -: 2329:  ACE_OSCALL_RETURN (::semTake (s->sema_, WAIT_FOREVER), int, -1);
        -: 2330:#   endif /* ACE_HAS_STHREADS */
        -: 2331:# else
        -: 2332:  ACE_UNUSED_ARG (s);
        -: 2333:  ACE_NOTSUP_RETURN (-1);
        -: 2334:# endif /* ACE_HAS_POSIX_SEM */
        -: 2335:}
        -: 2336:
        -: 2337:ACE_INLINE int
        -: 2338:ACE_OS::sema_wait (ACE_sema_t *s, ACE_Time_Value &tv)
        -: 2339:{
        -: 2340:  ACE_OS_TRACE ("ACE_OS::sema_wait");
        -: 2341:# if defined (ACE_HAS_POSIX_SEM)
        -: 2342:#   if defined (ACE_HAS_POSIX_SEM_TIMEOUT)
        -: 2343:  int rc;
        -: 2344:  timespec_t ts;
        -: 2345:  ts = tv; // Calls ACE_Time_Value::operator timespec_t().
        -: 2346:  ACE_OSCALL (::sem_timedwait (s->sema_, &ts), int, -1, rc);
        -: 2347:  if (rc == -1 && errno == ETIMEDOUT)
        -: 2348:    errno = ETIME;  /* POSIX returns ETIMEDOUT but we need ETIME */
        -: 2349:  return rc;
        -: 2350:#   elif !defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 2351:  int result = 0;
        -: 2352:  bool expired = false;
        -: 2353:  ACE_Errno_Guard error (errno);
        -: 2354:
        -: 2355:  ACE_PTHREAD_CLEANUP_PUSH (&s->lock_);
        -: 2356:
        -: 2357:  if (ACE_OS::mutex_lock (&s->lock_) != 0)
        -: 2358:    result = -2;
        -: 2359:  else
        -: 2360:    {
        -: 2361:      bool finished = true;
        -: 2362:      do
        -: 2363:      {
        -: 2364:        result = ACE_OS::sema_trywait (s);
        -: 2365:        if (result == -1 && errno == EAGAIN)
        -: 2366:          expired = (tv.to_relative_time () <= ACE_Time_Value::zero);
        -: 2367:        else
        -: 2368:          expired = false;
        -: 2369:
        -: 2370:        finished = result != -1 || expired ||
        -: 2371:                   (result == -1 && errno != EAGAIN);
        -: 2372:        if (!finished)
        -: 2373:          {
        -: 2374:            if (ACE_OS::cond_timedwait (&s->count_nonzero_,
        -: 2375:                                        &s->lock_,
        -: 2376:                                        &tv) == -1)
        -: 2377:              {
        -: 2378:                error = errno;
        -: 2379:                result = -1;
        -: 2380:                break;
        -: 2381:              }
        -: 2382:          }
        -: 2383:      } while (!finished);
        -: 2384:
        -: 2385:      if (expired)
        -: 2386:        error = ETIME;
        -: 2387:
        -: 2388:#     if defined (ACE_LACKS_COND_TIMEDWAIT_RESET)
        -: 2389:      tv = tv.now ();
        -: 2390:#     endif /* ACE_LACKS_COND_TIMEDWAIT_RESET */
        -: 2391:    }
        -: 2392:
        -: 2393:  if (result != -2)
        -: 2394:    ACE_OS::mutex_unlock (&s->lock_);
        -: 2395:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 2396:  return result < 0 ? -1 : result;
        -: 2397:#   else /* No native sem_timedwait(), and emulation disabled */
        -: 2398:  ACE_UNUSED_ARG (s);
        -: 2399:  ACE_UNUSED_ARG (tv);
        -: 2400:  ACE_NOTSUP_RETURN (-1);
        -: 2401:#   endif /* ACE_HAS_POSIX_SEM_TIMEOUT */
        -: 2402:# elif defined (ACE_USES_FIFO_SEM)
        -: 2403:  int rc;
        -: 2404:  ACE_Time_Value timeout = tv.to_relative_time ();
        -: 2405:
        -: 2406:  while (timeout > ACE_Time_Value::zero)
        -: 2407:    {
        -: 2408:      ACE_Handle_Set  fds_;
        -: 2409:
        -: 2410:      fds_.set_bit (s->fd_[0]);
        -: 2411:      if ((rc = ACE_OS::select (ACE_Handle_Set::MAXSIZE, fds_, 0, 0, timeout)) != 1)
        -: 2412:        {
        -: 2413:          if (rc == 0 || errno != EAGAIN)
        -: 2414:          {
        -: 2415:            if (rc == 0)
        -: 2416:              errno = ETIME;
        -: 2417:            return -1;
        -: 2418:          }
        -: 2419:        }
        -: 2420:
        -: 2421:      // try to read the signal *but* do *not* block
        -: 2422:      if (rc == 1 && ACE_OS::sema_trywait (s) == 0)
        -: 2423:        return 0;
        -: 2424:
        -: 2425:      // we were woken for input but someone beat us to it
        -: 2426:      // so we wait again if there is still time
        -: 2427:      timeout = tv.to_relative_time ();
        -: 2428:    }
        -: 2429:
        -: 2430:  // make sure errno is set right
        -: 2431:  errno = ETIME;
        -: 2432:
        -: 2433:  return -1;
        -: 2434:# elif defined (ACE_HAS_THREADS)
        -: 2435:#   if defined (ACE_HAS_STHREADS)
        -: 2436:  ACE_UNUSED_ARG (s);
        -: 2437:  ACE_UNUSED_ARG (tv);
        -: 2438:  ACE_NOTSUP_RETURN (-1);
        -: 2439:#   elif defined (ACE_HAS_PTHREADS)
        -: 2440:  int result = 0;
        -: 2441:  ACE_Errno_Guard error (errno);
        -: 2442:
        -: 2443:  ACE_PTHREAD_CLEANUP_PUSH (&s->lock_);
        -: 2444:
        -: 2445:  if (ACE_OS::mutex_lock (&s->lock_) != 0)
        -: 2446:    result = -1;
        -: 2447:  else
        -: 2448:    {
        -: 2449:      // Keep track of the number of waiters so that we can signal
        -: 2450:      // them properly in <ACE_OS::sema_post>.
        -: 2451:      s->waiters_++;
        -: 2452:
        -: 2453:      // Wait until the semaphore count is > 0 or until we time out.
        -: 2454:      while (s->count_ == 0)
        -: 2455:        if (ACE_OS::cond_timedwait (&s->count_nonzero_,
        -: 2456:                                    &s->lock_,
        -: 2457:                                    &tv) == -1)
        -: 2458:          {
        -: 2459:            error = errno;
        -: 2460:            result = -2; // -2 means that we need to release the mutex.
        -: 2461:            break;
        -: 2462:          }
        -: 2463:
        -: 2464:      --s->waiters_;
        -: 2465:    }
        -: 2466:
        -: 2467:  if (result == 0)
        -: 2468:    {
        -: 2469:#     if defined (ACE_LACKS_COND_TIMEDWAIT_RESET)
        -: 2470:      tv = tv.now ();
        -: 2471:#     endif /* ACE_LACKS_COND_TIMEDWAIT_RESET */
        -: 2472:      --s->count_;
        -: 2473:    }
        -: 2474:
        -: 2475:  if (result != -1)
        -: 2476:    ACE_OS::mutex_unlock (&s->lock_);
        -: 2477:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 2478:  return result < 0 ? -1 : result;
        -: 2479:#   elif defined (ACE_HAS_WTHREADS)
        -: 2480:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2481:  int msec_timeout;
        -: 2482:
        -: 2483:  if (tv == ACE_Time_Value::zero)
        -: 2484:    msec_timeout = 0; // Do a "poll."
        -: 2485:  else
        -: 2486:    {
        -: 2487:      // Note that we must convert between absolute time (which is
        -: 2488:      // passed as a parameter) and relative time (which is what
        -: 2489:      // <WaitForSingleObjects> expects).
        -: 2490:      ACE_Time_Value relative_time = tv.to_relative_time ();
        -: 2491:
        -: 2492:      // Watchout for situations where a context switch has caused the
        -: 2493:      // current time to be > the timeout.
        -: 2494:      if (relative_time < ACE_Time_Value::zero)
        -: 2495:        msec_timeout = 0;
        -: 2496:      else
        -: 2497:        msec_timeout = relative_time.msec ();
        -: 2498:    }
        -: 2499:
        -: 2500:  switch (::WaitForSingleObject (*s, msec_timeout))
        -: 2501:    {
        -: 2502:    case WAIT_OBJECT_0:
        -: 2503:      tv = tv.now ();     // Update time to when acquired
        -: 2504:      return 0;
        -: 2505:    case WAIT_TIMEOUT:
        -: 2506:      errno = ETIME;
        -: 2507:      return -1;
        -: 2508:    default:
        -: 2509:      // This is a hack, we need to find an appropriate mapping...
        -: 2510:      ACE_OS::set_errno_to_last_error ();
        -: 2511:      return -1;
        -: 2512:    }
        -: 2513:  /* NOTREACHED */
        -: 2514:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2515:  // Note that in this mode, the acquire is done in two steps, and
        -: 2516:  // we may get signaled but cannot grab the semaphore before
        -: 2517:  // timeout.  In that case, we'll need to restart the process with
        -: 2518:  // updated timeout value.
        -: 2519:
        -: 2520:  // tv is an absolute time, but we need relative to work with the Windows
        -: 2521:  // API. Also, some users have become accustomed to using a 0 time value
        -: 2522:  // as a shortcut for "now", which works on non-Windows because 0 is
        -: 2523:  // always earlier than now. However, the need to convert to relative time
        -: 2524:  // means we need to watch out for this case.
        -: 2525:  ACE_Time_Value relative_time (ACE_Time_Value::zero);
        -: 2526:  if (tv != ACE_Time_Value::zero)
        -: 2527:    relative_time = tv.to_relative_time ();
        -: 2528:  int result = -1;
        -: 2529:
        -: 2530:  // While we are not timeout yet. >= 0 will let this go through once
        -: 2531:  // and if not able to get the object, it should hit WAIT_TIMEOUT
        -: 2532:  // right away.
        -: 2533:  while (relative_time >= ACE_Time_Value::zero)
        -: 2534:    {
        -: 2535:      // Wait for our turn to get the object.
        -: 2536:      switch (::WaitForSingleObject (s->count_nonzero_, relative_time.msec ()))
        -: 2537:        {
        -: 2538:        case WAIT_OBJECT_0:
        -: 2539:          ACE_OS::thread_mutex_lock (&s->lock_);
        -: 2540:
        -: 2541:          // Need to double check if the semaphore is still available.
        -: 2542:          // We can only do a "try lock" styled wait here to avoid
        -: 2543:          // blocking threads that want to signal the semaphore.
        -: 2544:          if (::WaitForSingleObject (s->count_nonzero_, 0) == WAIT_OBJECT_0)
        -: 2545:            {
        -: 2546:              // As before, only reset the object when the semaphore
        -: 2547:              // is no longer available.
        -: 2548:              s->count_--;
        -: 2549:              if (s->count_ <= 0)
        -: 2550:                ACE_OS::event_reset (&s->count_nonzero_);
        -: 2551:              result = 0;
        -: 2552:            }
        -: 2553:
        -: 2554:          ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2555:
        -: 2556:          // Only return when we successfully get the semaphore.
        -: 2557:          if (result == 0)
        -: 2558:            {
        -: 2559:              tv = tv.now ();     // Update to time acquired
        -: 2560:              return 0;
        -: 2561:            }
        -: 2562:          break;
        -: 2563:
        -: 2564:          // We have timed out.
        -: 2565:        case WAIT_TIMEOUT:
        -: 2566:          errno = ETIME;
        -: 2567:          return -1;
        -: 2568:
        -: 2569:          // What?
        -: 2570:        default:
        -: 2571:          ACE_OS::set_errno_to_last_error ();
        -: 2572:          // This is taken from the hack above. ;)
        -: 2573:          return -1;
        -: 2574:        };
        -: 2575:
        -: 2576:      // Haven't been able to get the semaphore yet, update the
        -: 2577:      // timeout value to reflect the remaining time we want to wait.
        -: 2578:      // in case of tv == 0 relative_time will now be < 0 and we will be out of time
        -: 2579:      relative_time = tv.to_relative_time ();
        -: 2580:    }
        -: 2581:
        -: 2582:  // We have timed out.
        -: 2583:  errno = ETIME;
        -: 2584:  return -1;
        -: 2585:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2586:#   elif defined (ACE_VXWORKS)
        -: 2587:  // Note that we must convert between absolute time (which is
        -: 2588:  // passed as a parameter) and relative time (which is what
        -: 2589:  // the system call expects).
        -: 2590:  ACE_Time_Value relative_time = tv.to_relative_time ();
        -: 2591:
        -: 2592:  int ticks_per_sec = ::sysClkRateGet ();
        -: 2593:
        -: 2594:  int ticks = relative_time.sec () * ticks_per_sec +
        -: 2595:              relative_time.usec () * ticks_per_sec / ACE_ONE_SECOND_IN_USECS;
        -: 2596:  if (::semTake (s->sema_, ticks) == ERROR)
        -: 2597:    {
        -: 2598:      if (errno == S_objLib_OBJ_TIMEOUT)
        -: 2599:        // Convert the VxWorks errno to one that's common for to ACE
        -: 2600:        // platforms.
        -: 2601:        errno = ETIME;
        -: 2602:      else if (errno == S_objLib_OBJ_UNAVAILABLE)
        -: 2603:        errno = EBUSY;
        -: 2604:      return -1;
        -: 2605:    }
        -: 2606:  else
        -: 2607:    {
        -: 2608:      tv = tv.now ();  // Update to time acquired
        -: 2609:      return 0;
        -: 2610:    }
        -: 2611:#   endif /* ACE_HAS_STHREADS */
        -: 2612:# else
        -: 2613:  ACE_UNUSED_ARG (s);
        -: 2614:  ACE_UNUSED_ARG (tv);
        -: 2615:  ACE_NOTSUP_RETURN (-1);
        -: 2616:# endif /* ACE_HAS_POSIX_SEM */
        -: 2617:}
        -: 2618:
        -: 2619:ACE_INLINE int
        -: 2620:ACE_OS::sema_wait (ACE_sema_t *s, ACE_Time_Value *tv)
        -: 2621:{
        -: 2622:  return tv == 0 ? ACE_OS::sema_wait (s) : ACE_OS::sema_wait (s, *tv);
        -: 2623:}
        -: 2624:
        -: 2625:ACE_INLINE int
        -: 2626:ACE_OS::semctl (int int_id, int semnum, int cmd, semun value)
        -: 2627:{
        -: 2628:  ACE_OS_TRACE ("ACE_OS::semctl");
        -: 2629:#if defined (ACE_HAS_SYSV_IPC)
        -: 2630:  ACE_OSCALL_RETURN (::semctl (int_id, semnum, cmd, value), int, -1);
        -: 2631:#else
        -: 2632:  ACE_UNUSED_ARG (int_id);
        -: 2633:  ACE_UNUSED_ARG (semnum);
        -: 2634:  ACE_UNUSED_ARG (cmd);
        -: 2635:  ACE_UNUSED_ARG (value);
        -: 2636:
        -: 2637:  ACE_NOTSUP_RETURN (-1);
        -: 2638:#endif /* ACE_HAS_SYSV_IPC */
        -: 2639:}
        -: 2640:
        -: 2641:ACE_INLINE int
        -: 2642:ACE_OS::semget (key_t key, int nsems, int flags)
        -: 2643:{
        -: 2644:  ACE_OS_TRACE ("ACE_OS::semget");
        -: 2645:#if defined (ACE_HAS_SYSV_IPC)
        -: 2646:  ACE_OSCALL_RETURN (::semget (key, nsems, flags), int, -1);
        -: 2647:#else
        -: 2648:  ACE_UNUSED_ARG (key);
        -: 2649:  ACE_UNUSED_ARG (nsems);
        -: 2650:  ACE_UNUSED_ARG (flags);
        -: 2651:
        -: 2652:  ACE_NOTSUP_RETURN (-1);
        -: 2653:#endif /* ACE_HAS_SYSV_IPC */
        -: 2654:}
        -: 2655:
        -: 2656:ACE_INLINE int
        -: 2657:ACE_OS::semop (int int_id, struct sembuf *sops, size_t nsops)
        -: 2658:{
        -: 2659:  ACE_OS_TRACE ("ACE_OS::semop");
        -: 2660:#if defined (ACE_HAS_SYSV_IPC)
        -: 2661:  ACE_OSCALL_RETURN (::semop (int_id, sops, nsops), int, -1);
        -: 2662:#else
        -: 2663:  ACE_UNUSED_ARG (int_id);
        -: 2664:  ACE_UNUSED_ARG (sops);
        -: 2665:  ACE_UNUSED_ARG (nsops);
        -: 2666:
        -: 2667:  ACE_NOTSUP_RETURN (-1);
        -: 2668:#endif /* ACE_HAS_SYSV_IPC */
        -: 2669:}
        -: 2670:
        -: 2671:ACE_INLINE int
        -: 2672:ACE_OS::sigtimedwait (const sigset_t *sset,
        -: 2673:                      siginfo_t *info,
        -: 2674:                      const ACE_Time_Value *timeout)
        -: 2675:{
        -: 2676:  ACE_OS_TRACE ("ACE_OS::sigtimedwait");
        -: 2677:#if defined (ACE_HAS_SIGTIMEDWAIT)
        -: 2678:  timespec_t ts;
        -: 2679:  timespec_t *tsp = 0;
        -: 2680:
        -: 2681:  if (timeout != 0)
        -: 2682:    {
        -: 2683:      ts = *timeout; // Calls ACE_Time_Value::operator timespec_t().
        -: 2684:      tsp = &ts;
        -: 2685:    }
        -: 2686:
        -: 2687:  ACE_OSCALL_RETURN (::sigtimedwait (sset, info, tsp),
        -: 2688:                     int, -1);
        -: 2689:#else
        -: 2690:    ACE_UNUSED_ARG (sset);
        -: 2691:    ACE_UNUSED_ARG (info);
        -: 2692:    ACE_UNUSED_ARG (timeout);
        -: 2693:    ACE_NOTSUP_RETURN (-1);
        -: 2694:#endif /* ACE_HAS_SIGTIMEDWAIT */
        -: 2695:}
        -: 2696:
        -: 2697:ACE_INLINE int
        -: 2698:ACE_OS::sigwait (sigset_t *sset, int *sig)
        -: 2699:{
        -: 2700:  ACE_OS_TRACE ("ACE_OS::sigwait");
        -: 2701:  int local_sig;
        -: 2702:  if (sig == 0)
        -: 2703:    sig = &local_sig;
        -: 2704:#if defined (ACE_HAS_THREADS)
        -: 2705:# if (defined (__FreeBSD__) && (__FreeBSD__ < 3))
        -: 2706:    ACE_UNUSED_ARG (sset);
        -: 2707:    ACE_NOTSUP_RETURN (-1);
        -: 2708:# elif defined (ACE_HAS_STHREADS)
        -: 2709:   # if (_POSIX_C_SOURCE - 0 >= 199506L) || defined (_POSIX_PTHREAD_SEMANTICS)
        -: 2710:     errno = ::sigwait (sset, sig);
        -: 2711:     return errno == 0  ?  *sig  :  -1;
        -: 2712:   #else
        -: 2713:     *sig = ::sigwait (sset);
        -: 2714:     return *sig;
        -: 2715:   #endif /* _POSIX_C_SOURCE - 0 >= 199506L || _POSIX_PTHREAD_SEMANTICS */
        -: 2716:# elif defined (ACE_HAS_PTHREADS)
        -: 2717:#   if defined (CYGWIN32)
        -: 2718:      // Cygwin has sigwait definition, but it is not implemented
        -: 2719:      ACE_UNUSED_ARG (sset);
        -: 2720:      ACE_NOTSUP_RETURN (-1);
        -: 2721:#   else   /* this is std */
        -: 2722:      errno = ::sigwait (sset, sig);
        -: 2723:      return errno == 0  ?  *sig  :  -1;
        -: 2724:#   endif /* CYGWIN32 */
        -: 2725:# elif defined (ACE_HAS_WTHREADS)
        -: 2726:    ACE_UNUSED_ARG (sset);
        -: 2727:    ACE_NOTSUP_RETURN (-1);
        -: 2728:# elif defined (ACE_VXWORKS)
        -: 2729:    // Second arg is a struct siginfo *, which we don't need (the
        -: 2730:    // selected signal number is returned).  Third arg is timeout:  0
        -: 2731:    // means forever.
        -: 2732:    *sig = ::sigtimedwait (sset, 0, 0);
        -: 2733:    return *sig;
        -: 2734:# endif /* __FreeBSD__ */
        -: 2735:#else
        -: 2736:    ACE_UNUSED_ARG (sset);
        -: 2737:    ACE_UNUSED_ARG (sig);
        -: 2738:    ACE_NOTSUP_RETURN (-1);
        -: 2739:#endif /* ACE_HAS_THREADS */
        -: 2740:}
        -: 2741:
        -: 2742:ACE_INLINE int
        -: 2743:ACE_OS::sigwaitinfo (const sigset_t *sset,
        -: 2744:                     siginfo_t *info)
        -: 2745:{
        -: 2746:  ACE_OS_TRACE ("ACE_OS::sigwaitinfo");
        -: 2747:  // If this platform has sigtimedwait, it should have sigwaitinfo as well.
        -: 2748:  // If this isn't true somewhere, let me know and I'll fix this.
        -: 2749:  // -Steve Huston <shuston@riverace.com>.
        -: 2750:#if defined (ACE_HAS_SIGTIMEDWAIT)
        -: 2751:  ACE_OSCALL_RETURN (::sigwaitinfo (sset, info), int, -1);
        -: 2752:#else
        -: 2753:  ACE_UNUSED_ARG (sset);
        -: 2754:  ACE_UNUSED_ARG (info);
        -: 2755:  ACE_NOTSUP_RETURN (-1);
        -: 2756:#endif /* ACE_HAS_SIGTIMEDWAIT */
        -: 2757:}
        -: 2758:
        -: 2759:ACE_INLINE int
        -: 2760:ACE_OS::thr_cancel (ACE_thread_t thr_id)
        -: 2761:{
        -: 2762:  ACE_OS_TRACE ("ACE_OS::thr_cancel");
        -: 2763:#if defined (ACE_HAS_THREADS)
        -: 2764:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 2765:  int result;
        -: 2766:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cancel (thr_id),
        -: 2767:                                        result),
        -: 2768:                      int, -1);
        -: 2769:# elif defined (ACE_HAS_VXTHREADS)
        -: 2770:  ACE_OSCALL_RETURN (::taskDelete (thr_id), int, -1);
        -: 2771:# else /* Could be ACE_HAS_PTHREADS && ACE_LACKS_PTHREAD_CANCEL */
        -: 2772:  ACE_UNUSED_ARG (thr_id);
        -: 2773:  ACE_NOTSUP_RETURN (-1);
        -: 2774:# endif /* ACE_HAS_PTHREADS */
        -: 2775:#else
        -: 2776:  ACE_UNUSED_ARG (thr_id);
        -: 2777:  ACE_NOTSUP_RETURN (-1);
        -: 2778:#endif /* ACE_HAS_THREADS */
        -: 2779:}
        -: 2780:
        -: 2781:ACE_INLINE int
        -: 2782:ACE_OS::thr_cmp (ACE_hthread_t t1, ACE_hthread_t t2)
        -: 2783:{
        -: 2784:#if defined (ACE_HAS_PTHREADS)
        -: 2785:# if defined (pthread_equal)
        -: 2786:  // If it's a macro we can't say "pthread_equal"...
        -: 2787:  return pthread_equal (t1, t2);
        -: 2788:# else
        -: 2789:  return pthread_equal (t1, t2);
        -: 2790:# endif /* pthread_equal */
        -: 2791:#else /* For STHREADS, WTHREADS, and VXWORKS ... */
        -: 2792:  // Hum, Do we need to treat WTHREAD differently?
        -: 2793:  // levine 13 oct 98 % Probably, ACE_hthread_t is a HANDLE.
        -: 2794:  return t1 == t2;
        -: 2795:#endif /* ACE_HAS_PTHREADS */
        -: 2796:}
        -: 2797:
        -: 2798:ACE_INLINE int
        -: 2799:ACE_OS::thr_continue (ACE_hthread_t target_thread)
        -: 2800:{
        -: 2801:  ACE_OS_TRACE ("ACE_OS::thr_continue");
        -: 2802:#if defined (ACE_HAS_THREADS)
        -: 2803:# if defined (ACE_HAS_STHREADS)
        -: 2804:  int result;
        -: 2805:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_continue (target_thread), result), int, -1);
        -: 2806:# elif defined (ACE_HAS_PTHREADS)
        -: 2807:#  if defined (ACE_HAS_PTHREAD_CONTINUE)
        -: 2808:  int result;
        -: 2809:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_continue (target_thread),
        -: 2810:                                       result),
        -: 2811:                     int, -1);
        -: 2812:#  elif defined (ACE_HAS_PTHREAD_CONTINUE_NP)
        -: 2813:  int result;
        -: 2814:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_continue_np (target_thread),
        -: 2815:                                       result),
        -: 2816:                     int, -1);
        -: 2817:#  elif defined (ACE_HAS_PTHREAD_RESUME_NP)
        -: 2818:  int result;
        -: 2819:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_resume_np (target_thread),
        -: 2820:                                       result),
        -: 2821:                     int, -1);
        -: 2822:#  else
        -: 2823:  ACE_UNUSED_ARG (target_thread);
        -: 2824:  ACE_NOTSUP_RETURN (-1);
        -: 2825:#  endif /* ACE_HAS_PTHREAD_CONTINUE */
        -: 2826:# elif defined (ACE_HAS_WTHREADS)
        -: 2827:  DWORD result = ::ResumeThread (target_thread);
        -: 2828:  if (result == ACE_SYSCALL_FAILED)
        -: 2829:    ACE_FAIL_RETURN (-1);
        -: 2830:  else
        -: 2831:    return 0;
        -: 2832:# elif defined (ACE_HAS_VXTHREADS)
        -: 2833:  ACE_OSCALL_RETURN (::taskResume (target_thread), int, -1);
        -: 2834:# endif /* ACE_HAS_STHREADS */
        -: 2835:#else
        -: 2836:  ACE_UNUSED_ARG (target_thread);
        -: 2837:  ACE_NOTSUP_RETURN (-1);
        -: 2838:#endif /* ACE_HAS_THREADS */
        -: 2839:}
        -: 2840:
        -: 2841:ACE_INLINE int
        -: 2842:ACE_OS::thr_getconcurrency (void)
        -: 2843:{
        -: 2844:  ACE_OS_TRACE ("ACE_OS::thr_getconcurrency");
        -: 2845:#if defined (ACE_HAS_THREADS)
        -: 2846:# if defined (ACE_HAS_STHREADS)
        -: 2847:  return ::thr_getconcurrency ();
        -: 2848:# elif defined (ACE_HAS_PTHREADS) && defined (ACE_HAS_PTHREAD_GETCONCURRENCY)
        -: 2849:  return pthread_getconcurrency ();
        -: 2850:# else
        -: 2851:  ACE_NOTSUP_RETURN (-1);
        -: 2852:# endif /* ACE_HAS_STHREADS */
        -: 2853:#else
        -: 2854:  ACE_NOTSUP_RETURN (-1);
        -: 2855:#endif /* ACE_HAS_THREADS */
        -: 2856:}
        -: 2857:
        -: 2858:ACE_INLINE int
        -: 2859:ACE_OS::thr_getprio (ACE_hthread_t ht_id, int &priority, int &policy)
        -: 2860:{
        -: 2861:  ACE_OS_TRACE ("ACE_OS::thr_getprio");
        -: 2862:  ACE_UNUSED_ARG (policy);
        -: 2863:#if defined (ACE_HAS_THREADS)
        -: 2864:# if (defined (ACE_HAS_PTHREADS) && \
        -: 2865:     (!defined (ACE_LACKS_SETSCHED) || defined (ACE_HAS_PTHREAD_SCHEDPARAM)))
        -: 2866:
        -: 2867:  struct sched_param param;
        -: 2868:  int result;
        -: 2869:
        -: 2870:  ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_getschedparam (ht_id, &policy, &param),
        -: 2871:                                result), int,
        -: 2872:              -1, result);
        -: 2873:  priority = param.sched_priority;
        -: 2874:  return result;
        -: 2875:# elif defined (ACE_HAS_STHREADS)
        -: 2876:  int result;
        -: 2877:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_getprio (ht_id, &priority), result), int, -1);
        -: 2878:# elif defined (ACE_HAS_WTHREADS)
        -: 2879:  ACE_Errno_Guard error (errno);
        -: 2880:
        -: 2881:#   if defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY)
        -: 2882:  priority = ::CeGetThreadPriority (ht_id);
        -: 2883:#   else
        -: 2884:  priority = ::GetThreadPriority (ht_id);
        -: 2885:#   endif /* defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY) */
        -: 2886:
        -: 2887:#   if defined (ACE_HAS_PHARLAP)
        -: 2888:#     if defined (ACE_PHARLAP_LABVIEW_RT)
        -: 2889:  policy = ACE_SCHED_FIFO;
        -: 2890:#     else
        -: 2891:  DWORD timeslice = ::EtsGetTimeSlice ();
        -: 2892:  policy = timeslice == 0 ? ACE_SCHED_OTHER : ACE_SCHED_FIFO;
        -: 2893:#     endif /* ACE_PHARLAP_LABVIEW_RT */
        -: 2894:#   elif !defined (ACE_HAS_WINCE)
        -: 2895:  DWORD priority_class = ::GetPriorityClass (::GetCurrentProcess ());
        -: 2896:  if (priority_class == 0 && (error = ::GetLastError ()) != NO_ERROR)
        -: 2897:    ACE_FAIL_RETURN (-1);
        -: 2898:
        -: 2899:  policy =
        -: 2900:    (priority_class ==
        -: 2901:     REALTIME_PRIORITY_CLASS) ? ACE_SCHED_FIFO : ACE_SCHED_OTHER;
        -: 2902:#   endif /* ACE_HAS_PHARLAP */
        -: 2903:
        -: 2904:  return 0;
        -: 2905:# elif defined (ACE_HAS_VXTHREADS)
        -: 2906:  ACE_OSCALL_RETURN (::taskPriorityGet (ht_id, &priority), int, -1);
        -: 2907:# else
        -: 2908:  ACE_UNUSED_ARG (ht_id);
        -: 2909:  ACE_UNUSED_ARG (priority);
        -: 2910:  ACE_NOTSUP_RETURN (-1);
        -: 2911:# endif /* ACE_HAS_STHREADS */
        -: 2912:#else
        -: 2913:  ACE_UNUSED_ARG (ht_id);
        -: 2914:  ACE_UNUSED_ARG (priority);
        -: 2915:  ACE_NOTSUP_RETURN (-1);
        -: 2916:#endif /* ACE_HAS_THREADS */
        -: 2917:}
        -: 2918:
        -: 2919:ACE_INLINE int
        -: 2920:ACE_OS::thr_getprio (ACE_hthread_t ht_id, int &priority)
        -: 2921:{
        -: 2922:  ACE_OS_TRACE ("ACE_OS::thr_getprio");
        -: 2923:  int policy = 0;
        -: 2924:  return ACE_OS::thr_getprio (ht_id, priority, policy);
        -: 2925:}
        -: 2926:
        -: 2927:#if defined (ACE_HAS_THREAD_SPECIFIC_STORAGE)
        -: 2928:ACE_INLINE int
        -: 2929:ACE_OS::thr_getspecific_native (ACE_OS_thread_key_t key, void **data)
        -: 2930:{
        -: 2931://  ACE_OS_TRACE ("ACE_OS::thr_getspecific_native");
        -: 2932:# if defined (ACE_HAS_PTHREADS)
        -: 2933:    *data = pthread_getspecific (key);
        -: 2934:    return 0;
        -: 2935:# elif defined (ACE_HAS_STHREADS)
        -: 2936:    int result;
        -: 2937:    ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_getspecific (key, data), result), int, -1);
        -: 2938:# elif defined (ACE_HAS_WTHREADS)
        -: 2939:  *data = ::TlsGetValue (key);
        -: 2940:  if (*data == 0 && ::GetLastError () != NO_ERROR)
        -: 2941:    {
        -: 2942:      ACE_OS::set_errno_to_last_error ();
        -: 2943:      return -1;
        -: 2944:    }
        -: 2945:  else
        -: 2946:    return 0;
        -: 2947:# else /* ACE_HAS_PTHREADS etc.*/
        -: 2948:  ACE_UNUSED_ARG (key);
        -: 2949:  ACE_UNUSED_ARG (data);
        -: 2950:  ACE_NOTSUP_RETURN (-1);
        -: 2951:# endif /* ACE_HAS_PTHREADS etc.*/
        -: 2952:}
        -: 2953:#endif /* ACE_HAS_THREAD_SPECIFIC_STORAGE */
        -: 2954:
        -: 2955:ACE_INLINE int
        -: 2956:ACE_OS::thr_getspecific (ACE_thread_key_t key, void **data)
        -: 2957:{
        -: 2958://   ACE_OS_TRACE ("ACE_OS::thr_getspecific");
        -: 2959:#if defined (ACE_HAS_THREADS)
        -: 2960:# if defined (ACE_HAS_TSS_EMULATION)
        -: 2961:    if (ACE_TSS_Emulation::is_key (key) == 0)
        -: 2962:      {
        -: 2963:        errno = EINVAL;
        -: 2964:        data = 0;
        -: 2965:        return -1;
        -: 2966:      }
        -: 2967:    else
        -: 2968:      {
        -: 2969:        *data = ACE_TSS_Emulation::ts_object (key);
        -: 2970:        return 0;
        -: 2971:      }
        -: 2972:# elif defined (ACE_HAS_THREAD_SPECIFIC_STORAGE)
        -: 2973:  return ACE_OS::thr_getspecific_native (key, data);
        -: 2974:#else
        -: 2975:  ACE_UNUSED_ARG (key);
        -: 2976:  ACE_UNUSED_ARG (data);
        -: 2977:  ACE_NOTSUP_RETURN (-1);
        -: 2978:# endif /* ACE_HAS_TSS_EMULATION */
        -: 2979:#else
        -: 2980:  ACE_UNUSED_ARG (key);
        -: 2981:  ACE_UNUSED_ARG (data);
        -: 2982:  ACE_NOTSUP_RETURN (-1);
        -: 2983:#endif /* ACE_HAS_THREADS */
        -: 2984:}
        -: 2985:
        -: 2986:#if !defined (ACE_HAS_VXTHREADS)
        -: 2987:ACE_INLINE int
        -: 2988:ACE_OS::thr_join (ACE_hthread_t thr_handle,
        -: 2989:                  ACE_THR_FUNC_RETURN *status)
        -: 2990:{
        -: 2991:  ACE_OS_TRACE ("ACE_OS::thr_join");
        -: 2992:#if defined (ACE_HAS_THREADS)
        -: 2993:# if defined (ACE_HAS_STHREADS)
        -: 2994:  int result;
        -: 2995:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_join (thr_handle, 0, status), result),
        -: 2996:                     int, -1);
        -: 2997:# elif defined (ACE_HAS_PTHREADS)
        -: 2998:#  if defined (ACE_LACKS_PTHREAD_JOIN)
        -: 2999:  ACE_UNUSED_ARG (thr_handle);
        -: 3000:  ACE_UNUSED_ARG (status);
        -: 3001:  ACE_NOTSUP_RETURN (-1);
        -: 3002:#  else
        -: 3003:  int result;
        -: 3004:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_join (thr_handle, status), result),
        -: 3005:                     int, -1);
        -: 3006:#  endif /* ACE_LACKS_PTHREAD_JOIN */
        -: 3007:# elif defined (ACE_HAS_WTHREADS)
        -: 3008:  ACE_THR_FUNC_RETURN local_status = 0;
        -: 3009:
        -: 3010:  // Make sure that status is non-NULL.
        -: 3011:  if (status == 0)
        -: 3012:    status = &local_status;
        -: 3013:
        -: 3014:  if (::WaitForSingleObject (thr_handle, INFINITE) == WAIT_OBJECT_0
        -: 3015:      && ::GetExitCodeThread (thr_handle, status) != FALSE)
        -: 3016:    {
        -: 3017:      ::CloseHandle (thr_handle);
        -: 3018:      return 0;
        -: 3019:    }
        -: 3020:  ACE_FAIL_RETURN (-1);
        -: 3021:  /* NOTREACHED */
        -: 3022:# else
        -: 3023:  ACE_UNUSED_ARG (thr_handle);
        -: 3024:  ACE_UNUSED_ARG (status);
        -: 3025:  ACE_NOTSUP_RETURN (-1);
        -: 3026:# endif /* ACE_HAS_STHREADS */
        -: 3027:#else
        -: 3028:  ACE_UNUSED_ARG (thr_handle);
        -: 3029:  ACE_UNUSED_ARG (status);
        -: 3030:  ACE_NOTSUP_RETURN (-1);
        -: 3031:#endif /* ACE_HAS_THREADS */
        -: 3032:}
        -: 3033:
        -: 3034:ACE_INLINE int
        -: 3035:ACE_OS::thr_join (ACE_thread_t waiter_id,
        -: 3036:                  ACE_thread_t *thr_id,
        -: 3037:                  ACE_THR_FUNC_RETURN *status)
        -: 3038:{
        -: 3039:  ACE_OS_TRACE ("ACE_OS::thr_join");
        -: 3040:#if defined (ACE_HAS_THREADS)
        -: 3041:# if defined (ACE_HAS_STHREADS)
        -: 3042:  int result;
        -: 3043:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_join (waiter_id, thr_id, status), result),
        -: 3044:                     int, -1);
        -: 3045:# elif defined (ACE_HAS_PTHREADS)
        -: 3046:#  if defined (ACE_LACKS_PTHREAD_JOIN)
        -: 3047:  ACE_UNUSED_ARG (waiter_id);
        -: 3048:  ACE_UNUSED_ARG (thr_id);
        -: 3049:  ACE_UNUSED_ARG (status);
        -: 3050:  ACE_NOTSUP_RETURN (-1);
        -: 3051:#  else
        -: 3052:  ACE_UNUSED_ARG (thr_id);
        -: 3053:  int result;
        -: 3054:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_join (waiter_id, status), result),
        -: 3055:                     int, -1);
        -: 3056:#  endif /* ACE_LACKS_PTHREAD_JOIN */
        -: 3057:# elif defined (ACE_HAS_WTHREADS)
        -: 3058:  ACE_UNUSED_ARG (waiter_id);
        -: 3059:  ACE_UNUSED_ARG (thr_id);
        -: 3060:  ACE_UNUSED_ARG (status);
        -: 3061:
        -: 3062:  // This could be implemented if the DLL-Main function or the
        -: 3063:  // task exit base class some log the threads which have exited
        -: 3064:  ACE_NOTSUP_RETURN (-1);
        -: 3065:# endif /* ACE_HAS_STHREADS */
        -: 3066:#else
        -: 3067:  ACE_UNUSED_ARG (waiter_id);
        -: 3068:  ACE_UNUSED_ARG (thr_id);
        -: 3069:  ACE_UNUSED_ARG (status);
        -: 3070:  ACE_NOTSUP_RETURN (-1);
        -: 3071:#endif /* ACE_HAS_THREADS */
        -: 3072:}
        -: 3073:#endif /* !VXWORKS */
        -: 3074:
        -: 3075:ACE_INLINE int
        -: 3076:ACE_OS::thr_kill (ACE_thread_t thr_id, int signum)
        -: 3077:{
        -: 3078:  ACE_OS_TRACE ("ACE_OS::thr_kill");
        -: 3079:#if defined (ACE_HAS_THREADS)
        -: 3080:# if defined (ACE_HAS_PTHREADS)
        -: 3081:#   if defined (ACE_LACKS_PTHREAD_KILL)
        -: 3082:  ACE_UNUSED_ARG (signum);
        -: 3083:  ACE_UNUSED_ARG (thr_id);
        -: 3084:  ACE_NOTSUP_RETURN (-1);
        -: 3085:#   else
        -: 3086:  int result;
        -: 3087:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_kill (thr_id, signum),
        -: 3088:                                       result),
        -: 3089:                     int, -1);
        -: 3090:#   endif /* ACE_LACKS_PTHREAD_KILL */
        -: 3091:# elif defined (ACE_HAS_STHREADS)
        -: 3092:  int result;
        -: 3093:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_kill (thr_id, signum),
        -: 3094:                                       result),
        -: 3095:                     int, -1);
        -: 3096:# elif defined (ACE_HAS_VXTHREADS)
        -: 3097:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3098:  ACE_OSCALL_RETURN (::kill (thr_id, signum), int, -1);
        -: 3099:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3100:# else
        -: 3101:  ACE_UNUSED_ARG (thr_id);
        -: 3102:  ACE_UNUSED_ARG (signum);
        -: 3103:  ACE_NOTSUP_RETURN (-1);
        -: 3104:# endif /* ACE_HAS_STHREADS */
        -: 3105:#else
        -: 3106:  ACE_UNUSED_ARG (thr_id);
        -: 3107:  ACE_UNUSED_ARG (signum);
        -: 3108:  ACE_NOTSUP_RETURN (-1);
        -: 3109:#endif /* ACE_HAS_THREADS */
        -: 3110:}
        -: 3111:
        -: 3112:ACE_INLINE size_t
        -: 3113:ACE_OS::thr_min_stack (void)
        -: 3114:{
        -: 3115:  ACE_OS_TRACE ("ACE_OS::thr_min_stack");
        -: 3116:#if defined (ACE_HAS_THREADS)
        -: 3117:# if defined (ACE_HAS_STHREADS)
        -: 3118:#   if defined (ACE_HAS_THR_MINSTACK)
        -: 3119:  // Tandem did some weirdo mangling of STHREAD names...
        -: 3120:  return ::thr_minstack ();
        -: 3121:#   else
        -: 3122:  return ::thr_min_stack ();
        -: 3123:#   endif /* !ACE_HAS_THR_MINSTACK */
        -: 3124:# elif defined (ACE_HAS_PTHREADS)
        -: 3125:#   if defined (_SC_THREAD_STACK_MIN)
        -: 3126:  return (size_t) ACE_OS::sysconf (_SC_THREAD_STACK_MIN);
        -: 3127:#   elif defined (PTHREAD_STACK_MIN)
        -: 3128:  return PTHREAD_STACK_MIN;
        -: 3129:#   else
        -: 3130:  ACE_NOTSUP_RETURN (0);
        -: 3131:#   endif /* _SC_THREAD_STACK_MIN */
        -: 3132:# elif defined (ACE_HAS_WTHREADS)
        -: 3133:  ACE_NOTSUP_RETURN (0);
        -: 3134:# elif defined (ACE_HAS_VXTHREADS)
        -: 3135:  TASK_DESC taskDesc;
        -: 3136:  STATUS status;
        -: 3137:
        -: 3138:  ACE_thread_t tid = ACE_OS::thr_self ();
        -: 3139:
        -: 3140:  ACE_OSCALL (ACE_ADAPT_RETVAL (::taskInfoGet (tid, &taskDesc),
        -: 3141:                                status),
        -: 3142:              STATUS, -1, status);
        -: 3143:  return status == OK ? taskDesc.td_stackSize : 0;
        -: 3144:# else /* Should not happen... */
        -: 3145:  ACE_NOTSUP_RETURN (0);
        -: 3146:# endif /* ACE_HAS_STHREADS */
        -: 3147:#else
        -: 3148:  ACE_NOTSUP_RETURN (0);
        -: 3149:#endif /* ACE_HAS_THREADS */
        -: 3150:}
        -: 3151:
        -: 3152:ACE_INLINE ssize_t
        -: 3153:ACE_OS::thr_id (char buffer[], size_t buffer_length)
        -: 3154:{
        -: 3155:#if defined (ACE_WIN32)
        -: 3156:  return ACE_OS::snprintf (buffer,
        -: 3157:                           buffer_length,
        -: 3158:                           "%u",
        -: 3159:                           static_cast <unsigned> (ACE_OS::thr_self ()));
        -: 3160:#else /* ACE_WIN32 */
        -: 3161:  ACE_hthread_t t_id;
        -: 3162:  ACE_OS::thr_self (t_id);
        -: 3163:#if defined(ACE_HAS_OPAQUE_PTHREAD_T)
        -: 3164:  return ACE_OS::snprintf (buffer,
        -: 3165:                           buffer_length,
        -: 3166:                           "%s",
        -: 3167:                           "<unknown>");
        -: 3168:#else /* ACE_HAS_OPAQUE_PTHREAD_T */
        -: 3169:  return ACE_OS::snprintf (buffer,
        -: 3170:                           buffer_length,
        -: 3171:                           "%lu",
        -: 3172:                           (unsigned long) t_id);
        -: 3173:#endif /* ACE_HAS_OPAQUE_PTHREAD_T */
        -: 3174:#endif /* WIN32 */
        -: 3175:}
        -: 3176:
        -: 3177:ACE_INLINE ssize_t
        -: 3178:ACE_OS::thr_gettid (char buffer[], size_t buffer_length)
        -: 3179:{
        -: 3180:  return ACE_OS::snprintf (buffer, buffer_length, "%d",
        -: 3181:    static_cast<int> (ACE_OS::thr_gettid ()));
        -: 3182:}
        -: 3183:
        -: 3184:ACE_INLINE ACE_thread_t
    #####: 3185:ACE_OS::thr_self (void)
        -: 3186:{
        -: 3187:  // ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3188:#if defined (ACE_HAS_THREADS)
        -: 3189:# if defined (ACE_HAS_PTHREADS)
        -: 3190:  // Note, don't use "::" here since the following call is often a macro.
    #####: 3191:  return pthread_self ();
        -: 3192:# elif defined (ACE_HAS_STHREADS)
        -: 3193:  ACE_OSCALL_RETURN (::thr_self (), int, -1);
        -: 3194:# elif defined (ACE_HAS_WTHREADS)
        -: 3195:  return ::GetCurrentThreadId ();
        -: 3196:# elif defined (ACE_HAS_VXTHREADS)
        -: 3197:  return ::taskIdSelf ();
        -: 3198:# endif /* ACE_HAS_STHREADS */
        -: 3199:#else
        -: 3200:  return 1; // Might as well make it the first thread ;-)
        -: 3201:#endif /* ACE_HAS_THREADS */
        -: 3202:}
------------------
_ZN6ACE_OS8thr_selfEv:
    #####: 3185:ACE_OS::thr_self (void)
        -: 3186:{
        -: 3187:  // ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3188:#if defined (ACE_HAS_THREADS)
        -: 3189:# if defined (ACE_HAS_PTHREADS)
        -: 3190:  // Note, don't use "::" here since the following call is often a macro.
    #####: 3191:  return pthread_self ();
        -: 3192:# elif defined (ACE_HAS_STHREADS)
        -: 3193:  ACE_OSCALL_RETURN (::thr_self (), int, -1);
        -: 3194:# elif defined (ACE_HAS_WTHREADS)
        -: 3195:  return ::GetCurrentThreadId ();
        -: 3196:# elif defined (ACE_HAS_VXTHREADS)
        -: 3197:  return ::taskIdSelf ();
        -: 3198:# endif /* ACE_HAS_STHREADS */
        -: 3199:#else
        -: 3200:  return 1; // Might as well make it the first thread ;-)
        -: 3201:#endif /* ACE_HAS_THREADS */
        -: 3202:}
------------------
_ZN6ACE_OS8thr_selfEv:
    #####: 3185:ACE_OS::thr_self (void)
        -: 3186:{
        -: 3187:  // ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3188:#if defined (ACE_HAS_THREADS)
        -: 3189:# if defined (ACE_HAS_PTHREADS)
        -: 3190:  // Note, don't use "::" here since the following call is often a macro.
    #####: 3191:  return pthread_self ();
        -: 3192:# elif defined (ACE_HAS_STHREADS)
        -: 3193:  ACE_OSCALL_RETURN (::thr_self (), int, -1);
        -: 3194:# elif defined (ACE_HAS_WTHREADS)
        -: 3195:  return ::GetCurrentThreadId ();
        -: 3196:# elif defined (ACE_HAS_VXTHREADS)
        -: 3197:  return ::taskIdSelf ();
        -: 3198:# endif /* ACE_HAS_STHREADS */
        -: 3199:#else
        -: 3200:  return 1; // Might as well make it the first thread ;-)
        -: 3201:#endif /* ACE_HAS_THREADS */
        -: 3202:}
------------------
_ZN6ACE_OS8thr_selfEv:
    #####: 3185:ACE_OS::thr_self (void)
        -: 3186:{
        -: 3187:  // ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3188:#if defined (ACE_HAS_THREADS)
        -: 3189:# if defined (ACE_HAS_PTHREADS)
        -: 3190:  // Note, don't use "::" here since the following call is often a macro.
    #####: 3191:  return pthread_self ();
        -: 3192:# elif defined (ACE_HAS_STHREADS)
        -: 3193:  ACE_OSCALL_RETURN (::thr_self (), int, -1);
        -: 3194:# elif defined (ACE_HAS_WTHREADS)
        -: 3195:  return ::GetCurrentThreadId ();
        -: 3196:# elif defined (ACE_HAS_VXTHREADS)
        -: 3197:  return ::taskIdSelf ();
        -: 3198:# endif /* ACE_HAS_STHREADS */
        -: 3199:#else
        -: 3200:  return 1; // Might as well make it the first thread ;-)
        -: 3201:#endif /* ACE_HAS_THREADS */
        -: 3202:}
------------------
_ZN6ACE_OS8thr_selfEv:
    #####: 3185:ACE_OS::thr_self (void)
        -: 3186:{
        -: 3187:  // ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3188:#if defined (ACE_HAS_THREADS)
        -: 3189:# if defined (ACE_HAS_PTHREADS)
        -: 3190:  // Note, don't use "::" here since the following call is often a macro.
    #####: 3191:  return pthread_self ();
        -: 3192:# elif defined (ACE_HAS_STHREADS)
        -: 3193:  ACE_OSCALL_RETURN (::thr_self (), int, -1);
        -: 3194:# elif defined (ACE_HAS_WTHREADS)
        -: 3195:  return ::GetCurrentThreadId ();
        -: 3196:# elif defined (ACE_HAS_VXTHREADS)
        -: 3197:  return ::taskIdSelf ();
        -: 3198:# endif /* ACE_HAS_STHREADS */
        -: 3199:#else
        -: 3200:  return 1; // Might as well make it the first thread ;-)
        -: 3201:#endif /* ACE_HAS_THREADS */
        -: 3202:}
------------------
        -: 3203:
        -: 3204:ACE_INLINE const char*
        -: 3205:ACE_OS::thr_name (void)
        -: 3206:{
        -: 3207:#if defined (ACE_HAS_THREADS)
        -: 3208:#if defined (ACE_HAS_VXTHREADS)
        -: 3209:  return ::taskName (ACE_OS::thr_self ());
        -: 3210:#else
        -: 3211:  ACE_NOTSUP_RETURN (0);
        -: 3212:#endif
        -: 3213:#else
        -: 3214:  ACE_NOTSUP_RETURN (0);
        -: 3215:#endif
        -: 3216:}
        -: 3217:
        -: 3218:ACE_INLINE void
        -: 3219:ACE_OS::thr_self (ACE_hthread_t &self)
        -: 3220:{
        -: 3221:  ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3222:#if defined (ACE_HAS_THREADS)
        -: 3223:# if defined (ACE_HAS_PTHREADS)
        -: 3224:  // Note, don't use "::" here since the following call is often a macro.
        -: 3225:  self = pthread_self ();
        -: 3226:# elif defined (ACE_HAS_THREAD_SELF)
        -: 3227:  self = ::thread_self ();
        -: 3228:# elif defined (ACE_HAS_STHREADS)
        -: 3229:  self = ::thr_self ();
        -: 3230:# elif defined (ACE_HAS_WTHREADS)
        -: 3231:  self = ::GetCurrentThread ();
        -: 3232:# elif defined (ACE_HAS_VXTHREADS)
        -: 3233:  self = ::taskIdSelf ();
        -: 3234:# endif /* ACE_HAS_STHREADS */
        -: 3235:#else
        -: 3236:  self = 1; // Might as well make it the main thread ;-)
        -: 3237:#endif /* ACE_HAS_THREADS */
        -: 3238:}
        -: 3239:
        -: 3240:ACE_INLINE int
        -: 3241:ACE_OS::thr_setcancelstate (int new_state, int *old_state)
        -: 3242:{
        -: 3243:  ACE_OS_TRACE ("ACE_OS::thr_setcancelstate");
        -: 3244:#if defined (ACE_HAS_THREADS)
        -: 3245:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 3246:  int result;
        -: 3247:  int local_new, local_old;
        -: 3248:  switch (new_state)
        -: 3249:    {
        -: 3250:    case THR_CANCEL_ENABLE:
        -: 3251:      local_new = PTHREAD_CANCEL_ENABLE;
        -: 3252:      break;
        -: 3253:    case THR_CANCEL_DISABLE:
        -: 3254:      local_new = PTHREAD_CANCEL_DISABLE;
        -: 3255:      break;
        -: 3256:    default:
        -: 3257:      errno = EINVAL;
        -: 3258:      return -1;
        -: 3259:    }
        -: 3260:  ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_setcancelstate (local_new,
        -: 3261:                                                        &local_old),
        -: 3262:                                result),
        -: 3263:              int, -1, result);
        -: 3264:  if (result == -1)
        -: 3265:    return -1;
        -: 3266:  switch (local_old)
        -: 3267:    {
        -: 3268:    case PTHREAD_CANCEL_ENABLE:
        -: 3269:      *old_state = THR_CANCEL_ENABLE;
        -: 3270:      break;
        -: 3271:    case PTHREAD_CANCEL_DISABLE:
        -: 3272:      *old_state = THR_CANCEL_DISABLE;
        -: 3273:      break;
        -: 3274:    }
        -: 3275:  return result;
        -: 3276:# elif defined (ACE_HAS_STHREADS)
        -: 3277:  ACE_UNUSED_ARG (new_state);
        -: 3278:  ACE_UNUSED_ARG (old_state);
        -: 3279:  ACE_NOTSUP_RETURN (-1);
        -: 3280:# elif defined (ACE_HAS_WTHREADS)
        -: 3281:  ACE_UNUSED_ARG (new_state);
        -: 3282:  ACE_UNUSED_ARG (old_state);
        -: 3283:  ACE_NOTSUP_RETURN (-1);
        -: 3284:# else /* Could be ACE_HAS_PTHREADS && ACE_LACKS_PTHREAD_CANCEL */
        -: 3285:  ACE_UNUSED_ARG (new_state);
        -: 3286:  ACE_UNUSED_ARG (old_state);
        -: 3287:  ACE_NOTSUP_RETURN (-1);
        -: 3288:# endif /* ACE_HAS_PTHREADS */
        -: 3289:#else
        -: 3290:  ACE_UNUSED_ARG (new_state);
        -: 3291:  ACE_UNUSED_ARG (old_state);
        -: 3292:  ACE_NOTSUP_RETURN (-1);
        -: 3293:#endif /* ACE_HAS_THREADS */
        -: 3294:}
        -: 3295:
        -: 3296:ACE_INLINE int
        -: 3297:ACE_OS::thr_setcanceltype (int new_type, int *old_type)
        -: 3298:{
        -: 3299:  ACE_OS_TRACE ("ACE_OS::thr_setcanceltype");
        -: 3300:#if defined (ACE_HAS_THREADS)
        -: 3301:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 3302:  int result;
        -: 3303:  int local_new, local_old;
        -: 3304:  switch (new_type)
        -: 3305:    {
        -: 3306:    case THR_CANCEL_DEFERRED:
        -: 3307:      local_new = PTHREAD_CANCEL_DEFERRED;
        -: 3308:      break;
        -: 3309:    case THR_CANCEL_ASYNCHRONOUS:
        -: 3310:      local_new = PTHREAD_CANCEL_ASYNCHRONOUS;
        -: 3311:      break;
        -: 3312:    default:
        -: 3313:      errno = EINVAL;
        -: 3314:      return -1;
        -: 3315:    }
        -: 3316:  ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_setcanceltype (local_new,
        -: 3317:                                                       &local_old),
        -: 3318:                                result),
        -: 3319:              int, -1, result);
        -: 3320:  if (result == -1)
        -: 3321:    return -1;
        -: 3322:  switch (local_old)
        -: 3323:    {
        -: 3324:    case PTHREAD_CANCEL_DEFERRED:
        -: 3325:      *old_type = THR_CANCEL_DEFERRED;
        -: 3326:      break;
        -: 3327:    case PTHREAD_CANCEL_ASYNCHRONOUS:
        -: 3328:      *old_type = THR_CANCEL_ASYNCHRONOUS;
        -: 3329:      break;
        -: 3330:    }
        -: 3331:  return result;
        -: 3332:# else /* Could be ACE_HAS_PTHREADS && ACE_LACKS_PTHREAD_CANCEL */
        -: 3333:  ACE_UNUSED_ARG (new_type);
        -: 3334:  ACE_UNUSED_ARG (old_type);
        -: 3335:  ACE_NOTSUP_RETURN (-1);
        -: 3336:# endif /* ACE_HAS_PTHREADS */
        -: 3337:#else
        -: 3338:  ACE_UNUSED_ARG (new_type);
        -: 3339:  ACE_UNUSED_ARG (old_type);
        -: 3340:  ACE_NOTSUP_RETURN (-1);
        -: 3341:#endif /* ACE_HAS_THREADS */
        -: 3342:}
        -: 3343:
        -: 3344:ACE_INLINE int
        -: 3345:ACE_OS::thr_setconcurrency (int hint)
        -: 3346:{
        -: 3347:  ACE_OS_TRACE ("ACE_OS::thr_setconcurrency");
        -: 3348:#if defined (ACE_HAS_THREADS)
        -: 3349:# if defined (ACE_HAS_STHREADS)
        -: 3350:  int result;
        -: 3351:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_setconcurrency (hint),
        -: 3352:                                       result),
        -: 3353:                     int, -1);
        -: 3354:# elif defined (ACE_HAS_PTHREADS) && defined (ACE_HAS_PTHREAD_SETCONCURRENCY)
        -: 3355:  int result;
        -: 3356:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_setconcurrency (hint),
        -: 3357:                                       result),
        -: 3358:                     int, -1);
        -: 3359:# else
        -: 3360:  ACE_UNUSED_ARG (hint);
        -: 3361:  ACE_NOTSUP_RETURN (-1);
        -: 3362:# endif /* ACE_HAS_STHREADS */
        -: 3363:#else
        -: 3364:  ACE_UNUSED_ARG (hint);
        -: 3365:  ACE_NOTSUP_RETURN (-1);
        -: 3366:#endif /* ACE_HAS_THREADS */
        -: 3367:}
        -: 3368:
        -: 3369:ACE_INLINE int
        -: 3370:ACE_OS::thr_setprio (ACE_hthread_t ht_id, int priority, int policy)
        -: 3371:{
        -: 3372:  ACE_OS_TRACE ("ACE_OS::thr_setprio");
        -: 3373:  ACE_UNUSED_ARG (policy);
        -: 3374:#if defined (ACE_HAS_THREADS)
        -: 3375:# if (defined (ACE_HAS_PTHREADS) && \
        -: 3376:      (!defined (ACE_LACKS_SETSCHED) || defined (ACE_HAS_PTHREAD_SCHEDPARAM)))
        -: 3377:
        -: 3378:  int result;
        -: 3379:  struct sched_param param;
        -: 3380:  ACE_OS::memset ((void *) &param, 0, sizeof param);
        -: 3381:
        -: 3382:  // If <policy> is -1, we don't want to use it for
        -: 3383:  // pthread_setschedparam().  Instead, obtain policy from
        -: 3384:  // pthread_getschedparam().
        -: 3385:  if (policy == -1)
        -: 3386:    {
        -: 3387:      ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_getschedparam (ht_id, &policy, &param),
        -: 3388:                                    result),
        -: 3389:                  int, -1, result);
        -: 3390:      if (result == -1)
        -: 3391:        return result;
        -: 3392:    }
        -: 3393:
        -: 3394:  param.sched_priority = priority;
        -: 3395:
        -: 3396:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_setschedparam (ht_id,
        -: 3397:                                                              policy,
        -: 3398:                                                              &param),
        -: 3399:                                       result),
        -: 3400:                     int, -1);
        -: 3401:# elif defined (ACE_HAS_STHREADS)
        -: 3402:  int result;
        -: 3403:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_setprio (ht_id, priority),
        -: 3404:                                       result),
        -: 3405:                     int, -1);
        -: 3406:# elif defined (ACE_HAS_WTHREADS)
        -: 3407:
        -: 3408:#   if defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY)
        -: 3409:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::CeSetThreadPriority (ht_id, priority),
        -: 3410:                                          ace_result_),
        -: 3411:                        int, -1);
        -: 3412:#   else
        -: 3413:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::SetThreadPriority (ht_id, priority),
        -: 3414:                                          ace_result_),
        -: 3415:                        int, -1);
        -: 3416:#   endif /* defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY) */
        -: 3417:
        -: 3418:# elif defined (ACE_HAS_VXTHREADS)
        -: 3419:  ACE_OSCALL_RETURN (::taskPrioritySet (ht_id, priority), int, -1);
        -: 3420:# else
        -: 3421:  // For example, platforms that support Pthreads but LACK_SETSCHED.
        -: 3422:  ACE_UNUSED_ARG (ht_id);
        -: 3423:  ACE_UNUSED_ARG (priority);
        -: 3424:  ACE_NOTSUP_RETURN (-1);
        -: 3425:# endif /* ACE_HAS_STHREADS */
        -: 3426:#else
        -: 3427:  ACE_UNUSED_ARG (ht_id);
        -: 3428:  ACE_UNUSED_ARG (priority);
        -: 3429:  ACE_NOTSUP_RETURN (-1);
        -: 3430:#endif /* ACE_HAS_THREADS */
        -: 3431:}
        -: 3432:
        -: 3433:ACE_INLINE int
    #####: 3434:ACE_OS::thr_sigsetmask (int how,
        -: 3435:                        const sigset_t *nsm,
        -: 3436:                        sigset_t *osm)
        -: 3437:{
        -: 3438:  ACE_OS_TRACE ("ACE_OS::thr_sigsetmask");
        -: 3439:#if defined (ACE_HAS_THREADS)
        -: 3440:# if defined (ACE_LACKS_PTHREAD_THR_SIGSETMASK)
        -: 3441:  // DCE threads and Solaris 2.4 have no such function.
        -: 3442:  ACE_UNUSED_ARG (osm);
        -: 3443:  ACE_UNUSED_ARG (nsm);
        -: 3444:  ACE_UNUSED_ARG (how);
        -: 3445:
        -: 3446:  ACE_NOTSUP_RETURN (-1);
        -: 3447:# elif defined (ACE_HAS_SIGTHREADMASK)
        -: 3448:  int result;
        -: 3449:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sigthreadmask (how, nsm, osm),
        -: 3450:                                       result), int, -1);
        -: 3451:# elif defined (ACE_HAS_STHREADS)
        -: 3452:  int result;
        -: 3453:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_sigsetmask (how, nsm, osm),
        -: 3454:                                       result),
        -: 3455:                     int, -1);
        -: 3456:# elif defined (ACE_HAS_PTHREADS)
        -: 3457:#   if !defined (ACE_LACKS_PTHREAD_SIGMASK)
        -: 3458:  int result;
        -: 3459:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3460:#    if defined (ACE_HAS_NONCONST_PTHREAD_SIGMASK)
        -: 3461:  sigset_t *ncnsm = const_cast<sigset_t *>(nsm);
        -: 3462:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, ncnsm, osm),
        -: 3463:                                       result),
        -: 3464:                     int,
        -: 3465:                     -1);
        -: 3466:#    else
    #####: 3467:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, nsm, osm),
        -: 3468:                                       result),
        -: 3469:                     int,
        -: 3470:                     -1);
        -: 3471:#    endif /* ACE_HAS_NONCONST__PTHREAD_SIGMASK */
        -: 3472:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3473:#   endif /* !ACE_LACKS_PTHREAD_SIGMASK */
        -: 3474:
        -: 3475:# elif defined (ACE_HAS_WTHREADS)
        -: 3476:  ACE_UNUSED_ARG (osm);
        -: 3477:  ACE_UNUSED_ARG (nsm);
        -: 3478:  ACE_UNUSED_ARG (how);
        -: 3479:
        -: 3480:  ACE_NOTSUP_RETURN (-1);
        -: 3481:# elif defined (ACE_VXWORKS)
        -: 3482:  int old_mask = 0;
        -: 3483:  switch (how)
        -: 3484:    {
        -: 3485:    case SIG_BLOCK:
        -: 3486:    case SIG_UNBLOCK:
        -: 3487:      {
        -: 3488:        // get the old mask
        -: 3489:        old_mask = ::sigsetmask (*nsm);
        -: 3490:        // create a new mask:  the following assumes that sigset_t is 4 bytes,
        -: 3491:        // which it is on VxWorks 5.2, so bit operations are done simply . . .
        -: 3492:        ::sigsetmask (how == SIG_BLOCK ? (old_mask |= *nsm) : (old_mask &= ~*nsm));
        -: 3493:        if (osm)
        -: 3494:          *osm = old_mask;
        -: 3495:        break;
        -: 3496:      }
        -: 3497:    case SIG_SETMASK:
        -: 3498:      old_mask = ::sigsetmask (*nsm);
        -: 3499:      if (osm)
        -: 3500:        *osm = old_mask;
        -: 3501:      break;
        -: 3502:    default:
        -: 3503:      return -1;
        -: 3504:    }
        -: 3505:
        -: 3506:  return 0;
        -: 3507:# else /* Should not happen. */
        -: 3508:  ACE_UNUSED_ARG (how);
        -: 3509:  ACE_UNUSED_ARG (nsm);
        -: 3510:  ACE_UNUSED_ARG (osm);
        -: 3511:  ACE_NOTSUP_RETURN (-1);
        -: 3512:# endif /* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
        -: 3513:#else
        -: 3514:  ACE_UNUSED_ARG (how);
        -: 3515:  ACE_UNUSED_ARG (nsm);
        -: 3516:  ACE_UNUSED_ARG (osm);
        -: 3517:  ACE_NOTSUP_RETURN (-1);
        -: 3518:#endif /* ACE_HAS_THREADS */
        -: 3519:}
------------------
_ZN6ACE_OS14thr_sigsetmaskEiPK10__sigset_tPS0_:
    #####: 3434:ACE_OS::thr_sigsetmask (int how,
        -: 3435:                        const sigset_t *nsm,
        -: 3436:                        sigset_t *osm)
        -: 3437:{
        -: 3438:  ACE_OS_TRACE ("ACE_OS::thr_sigsetmask");
        -: 3439:#if defined (ACE_HAS_THREADS)
        -: 3440:# if defined (ACE_LACKS_PTHREAD_THR_SIGSETMASK)
        -: 3441:  // DCE threads and Solaris 2.4 have no such function.
        -: 3442:  ACE_UNUSED_ARG (osm);
        -: 3443:  ACE_UNUSED_ARG (nsm);
        -: 3444:  ACE_UNUSED_ARG (how);
        -: 3445:
        -: 3446:  ACE_NOTSUP_RETURN (-1);
        -: 3447:# elif defined (ACE_HAS_SIGTHREADMASK)
        -: 3448:  int result;
        -: 3449:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sigthreadmask (how, nsm, osm),
        -: 3450:                                       result), int, -1);
        -: 3451:# elif defined (ACE_HAS_STHREADS)
        -: 3452:  int result;
        -: 3453:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_sigsetmask (how, nsm, osm),
        -: 3454:                                       result),
        -: 3455:                     int, -1);
        -: 3456:# elif defined (ACE_HAS_PTHREADS)
        -: 3457:#   if !defined (ACE_LACKS_PTHREAD_SIGMASK)
        -: 3458:  int result;
        -: 3459:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3460:#    if defined (ACE_HAS_NONCONST_PTHREAD_SIGMASK)
        -: 3461:  sigset_t *ncnsm = const_cast<sigset_t *>(nsm);
        -: 3462:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, ncnsm, osm),
        -: 3463:                                       result),
        -: 3464:                     int,
        -: 3465:                     -1);
        -: 3466:#    else
    #####: 3467:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, nsm, osm),
        -: 3468:                                       result),
        -: 3469:                     int,
        -: 3470:                     -1);
        -: 3471:#    endif /* ACE_HAS_NONCONST__PTHREAD_SIGMASK */
        -: 3472:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3473:#   endif /* !ACE_LACKS_PTHREAD_SIGMASK */
        -: 3474:
        -: 3475:# elif defined (ACE_HAS_WTHREADS)
        -: 3476:  ACE_UNUSED_ARG (osm);
        -: 3477:  ACE_UNUSED_ARG (nsm);
        -: 3478:  ACE_UNUSED_ARG (how);
        -: 3479:
        -: 3480:  ACE_NOTSUP_RETURN (-1);
        -: 3481:# elif defined (ACE_VXWORKS)
        -: 3482:  int old_mask = 0;
        -: 3483:  switch (how)
        -: 3484:    {
        -: 3485:    case SIG_BLOCK:
        -: 3486:    case SIG_UNBLOCK:
        -: 3487:      {
        -: 3488:        // get the old mask
        -: 3489:        old_mask = ::sigsetmask (*nsm);
        -: 3490:        // create a new mask:  the following assumes that sigset_t is 4 bytes,
        -: 3491:        // which it is on VxWorks 5.2, so bit operations are done simply . . .
        -: 3492:        ::sigsetmask (how == SIG_BLOCK ? (old_mask |= *nsm) : (old_mask &= ~*nsm));
        -: 3493:        if (osm)
        -: 3494:          *osm = old_mask;
        -: 3495:        break;
        -: 3496:      }
        -: 3497:    case SIG_SETMASK:
        -: 3498:      old_mask = ::sigsetmask (*nsm);
        -: 3499:      if (osm)
        -: 3500:        *osm = old_mask;
        -: 3501:      break;
        -: 3502:    default:
        -: 3503:      return -1;
        -: 3504:    }
        -: 3505:
        -: 3506:  return 0;
        -: 3507:# else /* Should not happen. */
        -: 3508:  ACE_UNUSED_ARG (how);
        -: 3509:  ACE_UNUSED_ARG (nsm);
        -: 3510:  ACE_UNUSED_ARG (osm);
        -: 3511:  ACE_NOTSUP_RETURN (-1);
        -: 3512:# endif /* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
        -: 3513:#else
        -: 3514:  ACE_UNUSED_ARG (how);
        -: 3515:  ACE_UNUSED_ARG (nsm);
        -: 3516:  ACE_UNUSED_ARG (osm);
        -: 3517:  ACE_NOTSUP_RETURN (-1);
        -: 3518:#endif /* ACE_HAS_THREADS */
        -: 3519:}
------------------
_ZN6ACE_OS14thr_sigsetmaskEiPK10__sigset_tPS0_:
    #####: 3434:ACE_OS::thr_sigsetmask (int how,
        -: 3435:                        const sigset_t *nsm,
        -: 3436:                        sigset_t *osm)
        -: 3437:{
        -: 3438:  ACE_OS_TRACE ("ACE_OS::thr_sigsetmask");
        -: 3439:#if defined (ACE_HAS_THREADS)
        -: 3440:# if defined (ACE_LACKS_PTHREAD_THR_SIGSETMASK)
        -: 3441:  // DCE threads and Solaris 2.4 have no such function.
        -: 3442:  ACE_UNUSED_ARG (osm);
        -: 3443:  ACE_UNUSED_ARG (nsm);
        -: 3444:  ACE_UNUSED_ARG (how);
        -: 3445:
        -: 3446:  ACE_NOTSUP_RETURN (-1);
        -: 3447:# elif defined (ACE_HAS_SIGTHREADMASK)
        -: 3448:  int result;
        -: 3449:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sigthreadmask (how, nsm, osm),
        -: 3450:                                       result), int, -1);
        -: 3451:# elif defined (ACE_HAS_STHREADS)
        -: 3452:  int result;
        -: 3453:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_sigsetmask (how, nsm, osm),
        -: 3454:                                       result),
        -: 3455:                     int, -1);
        -: 3456:# elif defined (ACE_HAS_PTHREADS)
        -: 3457:#   if !defined (ACE_LACKS_PTHREAD_SIGMASK)
        -: 3458:  int result;
        -: 3459:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3460:#    if defined (ACE_HAS_NONCONST_PTHREAD_SIGMASK)
        -: 3461:  sigset_t *ncnsm = const_cast<sigset_t *>(nsm);
        -: 3462:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, ncnsm, osm),
        -: 3463:                                       result),
        -: 3464:                     int,
        -: 3465:                     -1);
        -: 3466:#    else
    #####: 3467:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, nsm, osm),
        -: 3468:                                       result),
        -: 3469:                     int,
        -: 3470:                     -1);
        -: 3471:#    endif /* ACE_HAS_NONCONST__PTHREAD_SIGMASK */
        -: 3472:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3473:#   endif /* !ACE_LACKS_PTHREAD_SIGMASK */
        -: 3474:
        -: 3475:# elif defined (ACE_HAS_WTHREADS)
        -: 3476:  ACE_UNUSED_ARG (osm);
        -: 3477:  ACE_UNUSED_ARG (nsm);
        -: 3478:  ACE_UNUSED_ARG (how);
        -: 3479:
        -: 3480:  ACE_NOTSUP_RETURN (-1);
        -: 3481:# elif defined (ACE_VXWORKS)
        -: 3482:  int old_mask = 0;
        -: 3483:  switch (how)
        -: 3484:    {
        -: 3485:    case SIG_BLOCK:
        -: 3486:    case SIG_UNBLOCK:
        -: 3487:      {
        -: 3488:        // get the old mask
        -: 3489:        old_mask = ::sigsetmask (*nsm);
        -: 3490:        // create a new mask:  the following assumes that sigset_t is 4 bytes,
        -: 3491:        // which it is on VxWorks 5.2, so bit operations are done simply . . .
        -: 3492:        ::sigsetmask (how == SIG_BLOCK ? (old_mask |= *nsm) : (old_mask &= ~*nsm));
        -: 3493:        if (osm)
        -: 3494:          *osm = old_mask;
        -: 3495:        break;
        -: 3496:      }
        -: 3497:    case SIG_SETMASK:
        -: 3498:      old_mask = ::sigsetmask (*nsm);
        -: 3499:      if (osm)
        -: 3500:        *osm = old_mask;
        -: 3501:      break;
        -: 3502:    default:
        -: 3503:      return -1;
        -: 3504:    }
        -: 3505:
        -: 3506:  return 0;
        -: 3507:# else /* Should not happen. */
        -: 3508:  ACE_UNUSED_ARG (how);
        -: 3509:  ACE_UNUSED_ARG (nsm);
        -: 3510:  ACE_UNUSED_ARG (osm);
        -: 3511:  ACE_NOTSUP_RETURN (-1);
        -: 3512:# endif /* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
        -: 3513:#else
        -: 3514:  ACE_UNUSED_ARG (how);
        -: 3515:  ACE_UNUSED_ARG (nsm);
        -: 3516:  ACE_UNUSED_ARG (osm);
        -: 3517:  ACE_NOTSUP_RETURN (-1);
        -: 3518:#endif /* ACE_HAS_THREADS */
        -: 3519:}
------------------
_ZN6ACE_OS14thr_sigsetmaskEiPK10__sigset_tPS0_:
    #####: 3434:ACE_OS::thr_sigsetmask (int how,
        -: 3435:                        const sigset_t *nsm,
        -: 3436:                        sigset_t *osm)
        -: 3437:{
        -: 3438:  ACE_OS_TRACE ("ACE_OS::thr_sigsetmask");
        -: 3439:#if defined (ACE_HAS_THREADS)
        -: 3440:# if defined (ACE_LACKS_PTHREAD_THR_SIGSETMASK)
        -: 3441:  // DCE threads and Solaris 2.4 have no such function.
        -: 3442:  ACE_UNUSED_ARG (osm);
        -: 3443:  ACE_UNUSED_ARG (nsm);
        -: 3444:  ACE_UNUSED_ARG (how);
        -: 3445:
        -: 3446:  ACE_NOTSUP_RETURN (-1);
        -: 3447:# elif defined (ACE_HAS_SIGTHREADMASK)
        -: 3448:  int result;
        -: 3449:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sigthreadmask (how, nsm, osm),
        -: 3450:                                       result), int, -1);
        -: 3451:# elif defined (ACE_HAS_STHREADS)
        -: 3452:  int result;
        -: 3453:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_sigsetmask (how, nsm, osm),
        -: 3454:                                       result),
        -: 3455:                     int, -1);
        -: 3456:# elif defined (ACE_HAS_PTHREADS)
        -: 3457:#   if !defined (ACE_LACKS_PTHREAD_SIGMASK)
        -: 3458:  int result;
        -: 3459:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3460:#    if defined (ACE_HAS_NONCONST_PTHREAD_SIGMASK)
        -: 3461:  sigset_t *ncnsm = const_cast<sigset_t *>(nsm);
        -: 3462:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, ncnsm, osm),
        -: 3463:                                       result),
        -: 3464:                     int,
        -: 3465:                     -1);
        -: 3466:#    else
    #####: 3467:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, nsm, osm),
        -: 3468:                                       result),
        -: 3469:                     int,
        -: 3470:                     -1);
        -: 3471:#    endif /* ACE_HAS_NONCONST__PTHREAD_SIGMASK */
        -: 3472:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3473:#   endif /* !ACE_LACKS_PTHREAD_SIGMASK */
        -: 3474:
        -: 3475:# elif defined (ACE_HAS_WTHREADS)
        -: 3476:  ACE_UNUSED_ARG (osm);
        -: 3477:  ACE_UNUSED_ARG (nsm);
        -: 3478:  ACE_UNUSED_ARG (how);
        -: 3479:
        -: 3480:  ACE_NOTSUP_RETURN (-1);
        -: 3481:# elif defined (ACE_VXWORKS)
        -: 3482:  int old_mask = 0;
        -: 3483:  switch (how)
        -: 3484:    {
        -: 3485:    case SIG_BLOCK:
        -: 3486:    case SIG_UNBLOCK:
        -: 3487:      {
        -: 3488:        // get the old mask
        -: 3489:        old_mask = ::sigsetmask (*nsm);
        -: 3490:        // create a new mask:  the following assumes that sigset_t is 4 bytes,
        -: 3491:        // which it is on VxWorks 5.2, so bit operations are done simply . . .
        -: 3492:        ::sigsetmask (how == SIG_BLOCK ? (old_mask |= *nsm) : (old_mask &= ~*nsm));
        -: 3493:        if (osm)
        -: 3494:          *osm = old_mask;
        -: 3495:        break;
        -: 3496:      }
        -: 3497:    case SIG_SETMASK:
        -: 3498:      old_mask = ::sigsetmask (*nsm);
        -: 3499:      if (osm)
        -: 3500:        *osm = old_mask;
        -: 3501:      break;
        -: 3502:    default:
        -: 3503:      return -1;
        -: 3504:    }
        -: 3505:
        -: 3506:  return 0;
        -: 3507:# else /* Should not happen. */
        -: 3508:  ACE_UNUSED_ARG (how);
        -: 3509:  ACE_UNUSED_ARG (nsm);
        -: 3510:  ACE_UNUSED_ARG (osm);
        -: 3511:  ACE_NOTSUP_RETURN (-1);
        -: 3512:# endif /* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
        -: 3513:#else
        -: 3514:  ACE_UNUSED_ARG (how);
        -: 3515:  ACE_UNUSED_ARG (nsm);
        -: 3516:  ACE_UNUSED_ARG (osm);
        -: 3517:  ACE_NOTSUP_RETURN (-1);
        -: 3518:#endif /* ACE_HAS_THREADS */
        -: 3519:}
------------------
        -: 3520:
        -: 3521:ACE_INLINE int
        -: 3522:ACE_OS::thr_suspend (ACE_hthread_t target_thread)
        -: 3523:{
        -: 3524:  ACE_OS_TRACE ("ACE_OS::thr_suspend");
        -: 3525:#if defined (ACE_HAS_THREADS)
        -: 3526:# if defined (ACE_HAS_STHREADS)
        -: 3527:  int result;
        -: 3528:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_suspend (target_thread), result), int, -1);
        -: 3529:# elif defined (ACE_HAS_PTHREADS)
        -: 3530:#  if defined (ACE_HAS_PTHREAD_SUSPEND)
        -: 3531:  int result;
        -: 3532:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_suspend (target_thread),
        -: 3533:                                       result),
        -: 3534:                     int, -1);
        -: 3535:#  elif defined (ACE_HAS_PTHREAD_SUSPEND_NP)
        -: 3536:  int result;
        -: 3537:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_suspend_np (target_thread),
        -: 3538:                                       result),
        -: 3539:                     int, -1);
        -: 3540:#  else
        -: 3541:  ACE_UNUSED_ARG (target_thread);
        -: 3542:  ACE_NOTSUP_RETURN (-1);
        -: 3543:#  endif /* ACE_HAS_PTHREAD_SUSPEND */
        -: 3544:# elif defined (ACE_HAS_WTHREADS)
        -: 3545:  if (::SuspendThread (target_thread) != ACE_SYSCALL_FAILED)
        -: 3546:    return 0;
        -: 3547:  else
        -: 3548:    ACE_FAIL_RETURN (-1);
        -: 3549:  /* NOTREACHED */
        -: 3550:# elif defined (ACE_HAS_VXTHREADS)
        -: 3551:  ACE_OSCALL_RETURN (::taskSuspend (target_thread), int, -1);
        -: 3552:# endif /* ACE_HAS_STHREADS */
        -: 3553:#else
        -: 3554:  ACE_UNUSED_ARG (target_thread);
        -: 3555:  ACE_NOTSUP_RETURN (-1);
        -: 3556:#endif /* ACE_HAS_THREADS */
        -: 3557:}
        -: 3558:
        -: 3559:ACE_INLINE void
        -: 3560:ACE_OS::thr_testcancel (void)
        -: 3561:{
        -: 3562:  ACE_OS_TRACE ("ACE_OS::thr_testcancel");
        -: 3563:#if defined (ACE_HAS_THREADS)
        -: 3564:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 3565:  pthread_testcancel ();
        -: 3566:# elif defined (ACE_HAS_STHREADS)
        -: 3567:# elif defined (ACE_HAS_WTHREADS)
        -: 3568:# elif defined (ACE_HAS_VXTHREADS)
        -: 3569:# else
        -: 3570:  // no-op:  can't use ACE_NOTSUP_RETURN because there is no return value
        -: 3571:# endif /* ACE_HAS_PTHREADS */
        -: 3572:#else
        -: 3573:#endif /* ACE_HAS_THREADS */
        -: 3574:}
        -: 3575:
        -: 3576:ACE_INLINE void
        -: 3577:ACE_OS::thr_yield (void)
        -: 3578:{
        -: 3579:  ACE_OS_TRACE ("ACE_OS::thr_yield");
        -: 3580:#if defined (ACE_HAS_THREADS)
        -: 3581:# if defined (ACE_HAS_PTHREADS)
        -: 3582:  ::sched_yield ();
        -: 3583:# elif defined (ACE_HAS_STHREADS)
        -: 3584:  ::thr_yield ();
        -: 3585:# elif defined (ACE_HAS_WTHREADS)
        -: 3586:  ::Sleep (0);
        -: 3587:# elif defined (ACE_HAS_VXTHREADS)
        -: 3588:  // An argument of 0 to ::taskDelay doesn't appear to yield the
        -: 3589:  // current thread.
        -: 3590:  // Now, it does seem to work.  The context_switch_time test
        -: 3591:  // works fine with task_delay set to 0.
        -: 3592:  ::taskDelay (0);
        -: 3593:# endif /* ACE_HAS_STHREADS */
        -: 3594:#else
        -: 3595:  ;
        -: 3596:#endif /* ACE_HAS_THREADS */
        -: 3597:}
        -: 3598:
        -: 3599:ACE_INLINE int
    #####: 3600:ACE_OS::thread_mutex_destroy (ACE_thread_mutex_t *m)
        -: 3601:{
        -: 3602:  ACE_OS_TRACE ("ACE_OS::thread_mutex_destroy");
        -: 3603:#if defined (ACE_HAS_THREADS)
        -: 3604:# if defined (ACE_HAS_WTHREADS)
        -: 3605:  ::DeleteCriticalSection (m);
        -: 3606:  return 0;
        -: 3607:# else
    #####: 3608:  return ACE_OS::mutex_destroy (m);
        -: 3609:# endif /* ACE_HAS_WTHREADS */
        -: 3610:#else
        -: 3611:  ACE_UNUSED_ARG (m);
        -: 3612:  ACE_NOTSUP_RETURN (-1);
        -: 3613:
        -: 3614:#endif /* ACE_HAS_THREADS */
        -: 3615:}
        -: 3616:
        -: 3617:ACE_INLINE int
        -: 3618:ACE_OS::thread_mutex_init (ACE_thread_mutex_t *m,
        -: 3619:                           int lock_type,
        -: 3620:                           const char *name,
        -: 3621:                           ACE_mutexattr_t *arg)
        -: 3622:{
        -: 3623:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_init");
        -: 3624:#if defined (ACE_HAS_THREADS)
        -: 3625:# if defined (ACE_HAS_WTHREADS)
        -: 3626:  ACE_UNUSED_ARG (lock_type);
        -: 3627:  ACE_UNUSED_ARG (name);
        -: 3628:  ACE_UNUSED_ARG (arg);
        -: 3629:
        -: 3630:  ACE_SEH_TRY
        -: 3631:    {
        -: 3632:      ::InitializeCriticalSection (m);
        -: 3633:    }
        -: 3634:  ACE_SEH_EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        -: 3635:    {
        -: 3636:      errno = ENOMEM;
        -: 3637:      return -1;
        -: 3638:    }
        -: 3639:  return 0;
        -: 3640:
        -: 3641:# elif defined (ACE_HAS_STHREADS) || defined (ACE_HAS_PTHREADS)
        -: 3642:  // Force the use of USYNC_THREAD!
        -: 3643:  return ACE_OS::mutex_init (m, USYNC_THREAD, name, arg, 0, lock_type);
        -: 3644:# elif defined (ACE_HAS_VXTHREADS)
        -: 3645:  return mutex_init (m, lock_type, name, arg);
        -: 3646:
        -: 3647:# endif /* ACE_HAS_STHREADS || ACE_HAS_PTHREADS */
        -: 3648:
        -: 3649:#else
        -: 3650:  ACE_UNUSED_ARG (m);
        -: 3651:  ACE_UNUSED_ARG (lock_type);
        -: 3652:  ACE_UNUSED_ARG (name);
        -: 3653:  ACE_UNUSED_ARG (arg);
        -: 3654:  ACE_NOTSUP_RETURN (-1);
        -: 3655:
        -: 3656:#endif /* ACE_HAS_THREADS */
        -: 3657:}
        -: 3658:
        -: 3659:#if defined (ACE_HAS_WCHAR)
        -: 3660:ACE_INLINE int
        -: 3661:ACE_OS::thread_mutex_init (ACE_thread_mutex_t *m,
        -: 3662:                           int lock_type,
        -: 3663:                           const wchar_t *name,
        -: 3664:                           ACE_mutexattr_t *arg)
        -: 3665:{
        -: 3666:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_init");
        -: 3667:#if defined (ACE_HAS_THREADS)
        -: 3668:# if defined (ACE_HAS_WTHREADS)
        -: 3669:  ACE_UNUSED_ARG (lock_type);
        -: 3670:  ACE_UNUSED_ARG (name);
        -: 3671:  ACE_UNUSED_ARG (arg);
        -: 3672:
        -: 3673:  ACE_SEH_TRY
        -: 3674:    {
        -: 3675:      ::InitializeCriticalSection (m);
        -: 3676:    }
        -: 3677:  ACE_SEH_EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        -: 3678:    {
        -: 3679:      errno = ENOMEM;
        -: 3680:      return -1;
        -: 3681:    }
        -: 3682:  return 0;
        -: 3683:
        -: 3684:# elif defined (ACE_HAS_STHREADS) || defined (ACE_HAS_PTHREADS)
        -: 3685:  // Force the use of USYNC_THREAD!
        -: 3686:  return ACE_OS::mutex_init (m, USYNC_THREAD, name, arg, 0, lock_type);
        -: 3687:# elif defined (ACE_HAS_VXTHREADS)
        -: 3688:  return mutex_init (m, lock_type, name, arg);
        -: 3689:# endif /* ACE_HAS_STHREADS || ACE_HAS_PTHREADS */
        -: 3690:#else
        -: 3691:  ACE_UNUSED_ARG (m);
        -: 3692:  ACE_UNUSED_ARG (lock_type);
        -: 3693:  ACE_UNUSED_ARG (name);
        -: 3694:  ACE_UNUSED_ARG (arg);
        -: 3695:  ACE_NOTSUP_RETURN (-1);
        -: 3696:
        -: 3697:#endif /* ACE_HAS_THREADS */
        -: 3698:}
        -: 3699:#endif /* ACE_HAS_WCHAR */
        -: 3700:
        -: 3701:ACE_INLINE int
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
_ZN6ACE_OS17thread_mutex_lockEP15pthread_mutex_t:
    #####: 3702:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3703:{
        -: 3704:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3705:#if defined (ACE_HAS_THREADS)
        -: 3706:# if defined (ACE_HAS_WTHREADS)
        -: 3707:  ::EnterCriticalSection (m);
        -: 3708:  return 0;
        -: 3709:# else
    #####: 3710:  return ACE_OS::mutex_lock (m);
        -: 3711:# endif /* ACE_HAS_WTHREADS */
        -: 3712:#else
        -: 3713:  ACE_UNUSED_ARG (m);
        -: 3714:  ACE_NOTSUP_RETURN (-1);
        -: 3715:#endif /* ACE_HAS_THREADS */
        -: 3716:}
------------------
        -: 3717:
        -: 3718:ACE_INLINE int
        -: 3719:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m,
        -: 3720:                           const ACE_Time_Value &timeout)
        -: 3721:{
        -: 3722:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3723:
        -: 3724:  // For all platforms, except MS Windows, this method is equivalent
        -: 3725:  // to calling ACE_OS::mutex_lock() since ACE_thread_mutex_t and
        -: 3726:  // ACE_mutex_t are the same type.  However, those typedefs evaluate
        -: 3727:  // to different types on MS Windows.  The "thread mutex"
        -: 3728:  // implementation in ACE for MS Windows cannot readily support
        -: 3729:  // timeouts due to a lack of timeout features for this type of MS
        -: 3730:  // Windows synchronization mechanism.
        -: 3731:
        -: 3732:#if defined (ACE_HAS_THREADS) && !defined (ACE_HAS_WTHREADS)
        -: 3733:  return ACE_OS::mutex_lock (m, timeout);
        -: 3734:#else
        -: 3735:  ACE_UNUSED_ARG (m);
        -: 3736:  ACE_UNUSED_ARG (timeout);
        -: 3737:  ACE_NOTSUP_RETURN (-1);
        -: 3738:#endif /* ACE_HAS_THREADS */
        -: 3739:}
        -: 3740:
        -: 3741:ACE_INLINE int
        -: 3742:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m,
        -: 3743:                           const ACE_Time_Value *timeout)
        -: 3744:{
        -: 3745:  return timeout == 0
        -: 3746:    ? ACE_OS::thread_mutex_lock (m)
        -: 3747:    : ACE_OS::thread_mutex_lock (m, *timeout);
        -: 3748:}
        -: 3749:
        -: 3750:ACE_INLINE int
        -: 3751:ACE_OS::thread_mutex_trylock (ACE_thread_mutex_t *m)
        -: 3752:{
        -: 3753:  ACE_OS_TRACE ("ACE_OS::thread_mutex_trylock");
        -: 3754:
        -: 3755:#if defined (ACE_HAS_THREADS)
        -: 3756:# if defined (ACE_HAS_WTHREADS)
        -: 3757:#   if defined (ACE_HAS_WIN32_TRYLOCK)
        -: 3758:  BOOL result = ::TryEnterCriticalSection (m);
        -: 3759:  if (result == TRUE)
        -: 3760:    {
        -: 3761:      return 0;
        -: 3762:    }
        -: 3763:  else
        -: 3764:    {
        -: 3765:      errno = EBUSY;
        -: 3766:      return -1;
        -: 3767:    }
        -: 3768:#   else
        -: 3769:  ACE_UNUSED_ARG (m);
        -: 3770:  ACE_NOTSUP_RETURN (-1);
        -: 3771:#   endif /* ACE_HAS_WIN32_TRYLOCK */
        -: 3772:# elif defined (ACE_HAS_STHREADS) || defined (ACE_HAS_PTHREADS) || defined (ACE_VXWORKS)
        -: 3773:  return ACE_OS::mutex_trylock (m);
        -: 3774:#endif /* Threads variety case */
        -: 3775:
        -: 3776:#else
        -: 3777:  ACE_UNUSED_ARG (m);
        -: 3778:  ACE_NOTSUP_RETURN (-1);
        -: 3779:#endif /* ACE_HAS_THREADS */
        -: 3780:}
        -: 3781:
        -: 3782:ACE_INLINE int
    #####: 3783:ACE_OS::thread_mutex_unlock (ACE_thread_mutex_t *m)
        -: 3784:{
        -: 3785:  ACE_OS_TRACE ("ACE_OS::thread_mutex_unlock");
        -: 3786:#if defined (ACE_HAS_THREADS)
        -: 3787:# if defined (ACE_HAS_WTHREADS)
        -: 3788:  ::LeaveCriticalSection (m);
        -: 3789:  return 0;
        -: 3790:# else
    #####: 3791:  return ACE_OS::mutex_unlock (m);
        -: 3792:# endif /* ACE_HAS_WTHREADS */
        -: 3793:#else
        -: 3794:  ACE_UNUSED_ARG (m);
        -: 3795:  ACE_NOTSUP_RETURN (-1);
        -: 3796:#endif /* ACE_HAS_THREADS */
        -: 3797:}
        -: 3798:
        -: 3799:/*****************************************************************************/
        -: 3800:
        -: 3801:# if defined (ACE_IS_SPLITTING)
        -: 3802:#   define ACE_SPECIAL_INLINE
        -: 3803:# else
        -: 3804:#   define ACE_SPECIAL_INLINE ACE_INLINE
        -: 3805://#   define ACE_SPECIAL_INLINE inline
        -: 3806:# endif
        -: 3807:
        -: 3808:#if defined (ACE_MT_SAFE) && (ACE_MT_SAFE != 0)
        -: 3809:
        -: 3810:ACE_INLINE
        -: 3811:int
        -: 3812:ACE_OS_Thread_Mutex_Guard::acquire (void)
        -: 3813:{
        -: 3814:  return owner_ = ACE_OS::thread_mutex_lock (&lock_);
        -: 3815:}
        -: 3816:
        -: 3817:ACE_INLINE
        -: 3818:int
        -: 3819:ACE_OS_Thread_Mutex_Guard::release (void)
        -: 3820:{
        -: 3821:  if (owner_ == -1)
        -: 3822:    return 0;
        -: 3823:  else
        -: 3824:    {
        -: 3825:      owner_ = -1;
        -: 3826:      return ACE_OS::thread_mutex_unlock (&lock_);
        -: 3827:    }
        -: 3828:}
        -: 3829:
        -: 3830:ACE_INLINE
        -: 3831:ACE_OS_Thread_Mutex_Guard::ACE_OS_Thread_Mutex_Guard (ACE_thread_mutex_t &m)
        -: 3832:  : lock_ (m), owner_ (-1)
        -: 3833:{
        -: 3834:  if (!ACE_OS_Object_Manager::starting_up ())
        -: 3835:    acquire ();
        -: 3836:}
        -: 3837:
        -: 3838:ACE_INLINE
        -: 3839:ACE_OS_Thread_Mutex_Guard::~ACE_OS_Thread_Mutex_Guard ()
        -: 3840:{
        -: 3841:  release ();
        -: 3842:}
        -: 3843:
        -: 3844:/*****************************************************************************/
        -: 3845:
        -: 3846:ACE_INLINE
        -: 3847:int
        -: 3848:ACE_OS_Recursive_Thread_Mutex_Guard::acquire (void)
        -: 3849:{
        -: 3850:  return owner_ = ACE_OS::recursive_mutex_lock (&lock_);
        -: 3851:}
        -: 3852:
        -: 3853:ACE_INLINE
        -: 3854:int
        -: 3855:ACE_OS_Recursive_Thread_Mutex_Guard::release (void)
        -: 3856:{
        -: 3857:  if (owner_ == -1)
        -: 3858:    return 0;
        -: 3859:  else
        -: 3860:    {
        -: 3861:      owner_ = -1;
        -: 3862:      return ACE_OS::recursive_mutex_unlock (&lock_);
        -: 3863:    }
        -: 3864:}
        -: 3865:
        -: 3866:ACE_INLINE
        -: 3867:ACE_OS_Recursive_Thread_Mutex_Guard::ACE_OS_Recursive_Thread_Mutex_Guard (
        -: 3868:  ACE_recursive_thread_mutex_t &m)
        -: 3869:   : lock_ (m),
        -: 3870:     owner_ (-1)
        -: 3871:{
        -: 3872:  if (!ACE_OS_Object_Manager::starting_up ())
        -: 3873:    acquire ();
        -: 3874:}
        -: 3875:
        -: 3876:ACE_INLINE
        -: 3877:ACE_OS_Recursive_Thread_Mutex_Guard::~ACE_OS_Recursive_Thread_Mutex_Guard ()
        -: 3878:{
        -: 3879:  release ();
        -: 3880:}
        -: 3881:
        -: 3882:#endif /* ACE_MT_SAFE && ACE_MT_SAFE != 0 */
        -: 3883:
        -: 3884:
        -: 3885:/*****************************************************************************/
        -: 3886:
        -: 3887:ACE_INLINE
        -: 3888:ACE_Thread_ID::ACE_Thread_ID (ACE_thread_t thread_id,
        -: 3889:                              ACE_hthread_t thread_handle)
        -: 3890:  : thread_id_ (thread_id),
        -: 3891:    thread_handle_ (thread_handle)
        -: 3892:{
        -: 3893:}
        -: 3894:
        -: 3895:ACE_INLINE
        -: 3896:ACE_Thread_ID::ACE_Thread_ID (const ACE_Thread_ID &id)
        -: 3897:  : thread_id_ (id.thread_id_),
        -: 3898:    thread_handle_ (id.thread_handle_)
        -: 3899:{
        -: 3900:}
        -: 3901:
        -: 3902:ACE_INLINE
        -: 3903:ACE_Thread_ID&
        -: 3904:ACE_Thread_ID::operator= (const ACE_Thread_ID &id)
        -: 3905:{
        -: 3906:  if (this != &id)
        -: 3907:    {
        -: 3908:      this->thread_id_ = id.thread_id_;
        -: 3909:      this->thread_handle_ = id.thread_handle_;
        -: 3910:    }
        -: 3911:  return *this;
        -: 3912:}
        -: 3913:
        -: 3914:ACE_INLINE
        -: 3915:ACE_Thread_ID::ACE_Thread_ID (void)
        -: 3916:  : thread_id_ (ACE_OS::thr_self ())
        -: 3917:{
        -: 3918:  ACE_OS::thr_self (thread_handle_);
        -: 3919:}
        -: 3920:
        -: 3921:ACE_INLINE
        -: 3922:ACE_thread_t
        -: 3923:ACE_Thread_ID::id (void) const
        -: 3924:{
        -: 3925:  return this->thread_id_;
        -: 3926:}
        -: 3927:
        -: 3928:ACE_INLINE void
        -: 3929:ACE_Thread_ID::id (ACE_thread_t thread_id)
        -: 3930:{
        -: 3931:  this->thread_id_ = thread_id;
        -: 3932:}
        -: 3933:
        -: 3934:ACE_INLINE ACE_hthread_t
        -: 3935:ACE_Thread_ID::handle (void) const
        -: 3936:{
        -: 3937:  return this->thread_handle_;
        -: 3938:}
        -: 3939:
        -: 3940:ACE_INLINE void
        -: 3941:ACE_Thread_ID::handle (ACE_hthread_t thread_handle)
        -: 3942:{
        -: 3943:  this->thread_handle_ = thread_handle;
        -: 3944:}
        -: 3945:
        -: 3946:ACE_INLINE bool
        -: 3947:ACE_Thread_ID::operator== (const ACE_Thread_ID &rhs) const
        -: 3948:{
        -: 3949:  return
        -: 3950:    ACE_OS::thr_cmp (this->thread_handle_, rhs.thread_handle_)
        -: 3951:    && ACE_OS::thr_equal (this->thread_id_, rhs.thread_id_);
        -: 3952:}
        -: 3953:
        -: 3954:ACE_INLINE bool
        -: 3955:ACE_Thread_ID::operator!= (const ACE_Thread_ID &rhs) const
        -: 3956:{
        -: 3957:  return !(*this == rhs);
        -: 3958:}
        -: 3959:
        -: 3960:#if !defined (ACE_WIN32)
        -: 3961:
        -: 3962:ACE_INLINE
        -: 3963:ACE_event_t::ACE_event_t (void) :
        -: 3964:  name_ (0),
        -: 3965:  eventdata_ (0)
        -: 3966:{
        -: 3967:}
        -: 3968:
        -: 3969:#endif /* !ACE_WIN32 */
        -: 3970:
        -: 3971:ACE_END_VERSIONED_NAMESPACE_DECL
