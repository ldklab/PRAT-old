        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/OS_NS_Thread.inl
        -:    0:Programs:72
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id: OS_NS_Thread.inl 2793 2015-11-30 23:09:18Z mitza $
        -:    4:
        -:    5:#include "ace/OS_NS_macros.h"
        -:    6:// for timespec_t, perhaps move it to os_time.h
        -:    7:#include "ace/Time_Value.h"
        -:    8:#include "ace/OS_NS_sys_mman.h"
        -:    9:#include "ace/OS_NS_sys_time.h"
        -:   10:#include "ace/OS_NS_string.h"
        -:   11:#include "ace/OS_NS_unistd.h"
        -:   12:#include "ace/OS_NS_stdio.h"
        -:   13:#include "ace/OS_NS_errno.h"
        -:   14:
        -:   15:#if defined (ACE_USES_FIFO_SEM)
        -:   16:#  include "ace/OS_NS_sys_stat.h"
        -:   17:#  include "ace/OS_NS_sys_select.h"
        -:   18:#  include "ace/OS_NS_fcntl.h"
        -:   19:#  include "ace/Handle_Set.h"
        -:   20:# endif /* ACE_USES_FIFO_SEM */
        -:   21:
        -:   22:#if defined (ACE_HAS_PRIOCNTL)
        -:   23:#  include /**/ <sys/priocntl.h>
        -:   24:#endif /* ACE_HAS_PRIOCNTL */
        -:   25:
        -:   26:#if defined (ACE_HAS_ALLOC_HOOKS)
        -:   27:# include "ace/Malloc_Base.h"
        -:   28:#endif /* ACE_HAS_ALLOC_HOOKS */
        -:   29:
        -:   30:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   31:
        -:   32:/*****************************************************************************/
        -:   33:
        -:   34:#if defined (ACE_LACKS_COND_T) && defined (ACE_HAS_THREADS)
        -:   35:ACE_INLINE long
        -:   36:ACE_cond_t::waiters (void) const
        -:   37:{
        -:   38:  return this->waiters_;
        -:   39:}
        -:   40:#endif /* ACE_LACKS_COND_T && ACE_HAS_THREADS */
        -:   41:
        -:   42:/*****************************************************************************/
        -:   43:
        -:   44:#if defined (ACE_HAS_TSS_EMULATION)
        -:   45:
        -:   46:#  if !defined (ACE_HAS_THREAD_SPECIFIC_STORAGE)
        -:   47:ACE_INLINE
        -:   48:void **&
        -:   49:ACE_TSS_Emulation::tss_base ()
        -:   50:{
        -:   51:#    if defined (ACE_HAS_VXTHREADS)
        -:   52:  #if (ACE_VXWORKS <= 0x680)
        -:   53:  int &spare = taskIdCurrent->ACE_VXWORKS_SPARE;
        -:   54:  #else // VxWorks 6.9 updated datatype (WIND00241209) see taskLib.h
        -:   55:  long  &spare = taskIdCurrent->ACE_VXWORKS_SPARE;
        -:   56:  #endif
        -:   57:  return reinterpret_cast <void **&> (spare);
        -:   58:#    else
        -:   59:  // Uh oh.
        -:   60:  ACE_NOTSUP_RETURN (0);
        -:   61:#    endif /* ACE_HAS_VXTHREADS */
        -:   62:}
        -:   63:#  endif /* ! ACE_HAS_THREAD_SPECIFIC_STORAGE */
        -:   64:
        -:   65:ACE_INLINE
        -:   66:ACE_TSS_Emulation::ACE_TSS_DESTRUCTOR
        -:   67:ACE_TSS_Emulation::tss_destructor (const ACE_thread_key_t key)
        -:   68:{
        -:   69:  return tss_destructor_ [key];
        -:   70:}
        -:   71:
        -:   72:ACE_INLINE
        -:   73:void
        -:   74:ACE_TSS_Emulation::tss_destructor (const ACE_thread_key_t key,
        -:   75:                                   ACE_TSS_DESTRUCTOR destructor)
        -:   76:{
        -:   77:  tss_destructor_ [key] = destructor;
        -:   78:}
        -:   79:
        -:   80:ACE_INLINE
        -:   81:void *&
        -:   82:ACE_TSS_Emulation::ts_object (const ACE_thread_key_t key)
        -:   83:{
        -:   84:#    if defined (ACE_HAS_VXTHREADS)
        -:   85:    /* If someone wants tss_base make sure they get one.  This
        -:   86:       gets used if someone spawns a VxWorks task directly, not
        -:   87:       through ACE.  The allocated array will never be deleted! */
        -:   88:    if (0 == taskIdCurrent->ACE_VXWORKS_SPARE)
        -:   89:      {
        -:   90:        taskIdCurrent->ACE_VXWORKS_SPARE =
        -:   91:          reinterpret_cast<int> (new void *[ACE_TSS_THREAD_KEYS_MAX]);
        -:   92:
        -:   93:        // Zero the entire TSS array.  Do it manually instead of using
        -:   94:        // memset, for optimum speed.  Though, memset may be faster :-)
        -:   95:        void **tss_base_p =
        -:   96:          reinterpret_cast<void **> (taskIdCurrent->ACE_VXWORKS_SPARE);
        -:   97:        for (u_int i = 0; i < ACE_TSS_THREAD_KEYS_MAX; ++i, ++tss_base_p)
        -:   98:          {
        -:   99:            *tss_base_p = 0;
        -:  100:          }
        -:  101:      }
        -:  102:#    endif /* ACE_HAS_VXTHREADS */
        -:  103:
        -:  104:  return tss_base ()[key];
        -:  105:}
        -:  106:
        -:  107:#endif /* ACE_HAS_TSS_EMULATION */
        -:  108:
        -:  109:/*****************************************************************************/
        -:  110:
        -:  111:ACE_INLINE int
        -:  112:ACE_OS::thr_equal (ACE_thread_t t1, ACE_thread_t t2)
        -:  113:{
        -:  114:#if defined (ACE_HAS_PTHREADS)
        -:  115:# if defined (pthread_equal)
        -:  116:  // If it's a macro we can't say "pthread_equal"...
        -:  117:  return pthread_equal (t1, t2);
        -:  118:# else
        -:  119:  return pthread_equal (t1, t2);
        -:  120:# endif /* pthread_equal */
        -:  121:#else /* For both STHREADS and WTHREADS... */
        -:  122:  // Hum, Do we need to treat WTHREAD differently?
        -:  123:  // levine 13 oct 98 % I don't think so, ACE_thread_t is a DWORD.
        -:  124:  return t1 == t2;
        -:  125:#endif /* ACE_HAS_PTHREADS */
        -:  126:}
        -:  127:
        -:  128:ACE_INLINE int
        -:  129:ACE_OS::condattr_destroy (ACE_condattr_t &attributes)
        -:  130:{
        -:  131:#if defined (ACE_HAS_THREADS) && !defined (ACE_LACKS_CONDATTR)
        -:  132:#   if defined (ACE_HAS_PTHREADS)
        -:  133:  pthread_condattr_destroy (&attributes);
        -:  134:#   else
        -:  135:  attributes.type = 0;
        -:  136:#   endif /* ACE_HAS_PTHREADS */
        -:  137:  return 0;
        -:  138:# else
        -:  139:  ACE_UNUSED_ARG (attributes);
        -:  140:  return 0;
        -:  141:# endif /* ACE_HAS_THREADS  */
        -:  142:}
        -:  143:
        -:  144:ACE_INLINE int
        -:  145:ACE_OS::condattr_init (ACE_condattr_t &attributes, int type)
        -:  146:{
        -:  147:  ACE_UNUSED_ARG (type);
        -:  148:# if defined (ACE_HAS_THREADS)
        -:  149:#   if defined (ACE_HAS_PTHREADS)
        -:  150:  int result = -1;
        -:  151:
        -:  152:#   if !defined (ACE_LACKS_CONDATTR)
        -:  153:#     if defined (ACE_PTHREAD_CONDATTR_T_INITIALIZE)
        -:  154:  /* Tests show that VxWorks 6.x pthread lib does not only
        -:  155:    * require zeroing of mutex/condition objects to function correctly
        -:  156:    * but also of the attribute objects.
        -:  157:    */
        -:  158:  ACE_OS::memset (&attributes, 0, sizeof (attributes));
        -:  159:#     endif
        -:  160:  if (
        -:  161:      ACE_ADAPT_RETVAL (pthread_condattr_init (&attributes), result) == 0
        -:  162:#     if defined (_POSIX_THREAD_PROCESS_SHARED) && !defined (ACE_LACKS_CONDATTR_PSHARED)
        -:  163:      && ACE_ADAPT_RETVAL (pthread_condattr_setpshared (&attributes, type),
        -:  164:                           result) == 0
        -:  165:#     endif /* _POSIX_THREAD_PROCESS_SHARED && ! ACE_LACKS_CONDATTR_PSHARED */
        -:  166:      )
        -:  167:#   else
        -:  168:  if (type == USYNC_THREAD)
        -:  169:#   endif /* !ACE_LACKS_CONDATTR */
        -:  170:     result = 0;
        -:  171:  else
        -:  172:    {
        -:  173:      ACE_UNUSED_ARG (attributes);
        -:  174:      result = -1;       // ACE_ADAPT_RETVAL used it for intermediate status
        -:  175:    }
        -:  176:
        -:  177:  return result;
        -:  178:#   else
        -:  179:  attributes.type = type;
        -:  180:  return 0;
        -:  181:#   endif /* ACE_HAS_PTHREADS */
        -:  182:
        -:  183:# else
        -:  184:  ACE_UNUSED_ARG (attributes);
        -:  185:  ACE_UNUSED_ARG (type);
        -:  186:  ACE_NOTSUP_RETURN (-1);
        -:  187:# endif /* ACE_HAS_THREADS */
        -:  188:}
        -:  189:
        -:  190:ACE_INLINE int
        -:  191:ACE_OS::condattr_synctype (ACE_condattr_t &attributes, int& type)
        -:  192:{
        -:  193:# if defined (ACE_HAS_THREADS)
        -:  194:#   if defined (ACE_HAS_PTHREADS)
        -:  195:#   if !defined (ACE_LACKS_CONDATTR) && defined (_POSIX_THREAD_PROCESS_SHARED) && !defined (ACE_LACKS_CONDATTR_PSHARED)
        -:  196:  int result = -1;
        -:  197:
        -:  198:  if (
        -:  199:      ACE_ADAPT_RETVAL (pthread_condattr_getpshared (&attributes, &type),
        -:  200:                           result) == 0
        -:  201:     )
        -:  202:    {
        -:  203:      result = 0;
        -:  204:    }
        -:  205:#   else
        -:  206:  ACE_UNUSED_ARG (attributes);
        -:  207:  int result = 0;
        -:  208:  type = USYNC_THREAD;
        -:  209:#   endif /* !ACE_LACKS_CONDATTR && _POSIX_THREAD_PROCESS_SHARED && ! ACE_LACKS_CONDATTR_PSHARED */
        -:  210:
        -:  211:  return result;
        -:  212:#   else
        -:  213:  type = attributes.type;
        -:  214:  return 0;
        -:  215:#   endif /* ACE_HAS_PTHREADS */
        -:  216:
        -:  217:# else
        -:  218:  ACE_UNUSED_ARG (attributes);
        -:  219:  ACE_UNUSED_ARG (type);
        -:  220:  ACE_NOTSUP_RETURN (-1);
        -:  221:# endif /* ACE_HAS_THREADS */
        -:  222:}
        -:  223:
        -:  224:ACE_INLINE int
        -:  225:ACE_OS::condattr_setclock (ACE_condattr_t &attributes, clockid_t clock_id)
        -:  226:{
        -:  227:# if defined (ACE_HAS_THREADS)
        -:  228:#   if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_CONDATTR)
        -:  229:  int result = -1;
        -:  230:
        -:  231:#   if defined (_POSIX_CLOCK_SELECTION) && !defined (ACE_LACKS_CONDATTR_SETCLOCK)
        -:  232:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_condattr_setclock (&attributes, clock_id),
        -:  233:                                       result),
        -:  234:                     int, -1);
        -:  235:#   else
        -:  236:  ACE_UNUSED_ARG (clock_id);
        -:  237:  ACE_UNUSED_ARG (attributes);
        -:  238:#   endif /* _POSIX_CLOCK_SELECTION) && !ACE_LACKS_CONDATTR_SETCLOCK */
        -:  239:
        -:  240:  return result;
        -:  241:#   else
        -:  242:  ACE_UNUSED_ARG (clock_id);
        -:  243:  ACE_UNUSED_ARG (attributes);
        -:  244:  ACE_NOTSUP_RETURN (-1);
        -:  245:#   endif /* ACE_HAS_PTHREADS && !ACE_LACKS_CONDATTR */
        -:  246:
        -:  247:# else
        -:  248:  ACE_UNUSED_ARG (clock_id);
        -:  249:  ACE_UNUSED_ARG (attributes);
        -:  250:  ACE_NOTSUP_RETURN (-1);
        -:  251:# endif /* ACE_HAS_THREADS */
        -:  252:}
        -:  253:
        -:  254:#if !defined (ACE_LACKS_COND_T)
        -:  255:// NOTE: The ACE_OS::cond_* functions for Unix platforms are defined
        -:  256:// here because the ACE_OS::sema_* functions below need them.
        -:  257:// However, ACE_WIN32 and VXWORKS define the ACE_OS::cond_* functions
        -:  258:// using the ACE_OS::sema_* functions.  So, they are defined in OS_NS_Tread.cpp.
        -:  259:
        -:  260:ACE_INLINE int
        -:  261:ACE_OS::cond_broadcast (ACE_cond_t *cv)
        -:  262:{
        -:  263:  ACE_OS_TRACE ("ACE_OS::cond_broadcast");
        -:  264:# if defined (ACE_HAS_THREADS)
        -:  265:#   if defined (ACE_HAS_PTHREADS)
        -:  266:  int result;
        -:  267:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_broadcast (cv),
        -:  268:                                       result),
        -:  269:                     int, -1);
        -:  270:#   elif defined (ACE_HAS_STHREADS)
        -:  271:  int result;
        -:  272:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_broadcast (cv),
        -:  273:                                       result),
        -:  274:                     int, -1);
        -:  275:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  276:  ::WakeAllConditionVariable  (cv);
        -:  277:  return 0;
        -:  278:#   endif /* ACE_HAS_STHREADS */
        -:  279:# else
        -:  280:  ACE_UNUSED_ARG (cv);
        -:  281:  ACE_NOTSUP_RETURN (-1);
        -:  282:# endif /* ACE_HAS_THREADS */
        -:  283:}
        -:  284:
        -:  285:ACE_INLINE int
        -:  286:ACE_OS::cond_destroy (ACE_cond_t *cv)
        -:  287:{
        -:  288:  ACE_OS_TRACE ("ACE_OS::cond_destroy");
        -:  289:# if defined (ACE_HAS_THREADS)
        -:  290:#   if defined (ACE_HAS_PTHREADS)
        -:  291:  int result;
        -:  292:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_destroy (cv), result), int, -1);
        -:  293:#   elif defined (ACE_HAS_STHREADS)
        -:  294:  int result;
        -:  295:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_destroy (cv), result), int, -1);
        -:  296:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  297:  // Windows doesn't have a destroy
        -:  298:  return 0;
        -:  299:#   endif /* ACE_HAS_STHREADS */
        -:  300:# else
        -:  301:  ACE_UNUSED_ARG (cv);
        -:  302:  ACE_NOTSUP_RETURN (-1);
        -:  303:# endif /* ACE_HAS_THREADS */
        -:  304:}
        -:  305:
        -:  306:ACE_INLINE int
        -:  307:ACE_OS::cond_init (ACE_cond_t *cv,
        -:  308:                   ACE_condattr_t &attributes,
        -:  309:                   const char *name,
        -:  310:                   void *arg)
        -:  311:{
        -:  312:  // ACE_OS_TRACE ("ACE_OS::cond_init");
        -:  313:  ACE_UNUSED_ARG (name);
        -:  314:  ACE_UNUSED_ARG (arg);
        -:  315:# if defined (ACE_HAS_THREADS)
        -:  316:#   if defined (ACE_HAS_PTHREADS)
        -:  317:  int result = -1;
        -:  318:
        -:  319:#     if defined (ACE_PTHREAD_COND_T_INITIALIZE)
        -:  320:  /* VxWorks 6.x API reference states:
        -:  321:   *   If the memory for the condition variable object has been allocated
        -:  322:   *   dynamically, it is a good policy to always zero out the
        -:  323:   *   block of memory so as to avoid spurious EBUSY return code
        -:  324:   *   when calling this routine.
        -:  325:   */
        -:  326:  ACE_OS::memset (cv, 0, sizeof (*cv));
        -:  327:#     endif
        -:  328:
        -:  329:  if (ACE_ADAPT_RETVAL (pthread_cond_init (cv, &attributes), result) == 0)
        -:  330:     result = 0;
        -:  331:  else
        -:  332:     result = -1;       // ACE_ADAPT_RETVAL used it for intermediate status
        -:  333:
        -:  334:  return result;
        -:  335:#   elif defined (ACE_HAS_STHREADS)
        -:  336:  int result;
        -:  337:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_init (cv,
        -:  338:                                                    attributes.type,
        -:  339:                                                    arg),
        -:  340:                                       result),
        -:  341:                     int, -1);
        -:  342:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  343:    ::InitializeConditionVariable (cv);
        -:  344:    return 0;
        -:  345:#   endif /* ACE_HAS_PTHREADS vs. ACE_HAS_STHREADS */
        -:  346:# else
        -:  347:  ACE_UNUSED_ARG (cv);
        -:  348:  ACE_UNUSED_ARG (attributes);
        -:  349:  ACE_UNUSED_ARG (name);
        -:  350:  ACE_UNUSED_ARG (arg);
        -:  351:  ACE_NOTSUP_RETURN (-1);
        -:  352:# endif /* ACE_HAS_THREADS */
        -:  353:}
        -:  354:
        -:  355:#if defined (ACE_HAS_WCHAR)
        -:  356:ACE_INLINE int
        -:  357:ACE_OS::cond_init (ACE_cond_t *cv,
        -:  358:                   ACE_condattr_t &attributes,
        -:  359:                   const wchar_t *name,
        -:  360:                   void *arg)
        -:  361:{
        -:  362:  return ACE_OS::cond_init (cv, attributes, ACE_Wide_To_Ascii (name).char_rep (), arg);
        -:  363:}
        -:  364:#endif /* ACE_HAS_WCHAR */
        -:  365:
        -:  366:#if defined (ACE_HAS_WCHAR)
        -:  367:ACE_INLINE int
        -:  368:ACE_OS::cond_init (ACE_cond_t *cv, short type, const wchar_t *name, void *arg)
        -:  369:{
        -:  370:  return ACE_OS::cond_init (cv, type, ACE_Wide_To_Ascii (name).char_rep (), arg);
        -:  371:}
        -:  372:#endif /* ACE_HAS_WCHAR */
        -:  373:
        -:  374:ACE_INLINE int
        -:  375:ACE_OS::cond_signal (ACE_cond_t *cv)
        -:  376:{
        -:  377:  ACE_OS_TRACE ("ACE_OS::cond_signal");
        -:  378:# if defined (ACE_HAS_THREADS)
        -:  379:#   if defined (ACE_HAS_PTHREADS)
        -:  380:  int result;
        -:  381:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_signal (cv), result),
        -:  382:                     int, -1);
        -:  383:#   elif defined (ACE_HAS_STHREADS)
        -:  384:  int result;
        -:  385:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_signal (cv), result), int, -1);
        -:  386:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  387:  ::WakeConditionVariable (cv);
        -:  388:  return 0;
        -:  389:#   endif /* ACE_HAS_STHREADS */
        -:  390:# else
        -:  391:  ACE_UNUSED_ARG (cv);
        -:  392:  ACE_NOTSUP_RETURN (-1);
        -:  393:# endif /* ACE_HAS_THREADS */
        -:  394:}
        -:  395:
        -:  396:ACE_INLINE int
        -:  397:ACE_OS::cond_wait (ACE_cond_t *cv,
        -:  398:                   ACE_mutex_t *external_mutex)
        -:  399:{
        -:  400:  ACE_OS_TRACE ("ACE_OS::cond_wait");
        -:  401:# if defined (ACE_HAS_THREADS)
        -:  402:#   if defined (ACE_HAS_PTHREADS)
        -:  403:  int result;
        -:  404:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cond_wait (cv, external_mutex), result),
        -:  405:                     int, -1);
        -:  406:#   elif defined (ACE_HAS_STHREADS)
        -:  407:  int result;
        -:  408:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::cond_wait (cv, external_mutex), result),
        -:  409:                     int, -1);
        -:  410:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  411:  int result;
        -:  412:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::SleepConditionVariableCS (cv, &external_mutex->thr_mutex_, INFINITE), result),
        -:  413:                     int, -1);
        -:  414:#   endif /* ACE_HAS_PTHREADS */
        -:  415:# else
        -:  416:  ACE_UNUSED_ARG (cv);
        -:  417:  ACE_UNUSED_ARG (external_mutex);
        -:  418:  ACE_NOTSUP_RETURN (-1);
        -:  419:# endif /* ACE_HAS_THREADS */
        -:  420:}
        -:  421:
        -:  422:ACE_INLINE int
        -:  423:ACE_OS::cond_timedwait (ACE_cond_t *cv,
        -:  424:                        ACE_mutex_t *external_mutex,
        -:  425:                        ACE_Time_Value *timeout)
        -:  426:{
        -:  427:  ACE_OS_TRACE ("ACE_OS::cond_timedwait");
        -:  428:# if defined (ACE_HAS_THREADS)
        -:  429:  int result = 0;
        -:  430:  timespec_t ts;
        -:  431:
        -:  432:  if (timeout != 0)
        -:  433:    ts = *timeout; // Calls ACE_Time_Value::operator timespec_t().
        -:  434:
        -:  435:#   if defined (ACE_HAS_PTHREADS)
        -:  436:
        -:  437:  ACE_OSCALL (ACE_ADAPT_RETVAL (timeout == 0
        -:  438:                                ? pthread_cond_wait (cv, external_mutex)
        -:  439:                                : pthread_cond_timedwait (cv, external_mutex,
        -:  440:                                                            (ACE_TIMESPEC_PTR) &ts),
        -:  441:                                result),
        -:  442:              int, -1, result);
        -:  443:  // We need to adjust this to make the POSIX and Solaris return
        -:  444:  // values consistent.  EAGAIN is from Pthreads DRAFT4 (HP-UX 10.20 and down)
        -:  445:  if (result == -1 &&
        -:  446:      (errno == ETIMEDOUT || errno == EAGAIN))
        -:  447:    errno = ETIME;
        -:  448:
        -:  449:#   elif defined (ACE_HAS_STHREADS)
        -:  450:  ACE_OSCALL (ACE_ADAPT_RETVAL (timeout == 0
        -:  451:                                ? ::cond_wait (cv, external_mutex)
        -:  452:                                : ::cond_timedwait (cv,
        -:  453:                                                    external_mutex,
        -:  454:                                                    (timestruc_t*)&ts),
        -:  455:                                result),
        -:  456:              int, -1, result);
        -:  457:#   elif defined (ACE_HAS_WTHREADS) && defined (ACE_HAS_WTHREADS_CONDITION_VARIABLE)
        -:  458:  int msec_timeout = 0;
        -:  459:  if (timeout != 0)
        -:  460:    {
        -:  461:      ACE_Time_Value relative_time = timeout->to_relative_time ();
        -:  462:      // Watchout for situations where a context switch has caused the
        -:  463:      // current time to be > the timeout.
        -:  464:      if (relative_time > ACE_Time_Value::zero)
        -:  465:        msec_timeout = relative_time.msec ();
        -:  466:    }
        -:  467:
        -:  468:  ACE_OSCALL (ACE_ADAPT_RETVAL (::SleepConditionVariableCS (cv, &external_mutex->thr_mutex_, msec_timeout),
        -:  469:                                result),
        -:  470:              int, -1, result);
        -:  471:
        -:  472:  return result;
        -:  473:#   endif /* ACE_HAS_STHREADS */
        -:  474:  if (timeout != 0)
        -:  475:    timeout->set (ts); // Update the time value before returning.
        -:  476:
        -:  477:  return result;
        -:  478:# else
        -:  479:  ACE_UNUSED_ARG (cv);
        -:  480:  ACE_UNUSED_ARG (external_mutex);
        -:  481:  ACE_UNUSED_ARG (timeout);
        -:  482:  ACE_NOTSUP_RETURN (-1);
        -:  483:# endif /* ACE_HAS_THREADS */
        -:  484:}
        -:  485:#endif /* !ACE_LACKS_COND_T */
        -:  486:
        -:  487:ACE_INLINE int
        -:  488:ACE_OS::mutex_lock (ACE_mutex_t *m,
        -:  489:                    const ACE_Time_Value *timeout)
        -:  490:{
        -:  491:  return timeout == 0 ? ACE_OS::mutex_lock (m) : ACE_OS::mutex_lock (m, *timeout);
        -:  492:}
        -:  493:
        -:  494:ACE_INLINE int
        -:  495:ACE_OS::event_wait (ACE_event_t *event)
        -:  496:{
        -:  497:  return ACE_OS::event_timedwait (event, 0);
        -:  498:}
        -:  499:
        -:  500:ACE_INLINE int
        -:  501:ACE_OS::event_init (ACE_event_t *event,
        -:  502:                    int manual_reset,
        -:  503:                    int initial_state,
        -:  504:                    int type,
        -:  505:                    const char *name,
        -:  506:                    void *arg,
        -:  507:                    LPSECURITY_ATTRIBUTES sa)
        -:  508:{
        -:  509:  ACE_condattr_t *pattr = 0;
        -:  510:  return ACE_OS::event_init (event, type, pattr, manual_reset, initial_state, name, arg, sa);
        -:  511:}
        -:  512:
        -:  513:#if defined (ACE_HAS_WCHAR)
        -:  514:ACE_INLINE int
        -:  515:ACE_OS::event_init (ACE_event_t *event,
        -:  516:                    int manual_reset,
        -:  517:                    int initial_state,
        -:  518:                    int type,
        -:  519:                    const wchar_t *name,
        -:  520:                    void *arg,
        -:  521:                    LPSECURITY_ATTRIBUTES sa)
        -:  522:{
        -:  523:#if defined (ACE_WIN32)
        -:  524:  ACE_UNUSED_ARG (type);
        -:  525:  ACE_UNUSED_ARG (arg);
        -:  526:  SECURITY_ATTRIBUTES sa_buffer;
        -:  527:  SECURITY_DESCRIPTOR sd_buffer;
        -:  528:  *event = ::CreateEventW (ACE_OS::default_win32_security_attributes_r
        -:  529:      (sa, &sa_buffer, &sd_buffer),
        -:  530:  manual_reset,
        -:  531:  initial_state,
        -:  532:  name);
        -:  533:  if (*event == 0)
        -:  534:    ACE_FAIL_RETURN (-1);
        -:  535:
        -:  536:  // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -:  537:  ACE_OS::set_errno_to_last_error ();
        -:  538:  return 0;
        -:  539:#else  /* ACE_WIN32 */
        -:  540:  return ACE_OS::event_init (event,
        -:  541:                             manual_reset,
        -:  542:                             initial_state,
        -:  543:                             type,
        -:  544:                             ACE_Wide_To_Ascii (name).char_rep (),
        -:  545:                             arg,
        -:  546:                             sa);
        -:  547:#endif /* ACE_WIN32 */
        -:  548:}
        -:  549:
        -:  550:ACE_INLINE int
        -:  551:ACE_OS::event_init (ACE_event_t *event,
        -:  552:                    int type,
        -:  553:                    ACE_condattr_t *attributes,
        -:  554:                    int manual_reset,
        -:  555:                    int initial_state,
        -:  556:                    const wchar_t *name,
        -:  557:                    void *arg,
        -:  558:                    LPSECURITY_ATTRIBUTES sa)
        -:  559:{
        -:  560:#if defined (ACE_WIN32)
        -:  561:  ACE_UNUSED_ARG (type);
        -:  562:  ACE_UNUSED_ARG (attributes);
        -:  563:  ACE_UNUSED_ARG (arg);
        -:  564:  SECURITY_ATTRIBUTES sa_buffer;
        -:  565:  SECURITY_DESCRIPTOR sd_buffer;
        -:  566:  *event = ::CreateEventW (ACE_OS::default_win32_security_attributes_r
        -:  567:      (sa, &sa_buffer, &sd_buffer),
        -:  568:  manual_reset,
        -:  569:  initial_state,
        -:  570:  name);
        -:  571:  if (*event == 0)
        -:  572:    ACE_FAIL_RETURN (-1);
        -:  573:
        -:  574:  // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -:  575:  ACE_OS::set_errno_to_last_error ();
        -:  576:  return 0;
        -:  577:#else  /* ACE_WIN32 */
        -:  578:  return ACE_OS::event_init (event,
        -:  579:                             type,
        -:  580:                             attributes,
        -:  581:                             manual_reset,
        -:  582:                             initial_state,
        -:  583:                             ACE_Wide_To_Ascii (name).char_rep (),
        -:  584:                             arg,
        -:  585:                             sa);
        -:  586:#endif /* ACE_WIN32 */
        -:  587:}
        -:  588:#endif /* ACE_HAS_WCHAR */
        -:  589:
        -:  590:ACE_INLINE long
        -:  591:ACE_OS::priority_control (ACE_idtype_t idtype, ACE_id_t identifier, int cmd, void *arg)
        -:  592:{
        -:  593:  ACE_OS_TRACE ("ACE_OS::priority_control");
        -:  594:#if defined (ACE_HAS_PRIOCNTL)
        -:  595:  ACE_OSCALL_RETURN (priocntl (idtype, identifier, cmd, static_cast<caddr_t> (arg)),
        -:  596:                     long, -1);
        -:  597:#else  /* ! ACE_HAS_PRIOCNTL*/
        -:  598:  ACE_UNUSED_ARG (idtype);
        -:  599:  ACE_UNUSED_ARG (identifier);
        -:  600:  ACE_UNUSED_ARG (cmd);
        -:  601:  ACE_UNUSED_ARG (arg);
        -:  602:  ACE_NOTSUP_RETURN (-1);
        -:  603:#endif /* ! ACE_HAS_PRIOCNTL*/
        -:  604:}
        -:  605:
        -:  606:// This method is used to prepare the recursive mutex for releasing
        -:  607:// when waiting on a condition variable. If the platform doesn't have
        -:  608:// native recursive mutex and condition variable support, then ACE needs
        -:  609:// to save the recursion state around the wait and also ensure that the
        -:  610:// wait and lock release are atomic. recursive_mutex_cond_relock()
        -:  611:// is the inverse of this method.
        -:  612:ACE_INLINE int
        -:  613:ACE_OS::recursive_mutex_cond_unlock (ACE_recursive_thread_mutex_t *m,
        -:  614:                                     ACE_recursive_mutex_state &state)
        -:  615:{
        -:  616:#if defined (ACE_HAS_THREADS)
        -:  617:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_cond_unlock");
        -:  618:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  619:  // Windows need special handling since it has recursive mutexes, but
        -:  620:  // does not integrate them into a condition variable.
        -:  621:#    if defined (ACE_WIN32)
        -:  622:  // For Windows, the OS takes care of the mutex and its recursion. We just
        -:  623:  // need to release the lock one fewer times than this thread has acquired
        -:  624:  // it. Remember how many times, and reacquire it that many more times when
        -:  625:  // the condition is signaled.
        -:  626:
        -:  627:  // We're using undocumented fields in the CRITICAL_SECTION structure
        -:  628:  // and they've been known to change across Windows variants and versions./
        -:  629:  // So be careful if you need to change these - there may be other
        -:  630:  // Windows variants that depend on existing values and limits.
        -:  631:
        -:  632:  state.relock_count_ = 0;
        -:  633:  while (
        -:  634:#      if !defined (ACE_HAS_WINCE)
        -:  635:         m->LockCount > 0 && m->RecursionCount > 1
        -:  636:#      else
        -:  637:         // WinCE doesn't have RecursionCount and the LockCount semantic
        -:  638:         // Mobile 5 has it 1-indexed.
        -:  639:         m->LockCount > 1
        -:  640:#      endif /* ACE_HAS_WINCE */
        -:  641:         )
        -:  642:    {
        -:  643:      // This may fail if the current thread doesn't own the mutex. If it
        -:  644:      // does fail, it'll be on the first try, so don't worry about resetting
        -:  645:      // the state.
        -:  646:      if (ACE_OS::recursive_mutex_unlock (m) == -1)
        -:  647:        return -1;
        -:  648:      ++state.relock_count_;
        -:  649:    }
        -:  650:#    else /* not ACE_WIN32 */
        -:  651:    // prevent warnings for unused variables
        -:  652:    ACE_UNUSED_ARG (state);
        -:  653:    ACE_UNUSED_ARG (m);
        -:  654:#    endif /* ACE_WIN32 */
        -:  655:  return 0;
        -:  656:#  else /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  657:  // For platforms without recursive mutexes, we obtain the nesting mutex
        -:  658:  // to gain control over the mutex internals. Then set the internals to say
        -:  659:  // the mutex is available. If there are waiters, signal the condition
        -:  660:  // to notify them (this is mostly like the recursive_mutex_unlock() method).
        -:  661:  // Then, return with the nesting mutex still held. The condition wait
        -:  662:  // will release it atomically, allowing mutex waiters to continue.
        -:  663:  // Note that this arrangement relies on the fact that on return from
        -:  664:  // the condition wait, this thread will again own the nesting mutex
        -:  665:  // and can either set the mutex internals directly or get in line for
        -:  666:  // the mutex... this part is handled in recursive_mutex_cond_relock().
        -:  667:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  668:    return -1;
        -:  669:
        -:  670:#    if !defined (ACE_NDEBUG)
        -:  671:  if (m->nesting_level_ == 0
        -:  672:      || ACE_OS::thr_equal (ACE_OS::thr_self (), m->owner_id_) == 0)
        -:  673:    {
        -:  674:      ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  675:      errno = EINVAL;
        -:  676:      return -1;
        -:  677:    }
        -:  678:#    endif /* ACE_NDEBUG */
        -:  679:
        -:  680:  // To make error recovery a bit easier, signal the condition now. Any
        -:  681:  // waiter won't regain control until the mutex is released, which won't
        -:  682:  // be until the caller returns and does the wait on the condition.
        -:  683:  if (ACE_OS::cond_signal (&m->lock_available_) == -1)
        -:  684:    {
        -:  685:      // Save/restore errno.
        -:  686:      ACE_Errno_Guard error (errno);
        -:  687:      ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  688:      return -1;
        -:  689:    }
        -:  690:
        -:  691:  // Ok, the nesting_mutex_ lock is still held, the condition has been
        -:  692:  // signaled... reset the nesting info and return _WITH_ the lock
        -:  693:  // held. The lock will be released when the condition waits, in the
        -:  694:  // caller.
        -:  695:  state.nesting_level_ = m->nesting_level_;
        -:  696:  state.owner_id_ = m->owner_id_;
        -:  697:  m->nesting_level_ = 0;
        -:  698:  m->owner_id_ = ACE_OS::NULL_thread;
        -:  699:  return 0;
        -:  700:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  701:#else
        -:  702:  ACE_UNUSED_ARG (m);
        -:  703:  ACE_UNUSED_ARG (state);
        -:  704:  ACE_NOTSUP_RETURN (-1);
        -:  705:#endif /* ACE_HAS_THREADS */
        -:  706:}
        -:  707:
        -:  708:
        -:  709:// This method is called after waiting on a condition variable when a
        -:  710:// recursive mutex must be reacquired. If the platform doesn't natively
        -:  711:// integrate recursive mutexes and condition variables, it's taken care
        -:  712:// of here (inverse of ACE_OS::recursive_mutex_cond_unlock).
        -:  713:ACE_INLINE void
        -:  714:ACE_OS::recursive_mutex_cond_relock (ACE_recursive_thread_mutex_t *m,
        -:  715:                                     ACE_recursive_mutex_state &state)
        -:  716:{
        -:  717:#if defined (ACE_HAS_THREADS)
        -:  718:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_cond_relock");
        -:  719:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  720:  // Windows need special handling since it has recursive mutexes, but
        -:  721:  // does not integrate them into a condition variable.
        -:  722:  // On entry, the OS has already reacquired the lock for us. Just
        -:  723:  // reacquire it the proper number of times so the recursion is the same as
        -:  724:  // before waiting on the condition.
        -:  725:#    if defined (ACE_WIN32)
        -:  726:  while (state.relock_count_ > 0)
        -:  727:    {
        -:  728:      ACE_OS::recursive_mutex_lock (m);
        -:  729:      --state.relock_count_;
        -:  730:    }
        -:  731:  return;
        -:  732:#    else /* not ACE_WIN32 */
        -:  733:    // prevent warnings for unused variables
        -:  734:    ACE_UNUSED_ARG (state);
        -:  735:    ACE_UNUSED_ARG (m);
        -:  736:
        -:  737:#    endif /* ACE_WIN32 */
        -:  738:#  else
        -:  739:  // Without recursive mutex support, it's somewhat trickier. On entry,
        -:  740:  // the current thread holds the nesting_mutex_, but another thread may
        -:  741:  // still be holding the ACE_recursive_mutex_t. If so, mimic the code
        -:  742:  // in ACE_OS::recursive_mutex_lock that waits to acquire the mutex.
        -:  743:  // After acquiring it, restore the nesting counts and release the
        -:  744:  // nesting mutex. This will restore the conditions to what they were
        -:  745:  // before calling ACE_OS::recursive_mutex_cond_unlock().
        -:  746:  while (m->nesting_level_ > 0)
        -:  747:    ACE_OS::cond_wait (&m->lock_available_, &m->nesting_mutex_);
        -:  748:
        -:  749:  // At this point, we still have nesting_mutex_ and the mutex is free.
        -:  750:  m->nesting_level_ = state.nesting_level_;
        -:  751:  m->owner_id_ = state.owner_id_;
        -:  752:  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  753:  return;
        -:  754:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  755:#else
        -:  756:  ACE_UNUSED_ARG (m);
        -:  757:  ACE_UNUSED_ARG (state);
        -:  758:  return;
        -:  759:#endif /* ACE_HAS_THREADS */
        -:  760:}
        -:  761:
        -:  762:ACE_INLINE int
        -:  763:ACE_OS::recursive_mutex_destroy (ACE_recursive_thread_mutex_t *m)
        -:  764:{
        -:  765:#if defined (ACE_HAS_THREADS)
        -:  766:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  767:  return ACE_OS::thread_mutex_destroy (m);
        -:  768:#else
        -:  769:  if (ACE_OS::cond_destroy (&m->lock_available_) == -1
        -:  770:      || ACE_OS::thread_mutex_destroy (&m->nesting_mutex_) == -1)
        -:  771:    return -1;
        -:  772:  return 0;
        -:  773:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  774:#else
        -:  775:  ACE_UNUSED_ARG (m);
        -:  776:  ACE_NOTSUP_RETURN (-1);
        -:  777:#endif /* ACE_HAS_THREADS */
        -:  778:}
        -:  779:
        -:  780:ACE_INLINE int
        -:  781:ACE_OS::recursive_mutex_init (ACE_recursive_thread_mutex_t *m,
        -:  782:                              const ACE_TCHAR *name,
        -:  783:                              ACE_mutexattr_t *arg,
        -:  784:                              LPSECURITY_ATTRIBUTES sa)
        -:  785:{
        -:  786:  ACE_UNUSED_ARG (sa);
        -:  787:#if defined (ACE_HAS_THREADS)
        -:  788:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  789:#    if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -:  790:  return ACE_OS::thread_mutex_init (m, PTHREAD_MUTEX_RECURSIVE, name, arg);
        -:  791:#    else
        -:  792:  return ACE_OS::thread_mutex_init (m, 0, name, arg);
        -:  793:#    endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -:  794:#  else
        -:  795:  if (ACE_OS::thread_mutex_init (&m->nesting_mutex_, 0, name, arg) == -1)
        -:  796:    return -1;
        -:  797:  else if (ACE_OS::cond_init (&m->lock_available_,
        -:  798:                              (short) USYNC_THREAD,
        -:  799:                              name,
        -:  800:                              0) == -1)
        -:  801:    return -1;
        -:  802:  else
        -:  803:    {
        -:  804:      m->nesting_level_ = 0;
        -:  805:      m->owner_id_ = ACE_OS::NULL_thread;
        -:  806:      return 0;
        -:  807:    }
        -:  808:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  809:#else
        -:  810:  ACE_UNUSED_ARG (m);
        -:  811:  ACE_UNUSED_ARG (name);
        -:  812:  ACE_UNUSED_ARG (arg);
        -:  813:  ACE_NOTSUP_RETURN (-1);
        -:  814:#endif /* ACE_HAS_THREADS */
        -:  815:}
        -:  816:
        -:  817:ACE_INLINE int
    33498:  818:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m)
        -:  819:{
        -:  820:#if defined (ACE_HAS_THREADS)
        -:  821:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
    33498:  822:  return ACE_OS::thread_mutex_lock (m);
        -:  823:#else
        -:  824:  ACE_thread_t const t_id = ACE_OS::thr_self ();
        -:  825:  int result = 0;
        -:  826:
        -:  827:  // Acquire the guard.
        -:  828:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  829:    result = -1;
        -:  830:  else
        -:  831:  {
        -:  832:    // If there's no contention, just grab the lock immediately
        -:  833:    // (since this is the common case we'll optimize for it).
        -:  834:    if (m->nesting_level_ == 0)
        -:  835:      m->owner_id_ = t_id;
        -:  836:      // If we already own the lock, then increment the nesting level
        -:  837:      // and return.
        -:  838:    else if (ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -:  839:    {
        -:  840:          // Wait until the nesting level has dropped to zero, at
        -:  841:          // which point we can acquire the lock.
        -:  842:      while (m->nesting_level_ > 0)
        -:  843:        ACE_OS::cond_wait (&m->lock_available_,
        -:  844:                            &m->nesting_mutex_);
        -:  845:
        -:  846:          // At this point the nesting_mutex_ is held...
        -:  847:      m->owner_id_ = t_id;
        -:  848:    }
        -:  849:
        -:  850:    // At this point, we can safely increment the nesting_level_ no
        -:  851:    // matter how we got here!
        -:  852:    ++m->nesting_level_;
        -:  853:  }
        -:  854:
        -:  855:  {
        -:  856:    // Save/restore errno.
        -:  857:    ACE_Errno_Guard error (errno);
        -:  858:    ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  859:  }
        -:  860:  return result;
        -:  861:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  862:#else
        -:  863:  ACE_UNUSED_ARG (m);
        -:  864:  ACE_NOTSUP_RETURN (-1);
        -:  865:#endif /* ACE_HAS_THREADS */
        -:  866:}
        -:  867:
        -:  868:ACE_INLINE int
        -:  869:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m,
        -:  870:                              const ACE_Time_Value &timeout)
        -:  871:{
        -:  872:#if defined (ACE_HAS_THREADS)
        -:  873:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  874:  return ACE_OS::thread_mutex_lock (m, timeout);
        -:  875:#else
        -:  876:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  877:  int result = 0;
        -:  878:
        -:  879:  // Try to acquire the guard.
        -:  880:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_, timeout) == -1)
        -:  881:    result = -1;
        -:  882:  else
        -:  883:    {
        -:  884:      // If there's no contention, just grab the lock immediately
        -:  885:      // (since this is the common case we'll optimize for it).
        -:  886:      if (m->nesting_level_ == 0)
        -:  887:        m->owner_id_ = t_id;
        -:  888:      // If we already own the lock, then increment the nesting level
        -:  889:      // and return.
        -:  890:      else if (ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -:  891:        {
        -:  892:          // Wait until the nesting level has dropped to zero, at
        -:  893:          // which point we can acquire the lock.
        -:  894:          while (m->nesting_level_ > 0)
        -:  895:            {
        -:  896:              result = ACE_OS::cond_timedwait (&m->lock_available_,
        -:  897:                                               &m->nesting_mutex_,
        -:  898:                                               const_cast <ACE_Time_Value *> (&timeout));
        -:  899:
        -:  900:              // The mutex is reacquired even in the case of a timeout
        -:  901:              // release the mutex to prevent a deadlock
        -:  902:              if (result == -1)
        -:  903:                {
        -:  904:                  // Save/restore errno.
        -:  905:                  ACE_Errno_Guard error (errno);
        -:  906:                  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  907:
        -:  908:                  return result;
        -:  909:                }
        -:  910:            }
        -:  911:
        -:  912:          // At this point the nesting_mutex_ is held...
        -:  913:          m->owner_id_ = t_id;
        -:  914:        }
        -:  915:
        -:  916:      // At this point, we can safely increment the nesting_level_ no
        -:  917:      // matter how we got here!
        -:  918:      m->nesting_level_++;
        -:  919:
        -:  920:      // Save/restore errno.
        -:  921:      ACE_Errno_Guard error (errno);
        -:  922:      ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  923:    }
        -:  924:  return result;
        -:  925:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  926:#else
        -:  927:  ACE_UNUSED_ARG (m);
        -:  928:  ACE_UNUSED_ARG (timeout);
        -:  929:  ACE_NOTSUP_RETURN (-1);
        -:  930:#endif /* ACE_HAS_THREADS */
        -:  931:}
        -:  932:
        -:  933:ACE_INLINE int
        -:  934:ACE_OS::recursive_mutex_lock (ACE_recursive_thread_mutex_t *m,
        -:  935:                              const ACE_Time_Value *timeout)
        -:  936:{
        -:  937:  return timeout == 0
        -:  938:    ? ACE_OS::recursive_mutex_lock (m)
        -:  939:    : ACE_OS::recursive_mutex_lock (m, *timeout);
        -:  940:}
        -:  941:
        -:  942:ACE_INLINE int
        -:  943:ACE_OS::recursive_mutex_trylock (ACE_recursive_thread_mutex_t *m)
        -:  944:{
        -:  945:#if defined (ACE_HAS_THREADS)
        -:  946:#if defined (ACE_HAS_RECURSIVE_MUTEXES)
        -:  947:  return ACE_OS::thread_mutex_trylock (m);
        -:  948:#else
        -:  949:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  950:  int result = 0;
        -:  951:
        -:  952:  // Acquire the guard.
        -:  953:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -:  954:    result = -1;
        -:  955:  else
        -:  956:  {
        -:  957:      // If there's no contention, just grab the lock immediately.
        -:  958:    if (m->nesting_level_ == 0)
        -:  959:    {
        -:  960:      m->owner_id_ = t_id;
        -:  961:      m->nesting_level_ = 1;
        -:  962:    }
        -:  963:      // If we already own the lock, then increment the nesting level
        -:  964:      // and proceed.
        -:  965:    else if (ACE_OS::thr_equal (t_id, m->owner_id_))
        -:  966:      m->nesting_level_++;
        -:  967:    else
        -:  968:    {
        -:  969:      errno = EBUSY;
        -:  970:      result = -1;
        -:  971:    }
        -:  972:  }
        -:  973:
        -:  974:  {
        -:  975:    // Save/restore errno.
        -:  976:    ACE_Errno_Guard error (errno);
        -:  977:    ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -:  978:  }
        -:  979:  return result;
        -:  980:#endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -:  981:#else
        -:  982:  ACE_UNUSED_ARG (m);
        -:  983:  ACE_NOTSUP_RETURN (-1);
        -:  984:#endif /* ACE_HAS_THREADS */
        -:  985:}
        -:  986:
        -:  987:ACE_INLINE int
    33498:  988:ACE_OS::recursive_mutex_unlock (ACE_recursive_thread_mutex_t *m)
        -:  989:{
        -:  990:#if defined (ACE_HAS_THREADS)
        -:  991:#  if defined (ACE_HAS_RECURSIVE_MUTEXES)
    33498:  992:  return ACE_OS::thread_mutex_unlock (m);
        -:  993:#  else
        -:  994:  ACE_OS_TRACE ("ACE_OS::recursive_mutex_unlock");
        -:  995:#    if !defined (ACE_NDEBUG)
        -:  996:  ACE_thread_t t_id = ACE_OS::thr_self ();
        -:  997:#    endif /* ACE_NDEBUG */
        -:  998:  int result = 0;
        -:  999:
        -: 1000:  if (ACE_OS::thread_mutex_lock (&m->nesting_mutex_) == -1)
        -: 1001:    result = -1;
        -: 1002:  else
        -: 1003:  {
        -: 1004:#    if !defined (ACE_NDEBUG)
        -: 1005:      if (m->nesting_level_ == 0
        -: 1006:          || ACE_OS::thr_equal (t_id, m->owner_id_) == 0)
        -: 1007:{
        -: 1008:  errno = EINVAL;
        -: 1009:  result = -1;
        -: 1010:}
        -: 1011:      else
        -: 1012:#    endif /* ACE_NDEBUG */
        -: 1013:{
        -: 1014:  m->nesting_level_--;
        -: 1015:  if (m->nesting_level_ == 0)
        -: 1016:  {
        -: 1017:              // This may not be strictly necessary, but it does put
        -: 1018:              // the mutex into a known state...
        -: 1019:    m->owner_id_ = ACE_OS::NULL_thread;
        -: 1020:
        -: 1021:              // Inform a waiter that the lock is free.
        -: 1022:    if (ACE_OS::cond_signal (&m->lock_available_) == -1)
        -: 1023:      result = -1;
        -: 1024:  }
        -: 1025:}
        -: 1026:  }
        -: 1027:
        -: 1028:{
        -: 1029:    // Save/restore errno.
        -: 1030:  ACE_Errno_Guard error (errno);
        -: 1031:  ACE_OS::thread_mutex_unlock (&m->nesting_mutex_);
        -: 1032:}
        -: 1033:  return result;
        -: 1034:#  endif /* ACE_HAS_RECURSIVE_MUTEXES */
        -: 1035:#else
        -: 1036:  ACE_UNUSED_ARG (m);
        -: 1037:  ACE_NOTSUP_RETURN (-1);
        -: 1038:#endif /* ACE_HAS_THREADS */
        -: 1039:}
        -: 1040:
        -: 1041:ACE_INLINE int
        -: 1042:ACE_OS::rw_rdlock (ACE_rwlock_t *rw)
        -: 1043:{
        -: 1044:  ACE_OS_TRACE ("ACE_OS::rw_rdlock");
        -: 1045:#if defined (ACE_HAS_THREADS)
        -: 1046:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1047:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1048:  int result;
        -: 1049:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_rdlock (rw),
        -: 1050:                                       result),
        -: 1051:                     int, -1);
        -: 1052:#  else /* Solaris */
        -: 1053:  int result;
        -: 1054:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_rdlock (rw), result), int, -1);
        -: 1055:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1056:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1057:#   if defined (ACE_HAS_PTHREADS)
        -: 1058:  ACE_PTHREAD_CLEANUP_PUSH (&rw->lock_);
        -: 1059:#   endif /* ACE_HAS_PTHREADS */
        -: 1060:  int result = 0;
        -: 1061:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1062:    result = -1; // -1 means didn't get the mutex.
        -: 1063:  else
        -: 1064:    {
        -: 1065:      // Give preference to writers who are waiting.
        -: 1066:      while (rw->ref_count_ < 0 || rw->num_waiting_writers_ > 0)
        -: 1067:        {
        -: 1068:          rw->num_waiting_readers_++;
        -: 1069:          if (ACE_OS::cond_wait (&rw->waiting_readers_, &rw->lock_) == -1)
        -: 1070:            {
        -: 1071:              result = -2; // -2 means that we need to release the mutex.
        -: 1072:              break;
        -: 1073:            }
        -: 1074:          rw->num_waiting_readers_--;
        -: 1075:        }
        -: 1076:    }
        -: 1077:  if (result == 0)
        -: 1078:    rw->ref_count_++;
        -: 1079:  if (result != -1)
        -: 1080:    ACE_OS::mutex_unlock (&rw->lock_);
        -: 1081:#   if defined (ACE_HAS_PTHREADS)
        -: 1082:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 1083:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1084:  return 0;
        -: 1085:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1086:#else
        -: 1087:  ACE_UNUSED_ARG (rw);
        -: 1088:  ACE_NOTSUP_RETURN (-1);
        -: 1089:#endif /* ACE_HAS_THREADS */
        -: 1090:}
        -: 1091:
        -: 1092:ACE_INLINE int
        -: 1093:ACE_OS::rw_tryrdlock (ACE_rwlock_t *rw)
        -: 1094:{
        -: 1095:  ACE_OS_TRACE ("ACE_OS::rw_tryrdlock");
        -: 1096:#if defined (ACE_HAS_THREADS)
        -: 1097:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1098:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1099:  int result;
        -: 1100:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_tryrdlock (rw),
        -: 1101:                                       result),
        -: 1102:                     int, -1);
        -: 1103:#  else /* Solaris */
        -: 1104:  int result;
        -: 1105:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_tryrdlock (rw), result), int, -1);
        -: 1106:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1107:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1108:  int result = -1;
        -: 1109:
        -: 1110:  if (ACE_OS::mutex_lock (&rw->lock_) != -1)
        -: 1111:    {
        -: 1112:      ACE_Errno_Guard error (errno);
        -: 1113:
        -: 1114:      if (rw->ref_count_ == -1 || rw->num_waiting_writers_ > 0)
        -: 1115:        {
        -: 1116:          error = EBUSY;
        -: 1117:          result = -1;
        -: 1118:        }
        -: 1119:      else
        -: 1120:        {
        -: 1121:          rw->ref_count_++;
        -: 1122:          result = 0;
        -: 1123:        }
        -: 1124:
        -: 1125:      ACE_OS::mutex_unlock (&rw->lock_);
        -: 1126:    }
        -: 1127:  return result;
        -: 1128:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1129:#else
        -: 1130:  ACE_UNUSED_ARG (rw);
        -: 1131:  ACE_NOTSUP_RETURN (-1);
        -: 1132:#endif /* ACE_HAS_THREADS */
        -: 1133:}
        -: 1134:
        -: 1135:ACE_INLINE int
        -: 1136:ACE_OS::rw_trywrlock (ACE_rwlock_t *rw)
        -: 1137:{
        -: 1138:  ACE_OS_TRACE ("ACE_OS::rw_trywrlock");
        -: 1139:#if defined (ACE_HAS_THREADS)
        -: 1140:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1141:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1142:  int result;
        -: 1143:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_trywrlock (rw),
        -: 1144:                                       result),
        -: 1145:                     int, -1);
        -: 1146:#  else /* Solaris */
        -: 1147:  int result;
        -: 1148:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_trywrlock (rw), result), int, -1);
        -: 1149:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1150:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1151:  int result = -1;
        -: 1152:
        -: 1153:  if (ACE_OS::mutex_lock (&rw->lock_) != -1)
        -: 1154:    {
        -: 1155:      ACE_Errno_Guard error (errno);
        -: 1156:
        -: 1157:      if (rw->ref_count_ != 0)
        -: 1158:        {
        -: 1159:          error = EBUSY;
        -: 1160:          result = -1;
        -: 1161:        }
        -: 1162:      else
        -: 1163:        {
        -: 1164:          rw->ref_count_ = -1;
        -: 1165:          result = 0;
        -: 1166:        }
        -: 1167:
        -: 1168:      ACE_OS::mutex_unlock (&rw->lock_);
        -: 1169:    }
        -: 1170:  return result;
        -: 1171:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1172:#else
        -: 1173:  ACE_UNUSED_ARG (rw);
        -: 1174:  ACE_NOTSUP_RETURN (-1);
        -: 1175:#endif /* ACE_HAS_THREADS */
        -: 1176:}
        -: 1177:
        -: 1178:// Note that the caller of this method *must* already possess this
        -: 1179:// lock as a read lock.
        -: 1180:// return {-1 and no errno set means: error,
        -: 1181://         -1 and errno==EBUSY set means: could not upgrade,
        -: 1182://         0 means: upgraded successfully}
        -: 1183:
        -: 1184:ACE_INLINE int
        -: 1185:ACE_OS::rw_trywrlock_upgrade (ACE_rwlock_t *rw)
        -: 1186:{
        -: 1187:  ACE_OS_TRACE ("ACE_OS::rw_trywrlock_upgrade");
        -: 1188:#if defined (ACE_HAS_THREADS)
        -: 1189:# if defined (ACE_HAS_PTHREADS_UNIX98_EXT) && !defined (ACE_LACKS_RWLOCK_T)
        -: 1190:  int result;
        -: 1191:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_trywrlock (rw),
        -: 1192:                                       result),
        -: 1193:                     int, -1);
        -: 1194:# elif !defined (ACE_LACKS_RWLOCK_T)
        -: 1195:  // Some native rwlocks, such as those on Solaris, don't
        -: 1196:  // support the upgrade feature . . .
        -: 1197:  ACE_UNUSED_ARG (rw);
        -: 1198:  ACE_NOTSUP_RETURN (-1);
        -: 1199:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1200:  // The ACE rwlock emulation does support upgrade . . .
        -: 1201:  int result = 0;
        -: 1202:
        -: 1203:#   if defined (ACE_HAS_PTHREADS)
        -: 1204:  ACE_PTHREAD_CLEANUP_PUSH (&rw->lock_);
        -: 1205:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1206:
        -: 1207:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1208:    return -1;
        -: 1209:    // -1 means didn't get the mutex, error
        -: 1210:  else if (rw->important_writer_)
        -: 1211:    // an other reader upgrades already
        -: 1212:    {
        -: 1213:      result = -1;
        -: 1214:      errno = EBUSY;
        -: 1215:    }
        -: 1216:  else
        -: 1217:    {
        -: 1218:      while (rw->ref_count_ > 1) // wait until only I am left
        -: 1219:        {
        -: 1220:          rw->num_waiting_writers_++; // prohibit any more readers
        -: 1221:          rw->important_writer_ = true;
        -: 1222:
        -: 1223:          if (ACE_OS::cond_wait (&rw->waiting_important_writer_, &rw->lock_) == -1)
        -: 1224:            {
        -: 1225:              result = -1;
        -: 1226:              // we know that we have the lock again, we have this guarantee,
        -: 1227:              // but something went wrong
        -: 1228:            }
        -: 1229:          rw->important_writer_ = false;
        -: 1230:          rw->num_waiting_writers_--;
        -: 1231:        }
        -: 1232:      if (result == 0)
        -: 1233:        {
        -: 1234:          // nothing bad happend
        -: 1235:          rw->ref_count_ = -1;
        -: 1236:          // now I am a writer
        -: 1237:          // everything is O.K.
        -: 1238:        }
        -: 1239:    }
        -: 1240:
        -: 1241:  ACE_OS::mutex_unlock (&rw->lock_);
        -: 1242:
        -: 1243:#   if defined (ACE_HAS_PTHREADS)
        -: 1244:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 1245:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1246:
        -: 1247:  return result;
        -: 1248:
        -: 1249:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1250:#else
        -: 1251:  ACE_UNUSED_ARG (rw);
        -: 1252:  ACE_NOTSUP_RETURN (-1);
        -: 1253:#endif /* ACE_HAS_THREADS */
        -: 1254:}
        -: 1255:
        -: 1256:ACE_INLINE int
        -: 1257:ACE_OS::rw_unlock (ACE_rwlock_t *rw)
        -: 1258:{
        -: 1259:  ACE_OS_TRACE ("ACE_OS::rw_unlock");
        -: 1260:#if defined (ACE_HAS_THREADS)
        -: 1261:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1262:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1263:  int result;
        -: 1264:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_unlock (rw),
        -: 1265:                                       result),
        -: 1266:                     int, -1);
        -: 1267:#  else /* Solaris */
        -: 1268:  int result;
        -: 1269:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_unlock (rw), result), int, -1);
        -: 1270:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1271:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1272:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1273:    return -1;
        -: 1274:
        -: 1275:  if (rw->ref_count_ > 0) // Releasing a reader.
        -: 1276:    rw->ref_count_--;
        -: 1277:  else if (rw->ref_count_ == -1) // Releasing a writer.
        -: 1278:    rw->ref_count_ = 0;
        -: 1279:  else
        -: 1280:    {
        -: 1281:      (void) ACE_OS::mutex_unlock (&rw->lock_);
        -: 1282:      return -1; // @@ ACE_ASSERT (!"count should not be 0!\n");
        -: 1283:    }
        -: 1284:
        -: 1285:  int result = 0;
        -: 1286:  ACE_Errno_Guard error (errno);
        -: 1287:
        -: 1288:  if (rw->important_writer_ && rw->ref_count_ == 1)
        -: 1289:    // only the reader requesting to upgrade its lock is left over.
        -: 1290:    {
        -: 1291:      result = ACE_OS::cond_signal (&rw->waiting_important_writer_);
        -: 1292:      error = errno;
        -: 1293:    }
        -: 1294:  else if (rw->num_waiting_writers_ > 0 && rw->ref_count_ == 0)
        -: 1295:    // give preference to writers over readers...
        -: 1296:    {
        -: 1297:      result = ACE_OS::cond_signal (&rw->waiting_writers_);
        -: 1298:      error =  errno;
        -: 1299:    }
        -: 1300:  else if (rw->num_waiting_readers_ > 0 && rw->num_waiting_writers_ == 0)
        -: 1301:    {
        -: 1302:      result = ACE_OS::cond_broadcast (&rw->waiting_readers_);
        -: 1303:      error = errno;
        -: 1304:    }
        -: 1305:
        -: 1306:  (void) ACE_OS::mutex_unlock (&rw->lock_);
        -: 1307:  return result;
        -: 1308:# endif /* ! ace_lacks_rwlock_t */
        -: 1309:#else
        -: 1310:  ACE_UNUSED_ARG (rw);
        -: 1311:  ACE_NOTSUP_RETURN (-1);
        -: 1312:#endif /* ace_has_threads */
        -: 1313:}
        -: 1314:
        -: 1315:ACE_INLINE int
        -: 1316:ACE_OS::rw_wrlock (ACE_rwlock_t *rw)
        -: 1317:{
        -: 1318:  ACE_OS_TRACE ("ACE_OS::rw_wrlock");
        -: 1319:#if defined (ACE_HAS_THREADS)
        -: 1320:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1321:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1322:  int result;
        -: 1323:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_wrlock (rw),
        -: 1324:                                       result),
        -: 1325:                     int, -1);
        -: 1326:#  else /* Solaris */
        -: 1327:  int result;
        -: 1328:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rw_wrlock (rw), result), int, -1);
        -: 1329:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1330:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1331:#   if defined (ACE_HAS_PTHREADS)
        -: 1332:  ACE_PTHREAD_CLEANUP_PUSH (&rw->lock_);
        -: 1333:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1334:  int result = 0;
        -: 1335:
        -: 1336:  if (ACE_OS::mutex_lock (&rw->lock_) == -1)
        -: 1337:    result = -1; // -1 means didn't get the mutex.
        -: 1338:  else
        -: 1339:    {
        -: 1340:      while (rw->ref_count_ != 0)
        -: 1341:        {
        -: 1342:          rw->num_waiting_writers_++;
        -: 1343:
        -: 1344:          if (ACE_OS::cond_wait (&rw->waiting_writers_, &rw->lock_) == -1)
        -: 1345:            {
        -: 1346:              result = -2; // -2 means we need to release the mutex.
        -: 1347:              break;
        -: 1348:            }
        -: 1349:
        -: 1350:          rw->num_waiting_writers_--;
        -: 1351:        }
        -: 1352:    }
        -: 1353:  if (result == 0)
        -: 1354:    rw->ref_count_ = -1;
        -: 1355:  if (result != -1)
        -: 1356:    ACE_OS::mutex_unlock (&rw->lock_);
        -: 1357:#   if defined (ACE_HAS_PTHREADS)
        -: 1358:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 1359:#   endif /* defined (ACE_HAS_PTHREADS) */
        -: 1360:  return 0;
        -: 1361:# endif /* ! ACE_LACKS_RWLOCK_T */
        -: 1362:#else
        -: 1363:  ACE_UNUSED_ARG (rw);
        -: 1364:  ACE_NOTSUP_RETURN (-1);
        -: 1365:#endif /* ACE_HAS_THREADS */
        -: 1366:}
        -: 1367:
        -: 1368:ACE_INLINE int
        -: 1369:ACE_OS::rwlock_destroy (ACE_rwlock_t *rw)
        -: 1370:{
        -: 1371:  ACE_OS_TRACE ("ACE_OS::rwlock_destroy");
        -: 1372:#if defined (ACE_HAS_THREADS)
        -: 1373:# if !defined (ACE_LACKS_RWLOCK_T)
        -: 1374:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1375:  int result;
        -: 1376:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_rwlock_destroy (rw),
        -: 1377:                                       result),
        -: 1378:                     int, -1);
        -: 1379:#  else /* Solaris */
        -: 1380:  int result;
        -: 1381:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rwlock_destroy (rw), result), int, -1);
        -: 1382:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1383:# else /* NT, POSIX, and VxWorks don't support this natively. */
        -: 1384:  ACE_OS::mutex_destroy (&rw->lock_);
        -: 1385:  ACE_OS::cond_destroy (&rw->waiting_readers_);
        -: 1386:  ACE_OS::cond_destroy (&rw->waiting_important_writer_);
        -: 1387:  return ACE_OS::cond_destroy (&rw->waiting_writers_);
        -: 1388:# endif /* ACE_HAS_STHREADS && !defined (ACE_LACKS_RWLOCK_T) */
        -: 1389:#else
        -: 1390:  ACE_UNUSED_ARG (rw);
        -: 1391:  ACE_NOTSUP_RETURN (-1);
        -: 1392:#endif /* ACE_HAS_THREADS */
        -: 1393:}
        -: 1394:
        -: 1395:#if defined (ACE_HAS_THREADS) && !defined (ACE_LACKS_RWLOCK_T)
        -: 1396:ACE_INLINE int
        -: 1397:ACE_OS::rwlock_init (ACE_rwlock_t *rw,
        -: 1398:                     int type,
        -: 1399:                     const ACE_TCHAR *name,
        -: 1400:                     void *arg)
        -: 1401:{
        -: 1402:  // ACE_OS_TRACE ("ACE_OS::rwlock_init");
        -: 1403:#  if defined (ACE_HAS_PTHREADS_UNIX98_EXT)
        -: 1404:  ACE_UNUSED_ARG (name);
        -: 1405:  ACE_UNUSED_ARG (arg);
        -: 1406:
        -: 1407:  int status;
        -: 1408:  pthread_rwlockattr_t attr;
        -: 1409:  pthread_rwlockattr_init (&attr);
        -: 1410:#    if !defined (ACE_LACKS_RWLOCKATTR_PSHARED)
        -: 1411:  pthread_rwlockattr_setpshared (&attr, (type == USYNC_THREAD ?
        -: 1412:                                         PTHREAD_PROCESS_PRIVATE :
        -: 1413:                                         PTHREAD_PROCESS_SHARED));
        -: 1414:#    else
        -: 1415:  ACE_UNUSED_ARG (type);
        -: 1416:#    endif /* !ACE_LACKS_RWLOCKATTR_PSHARED */
        -: 1417:  status = ACE_ADAPT_RETVAL (pthread_rwlock_init (rw, &attr), status);
        -: 1418:  pthread_rwlockattr_destroy (&attr);
        -: 1419:
        -: 1420:  return status;
        -: 1421:
        -: 1422:#  else
        -: 1423:  type = type;
        -: 1424:  name = name;
        -: 1425:  int result;
        -: 1426:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::rwlock_init (rw, type, arg), result), int, -1);
        -: 1427:#  endif /* ACE_HAS_PTHREADS_UNIX98_EXT */
        -: 1428:}
        -: 1429:#endif /* ACE_HAS_THREADS && !defined (ACE_LACKS_RWLOCK_T) */
        -: 1430:
        -: 1431:ACE_INLINE int
        -: 1432:ACE_OS::sema_destroy (ACE_sema_t *s)
        -: 1433:{
        -: 1434:  ACE_OS_TRACE ("ACE_OS::sema_destroy");
        -: 1435:#if defined (ACE_HAS_POSIX_SEM)
        -: 1436:  int result = 0;
        -: 1437:# if !defined (ACE_HAS_POSIX_SEM_TIMEOUT) && !defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 1438:  ACE_OS::mutex_destroy (&s->lock_);
        -: 1439:  ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1440:# endif /* !ACE_HAS_POSIX_SEM_TIMEOUT && !ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION */
        -: 1441:# if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1442:  if (s->name_)
        -: 1443:    {
        -: 1444:      // Only destroy the semaphore if we're the ones who
        -: 1445:      // initialized it.
        -: 1446:#  if !defined (ACE_LACKS_SEM_DESTROY)
        -: 1447:      ACE_OSCALL (::sem_destroy (s->sema_),int, -1, result);
        -: 1448:#  endif /* ACE_LACKS_SEM_DESTROY */
        -: 1449:      ACE_OS::shm_unlink (s->name_);
        -: 1450:      delete s->name_;
        -: 1451:      return result;
        -: 1452:    }
        -: 1453:# else
        -: 1454:  if (s->name_)
        -: 1455:    {
        -: 1456:      if (!s->avoid_unlink_)
        -: 1457:        ACE_OS::sema_unlink (s->name_);
        -: 1458:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1459:      ACE_Allocator::instance()->free ((void *) s->name_);
        -: 1460:#else
        -: 1461:      ACE_OS::free ((void *) s->name_);
        -: 1462:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1463:      ACE_OSCALL_RETURN (::sem_close (s->sema_), int, -1);
        -: 1464:    }
        -: 1465:# endif /*  ACE_LACKS_NAMED_POSIX_SEM */
        -: 1466:  else
        -: 1467:    {
        -: 1468:# if !defined (ACE_LACKS_UNNAMED_SEMAPHORE) && !defined (ACE_LACKS_SEM_DESTROY)
        -: 1469:      ACE_OSCALL (::sem_destroy (s->sema_), int, -1, result);
        -: 1470:# endif /* !ACE_LACKS_UNNAMED_SEMAPHORE  && !ACE_LACKS_SEM_DESTROY */
        -: 1471:# if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1472:      if (s->new_sema_)
        -: 1473:# endif /* ACE_LACKS_NAMED_POSIX_SEM */
        -: 1474:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1475:        ACE_Allocator::instance()->free(s->sema_);
        -: 1476:#else
        -: 1477:        delete s->sema_;
        -: 1478:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1479:      s->sema_ = 0;
        -: 1480:      return result;
        -: 1481:    }
        -: 1482:#elif defined (ACE_USES_FIFO_SEM)
        -: 1483:  int r0 = 0;
        -: 1484:  if (s->name_)
        -: 1485:    {
        -: 1486:      r0 = ACE_OS::unlink (s->name_);
        -: 1487:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1488:      ACE_Allocator::instance()->free ((void *) s->name_);
        -: 1489:#else
        -: 1490:      ACE_OS::free ((void *) s->name_);
        -: 1491:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1492:      s->name_ = 0;
        -: 1493:    }
        -: 1494:  int r1 = ACE_OS::close (s->fd_[0]);      /* ignore error */
        -: 1495:  int r2 = ACE_OS::close (s->fd_[1]);      /* ignore error */
        -: 1496:  return r0 != 0 || r1 != 0 || r2 != 0 ? -1 : 0;
        -: 1497:#elif defined (ACE_HAS_THREADS)
        -: 1498:#  if defined (ACE_HAS_STHREADS)
        -: 1499:  int result;
        -: 1500:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_destroy (s), result), int, -1);
        -: 1501:#  elif defined (ACE_HAS_PTHREADS)
        -: 1502:  int r1 = ACE_OS::mutex_destroy (&s->lock_);
        -: 1503:  int r2 = ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1504:  return r1 != 0 || r2 != 0 ? -1 : 0;
        -: 1505:#  elif defined (ACE_HAS_WTHREADS)
        -: 1506:#    if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 1507:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::CloseHandle (*s), ace_result_), int, -1);
        -: 1508:#    else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1509:  // Free up underlying objects of the simulated semaphore.
        -: 1510:  int const r1 = ACE_OS::thread_mutex_destroy (&s->lock_);
        -: 1511:  int const r2 = ACE_OS::event_destroy (&s->count_nonzero_);
        -: 1512:  return r1 != 0 || r2 != 0 ? -1 : 0;
        -: 1513:#    endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1514:#  elif defined (ACE_VXWORKS)
        -: 1515:  int result;
        -: 1516:  ACE_OSCALL (::semDelete (s->sema_), int, -1, result);
        -: 1517:  s->sema_ = 0;
        -: 1518:  return result;
        -: 1519:#  endif /* ACE_HAS_STHREADS */
        -: 1520:#else
        -: 1521:  ACE_UNUSED_ARG (s);
        -: 1522:  ACE_NOTSUP_RETURN (-1);
        -: 1523:#endif /* ACE_HAS_POSIX_SEM */
        -: 1524:}
        -: 1525:
        -: 1526:// NOTE: The previous four function definitions must appear before
        -: 1527:// ACE_OS::sema_init ().
        -: 1528:
        -: 1529:ACE_INLINE int
        -: 1530:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1531:                   u_int count,
        -: 1532:                   int type,
        -: 1533:                   const char *name,
        -: 1534:                   void *arg,
        -: 1535:                   int max,
        -: 1536:                   LPSECURITY_ATTRIBUTES sa)
        -: 1537:{
        -: 1538:  ACE_condattr_t *pattr = 0;
        -: 1539:  return ACE_OS::sema_init (s, count, type, pattr, name, arg, max, sa);
        -: 1540:}
        -: 1541:
        -: 1542:ACE_INLINE int
        -: 1543:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1544:                   u_int count,
        -: 1545:                   int type,
        -: 1546:                   ACE_condattr_t *attributes,
        -: 1547:                   const char *name,
        -: 1548:                   void *arg,
        -: 1549:                   int max,
        -: 1550:                   LPSECURITY_ATTRIBUTES sa)
        -: 1551:{
        -: 1552:  ACE_OS_TRACE ("ACE_OS::sema_init");
        -: 1553:#if defined (ACE_HAS_POSIX_SEM)
        -: 1554:  ACE_UNUSED_ARG (max);
        -: 1555:  ACE_UNUSED_ARG (sa);
        -: 1556:
        -: 1557:  s->name_ = 0;
        -: 1558:  s->avoid_unlink_ = false;
        -: 1559:#  if defined (ACE_HAS_POSIX_SEM_TIMEOUT) || defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 1560:  ACE_UNUSED_ARG (arg);
        -: 1561:  ACE_UNUSED_ARG (attributes);
        -: 1562:#  else
        -: 1563:  int result = -1;
        -: 1564:
        -: 1565:  if (ACE_OS::mutex_init (&s->lock_, type, name,
        -: 1566:                          (ACE_mutexattr_t *) arg) == 0
        -: 1567:      && (attributes == 0 ?
        -: 1568:            ACE_OS::cond_init (&s->count_nonzero_, type, name, arg) :
        -: 1569:            ACE_OS::cond_init (&s->count_nonzero_, *attributes, name, arg)) == 0
        -: 1570:      && ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 1571:    {
        -: 1572:      if (ACE_OS::mutex_unlock (&s->lock_) == 0)
        -: 1573:        result = 0;
        -: 1574:    }
        -: 1575:
        -: 1576:  if (result == -1)
        -: 1577:    {
        -: 1578:      ACE_OS::mutex_destroy (&s->lock_);
        -: 1579:      ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1580:      return result;
        -: 1581:    }
        -: 1582:#  endif /* ACE_HAS_POSIX_SEM_TIMEOUT || ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION */
        -: 1583:
        -: 1584:#  if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1585:  s->new_sema_ = false;
        -: 1586:  if (type == USYNC_PROCESS)
        -: 1587:    {
        -: 1588:      // Let's see if it already exists.
        -: 1589:      ACE_HANDLE fd = ACE_OS::shm_open (ACE_TEXT_CHAR_TO_TCHAR (name),
        -: 1590:                                        O_RDWR | O_CREAT | O_EXCL,
        -: 1591:                                        ACE_DEFAULT_FILE_PERMS);
        -: 1592:      if (fd == ACE_INVALID_HANDLE)
        -: 1593:        {
        -: 1594:          if (errno == EEXIST)
        -: 1595:            fd = ACE_OS::shm_open (ACE_TEXT_CHAR_TO_TCHAR (name),
        -: 1596:                                   O_RDWR | O_CREAT,
        -: 1597:                                   ACE_DEFAULT_FILE_PERMS);
        -: 1598:          else
        -: 1599:            return -1;
        -: 1600:        }
        -: 1601:      else
        -: 1602:        {
        -: 1603:          // We own this shared memory object!  Let's set its
        -: 1604:          // size.
        -: 1605:          if (ACE_OS::ftruncate (fd,
        -: 1606:                                 sizeof (ACE_sema_t)) == -1)
        -: 1607:            return -1;
        -: 1608:          s->name_ = ACE_OS::strdup (name);
        -: 1609:          if (s->name_ == 0)
        -: 1610:            return -1;
        -: 1611:        }
        -: 1612:      if (fd == -1)
        -: 1613:        return -1;
        -: 1614:
        -: 1615:      s->sema_ = (sem_t *)
        -: 1616:        ACE_OS::mmap (0,
        -: 1617:                      sizeof (ACE_sema_t),
        -: 1618:                      PROT_RDWR,
        -: 1619:                      MAP_SHARED,
        -: 1620:                      fd,
        -: 1621:                      0);
        -: 1622:      ACE_OS::close (fd);
        -: 1623:      if (s->sema_ == (sem_t *) MAP_FAILED)
        -: 1624:        return -1;
        -: 1625:      if (s->name_
        -: 1626:          // @@ According UNIX Network Programming V2 by Stevens,
        -: 1627:          //    sem_init() is currently not required to return zero on
        -: 1628:          //    success, but it *does* return -1 upon failure.  For
        -: 1629:          //    this reason, check for failure by comparing to -1,
        -: 1630:          //    instead of checking for success by comparing to zero.
        -: 1631:          //        -Ossama
        -: 1632:          // Only initialize it if we're the one who created it.
        -: 1633:          && ::sem_init (s->sema_, type == USYNC_PROCESS, count) == -1)
        -: 1634:        return -1;
        -: 1635:      return 0;
        -: 1636:    }
        -: 1637:#  else
        -: 1638:  if (name)
        -: 1639:    {
        -: 1640:#    if defined (sun) || defined (HPUX)
        -: 1641:      // Solaris and HP-UX require the name to start with a slash. Solaris
        -: 1642:      // further requires that there be no other slashes than the first.
        -: 1643:      const char *last_slash = ACE_OS::strrchr (name, '/');
        -: 1644:      char name2[MAXPATHLEN];
        -: 1645:      if (0 == last_slash)
        -: 1646:        {
        -: 1647:          ACE_OS::strcpy (name2, "/");
        -: 1648:          ACE_OS::strcat (name2, name);
        -: 1649:          name = name2;
        -: 1650:        }
        -: 1651:#      if defined (sun)
        -: 1652:      else
        -: 1653:        name = last_slash;         // Chop off chars preceding last slash
        -: 1654:#      endif /* sun */
        -: 1655:#    endif /* sun || HPUX */
        -: 1656:
        -: 1657:      ACE_ALLOCATOR_RETURN (s->name_,
        -: 1658:                            ACE_OS::strdup (name),
        -: 1659:                            -1);
        -: 1660:      s->sema_ = ::sem_open (s->name_,
        -: 1661:                             O_CREAT,
        -: 1662:                             ACE_DEFAULT_FILE_PERMS,
        -: 1663:                             count);
        -: 1664:      if (s->sema_ == (sem_t *) SEM_FAILED)
        -: 1665:        return -1;
        -: 1666:      else
        -: 1667:        return 0;
        -: 1668:    }
        -: 1669:#  endif /* ACE_LACKS_NAMED_POSIX_SEM */
        -: 1670:  else
        -: 1671:    {
        -: 1672:#  if defined (ACE_LACKS_UNNAMED_SEMAPHORE)
        -: 1673:      ACE_NOTSUP_RETURN (-1);
        -: 1674:#  else
        -: 1675:#if defined (ACE_HAS_ALLOC_HOOKS)
        -: 1676:      ACE_ALLOCATOR_RETURN (s->sema_,
        -: 1677:                            static_cast<sem_t*>(ACE_Allocator::instance()->malloc(sizeof(sem_t))),
        -: 1678:                            -1);
        -: 1679:#else
        -: 1680:      ACE_NEW_RETURN (s->sema_,
        -: 1681:                      sem_t,
        -: 1682:                      -1);
        -: 1683:#endif /* ACE_HAS_ALLOC_HOOKS */
        -: 1684:
        -: 1685:#   if defined (ACE_LACKS_NAMED_POSIX_SEM)
        -: 1686:      s->new_sema_ = true;
        -: 1687:#   endif /* ACE_LACKS_NAMED_POSIX_SEM */
        -: 1688:      ACE_OSCALL_RETURN (::sem_init (s->sema_,
        -: 1689:                                     type != USYNC_THREAD,
        -: 1690:                                     count), int, -1);
        -: 1691:#  endif /* ACE_LACKS_UNNAMED_SEMAPHORE */
        -: 1692:    }
        -: 1693:
        -: 1694:#elif defined (ACE_USES_FIFO_SEM)
        -: 1695:  ACE_UNUSED_ARG (arg);
        -: 1696:  ACE_UNUSED_ARG (max);
        -: 1697:  ACE_UNUSED_ARG (sa);
        -: 1698:  int             flags = 0;
        -: 1699:  mode_t          mode = S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP;
        -: 1700:
        -: 1701:  if (type == USYNC_THREAD)
        -: 1702:    {
        -: 1703:      // Create systemwide unique name for semaphore
        -: 1704:      char   uname[ACE_UNIQUE_NAME_LEN];
        -: 1705:      ACE_OS::unique_name ((const void *) s,
        -: 1706:                            uname,
        -: 1707:                            ACE_UNIQUE_NAME_LEN);
        -: 1708:      name = &uname[0];
        -: 1709:    }
        -: 1710:
        -: 1711:  s->name_ = 0;
        -: 1712:  s->fd_[0] = s->fd_[1] = ACE_INVALID_HANDLE;
        -: 1713:  bool creator = false;
        -: 1714:
        -: 1715:  if (ACE_OS::mkfifo (ACE_TEXT_CHAR_TO_TCHAR (name), mode) < 0)
        -: 1716:    {
        -: 1717:      if (errno != EEXIST)    /* already exists OK else ERR */
        -: 1718:        return -1;
        -: 1719:      // check if this is a real FIFO, not just some other existing file
        -: 1720:      ACE_stat fs;
        -: 1721:      if (ACE_OS::stat (name, &fs))
        -: 1722:        return -1;
        -: 1723:      if (!S_ISFIFO (fs.st_mode))
        -: 1724:        {
        -: 1725:          // existing file is not a FIFO
        -: 1726:          errno = EEXIST;
        -: 1727:          return -1;
        -: 1728:        }
        -: 1729:    }
        -: 1730:    else
        -: 1731:      creator = true; // remember we created it for initialization at end
        -: 1732:
        -: 1733:  // for processshared semaphores remember who we are to be able to remove
        -: 1734:  // the FIFO when we're done with it
        -: 1735:  if (type == USYNC_PROCESS)
        -: 1736:    {
        -: 1737:      s->name_ = ACE_OS::strdup (name);
        -: 1738:      if (s->name_ == 0)
        -: 1739:        {
        -: 1740:          if (creator)
        -: 1741:            ACE_OS::unlink (name);
        -: 1742:          return -1;
        -: 1743:        }
        -: 1744:    }
        -: 1745:
        -: 1746:  if ((s->fd_[0] = ACE_OS::open (name, O_RDONLY | O_NONBLOCK)) == ACE_INVALID_HANDLE
        -: 1747:      || (s->fd_[1] = ACE_OS::open (name, O_WRONLY | O_NONBLOCK)) == ACE_INVALID_HANDLE)
        -: 1748:    return -1;
        -: 1749:
        -: 1750:  /* turn off nonblocking for fd_[0] */
        -: 1751:  if ((flags = ACE_OS::fcntl (s->fd_[0], F_GETFL, 0)) < 0)
        -: 1752:    return -1;
        -: 1753:
        -: 1754:  flags &= ~O_NONBLOCK;
        -: 1755:  if (ACE_OS::fcntl (s->fd_[0], F_SETFL, flags) < 0)
        -: 1756:    return -1;
        -: 1757:
        -: 1758:  //if (s->name_ && count)
        -: 1759:  if (creator && count)
        -: 1760:    {
        -: 1761:      char    c = 1;
        -: 1762:      for (u_int i=0; i<count ;++i)
        -: 1763:        if (ACE_OS::write (s->fd_[1], &c, sizeof (char)) != 1)
        -: 1764:          return -1;
        -: 1765:    }
        -: 1766:
        -: 1767:  // In the case of process scope semaphores we can already unlink the FIFO now that
        -: 1768:  // we completely set it up (the opened handles will keep it active until we close
        -: 1769:  // thos down). This way we're protected against unexpected crashes as far as removal
        -: 1770:  // is concerned.
        -: 1771:  // Unfortunately this does not work for processshared FIFOs since as soon as we
        -: 1772:  // have unlinked the semaphore no other process will be able to open it anymore.
        -: 1773:  if (type == USYNC_THREAD)
        -: 1774:    {
        -: 1775:      ACE_OS::unlink (name);
        -: 1776:    }
        -: 1777:
        -: 1778:  return 0;
        -: 1779:#elif defined (ACE_HAS_THREADS)
        -: 1780:#  if defined (ACE_HAS_STHREADS)
        -: 1781:  ACE_UNUSED_ARG (name);
        -: 1782:  ACE_UNUSED_ARG (max);
        -: 1783:  ACE_UNUSED_ARG (sa);
        -: 1784:  ACE_UNUSED_ARG (attributes);
        -: 1785:  int result;
        -: 1786:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_init (s, count, type, arg), result),
        -: 1787:                     int, -1);
        -: 1788:#  elif defined (ACE_HAS_PTHREADS)
        -: 1789:  ACE_UNUSED_ARG (max);
        -: 1790:  ACE_UNUSED_ARG (sa);
        -: 1791:  int result = -1;
        -: 1792:
        -: 1793:  if (ACE_OS::mutex_init (&s->lock_, type, name,
        -: 1794:                          (ACE_mutexattr_t *) arg) == 0
        -: 1795:      && (attributes == 0 ?
        -: 1796:            ACE_OS::cond_init (&s->count_nonzero_, type, name, arg) :
        -: 1797:            ACE_OS::cond_init (&s->count_nonzero_, *attributes, name, arg)) == 0
        -: 1798:      && ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 1799:    {
        -: 1800:      s->count_ = count;
        -: 1801:      s->waiters_ = 0;
        -: 1802:
        -: 1803:      if (ACE_OS::mutex_unlock (&s->lock_) == 0)
        -: 1804:        result = 0;
        -: 1805:    }
        -: 1806:
        -: 1807:  if (result == -1)
        -: 1808:    {
        -: 1809:      ACE_OS::mutex_destroy (&s->lock_);
        -: 1810:      ACE_OS::cond_destroy (&s->count_nonzero_);
        -: 1811:    }
        -: 1812:  return result;
        -: 1813:#  elif defined (ACE_HAS_WTHREADS)
        -: 1814:  ACE_UNUSED_ARG (attributes);
        -: 1815:#    if ! defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 1816:  ACE_UNUSED_ARG (type);
        -: 1817:  ACE_UNUSED_ARG (arg);
        -: 1818:  // Create the semaphore with its value initialized to <count> and
        -: 1819:  // its maximum value initialized to <max>.
        -: 1820:  SECURITY_ATTRIBUTES sa_buffer;
        -: 1821:  SECURITY_DESCRIPTOR sd_buffer;
        -: 1822:  *s = ACE_TEXT_CreateSemaphore
        -: 1823:    (ACE_OS::default_win32_security_attributes_r (sa, &sa_buffer, &sd_buffer),
        -: 1824:     count,
        -: 1825:     max,
        -: 1826:     ACE_TEXT_CHAR_TO_TCHAR (name));
        -: 1827:
        -: 1828:  if (*s == 0)
        -: 1829:    ACE_FAIL_RETURN (-1);
        -: 1830:  /* NOTREACHED */
        -: 1831:  else
        -: 1832:    {
        -: 1833:      // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -: 1834:      ACE_OS::set_errno_to_last_error ();
        -: 1835:      return 0;
        -: 1836:    }
        -: 1837:#    else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1838:  int result = -1;
        -: 1839:
        -: 1840:  // Initialize internal object for semaphore simulation.
        -: 1841:  // Grab the lock as soon as possible when we initializing
        -: 1842:  // the semaphore count.  Notice that we initialize the
        -: 1843:  // event object as "manually reset" so we can amortize the
        -: 1844:  // cost for singling/reseting the event.
        -: 1845:  // @@ I changed the mutex type to thread_mutex.  Notice that this
        -: 1846:  // is basically a CriticalSection object and doesn't not has
        -: 1847:  // any security attribute whatsoever.  However, since this
        -: 1848:  // semaphore implementation only works within a process, there
        -: 1849:  // shouldn't any security issue at all.
        -: 1850:  if (ACE_OS::thread_mutex_init (&s->lock_, type, name, (ACE_mutexattr_t *)arg) == 0
        -: 1851:      && ACE_OS::event_init (&s->count_nonzero_, 1,
        -: 1852:                             count > 0, type, name, arg, sa) == 0
        -: 1853:      && ACE_OS::thread_mutex_lock (&s->lock_) == 0)
        -: 1854:    {
        -: 1855:      s->count_ = count;
        -: 1856:
        -: 1857:      if (ACE_OS::thread_mutex_unlock (&s->lock_) == 0)
        -: 1858:        result = 0;
        -: 1859:    }
        -: 1860:
        -: 1861:  // Destroy the internal objects if we didn't initialize
        -: 1862:  // either of them successfully.  Don't bother to check
        -: 1863:  // for errors.
        -: 1864:  if (result == -1)
        -: 1865:    {
        -: 1866:      ACE_OS::thread_mutex_destroy (&s->lock_);
        -: 1867:      ACE_OS::event_destroy (&s->count_nonzero_);
        -: 1868:    }
        -: 1869:  return result;
        -: 1870:#    endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1871:#  elif defined (ACE_VXWORKS)
        -: 1872:  ACE_UNUSED_ARG (name);
        -: 1873:  ACE_UNUSED_ARG (arg);
        -: 1874:  ACE_UNUSED_ARG (max);
        -: 1875:  ACE_UNUSED_ARG (sa);
        -: 1876:  s->name_ = 0;
        -: 1877:  s->sema_ = ::semCCreate (type, count);
        -: 1878:  return s->sema_ ? 0 : -1;
        -: 1879:#  endif /* ACE_HAS_STHREADS */
        -: 1880:#else
        -: 1881:  ACE_UNUSED_ARG (s);
        -: 1882:  ACE_UNUSED_ARG (count);
        -: 1883:  ACE_UNUSED_ARG (type);
        -: 1884:  ACE_UNUSED_ARG (attributes);
        -: 1885:  ACE_UNUSED_ARG (name);
        -: 1886:  ACE_UNUSED_ARG (arg);
        -: 1887:  ACE_UNUSED_ARG (max);
        -: 1888:  ACE_UNUSED_ARG (sa);
        -: 1889:  ACE_NOTSUP_RETURN (-1);
        -: 1890:#endif /* ACE_HAS_POSIX_SEM */
        -: 1891:}
        -: 1892:
        -: 1893:#if defined (ACE_HAS_WCHAR)
        -: 1894:ACE_INLINE int
        -: 1895:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1896:                   u_int count,
        -: 1897:                   int type,
        -: 1898:                   const wchar_t *name,
        -: 1899:                   void *arg,
        -: 1900:                   int max,
        -: 1901:                   LPSECURITY_ATTRIBUTES sa)
        -: 1902:{
        -: 1903:  ACE_condattr_t *pattr = 0;
        -: 1904:  return ACE_OS::sema_init (s, count, type, pattr, name, arg, max, sa);
        -: 1905:}
        -: 1906:
        -: 1907:ACE_INLINE int
        -: 1908:ACE_OS::sema_init (ACE_sema_t *s,
        -: 1909:                   u_int count,
        -: 1910:                   int type,
        -: 1911:                   ACE_condattr_t *attributes,
        -: 1912:                   const wchar_t *name,
        -: 1913:                   void *arg,
        -: 1914:                   int max,
        -: 1915:                   LPSECURITY_ATTRIBUTES sa)
        -: 1916:{
        -: 1917:# if defined (ACE_HAS_WTHREADS)
        -: 1918:  ACE_UNUSED_ARG (attributes);
        -: 1919:#   if ! defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 1920:  ACE_UNUSED_ARG (type);
        -: 1921:  ACE_UNUSED_ARG (arg);
        -: 1922:  // Create the semaphore with its value initialized to <count> and
        -: 1923:  // its maximum value initialized to <max>.
        -: 1924:  SECURITY_ATTRIBUTES sa_buffer;
        -: 1925:  SECURITY_DESCRIPTOR sd_buffer;
        -: 1926:  *s = ::CreateSemaphoreW
        -: 1927:    (ACE_OS::default_win32_security_attributes_r (sa, &sa_buffer, &sd_buffer),
        -: 1928:     count,
        -: 1929:     max,
        -: 1930:     name);
        -: 1931:
        -: 1932:  if (*s == 0)
        -: 1933:    ACE_FAIL_RETURN (-1);
        -: 1934:  /* NOTREACHED */
        -: 1935:  else
        -: 1936:    {
        -: 1937:      // Make sure to set errno to ERROR_ALREADY_EXISTS if necessary.
        -: 1938:      ACE_OS::set_errno_to_last_error ();
        -: 1939:      return 0;
        -: 1940:    }
        -: 1941:#   else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1942:  int result = -1;
        -: 1943:
        -: 1944:  // Initialize internal object for semaphore simulation.
        -: 1945:  // Grab the lock as soon as possible when we initializing
        -: 1946:  // the semaphore count.  Notice that we initialize the
        -: 1947:  // event object as "manually reset" so we can amortize the
        -: 1948:  // cost for singling/reseting the event.
        -: 1949:  // @@ I changed the mutex type to thread_mutex.  Notice that this
        -: 1950:  // is basically a CriticalSection object and doesn't not has
        -: 1951:  // any security attribute whatsoever.  However, since this
        -: 1952:  // semaphore implementation only works within a process, there
        -: 1953:  // shouldn't any security issue at all.
        -: 1954:  if (ACE_OS::thread_mutex_init (&s->lock_, type, name, (ACE_mutexattr_t *)arg) == 0
        -: 1955:      && ACE_OS::event_init (&s->count_nonzero_, 1,
        -: 1956:                             count > 0, type, name, arg, sa) == 0
        -: 1957:      && ACE_OS::thread_mutex_lock (&s->lock_) == 0)
        -: 1958:    {
        -: 1959:      s->count_ = count;
        -: 1960:
        -: 1961:      if (ACE_OS::thread_mutex_unlock (&s->lock_) == 0)
        -: 1962:        result = 0;
        -: 1963:    }
        -: 1964:
        -: 1965:  // Destroy the internal objects if we didn't initialize
        -: 1966:  // either of them successfully.  Don't bother to check
        -: 1967:  // for errors.
        -: 1968:  if (result == -1)
        -: 1969:    {
        -: 1970:      ACE_OS::thread_mutex_destroy (&s->lock_);
        -: 1971:      ACE_OS::event_destroy (&s->count_nonzero_);
        -: 1972:    }
        -: 1973:  return result;
        -: 1974:#   endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 1975:# else /* ACE_HAS_WTHREADS */
        -: 1976:  // Just call the normal char version.
        -: 1977:  return ACE_OS::sema_init (s, count, type, attributes, ACE_Wide_To_Ascii (name).char_rep (), arg, max, sa);
        -: 1978:# endif /* ACE_HAS_WTHREADS */
        -: 1979:}
        -: 1980:#endif /* ACE_HAS_WCHAR */
        -: 1981:
        -: 1982:ACE_INLINE void
        -: 1983:ACE_OS::sema_avoid_unlink (ACE_sema_t *s, bool avoid_unlink)
        -: 1984:{
        -: 1985:#if defined (ACE_HAS_POSIX_SEM)
        -: 1986:  s->avoid_unlink_ = avoid_unlink;
        -: 1987:#else
        -: 1988:  ACE_UNUSED_ARG (s);
        -: 1989:  ACE_UNUSED_ARG (avoid_unlink);
        -: 1990:#endif
        -: 1991:}
        -: 1992:
        -: 1993:ACE_INLINE int
        -: 1994:ACE_OS::sema_unlink (const char *name)
        -: 1995:{
        -: 1996:#if defined (ACE_HAS_POSIX_SEM) && !defined (ACE_LACKS_SEM_UNLINK)
        -: 1997:  ACE_OSCALL_RETURN (::sem_unlink (name), int, -1);
        -: 1998:#else
        -: 1999:  ACE_UNUSED_ARG (name);
        -: 2000:  ACE_NOTSUP_RETURN (-1);
        -: 2001:#endif
        -: 2002:}
        -: 2003:
        -: 2004:ACE_INLINE int
        -: 2005:ACE_OS::sema_post (ACE_sema_t *s)
        -: 2006:{
        -: 2007:  ACE_OS_TRACE ("ACE_OS::sema_post");
        -: 2008:# if defined (ACE_HAS_POSIX_SEM)
        -: 2009:#   if defined (ACE_HAS_POSIX_SEM_TIMEOUT) || defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 2010:  ACE_OSCALL_RETURN (::sem_post (s->sema_), int, -1);
        -: 2011:#   else
        -: 2012:  int result = -1;
        -: 2013:
        -: 2014:  if (ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 2015:    {
        -: 2016:      if (::sem_post (s->sema_) == 0)
        -: 2017:        result = ACE_OS::cond_signal (&s->count_nonzero_);
        -: 2018:
        -: 2019:      ACE_OS::mutex_unlock (&s->lock_);
        -: 2020:    }
        -: 2021:  return result;
        -: 2022:#   endif /* ACE_HAS_POSIX_SEM_TIMEOUT || ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION */
        -: 2023:# elif defined (ACE_USES_FIFO_SEM)
        -: 2024:  char    c = 1;
        -: 2025:  if (ACE_OS::write (s->fd_[1], &c, sizeof (char)) == sizeof (char))
        -: 2026:    return 0;
        -: 2027:  return -1;
        -: 2028:# elif defined (ACE_HAS_THREADS)
        -: 2029:#   if defined (ACE_HAS_STHREADS)
        -: 2030:  int result;
        -: 2031:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_post (s), result), int, -1);
        -: 2032:#   elif defined (ACE_HAS_PTHREADS)
        -: 2033:  int result = -1;
        -: 2034:
        -: 2035:  if (ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 2036:    {
        -: 2037:      // Always allow a waiter to continue if there is one.
        -: 2038:      if (s->waiters_ > 0)
        -: 2039:        result = ACE_OS::cond_signal (&s->count_nonzero_);
        -: 2040:      else
        -: 2041:        result = 0;
        -: 2042:
        -: 2043:      s->count_++;
        -: 2044:      ACE_OS::mutex_unlock (&s->lock_);
        -: 2045:    }
        -: 2046:  return result;
        -: 2047:#   elif defined (ACE_HAS_WTHREADS)
        -: 2048:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2049:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::ReleaseSemaphore (*s, 1, 0),
        -: 2050:                                          ace_result_),
        -: 2051:                        int, -1);
        -: 2052:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2053:  int result = -1;
        -: 2054:
        -: 2055:  // Since we are simulating semaphores, we need to update semaphore
        -: 2056:  // count manually.  Grab the lock to prevent race condition first.
        -: 2057:  if (ACE_OS::thread_mutex_lock (&s->lock_) == 0)
        -: 2058:    {
        -: 2059:      // Check the original state of event object.  Single the event
        -: 2060:      // object in transition from semaphore not available to
        -: 2061:      // semaphore available.
        -: 2062:      if (s->count_++ <= 0)
        -: 2063:        result = ACE_OS::event_signal (&s->count_nonzero_);
        -: 2064:      else
        -: 2065:        result = 0;
        -: 2066:
        -: 2067:      ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2068:    }
        -: 2069:  return result;
        -: 2070:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2071:#   elif defined (ACE_VXWORKS)
        -: 2072:  ACE_OSCALL_RETURN (::semGive (s->sema_), int, -1);
        -: 2073:#   endif /* ACE_HAS_STHREADS */
        -: 2074:# else
        -: 2075:  ACE_UNUSED_ARG (s);
        -: 2076:  ACE_NOTSUP_RETURN (-1);
        -: 2077:# endif /* ACE_HAS_POSIX_SEM */
        -: 2078:}
        -: 2079:
        -: 2080:ACE_INLINE int
        -: 2081:ACE_OS::sema_post (ACE_sema_t *s, u_int release_count)
        -: 2082:{
        -: 2083:#if defined (ACE_WIN32) && !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2084:  // Win32 supports this natively.
        -: 2085:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::ReleaseSemaphore (*s, release_count, 0),
        -: 2086:                                          ace_result_), int, -1);
        -: 2087:#else
        -: 2088:  // On POSIX platforms we need to emulate this ourselves.
        -: 2089:  // @@ We can optimize on this implementation.  However,
        -: 2090:  // the semaphore promitive on Win32 doesn't allow one
        -: 2091:  // to increase a semaphore to more than the count it was
        -: 2092:  // first initialized.  Posix and solaris don't seem to have
        -: 2093:  // this restriction.  Should we impose the restriction in
        -: 2094:  // our semaphore simulation?
        -: 2095:  for (size_t i = 0; i < release_count; i++)
        -: 2096:    if (ACE_OS::sema_post (s) == -1)
        -: 2097:      return -1;
        -: 2098:
        -: 2099:  return 0;
        -: 2100:#endif /* ACE_WIN32 */
        -: 2101:}
        -: 2102:
        -: 2103:ACE_INLINE int
        -: 2104:ACE_OS::sema_trywait (ACE_sema_t *s)
        -: 2105:{
        -: 2106:  ACE_OS_TRACE ("ACE_OS::sema_trywait");
        -: 2107:# if defined (ACE_HAS_POSIX_SEM)
        -: 2108:  // POSIX semaphores set errno to EAGAIN if trywait fails
        -: 2109:  ACE_OSCALL_RETURN (::sem_trywait (s->sema_), int, -1);
        -: 2110:# elif defined (ACE_USES_FIFO_SEM)
        -: 2111:  char  c;
        -: 2112:  int     rc, flags;
        -: 2113:
        -: 2114:  /* turn on nonblocking for s->fd_[0] */
        -: 2115:  if ((flags = ACE_OS::fcntl (s->fd_[0], F_GETFL, 0)) < 0)
        -: 2116:    return -1;
        -: 2117:  flags |= O_NONBLOCK;
        -: 2118:  if (ACE_OS::fcntl (s->fd_[0], F_SETFL, flags) < 0)
        -: 2119:    return -1;
        -: 2120:
        -: 2121:  // read sets errno to EAGAIN if no input
        -: 2122:  rc = ACE_OS::read (s->fd_[0], &c, sizeof (char));
        -: 2123:
        -: 2124:  /* turn off nonblocking for fd_[0] */
        -: 2125:  if ((flags = ACE_OS::fcntl (s->fd_[0], F_GETFL, 0)) >= 0)
        -: 2126:  {
        -: 2127:    flags &= ~O_NONBLOCK;
        -: 2128:    ACE_OS::fcntl (s->fd_[0], F_SETFL, flags);
        -: 2129:  }
        -: 2130:
        -: 2131:  return rc == 1 ? 0 : (-1);
        -: 2132:# elif defined (ACE_HAS_THREADS)
        -: 2133:#   if defined (ACE_HAS_STHREADS)
        -: 2134:  // STHREADS semaphores set errno to EBUSY if trywait fails.
        -: 2135:  int result;
        -: 2136:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_trywait (s),
        -: 2137:                                       result),
        -: 2138:                     int, -1);
        -: 2139:#   elif defined (ACE_HAS_PTHREADS)
        -: 2140:
        -: 2141:  int result = -1;
        -: 2142:
        -: 2143:  if (ACE_OS::mutex_lock (&s->lock_) == 0)
        -: 2144:    {
        -: 2145:      if (s->count_ > 0)
        -: 2146:        {
        -: 2147:          --s->count_;
        -: 2148:          result = 0;
        -: 2149:        }
        -: 2150:      else
        -: 2151:        errno = EBUSY;
        -: 2152:
        -: 2153:      ACE_OS::mutex_unlock (&s->lock_);
        -: 2154:    }
        -: 2155:  return result;
        -: 2156:#   elif defined (ACE_HAS_WTHREADS)
        -: 2157:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2158:  DWORD result = ::WaitForSingleObject (*s, 0);
        -: 2159:
        -: 2160:  if (result == WAIT_OBJECT_0)
        -: 2161:    return 0;
        -: 2162:  else
        -: 2163:    {
        -: 2164:      if (result == WAIT_TIMEOUT)
        -: 2165:        errno = EBUSY;
        -: 2166:      else
        -: 2167:        ACE_OS::set_errno_to_last_error ();
        -: 2168:      // This is a hack, we need to find an appropriate mapping...
        -: 2169:      return -1;
        -: 2170:    }
        -: 2171:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2172:  // Check the status of semaphore first.  Return immediately
        -: 2173:  // if the semaphore is not available and avoid grabing the
        -: 2174:  // lock.
        -: 2175:  DWORD result = ::WaitForSingleObject (s->count_nonzero_, 0);
        -: 2176:
        -: 2177:  if (result == WAIT_OBJECT_0)  // Proceed when it is available.
        -: 2178:    {
        -: 2179:      ACE_OS::thread_mutex_lock (&s->lock_);
        -: 2180:
        -: 2181:      // Need to double check if the semaphore is still available.
        -: 2182:      // The double checking scheme will slightly affect the
        -: 2183:      // efficiency if most of the time semaphores are not blocked.
        -: 2184:      result = ::WaitForSingleObject (s->count_nonzero_, 0);
        -: 2185:      if (result == WAIT_OBJECT_0)
        -: 2186:        {
        -: 2187:          // Adjust the semaphore count.  Only update the event
        -: 2188:          // object status when the state changed.
        -: 2189:          s->count_--;
        -: 2190:          if (s->count_ <= 0)
        -: 2191:            ACE_OS::event_reset (&s->count_nonzero_);
        -: 2192:          result = 0;
        -: 2193:        }
        -: 2194:
        -: 2195:      ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2196:    }
        -: 2197:
        -: 2198:  // Translate error message to errno used by ACE.
        -: 2199:  if (result == WAIT_TIMEOUT)
        -: 2200:    errno = EBUSY;
        -: 2201:  else
        -: 2202:    ACE_OS::set_errno_to_last_error ();
        -: 2203:  // This is taken from the hack above. ;)
        -: 2204:  return -1;
        -: 2205:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2206:#   elif defined (ACE_VXWORKS)
        -: 2207:  if (::semTake (s->sema_, NO_WAIT) == ERROR)
        -: 2208:    if (errno == S_objLib_OBJ_UNAVAILABLE)
        -: 2209:      {
        -: 2210:        // couldn't get the semaphore
        -: 2211:        errno = EBUSY;
        -: 2212:        return -1;
        -: 2213:      }
        -: 2214:    else
        -: 2215:      // error
        -: 2216:      return -1;
        -: 2217:  else
        -: 2218:    // got the semaphore
        -: 2219:    return 0;
        -: 2220:#   endif /* ACE_HAS_STHREADS */
        -: 2221:# else
        -: 2222:  ACE_UNUSED_ARG (s);
        -: 2223:  ACE_NOTSUP_RETURN (-1);
        -: 2224:# endif /* ACE_HAS_POSIX_SEM */
        -: 2225:}
        -: 2226:
        -: 2227:ACE_INLINE int
        -: 2228:ACE_OS::sema_wait (ACE_sema_t *s)
        -: 2229:{
        -: 2230:  ACE_OS_TRACE ("ACE_OS::sema_wait");
        -: 2231:# if defined (ACE_HAS_POSIX_SEM)
        -: 2232:  ACE_OSCALL_RETURN (::sem_wait (s->sema_), int, -1);
        -: 2233:# elif defined (ACE_USES_FIFO_SEM)
        -: 2234:  char c;
        -: 2235:  if (ACE_OS::read (s->fd_[0], &c, sizeof (char)) == 1)
        -: 2236:    return 0;
        -: 2237:  return -1;
        -: 2238:# elif defined (ACE_HAS_THREADS)
        -: 2239:#   if defined (ACE_HAS_STHREADS)
        -: 2240:  int result;
        -: 2241:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sema_wait (s), result), int, -1);
        -: 2242:#   elif defined (ACE_HAS_PTHREADS)
        -: 2243:  int result = 0;
        -: 2244:
        -: 2245:  ACE_PTHREAD_CLEANUP_PUSH (&s->lock_);
        -: 2246:
        -: 2247:  if (ACE_OS::mutex_lock (&s->lock_) != 0)
        -: 2248:    result = -1;
        -: 2249:  else
        -: 2250:    {
        -: 2251:      // Keep track of the number of waiters so that we can signal
        -: 2252:      // them properly in <ACE_OS::sema_post>.
        -: 2253:      s->waiters_++;
        -: 2254:
        -: 2255:      // Wait until the semaphore count is > 0.
        -: 2256:      while (s->count_ == 0)
        -: 2257:        if (ACE_OS::cond_wait (&s->count_nonzero_,
        -: 2258:                               &s->lock_) == -1)
        -: 2259:          {
        -: 2260:            result = -2; // -2 means that we need to release the mutex.
        -: 2261:            break;
        -: 2262:          }
        -: 2263:
        -: 2264:      --s->waiters_;
        -: 2265:    }
        -: 2266:
        -: 2267:  if (result == 0)
        -: 2268:    --s->count_;
        -: 2269:
        -: 2270:  if (result != -1)
        -: 2271:    ACE_OS::mutex_unlock (&s->lock_);
        -: 2272:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 2273:  return result < 0 ? -1 : result;
        -: 2274:
        -: 2275:#   elif defined (ACE_HAS_WTHREADS)
        -: 2276:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2277:  switch (::WaitForSingleObject (*s, INFINITE))
        -: 2278:    {
        -: 2279:    case WAIT_OBJECT_0:
        -: 2280:      return 0;
        -: 2281:    default:
        -: 2282:      // This is a hack, we need to find an appropriate mapping...
        -: 2283:      ACE_OS::set_errno_to_last_error ();
        -: 2284:      return -1;
        -: 2285:    }
        -: 2286:  /* NOTREACHED */
        -: 2287:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2288:  // Timed wait.
        -: 2289:  int result = -1;
        -: 2290:  for (;;)
        -: 2291:    // Check if the semaphore is avialable or not and wait forever.
        -: 2292:    // Don't bother to grab the lock if it is not available (to avoid
        -: 2293:    // deadlock.)
        -: 2294:    switch (::WaitForSingleObject (s->count_nonzero_, INFINITE))
        -: 2295:      {
        -: 2296:      case WAIT_OBJECT_0:
        -: 2297:        ACE_OS::thread_mutex_lock (&s->lock_);
        -: 2298:
        -: 2299:        // Need to double check if the semaphore is still available.
        -: 2300:        // This time, we shouldn't wait at all.
        -: 2301:        if (::WaitForSingleObject (s->count_nonzero_, 0) == WAIT_OBJECT_0)
        -: 2302:          {
        -: 2303:            // Decrease the internal counter.  Only update the event
        -: 2304:            // object's status when the state changed.
        -: 2305:            s->count_--;
        -: 2306:            if (s->count_ <= 0)
        -: 2307:              ACE_OS::event_reset (&s->count_nonzero_);
        -: 2308:            result = 0;
        -: 2309:          }
        -: 2310:
        -: 2311:        ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2312:        // if we didn't get a hold on the semaphore, the result won't
        -: 2313:        // be 0 and thus, we'll start from the beginning again.
        -: 2314:        if (result == 0)
        -: 2315:          return 0;
        -: 2316:        break;
        -: 2317:
        -: 2318:      default:
        -: 2319:        // Since we wait indefinitely, anything other than
        -: 2320:        // WAIT_OBJECT_O indicates an error.
        -: 2321:        ACE_OS::set_errno_to_last_error ();
        -: 2322:        // This is taken from the hack above. ;)
        -: 2323:        return -1;
        -: 2324:      }
        -: 2325:  /* NOTREACHED */
        -: 2326:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2327:#   elif defined (ACE_VXWORKS)
        -: 2328:  ACE_OSCALL_RETURN (::semTake (s->sema_, WAIT_FOREVER), int, -1);
        -: 2329:#   endif /* ACE_HAS_STHREADS */
        -: 2330:# else
        -: 2331:  ACE_UNUSED_ARG (s);
        -: 2332:  ACE_NOTSUP_RETURN (-1);
        -: 2333:# endif /* ACE_HAS_POSIX_SEM */
        -: 2334:}
        -: 2335:
        -: 2336:ACE_INLINE int
        -: 2337:ACE_OS::sema_wait (ACE_sema_t *s, ACE_Time_Value &tv)
        -: 2338:{
        -: 2339:  ACE_OS_TRACE ("ACE_OS::sema_wait");
        -: 2340:# if defined (ACE_HAS_POSIX_SEM)
        -: 2341:#   if defined (ACE_HAS_POSIX_SEM_TIMEOUT)
        -: 2342:  int rc;
        -: 2343:  timespec_t ts;
        -: 2344:  ts = tv; // Calls ACE_Time_Value::operator timespec_t().
        -: 2345:  ACE_OSCALL (::sem_timedwait (s->sema_, &ts), int, -1, rc);
        -: 2346:  if (rc == -1 && errno == ETIMEDOUT)
        -: 2347:    errno = ETIME;  /* POSIX returns ETIMEDOUT but we need ETIME */
        -: 2348:  return rc;
        -: 2349:#   elif !defined (ACE_DISABLE_POSIX_SEM_TIMEOUT_EMULATION)
        -: 2350:  int result = 0;
        -: 2351:  bool expired = false;
        -: 2352:  ACE_Errno_Guard error (errno);
        -: 2353:
        -: 2354:  ACE_PTHREAD_CLEANUP_PUSH (&s->lock_);
        -: 2355:
        -: 2356:  if (ACE_OS::mutex_lock (&s->lock_) != 0)
        -: 2357:    result = -2;
        -: 2358:  else
        -: 2359:    {
        -: 2360:      bool finished = true;
        -: 2361:      do
        -: 2362:      {
        -: 2363:        result = ACE_OS::sema_trywait (s);
        -: 2364:        if (result == -1 && errno == EAGAIN)
        -: 2365:          expired = (tv.to_relative_time () <= ACE_Time_Value::zero);
        -: 2366:        else
        -: 2367:          expired = false;
        -: 2368:
        -: 2369:        finished = result != -1 || expired ||
        -: 2370:                   (result == -1 && errno != EAGAIN);
        -: 2371:        if (!finished)
        -: 2372:          {
        -: 2373:            if (ACE_OS::cond_timedwait (&s->count_nonzero_,
        -: 2374:                                        &s->lock_,
        -: 2375:                                        &tv) == -1)
        -: 2376:              {
        -: 2377:                error = errno;
        -: 2378:                result = -1;
        -: 2379:                break;
        -: 2380:              }
        -: 2381:          }
        -: 2382:      } while (!finished);
        -: 2383:
        -: 2384:      if (expired)
        -: 2385:        error = ETIME;
        -: 2386:
        -: 2387:#     if defined (ACE_LACKS_COND_TIMEDWAIT_RESET)
        -: 2388:      tv = tv.now ();
        -: 2389:#     endif /* ACE_LACKS_COND_TIMEDWAIT_RESET */
        -: 2390:    }
        -: 2391:
        -: 2392:  if (result != -2)
        -: 2393:    ACE_OS::mutex_unlock (&s->lock_);
        -: 2394:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 2395:  return result < 0 ? -1 : result;
        -: 2396:#   else /* No native sem_timedwait(), and emulation disabled */
        -: 2397:  ACE_UNUSED_ARG (s);
        -: 2398:  ACE_UNUSED_ARG (tv);
        -: 2399:  ACE_NOTSUP_RETURN (-1);
        -: 2400:#   endif /* ACE_HAS_POSIX_SEM_TIMEOUT */
        -: 2401:# elif defined (ACE_USES_FIFO_SEM)
        -: 2402:  int rc;
        -: 2403:  ACE_Time_Value timeout = tv.to_relative_time ();
        -: 2404:
        -: 2405:  while (timeout > ACE_Time_Value::zero)
        -: 2406:    {
        -: 2407:      ACE_Handle_Set  fds_;
        -: 2408:
        -: 2409:      fds_.set_bit (s->fd_[0]);
        -: 2410:      if ((rc = ACE_OS::select (ACE_Handle_Set::MAXSIZE, fds_, 0, 0, timeout)) != 1)
        -: 2411:        {
        -: 2412:          if (rc == 0 || errno != EAGAIN)
        -: 2413:          {
        -: 2414:            if (rc == 0)
        -: 2415:              errno = ETIME;
        -: 2416:            return -1;
        -: 2417:          }
        -: 2418:        }
        -: 2419:
        -: 2420:      // try to read the signal *but* do *not* block
        -: 2421:      if (rc == 1 && ACE_OS::sema_trywait (s) == 0)
        -: 2422:        return 0;
        -: 2423:
        -: 2424:      // we were woken for input but someone beat us to it
        -: 2425:      // so we wait again if there is still time
        -: 2426:      timeout = tv.to_relative_time ();
        -: 2427:    }
        -: 2428:
        -: 2429:  // make sure errno is set right
        -: 2430:  errno = ETIME;
        -: 2431:
        -: 2432:  return -1;
        -: 2433:# elif defined (ACE_HAS_THREADS)
        -: 2434:#   if defined (ACE_HAS_STHREADS)
        -: 2435:  ACE_UNUSED_ARG (s);
        -: 2436:  ACE_UNUSED_ARG (tv);
        -: 2437:  ACE_NOTSUP_RETURN (-1);
        -: 2438:#   elif defined (ACE_HAS_PTHREADS)
        -: 2439:  int result = 0;
        -: 2440:  ACE_Errno_Guard error (errno);
        -: 2441:
        -: 2442:  ACE_PTHREAD_CLEANUP_PUSH (&s->lock_);
        -: 2443:
        -: 2444:  if (ACE_OS::mutex_lock (&s->lock_) != 0)
        -: 2445:    result = -1;
        -: 2446:  else
        -: 2447:    {
        -: 2448:      // Keep track of the number of waiters so that we can signal
        -: 2449:      // them properly in <ACE_OS::sema_post>.
        -: 2450:      s->waiters_++;
        -: 2451:
        -: 2452:      // Wait until the semaphore count is > 0 or until we time out.
        -: 2453:      while (s->count_ == 0)
        -: 2454:        if (ACE_OS::cond_timedwait (&s->count_nonzero_,
        -: 2455:                                    &s->lock_,
        -: 2456:                                    &tv) == -1)
        -: 2457:          {
        -: 2458:            error = errno;
        -: 2459:            result = -2; // -2 means that we need to release the mutex.
        -: 2460:            break;
        -: 2461:          }
        -: 2462:
        -: 2463:      --s->waiters_;
        -: 2464:    }
        -: 2465:
        -: 2466:  if (result == 0)
        -: 2467:    {
        -: 2468:#     if defined (ACE_LACKS_COND_TIMEDWAIT_RESET)
        -: 2469:      tv = tv.now ();
        -: 2470:#     endif /* ACE_LACKS_COND_TIMEDWAIT_RESET */
        -: 2471:      --s->count_;
        -: 2472:    }
        -: 2473:
        -: 2474:  if (result != -1)
        -: 2475:    ACE_OS::mutex_unlock (&s->lock_);
        -: 2476:  ACE_PTHREAD_CLEANUP_POP (0);
        -: 2477:  return result < 0 ? -1 : result;
        -: 2478:#   elif defined (ACE_HAS_WTHREADS)
        -: 2479:#     if !defined (ACE_USES_WINCE_SEMA_SIMULATION)
        -: 2480:  int msec_timeout;
        -: 2481:
        -: 2482:  if (tv == ACE_Time_Value::zero)
        -: 2483:    msec_timeout = 0; // Do a "poll."
        -: 2484:  else
        -: 2485:    {
        -: 2486:      // Note that we must convert between absolute time (which is
        -: 2487:      // passed as a parameter) and relative time (which is what
        -: 2488:      // <WaitForSingleObjects> expects).
        -: 2489:      ACE_Time_Value relative_time = tv.to_relative_time ();
        -: 2490:
        -: 2491:      // Watchout for situations where a context switch has caused the
        -: 2492:      // current time to be > the timeout.
        -: 2493:      if (relative_time < ACE_Time_Value::zero)
        -: 2494:        msec_timeout = 0;
        -: 2495:      else
        -: 2496:        msec_timeout = relative_time.msec ();
        -: 2497:    }
        -: 2498:
        -: 2499:  switch (::WaitForSingleObject (*s, msec_timeout))
        -: 2500:    {
        -: 2501:    case WAIT_OBJECT_0:
        -: 2502:      tv = tv.now ();     // Update time to when acquired
        -: 2503:      return 0;
        -: 2504:    case WAIT_TIMEOUT:
        -: 2505:      errno = ETIME;
        -: 2506:      return -1;
        -: 2507:    default:
        -: 2508:      // This is a hack, we need to find an appropriate mapping...
        -: 2509:      ACE_OS::set_errno_to_last_error ();
        -: 2510:      return -1;
        -: 2511:    }
        -: 2512:  /* NOTREACHED */
        -: 2513:#     else /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2514:  // Note that in this mode, the acquire is done in two steps, and
        -: 2515:  // we may get signaled but cannot grab the semaphore before
        -: 2516:  // timeout.  In that case, we'll need to restart the process with
        -: 2517:  // updated timeout value.
        -: 2518:
        -: 2519:  // tv is an absolute time, but we need relative to work with the Windows
        -: 2520:  // API. Also, some users have become accustomed to using a 0 time value
        -: 2521:  // as a shortcut for "now", which works on non-Windows because 0 is
        -: 2522:  // always earlier than now. However, the need to convert to relative time
        -: 2523:  // means we need to watch out for this case.
        -: 2524:  ACE_Time_Value relative_time (ACE_Time_Value::zero);
        -: 2525:  if (tv != ACE_Time_Value::zero)
        -: 2526:    relative_time = tv.to_relative_time ();
        -: 2527:  int result = -1;
        -: 2528:
        -: 2529:  // While we are not timeout yet. >= 0 will let this go through once
        -: 2530:  // and if not able to get the object, it should hit WAIT_TIMEOUT
        -: 2531:  // right away.
        -: 2532:  while (relative_time >= ACE_Time_Value::zero)
        -: 2533:    {
        -: 2534:      // Wait for our turn to get the object.
        -: 2535:      switch (::WaitForSingleObject (s->count_nonzero_, relative_time.msec ()))
        -: 2536:        {
        -: 2537:        case WAIT_OBJECT_0:
        -: 2538:          ACE_OS::thread_mutex_lock (&s->lock_);
        -: 2539:
        -: 2540:          // Need to double check if the semaphore is still available.
        -: 2541:          // We can only do a "try lock" styled wait here to avoid
        -: 2542:          // blocking threads that want to signal the semaphore.
        -: 2543:          if (::WaitForSingleObject (s->count_nonzero_, 0) == WAIT_OBJECT_0)
        -: 2544:            {
        -: 2545:              // As before, only reset the object when the semaphore
        -: 2546:              // is no longer available.
        -: 2547:              s->count_--;
        -: 2548:              if (s->count_ <= 0)
        -: 2549:                ACE_OS::event_reset (&s->count_nonzero_);
        -: 2550:              result = 0;
        -: 2551:            }
        -: 2552:
        -: 2553:          ACE_OS::thread_mutex_unlock (&s->lock_);
        -: 2554:
        -: 2555:          // Only return when we successfully get the semaphore.
        -: 2556:          if (result == 0)
        -: 2557:            {
        -: 2558:              tv = tv.now ();     // Update to time acquired
        -: 2559:              return 0;
        -: 2560:            }
        -: 2561:          break;
        -: 2562:
        -: 2563:          // We have timed out.
        -: 2564:        case WAIT_TIMEOUT:
        -: 2565:          errno = ETIME;
        -: 2566:          return -1;
        -: 2567:
        -: 2568:          // What?
        -: 2569:        default:
        -: 2570:          ACE_OS::set_errno_to_last_error ();
        -: 2571:          // This is taken from the hack above. ;)
        -: 2572:          return -1;
        -: 2573:        };
        -: 2574:
        -: 2575:      // Haven't been able to get the semaphore yet, update the
        -: 2576:      // timeout value to reflect the remaining time we want to wait.
        -: 2577:      // in case of tv == 0 relative_time will now be < 0 and we will be out of time
        -: 2578:      relative_time = tv.to_relative_time ();
        -: 2579:    }
        -: 2580:
        -: 2581:  // We have timed out.
        -: 2582:  errno = ETIME;
        -: 2583:  return -1;
        -: 2584:#     endif /* ACE_USES_WINCE_SEMA_SIMULATION */
        -: 2585:#   elif defined (ACE_VXWORKS)
        -: 2586:  // Note that we must convert between absolute time (which is
        -: 2587:  // passed as a parameter) and relative time (which is what
        -: 2588:  // the system call expects).
        -: 2589:  ACE_Time_Value relative_time = tv.to_relative_time ();
        -: 2590:
        -: 2591:  int ticks_per_sec = ::sysClkRateGet ();
        -: 2592:
        -: 2593:  int ticks = relative_time.sec () * ticks_per_sec +
        -: 2594:              relative_time.usec () * ticks_per_sec / ACE_ONE_SECOND_IN_USECS;
        -: 2595:  if (::semTake (s->sema_, ticks) == ERROR)
        -: 2596:    {
        -: 2597:      if (errno == S_objLib_OBJ_TIMEOUT)
        -: 2598:        // Convert the VxWorks errno to one that's common for to ACE
        -: 2599:        // platforms.
        -: 2600:        errno = ETIME;
        -: 2601:      else if (errno == S_objLib_OBJ_UNAVAILABLE)
        -: 2602:        errno = EBUSY;
        -: 2603:      return -1;
        -: 2604:    }
        -: 2605:  else
        -: 2606:    {
        -: 2607:      tv = tv.now ();  // Update to time acquired
        -: 2608:      return 0;
        -: 2609:    }
        -: 2610:#   endif /* ACE_HAS_STHREADS */
        -: 2611:# else
        -: 2612:  ACE_UNUSED_ARG (s);
        -: 2613:  ACE_UNUSED_ARG (tv);
        -: 2614:  ACE_NOTSUP_RETURN (-1);
        -: 2615:# endif /* ACE_HAS_POSIX_SEM */
        -: 2616:}
        -: 2617:
        -: 2618:ACE_INLINE int
        -: 2619:ACE_OS::sema_wait (ACE_sema_t *s, ACE_Time_Value *tv)
        -: 2620:{
        -: 2621:  return tv == 0 ? ACE_OS::sema_wait (s) : ACE_OS::sema_wait (s, *tv);
        -: 2622:}
        -: 2623:
        -: 2624:ACE_INLINE int
        -: 2625:ACE_OS::semctl (int int_id, int semnum, int cmd, semun value)
        -: 2626:{
        -: 2627:  ACE_OS_TRACE ("ACE_OS::semctl");
        -: 2628:#if defined (ACE_HAS_SYSV_IPC)
        -: 2629:  ACE_OSCALL_RETURN (::semctl (int_id, semnum, cmd, value), int, -1);
        -: 2630:#else
        -: 2631:  ACE_UNUSED_ARG (int_id);
        -: 2632:  ACE_UNUSED_ARG (semnum);
        -: 2633:  ACE_UNUSED_ARG (cmd);
        -: 2634:  ACE_UNUSED_ARG (value);
        -: 2635:
        -: 2636:  ACE_NOTSUP_RETURN (-1);
        -: 2637:#endif /* ACE_HAS_SYSV_IPC */
        -: 2638:}
        -: 2639:
        -: 2640:ACE_INLINE int
        -: 2641:ACE_OS::semget (key_t key, int nsems, int flags)
        -: 2642:{
        -: 2643:  ACE_OS_TRACE ("ACE_OS::semget");
        -: 2644:#if defined (ACE_HAS_SYSV_IPC)
        -: 2645:  ACE_OSCALL_RETURN (::semget (key, nsems, flags), int, -1);
        -: 2646:#else
        -: 2647:  ACE_UNUSED_ARG (key);
        -: 2648:  ACE_UNUSED_ARG (nsems);
        -: 2649:  ACE_UNUSED_ARG (flags);
        -: 2650:
        -: 2651:  ACE_NOTSUP_RETURN (-1);
        -: 2652:#endif /* ACE_HAS_SYSV_IPC */
        -: 2653:}
        -: 2654:
        -: 2655:ACE_INLINE int
        -: 2656:ACE_OS::semop (int int_id, struct sembuf *sops, size_t nsops)
        -: 2657:{
        -: 2658:  ACE_OS_TRACE ("ACE_OS::semop");
        -: 2659:#if defined (ACE_HAS_SYSV_IPC)
        -: 2660:  ACE_OSCALL_RETURN (::semop (int_id, sops, nsops), int, -1);
        -: 2661:#else
        -: 2662:  ACE_UNUSED_ARG (int_id);
        -: 2663:  ACE_UNUSED_ARG (sops);
        -: 2664:  ACE_UNUSED_ARG (nsops);
        -: 2665:
        -: 2666:  ACE_NOTSUP_RETURN (-1);
        -: 2667:#endif /* ACE_HAS_SYSV_IPC */
        -: 2668:}
        -: 2669:
        -: 2670:ACE_INLINE int
        -: 2671:ACE_OS::sigtimedwait (const sigset_t *sset,
        -: 2672:                      siginfo_t *info,
        -: 2673:                      const ACE_Time_Value *timeout)
        -: 2674:{
        -: 2675:  ACE_OS_TRACE ("ACE_OS::sigtimedwait");
        -: 2676:#if defined (ACE_HAS_SIGTIMEDWAIT)
        -: 2677:  timespec_t ts;
        -: 2678:  timespec_t *tsp = 0;
        -: 2679:
        -: 2680:  if (timeout != 0)
        -: 2681:    {
        -: 2682:      ts = *timeout; // Calls ACE_Time_Value::operator timespec_t().
        -: 2683:      tsp = &ts;
        -: 2684:    }
        -: 2685:
        -: 2686:  ACE_OSCALL_RETURN (::sigtimedwait (sset, info, tsp),
        -: 2687:                     int, -1);
        -: 2688:#else
        -: 2689:    ACE_UNUSED_ARG (sset);
        -: 2690:    ACE_UNUSED_ARG (info);
        -: 2691:    ACE_UNUSED_ARG (timeout);
        -: 2692:    ACE_NOTSUP_RETURN (-1);
        -: 2693:#endif /* ACE_HAS_SIGTIMEDWAIT */
        -: 2694:}
        -: 2695:
        -: 2696:ACE_INLINE int
        -: 2697:ACE_OS::sigwait (sigset_t *sset, int *sig)
        -: 2698:{
        -: 2699:  ACE_OS_TRACE ("ACE_OS::sigwait");
        -: 2700:  int local_sig;
        -: 2701:  if (sig == 0)
        -: 2702:    sig = &local_sig;
        -: 2703:#if defined (ACE_HAS_THREADS)
        -: 2704:# if (defined (__FreeBSD__) && (__FreeBSD__ < 3))
        -: 2705:    ACE_UNUSED_ARG (sset);
        -: 2706:    ACE_NOTSUP_RETURN (-1);
        -: 2707:# elif defined (ACE_HAS_STHREADS)
        -: 2708:   # if (_POSIX_C_SOURCE - 0 >= 199506L) || defined (_POSIX_PTHREAD_SEMANTICS)
        -: 2709:     errno = ::sigwait (sset, sig);
        -: 2710:     return errno == 0  ?  *sig  :  -1;
        -: 2711:   #else
        -: 2712:     *sig = ::sigwait (sset);
        -: 2713:     return *sig;
        -: 2714:   #endif /* _POSIX_C_SOURCE - 0 >= 199506L || _POSIX_PTHREAD_SEMANTICS */
        -: 2715:# elif defined (ACE_HAS_PTHREADS)
        -: 2716:#   if defined (CYGWIN32)
        -: 2717:      // Cygwin has sigwait definition, but it is not implemented
        -: 2718:      ACE_UNUSED_ARG (sset);
        -: 2719:      ACE_NOTSUP_RETURN (-1);
        -: 2720:#   else   /* this is std */
        -: 2721:      errno = ::sigwait (sset, sig);
        -: 2722:      return errno == 0  ?  *sig  :  -1;
        -: 2723:#   endif /* CYGWIN32 */
        -: 2724:# elif defined (ACE_HAS_WTHREADS)
        -: 2725:    ACE_UNUSED_ARG (sset);
        -: 2726:    ACE_NOTSUP_RETURN (-1);
        -: 2727:# elif defined (ACE_VXWORKS)
        -: 2728:    // Second arg is a struct siginfo *, which we don't need (the
        -: 2729:    // selected signal number is returned).  Third arg is timeout:  0
        -: 2730:    // means forever.
        -: 2731:    *sig = ::sigtimedwait (sset, 0, 0);
        -: 2732:    return *sig;
        -: 2733:# endif /* __FreeBSD__ */
        -: 2734:#else
        -: 2735:    ACE_UNUSED_ARG (sset);
        -: 2736:    ACE_UNUSED_ARG (sig);
        -: 2737:    ACE_NOTSUP_RETURN (-1);
        -: 2738:#endif /* ACE_HAS_THREADS */
        -: 2739:}
        -: 2740:
        -: 2741:ACE_INLINE int
        -: 2742:ACE_OS::sigwaitinfo (const sigset_t *sset,
        -: 2743:                     siginfo_t *info)
        -: 2744:{
        -: 2745:  ACE_OS_TRACE ("ACE_OS::sigwaitinfo");
        -: 2746:  // If this platform has sigtimedwait, it should have sigwaitinfo as well.
        -: 2747:  // If this isn't true somewhere, let me know and I'll fix this.
        -: 2748:  // -Steve Huston <shuston@riverace.com>.
        -: 2749:#if defined (ACE_HAS_SIGTIMEDWAIT)
        -: 2750:  ACE_OSCALL_RETURN (::sigwaitinfo (sset, info), int, -1);
        -: 2751:#else
        -: 2752:  ACE_UNUSED_ARG (sset);
        -: 2753:  ACE_UNUSED_ARG (info);
        -: 2754:  ACE_NOTSUP_RETURN (-1);
        -: 2755:#endif /* ACE_HAS_SIGTIMEDWAIT */
        -: 2756:}
        -: 2757:
        -: 2758:ACE_INLINE int
        -: 2759:ACE_OS::thr_cancel (ACE_thread_t thr_id)
        -: 2760:{
        -: 2761:  ACE_OS_TRACE ("ACE_OS::thr_cancel");
        -: 2762:#if defined (ACE_HAS_THREADS)
        -: 2763:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 2764:  int result;
        -: 2765:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_cancel (thr_id),
        -: 2766:                                        result),
        -: 2767:                      int, -1);
        -: 2768:# elif defined (ACE_HAS_VXTHREADS)
        -: 2769:  ACE_OSCALL_RETURN (::taskDelete (thr_id), int, -1);
        -: 2770:# else /* Could be ACE_HAS_PTHREADS && ACE_LACKS_PTHREAD_CANCEL */
        -: 2771:  ACE_UNUSED_ARG (thr_id);
        -: 2772:  ACE_NOTSUP_RETURN (-1);
        -: 2773:# endif /* ACE_HAS_PTHREADS */
        -: 2774:#else
        -: 2775:  ACE_UNUSED_ARG (thr_id);
        -: 2776:  ACE_NOTSUP_RETURN (-1);
        -: 2777:#endif /* ACE_HAS_THREADS */
        -: 2778:}
        -: 2779:
        -: 2780:ACE_INLINE int
        -: 2781:ACE_OS::thr_cmp (ACE_hthread_t t1, ACE_hthread_t t2)
        -: 2782:{
        -: 2783:#if defined (ACE_HAS_PTHREADS)
        -: 2784:# if defined (pthread_equal)
        -: 2785:  // If it's a macro we can't say "pthread_equal"...
        -: 2786:  return pthread_equal (t1, t2);
        -: 2787:# else
        -: 2788:  return pthread_equal (t1, t2);
        -: 2789:# endif /* pthread_equal */
        -: 2790:#else /* For STHREADS, WTHREADS, and VXWORKS ... */
        -: 2791:  // Hum, Do we need to treat WTHREAD differently?
        -: 2792:  // levine 13 oct 98 % Probably, ACE_hthread_t is a HANDLE.
        -: 2793:  return t1 == t2;
        -: 2794:#endif /* ACE_HAS_PTHREADS */
        -: 2795:}
        -: 2796:
        -: 2797:ACE_INLINE int
        -: 2798:ACE_OS::thr_continue (ACE_hthread_t target_thread)
        -: 2799:{
        -: 2800:  ACE_OS_TRACE ("ACE_OS::thr_continue");
        -: 2801:#if defined (ACE_HAS_THREADS)
        -: 2802:# if defined (ACE_HAS_STHREADS)
        -: 2803:  int result;
        -: 2804:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_continue (target_thread), result), int, -1);
        -: 2805:# elif defined (ACE_HAS_PTHREADS)
        -: 2806:#  if defined (ACE_HAS_PTHREAD_CONTINUE)
        -: 2807:  int result;
        -: 2808:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_continue (target_thread),
        -: 2809:                                       result),
        -: 2810:                     int, -1);
        -: 2811:#  elif defined (ACE_HAS_PTHREAD_CONTINUE_NP)
        -: 2812:  int result;
        -: 2813:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_continue_np (target_thread),
        -: 2814:                                       result),
        -: 2815:                     int, -1);
        -: 2816:#  elif defined (ACE_HAS_PTHREAD_RESUME_NP)
        -: 2817:  int result;
        -: 2818:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_resume_np (target_thread),
        -: 2819:                                       result),
        -: 2820:                     int, -1);
        -: 2821:#  else
        -: 2822:  ACE_UNUSED_ARG (target_thread);
        -: 2823:  ACE_NOTSUP_RETURN (-1);
        -: 2824:#  endif /* ACE_HAS_PTHREAD_CONTINUE */
        -: 2825:# elif defined (ACE_HAS_WTHREADS)
        -: 2826:  DWORD result = ::ResumeThread (target_thread);
        -: 2827:  if (result == ACE_SYSCALL_FAILED)
        -: 2828:    ACE_FAIL_RETURN (-1);
        -: 2829:  else
        -: 2830:    return 0;
        -: 2831:# elif defined (ACE_HAS_VXTHREADS)
        -: 2832:  ACE_OSCALL_RETURN (::taskResume (target_thread), int, -1);
        -: 2833:# endif /* ACE_HAS_STHREADS */
        -: 2834:#else
        -: 2835:  ACE_UNUSED_ARG (target_thread);
        -: 2836:  ACE_NOTSUP_RETURN (-1);
        -: 2837:#endif /* ACE_HAS_THREADS */
        -: 2838:}
        -: 2839:
        -: 2840:ACE_INLINE int
        -: 2841:ACE_OS::thr_getconcurrency (void)
        -: 2842:{
        -: 2843:  ACE_OS_TRACE ("ACE_OS::thr_getconcurrency");
        -: 2844:#if defined (ACE_HAS_THREADS)
        -: 2845:# if defined (ACE_HAS_STHREADS)
        -: 2846:  return ::thr_getconcurrency ();
        -: 2847:# elif defined (ACE_HAS_PTHREADS) && defined (ACE_HAS_PTHREAD_GETCONCURRENCY)
        -: 2848:  return pthread_getconcurrency ();
        -: 2849:# else
        -: 2850:  ACE_NOTSUP_RETURN (-1);
        -: 2851:# endif /* ACE_HAS_STHREADS */
        -: 2852:#else
        -: 2853:  ACE_NOTSUP_RETURN (-1);
        -: 2854:#endif /* ACE_HAS_THREADS */
        -: 2855:}
        -: 2856:
        -: 2857:ACE_INLINE int
        -: 2858:ACE_OS::thr_getprio (ACE_hthread_t ht_id, int &priority, int &policy)
        -: 2859:{
        -: 2860:  ACE_OS_TRACE ("ACE_OS::thr_getprio");
        -: 2861:  ACE_UNUSED_ARG (policy);
        -: 2862:#if defined (ACE_HAS_THREADS)
        -: 2863:# if (defined (ACE_HAS_PTHREADS) && \
        -: 2864:     (!defined (ACE_LACKS_SETSCHED) || defined (ACE_HAS_PTHREAD_SCHEDPARAM)))
        -: 2865:
        -: 2866:  struct sched_param param;
        -: 2867:  int result;
        -: 2868:
        -: 2869:  ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_getschedparam (ht_id, &policy, &param),
        -: 2870:                                result), int,
        -: 2871:              -1, result);
        -: 2872:  priority = param.sched_priority;
        -: 2873:  return result;
        -: 2874:# elif defined (ACE_HAS_STHREADS)
        -: 2875:  int result;
        -: 2876:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_getprio (ht_id, &priority), result), int, -1);
        -: 2877:# elif defined (ACE_HAS_WTHREADS)
        -: 2878:  ACE_Errno_Guard error (errno);
        -: 2879:
        -: 2880:#   if defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY)
        -: 2881:  priority = ::CeGetThreadPriority (ht_id);
        -: 2882:#   else
        -: 2883:  priority = ::GetThreadPriority (ht_id);
        -: 2884:#   endif /* defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY) */
        -: 2885:
        -: 2886:#   if defined (ACE_HAS_PHARLAP)
        -: 2887:#     if defined (ACE_PHARLAP_LABVIEW_RT)
        -: 2888:  policy = ACE_SCHED_FIFO;
        -: 2889:#     else
        -: 2890:  DWORD timeslice = ::EtsGetTimeSlice ();
        -: 2891:  policy = timeslice == 0 ? ACE_SCHED_OTHER : ACE_SCHED_FIFO;
        -: 2892:#     endif /* ACE_PHARLAP_LABVIEW_RT */
        -: 2893:#   elif !defined (ACE_HAS_WINCE)
        -: 2894:  DWORD priority_class = ::GetPriorityClass (::GetCurrentProcess ());
        -: 2895:  if (priority_class == 0 && (error = ::GetLastError ()) != NO_ERROR)
        -: 2896:    ACE_FAIL_RETURN (-1);
        -: 2897:
        -: 2898:  policy =
        -: 2899:    (priority_class ==
        -: 2900:     REALTIME_PRIORITY_CLASS) ? ACE_SCHED_FIFO : ACE_SCHED_OTHER;
        -: 2901:#   endif /* ACE_HAS_PHARLAP */
        -: 2902:
        -: 2903:  return 0;
        -: 2904:# elif defined (ACE_HAS_VXTHREADS)
        -: 2905:  ACE_OSCALL_RETURN (::taskPriorityGet (ht_id, &priority), int, -1);
        -: 2906:# else
        -: 2907:  ACE_UNUSED_ARG (ht_id);
        -: 2908:  ACE_UNUSED_ARG (priority);
        -: 2909:  ACE_NOTSUP_RETURN (-1);
        -: 2910:# endif /* ACE_HAS_STHREADS */
        -: 2911:#else
        -: 2912:  ACE_UNUSED_ARG (ht_id);
        -: 2913:  ACE_UNUSED_ARG (priority);
        -: 2914:  ACE_NOTSUP_RETURN (-1);
        -: 2915:#endif /* ACE_HAS_THREADS */
        -: 2916:}
        -: 2917:
        -: 2918:ACE_INLINE int
        -: 2919:ACE_OS::thr_getprio (ACE_hthread_t ht_id, int &priority)
        -: 2920:{
        -: 2921:  ACE_OS_TRACE ("ACE_OS::thr_getprio");
        -: 2922:  int policy = 0;
        -: 2923:  return ACE_OS::thr_getprio (ht_id, priority, policy);
        -: 2924:}
        -: 2925:
        -: 2926:#if defined (ACE_HAS_THREAD_SPECIFIC_STORAGE)
        -: 2927:ACE_INLINE int
        -: 2928:ACE_OS::thr_getspecific_native (ACE_OS_thread_key_t key, void **data)
        -: 2929:{
        -: 2930://  ACE_OS_TRACE ("ACE_OS::thr_getspecific_native");
        -: 2931:# if defined (ACE_HAS_PTHREADS)
        -: 2932:    *data = pthread_getspecific (key);
        -: 2933:    return 0;
        -: 2934:# elif defined (ACE_HAS_STHREADS)
        -: 2935:    int result;
        -: 2936:    ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_getspecific (key, data), result), int, -1);
        -: 2937:# elif defined (ACE_HAS_WTHREADS)
        -: 2938:  *data = ::TlsGetValue (key);
        -: 2939:  if (*data == 0 && ::GetLastError () != NO_ERROR)
        -: 2940:    {
        -: 2941:      ACE_OS::set_errno_to_last_error ();
        -: 2942:      return -1;
        -: 2943:    }
        -: 2944:  else
        -: 2945:    return 0;
        -: 2946:# else /* ACE_HAS_PTHREADS etc.*/
        -: 2947:  ACE_UNUSED_ARG (key);
        -: 2948:  ACE_UNUSED_ARG (data);
        -: 2949:  ACE_NOTSUP_RETURN (-1);
        -: 2950:# endif /* ACE_HAS_PTHREADS etc.*/
        -: 2951:}
        -: 2952:#endif /* ACE_HAS_THREAD_SPECIFIC_STORAGE */
        -: 2953:
        -: 2954:ACE_INLINE int
        -: 2955:ACE_OS::thr_getspecific (ACE_thread_key_t key, void **data)
        -: 2956:{
        -: 2957://   ACE_OS_TRACE ("ACE_OS::thr_getspecific");
        -: 2958:#if defined (ACE_HAS_THREADS)
        -: 2959:# if defined (ACE_HAS_TSS_EMULATION)
        -: 2960:    if (ACE_TSS_Emulation::is_key (key) == 0)
        -: 2961:      {
        -: 2962:        errno = EINVAL;
        -: 2963:        data = 0;
        -: 2964:        return -1;
        -: 2965:      }
        -: 2966:    else
        -: 2967:      {
        -: 2968:        *data = ACE_TSS_Emulation::ts_object (key);
        -: 2969:        return 0;
        -: 2970:      }
        -: 2971:# elif defined (ACE_HAS_THREAD_SPECIFIC_STORAGE)
        -: 2972:  return ACE_OS::thr_getspecific_native (key, data);
        -: 2973:#else
        -: 2974:  ACE_UNUSED_ARG (key);
        -: 2975:  ACE_UNUSED_ARG (data);
        -: 2976:  ACE_NOTSUP_RETURN (-1);
        -: 2977:# endif /* ACE_HAS_TSS_EMULATION */
        -: 2978:#else
        -: 2979:  ACE_UNUSED_ARG (key);
        -: 2980:  ACE_UNUSED_ARG (data);
        -: 2981:  ACE_NOTSUP_RETURN (-1);
        -: 2982:#endif /* ACE_HAS_THREADS */
        -: 2983:}
        -: 2984:
        -: 2985:#if !defined (ACE_HAS_VXTHREADS)
        -: 2986:ACE_INLINE int
        -: 2987:ACE_OS::thr_join (ACE_hthread_t thr_handle,
        -: 2988:                  ACE_THR_FUNC_RETURN *status)
        -: 2989:{
        -: 2990:  ACE_OS_TRACE ("ACE_OS::thr_join");
        -: 2991:#if defined (ACE_HAS_THREADS)
        -: 2992:# if defined (ACE_HAS_STHREADS)
        -: 2993:  int result;
        -: 2994:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_join (thr_handle, 0, status), result),
        -: 2995:                     int, -1);
        -: 2996:# elif defined (ACE_HAS_PTHREADS)
        -: 2997:#  if defined (ACE_LACKS_PTHREAD_JOIN)
        -: 2998:  ACE_UNUSED_ARG (thr_handle);
        -: 2999:  ACE_UNUSED_ARG (status);
        -: 3000:  ACE_NOTSUP_RETURN (-1);
        -: 3001:#  else
        -: 3002:  int result;
        -: 3003:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_join (thr_handle, status), result),
        -: 3004:                     int, -1);
        -: 3005:#  endif /* ACE_LACKS_PTHREAD_JOIN */
        -: 3006:# elif defined (ACE_HAS_WTHREADS)
        -: 3007:  ACE_THR_FUNC_RETURN local_status = 0;
        -: 3008:
        -: 3009:  // Make sure that status is non-NULL.
        -: 3010:  if (status == 0)
        -: 3011:    status = &local_status;
        -: 3012:
        -: 3013:  if (::WaitForSingleObject (thr_handle, INFINITE) == WAIT_OBJECT_0
        -: 3014:      && ::GetExitCodeThread (thr_handle, status) != FALSE)
        -: 3015:    {
        -: 3016:      ::CloseHandle (thr_handle);
        -: 3017:      return 0;
        -: 3018:    }
        -: 3019:  ACE_FAIL_RETURN (-1);
        -: 3020:  /* NOTREACHED */
        -: 3021:# else
        -: 3022:  ACE_UNUSED_ARG (thr_handle);
        -: 3023:  ACE_UNUSED_ARG (status);
        -: 3024:  ACE_NOTSUP_RETURN (-1);
        -: 3025:# endif /* ACE_HAS_STHREADS */
        -: 3026:#else
        -: 3027:  ACE_UNUSED_ARG (thr_handle);
        -: 3028:  ACE_UNUSED_ARG (status);
        -: 3029:  ACE_NOTSUP_RETURN (-1);
        -: 3030:#endif /* ACE_HAS_THREADS */
        -: 3031:}
        -: 3032:
        -: 3033:ACE_INLINE int
        -: 3034:ACE_OS::thr_join (ACE_thread_t waiter_id,
        -: 3035:                  ACE_thread_t *thr_id,
        -: 3036:                  ACE_THR_FUNC_RETURN *status)
        -: 3037:{
        -: 3038:  ACE_OS_TRACE ("ACE_OS::thr_join");
        -: 3039:#if defined (ACE_HAS_THREADS)
        -: 3040:# if defined (ACE_HAS_STHREADS)
        -: 3041:  int result;
        -: 3042:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_join (waiter_id, thr_id, status), result),
        -: 3043:                     int, -1);
        -: 3044:# elif defined (ACE_HAS_PTHREADS)
        -: 3045:#  if defined (ACE_LACKS_PTHREAD_JOIN)
        -: 3046:  ACE_UNUSED_ARG (waiter_id);
        -: 3047:  ACE_UNUSED_ARG (thr_id);
        -: 3048:  ACE_UNUSED_ARG (status);
        -: 3049:  ACE_NOTSUP_RETURN (-1);
        -: 3050:#  else
        -: 3051:  ACE_UNUSED_ARG (thr_id);
        -: 3052:  int result;
        -: 3053:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_join (waiter_id, status), result),
        -: 3054:                     int, -1);
        -: 3055:#  endif /* ACE_LACKS_PTHREAD_JOIN */
        -: 3056:# elif defined (ACE_HAS_WTHREADS)
        -: 3057:  ACE_UNUSED_ARG (waiter_id);
        -: 3058:  ACE_UNUSED_ARG (thr_id);
        -: 3059:  ACE_UNUSED_ARG (status);
        -: 3060:
        -: 3061:  // This could be implemented if the DLL-Main function or the
        -: 3062:  // task exit base class some log the threads which have exited
        -: 3063:  ACE_NOTSUP_RETURN (-1);
        -: 3064:# endif /* ACE_HAS_STHREADS */
        -: 3065:#else
        -: 3066:  ACE_UNUSED_ARG (waiter_id);
        -: 3067:  ACE_UNUSED_ARG (thr_id);
        -: 3068:  ACE_UNUSED_ARG (status);
        -: 3069:  ACE_NOTSUP_RETURN (-1);
        -: 3070:#endif /* ACE_HAS_THREADS */
        -: 3071:}
        -: 3072:#endif /* !VXWORKS */
        -: 3073:
        -: 3074:ACE_INLINE int
        -: 3075:ACE_OS::thr_kill (ACE_thread_t thr_id, int signum)
        -: 3076:{
        -: 3077:  ACE_OS_TRACE ("ACE_OS::thr_kill");
        -: 3078:#if defined (ACE_HAS_THREADS)
        -: 3079:# if defined (ACE_HAS_PTHREADS)
        -: 3080:#   if defined (ACE_LACKS_PTHREAD_KILL)
        -: 3081:  ACE_UNUSED_ARG (signum);
        -: 3082:  ACE_UNUSED_ARG (thr_id);
        -: 3083:  ACE_NOTSUP_RETURN (-1);
        -: 3084:#   else
        -: 3085:  int result;
        -: 3086:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_kill (thr_id, signum),
        -: 3087:                                       result),
        -: 3088:                     int, -1);
        -: 3089:#   endif /* ACE_LACKS_PTHREAD_KILL */
        -: 3090:# elif defined (ACE_HAS_STHREADS)
        -: 3091:  int result;
        -: 3092:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_kill (thr_id, signum),
        -: 3093:                                       result),
        -: 3094:                     int, -1);
        -: 3095:# elif defined (ACE_HAS_VXTHREADS)
        -: 3096:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3097:  ACE_OSCALL_RETURN (::kill (thr_id, signum), int, -1);
        -: 3098:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3099:# else
        -: 3100:  ACE_UNUSED_ARG (thr_id);
        -: 3101:  ACE_UNUSED_ARG (signum);
        -: 3102:  ACE_NOTSUP_RETURN (-1);
        -: 3103:# endif /* ACE_HAS_STHREADS */
        -: 3104:#else
        -: 3105:  ACE_UNUSED_ARG (thr_id);
        -: 3106:  ACE_UNUSED_ARG (signum);
        -: 3107:  ACE_NOTSUP_RETURN (-1);
        -: 3108:#endif /* ACE_HAS_THREADS */
        -: 3109:}
        -: 3110:
        -: 3111:ACE_INLINE size_t
        -: 3112:ACE_OS::thr_min_stack (void)
        -: 3113:{
        -: 3114:  ACE_OS_TRACE ("ACE_OS::thr_min_stack");
        -: 3115:#if defined (ACE_HAS_THREADS)
        -: 3116:# if defined (ACE_HAS_STHREADS)
        -: 3117:#   if defined (ACE_HAS_THR_MINSTACK)
        -: 3118:  // Tandem did some weirdo mangling of STHREAD names...
        -: 3119:  return ::thr_minstack ();
        -: 3120:#   else
        -: 3121:  return ::thr_min_stack ();
        -: 3122:#   endif /* !ACE_HAS_THR_MINSTACK */
        -: 3123:# elif defined (ACE_HAS_PTHREADS)
        -: 3124:#   if defined (_SC_THREAD_STACK_MIN)
        -: 3125:  return (size_t) ACE_OS::sysconf (_SC_THREAD_STACK_MIN);
        -: 3126:#   elif defined (PTHREAD_STACK_MIN)
        -: 3127:  return PTHREAD_STACK_MIN;
        -: 3128:#   else
        -: 3129:  ACE_NOTSUP_RETURN (0);
        -: 3130:#   endif /* _SC_THREAD_STACK_MIN */
        -: 3131:# elif defined (ACE_HAS_WTHREADS)
        -: 3132:  ACE_NOTSUP_RETURN (0);
        -: 3133:# elif defined (ACE_HAS_VXTHREADS)
        -: 3134:  TASK_DESC taskDesc;
        -: 3135:  STATUS status;
        -: 3136:
        -: 3137:  ACE_thread_t tid = ACE_OS::thr_self ();
        -: 3138:
        -: 3139:  ACE_OSCALL (ACE_ADAPT_RETVAL (::taskInfoGet (tid, &taskDesc),
        -: 3140:                                status),
        -: 3141:              STATUS, -1, status);
        -: 3142:  return status == OK ? taskDesc.td_stackSize : 0;
        -: 3143:# else /* Should not happen... */
        -: 3144:  ACE_NOTSUP_RETURN (0);
        -: 3145:# endif /* ACE_HAS_STHREADS */
        -: 3146:#else
        -: 3147:  ACE_NOTSUP_RETURN (0);
        -: 3148:#endif /* ACE_HAS_THREADS */
        -: 3149:}
        -: 3150:
        -: 3151:ACE_INLINE ssize_t
        -: 3152:ACE_OS::thr_id (char buffer[], size_t buffer_length)
        -: 3153:{
        -: 3154:#if defined (ACE_WIN32)
        -: 3155:  return ACE_OS::snprintf (buffer,
        -: 3156:                           buffer_length,
        -: 3157:                           "%u",
        -: 3158:                           static_cast <unsigned> (ACE_OS::thr_self ()));
        -: 3159:#else /* ACE_WIN32 */
        -: 3160:  ACE_hthread_t t_id;
        -: 3161:  ACE_OS::thr_self (t_id);
        -: 3162:#if defined(ACE_HAS_OPAQUE_PTHREAD_T)
        -: 3163:  return ACE_OS::snprintf (buffer,
        -: 3164:                           buffer_length,
        -: 3165:                           "%s",
        -: 3166:                           "<unknown>");
        -: 3167:#else /* ACE_HAS_OPAQUE_PTHREAD_T */
        -: 3168:  return ACE_OS::snprintf (buffer,
        -: 3169:                           buffer_length,
        -: 3170:                           "%lu",
        -: 3171:                           (unsigned long) t_id);
        -: 3172:#endif /* ACE_HAS_OPAQUE_PTHREAD_T */
        -: 3173:#endif /* WIN32 */
        -: 3174:}
        -: 3175:
        -: 3176:ACE_INLINE ACE_thread_t
        -: 3177:ACE_OS::thr_self (void)
        -: 3178:{
        -: 3179:  // ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3180:#if defined (ACE_HAS_THREADS)
        -: 3181:# if defined (ACE_HAS_PTHREADS)
        -: 3182:  // Note, don't use "::" here since the following call is often a macro.
        -: 3183:  return pthread_self ();
        -: 3184:# elif defined (ACE_HAS_STHREADS)
        -: 3185:  ACE_OSCALL_RETURN (::thr_self (), int, -1);
        -: 3186:# elif defined (ACE_HAS_WTHREADS)
        -: 3187:  return ::GetCurrentThreadId ();
        -: 3188:# elif defined (ACE_HAS_VXTHREADS)
        -: 3189:  return ::taskIdSelf ();
        -: 3190:# endif /* ACE_HAS_STHREADS */
        -: 3191:#else
        -: 3192:  return 1; // Might as well make it the first thread ;-)
        -: 3193:#endif /* ACE_HAS_THREADS */
        -: 3194:}
        -: 3195:
        -: 3196:ACE_INLINE const char*
        -: 3197:ACE_OS::thr_name (void)
        -: 3198:{
        -: 3199:#if defined (ACE_HAS_THREADS)
        -: 3200:#if defined (ACE_HAS_VXTHREADS)
        -: 3201:  return ::taskName (ACE_OS::thr_self ());
        -: 3202:#else
        -: 3203:  ACE_NOTSUP_RETURN (0);
        -: 3204:#endif
        -: 3205:#else
        -: 3206:  ACE_NOTSUP_RETURN (0);
        -: 3207:#endif
        -: 3208:}
        -: 3209:
        -: 3210:ACE_INLINE void
        -: 3211:ACE_OS::thr_self (ACE_hthread_t &self)
        -: 3212:{
        -: 3213:  ACE_OS_TRACE ("ACE_OS::thr_self");
        -: 3214:#if defined (ACE_HAS_THREADS)
        -: 3215:# if defined (ACE_HAS_PTHREADS)
        -: 3216:  // Note, don't use "::" here since the following call is often a macro.
        -: 3217:  self = pthread_self ();
        -: 3218:# elif defined (ACE_HAS_THREAD_SELF)
        -: 3219:  self = ::thread_self ();
        -: 3220:# elif defined (ACE_HAS_STHREADS)
        -: 3221:  self = ::thr_self ();
        -: 3222:# elif defined (ACE_HAS_WTHREADS)
        -: 3223:  self = ::GetCurrentThread ();
        -: 3224:# elif defined (ACE_HAS_VXTHREADS)
        -: 3225:  self = ::taskIdSelf ();
        -: 3226:# endif /* ACE_HAS_STHREADS */
        -: 3227:#else
        -: 3228:  self = 1; // Might as well make it the main thread ;-)
        -: 3229:#endif /* ACE_HAS_THREADS */
        -: 3230:}
        -: 3231:
        -: 3232:ACE_INLINE int
        -: 3233:ACE_OS::thr_setcancelstate (int new_state, int *old_state)
        -: 3234:{
        -: 3235:  ACE_OS_TRACE ("ACE_OS::thr_setcancelstate");
        -: 3236:#if defined (ACE_HAS_THREADS)
        -: 3237:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 3238:  int result;
        -: 3239:  int local_new, local_old;
        -: 3240:  switch (new_state)
        -: 3241:    {
        -: 3242:    case THR_CANCEL_ENABLE:
        -: 3243:      local_new = PTHREAD_CANCEL_ENABLE;
        -: 3244:      break;
        -: 3245:    case THR_CANCEL_DISABLE:
        -: 3246:      local_new = PTHREAD_CANCEL_DISABLE;
        -: 3247:      break;
        -: 3248:    default:
        -: 3249:      errno = EINVAL;
        -: 3250:      return -1;
        -: 3251:    }
        -: 3252:  ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_setcancelstate (local_new,
        -: 3253:                                                        &local_old),
        -: 3254:                                result),
        -: 3255:              int, -1, result);
        -: 3256:  if (result == -1)
        -: 3257:    return -1;
        -: 3258:  switch (local_old)
        -: 3259:    {
        -: 3260:    case PTHREAD_CANCEL_ENABLE:
        -: 3261:      *old_state = THR_CANCEL_ENABLE;
        -: 3262:      break;
        -: 3263:    case PTHREAD_CANCEL_DISABLE:
        -: 3264:      *old_state = THR_CANCEL_DISABLE;
        -: 3265:      break;
        -: 3266:    }
        -: 3267:  return result;
        -: 3268:# elif defined (ACE_HAS_STHREADS)
        -: 3269:  ACE_UNUSED_ARG (new_state);
        -: 3270:  ACE_UNUSED_ARG (old_state);
        -: 3271:  ACE_NOTSUP_RETURN (-1);
        -: 3272:# elif defined (ACE_HAS_WTHREADS)
        -: 3273:  ACE_UNUSED_ARG (new_state);
        -: 3274:  ACE_UNUSED_ARG (old_state);
        -: 3275:  ACE_NOTSUP_RETURN (-1);
        -: 3276:# else /* Could be ACE_HAS_PTHREADS && ACE_LACKS_PTHREAD_CANCEL */
        -: 3277:  ACE_UNUSED_ARG (new_state);
        -: 3278:  ACE_UNUSED_ARG (old_state);
        -: 3279:  ACE_NOTSUP_RETURN (-1);
        -: 3280:# endif /* ACE_HAS_PTHREADS */
        -: 3281:#else
        -: 3282:  ACE_UNUSED_ARG (new_state);
        -: 3283:  ACE_UNUSED_ARG (old_state);
        -: 3284:  ACE_NOTSUP_RETURN (-1);
        -: 3285:#endif /* ACE_HAS_THREADS */
        -: 3286:}
        -: 3287:
        -: 3288:ACE_INLINE int
        -: 3289:ACE_OS::thr_setcanceltype (int new_type, int *old_type)
        -: 3290:{
        -: 3291:  ACE_OS_TRACE ("ACE_OS::thr_setcanceltype");
        -: 3292:#if defined (ACE_HAS_THREADS)
        -: 3293:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 3294:  int result;
        -: 3295:  int local_new, local_old;
        -: 3296:  switch (new_type)
        -: 3297:    {
        -: 3298:    case THR_CANCEL_DEFERRED:
        -: 3299:      local_new = PTHREAD_CANCEL_DEFERRED;
        -: 3300:      break;
        -: 3301:    case THR_CANCEL_ASYNCHRONOUS:
        -: 3302:      local_new = PTHREAD_CANCEL_ASYNCHRONOUS;
        -: 3303:      break;
        -: 3304:    default:
        -: 3305:      errno = EINVAL;
        -: 3306:      return -1;
        -: 3307:    }
        -: 3308:  ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_setcanceltype (local_new,
        -: 3309:                                                       &local_old),
        -: 3310:                                result),
        -: 3311:              int, -1, result);
        -: 3312:  if (result == -1)
        -: 3313:    return -1;
        -: 3314:  switch (local_old)
        -: 3315:    {
        -: 3316:    case PTHREAD_CANCEL_DEFERRED:
        -: 3317:      *old_type = THR_CANCEL_DEFERRED;
        -: 3318:      break;
        -: 3319:    case PTHREAD_CANCEL_ASYNCHRONOUS:
        -: 3320:      *old_type = THR_CANCEL_ASYNCHRONOUS;
        -: 3321:      break;
        -: 3322:    }
        -: 3323:  return result;
        -: 3324:# else /* Could be ACE_HAS_PTHREADS && ACE_LACKS_PTHREAD_CANCEL */
        -: 3325:  ACE_UNUSED_ARG (new_type);
        -: 3326:  ACE_UNUSED_ARG (old_type);
        -: 3327:  ACE_NOTSUP_RETURN (-1);
        -: 3328:# endif /* ACE_HAS_PTHREADS */
        -: 3329:#else
        -: 3330:  ACE_UNUSED_ARG (new_type);
        -: 3331:  ACE_UNUSED_ARG (old_type);
        -: 3332:  ACE_NOTSUP_RETURN (-1);
        -: 3333:#endif /* ACE_HAS_THREADS */
        -: 3334:}
        -: 3335:
        -: 3336:ACE_INLINE int
        -: 3337:ACE_OS::thr_setconcurrency (int hint)
        -: 3338:{
        -: 3339:  ACE_OS_TRACE ("ACE_OS::thr_setconcurrency");
        -: 3340:#if defined (ACE_HAS_THREADS)
        -: 3341:# if defined (ACE_HAS_STHREADS)
        -: 3342:  int result;
        -: 3343:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_setconcurrency (hint),
        -: 3344:                                       result),
        -: 3345:                     int, -1);
        -: 3346:# elif defined (ACE_HAS_PTHREADS) && defined (ACE_HAS_PTHREAD_SETCONCURRENCY)
        -: 3347:  int result;
        -: 3348:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_setconcurrency (hint),
        -: 3349:                                       result),
        -: 3350:                     int, -1);
        -: 3351:# else
        -: 3352:  ACE_UNUSED_ARG (hint);
        -: 3353:  ACE_NOTSUP_RETURN (-1);
        -: 3354:# endif /* ACE_HAS_STHREADS */
        -: 3355:#else
        -: 3356:  ACE_UNUSED_ARG (hint);
        -: 3357:  ACE_NOTSUP_RETURN (-1);
        -: 3358:#endif /* ACE_HAS_THREADS */
        -: 3359:}
        -: 3360:
        -: 3361:ACE_INLINE int
        -: 3362:ACE_OS::thr_setprio (ACE_hthread_t ht_id, int priority, int policy)
        -: 3363:{
        -: 3364:  ACE_OS_TRACE ("ACE_OS::thr_setprio");
        -: 3365:  ACE_UNUSED_ARG (policy);
        -: 3366:#if defined (ACE_HAS_THREADS)
        -: 3367:# if (defined (ACE_HAS_PTHREADS) && \
        -: 3368:      (!defined (ACE_LACKS_SETSCHED) || defined (ACE_HAS_PTHREAD_SCHEDPARAM)))
        -: 3369:
        -: 3370:  int result;
        -: 3371:  struct sched_param param;
        -: 3372:  ACE_OS::memset ((void *) &param, 0, sizeof param);
        -: 3373:
        -: 3374:  // If <policy> is -1, we don't want to use it for
        -: 3375:  // pthread_setschedparam().  Instead, obtain policy from
        -: 3376:  // pthread_getschedparam().
        -: 3377:  if (policy == -1)
        -: 3378:    {
        -: 3379:      ACE_OSCALL (ACE_ADAPT_RETVAL (pthread_getschedparam (ht_id, &policy, &param),
        -: 3380:                                    result),
        -: 3381:                  int, -1, result);
        -: 3382:      if (result == -1)
        -: 3383:        return result;
        -: 3384:    }
        -: 3385:
        -: 3386:  param.sched_priority = priority;
        -: 3387:
        -: 3388:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_setschedparam (ht_id,
        -: 3389:                                                              policy,
        -: 3390:                                                              &param),
        -: 3391:                                       result),
        -: 3392:                     int, -1);
        -: 3393:# elif defined (ACE_HAS_STHREADS)
        -: 3394:  int result;
        -: 3395:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_setprio (ht_id, priority),
        -: 3396:                                       result),
        -: 3397:                     int, -1);
        -: 3398:# elif defined (ACE_HAS_WTHREADS)
        -: 3399:
        -: 3400:#   if defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY)
        -: 3401:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::CeSetThreadPriority (ht_id, priority),
        -: 3402:                                          ace_result_),
        -: 3403:                        int, -1);
        -: 3404:#   else
        -: 3405:  ACE_WIN32CALL_RETURN (ACE_ADAPT_RETVAL (::SetThreadPriority (ht_id, priority),
        -: 3406:                                          ace_result_),
        -: 3407:                        int, -1);
        -: 3408:#   endif /* defined (ACE_HAS_WINCE) && !defined (ACE_LACKS_CE_THREAD_PRIORITY) */
        -: 3409:
        -: 3410:# elif defined (ACE_HAS_VXTHREADS)
        -: 3411:  ACE_OSCALL_RETURN (::taskPrioritySet (ht_id, priority), int, -1);
        -: 3412:# else
        -: 3413:  // For example, platforms that support Pthreads but LACK_SETSCHED.
        -: 3414:  ACE_UNUSED_ARG (ht_id);
        -: 3415:  ACE_UNUSED_ARG (priority);
        -: 3416:  ACE_NOTSUP_RETURN (-1);
        -: 3417:# endif /* ACE_HAS_STHREADS */
        -: 3418:#else
        -: 3419:  ACE_UNUSED_ARG (ht_id);
        -: 3420:  ACE_UNUSED_ARG (priority);
        -: 3421:  ACE_NOTSUP_RETURN (-1);
        -: 3422:#endif /* ACE_HAS_THREADS */
        -: 3423:}
        -: 3424:
        -: 3425:ACE_INLINE int
        -: 3426:ACE_OS::thr_sigsetmask (int how,
        -: 3427:                        const sigset_t *nsm,
        -: 3428:                        sigset_t *osm)
        -: 3429:{
        -: 3430:  ACE_OS_TRACE ("ACE_OS::thr_sigsetmask");
        -: 3431:#if defined (ACE_HAS_THREADS)
        -: 3432:# if defined (ACE_LACKS_PTHREAD_THR_SIGSETMASK)
        -: 3433:  // DCE threads and Solaris 2.4 have no such function.
        -: 3434:  ACE_UNUSED_ARG (osm);
        -: 3435:  ACE_UNUSED_ARG (nsm);
        -: 3436:  ACE_UNUSED_ARG (how);
        -: 3437:
        -: 3438:  ACE_NOTSUP_RETURN (-1);
        -: 3439:# elif defined (ACE_HAS_SIGTHREADMASK)
        -: 3440:  int result;
        -: 3441:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::sigthreadmask (how, nsm, osm),
        -: 3442:                                       result), int, -1);
        -: 3443:# elif defined (ACE_HAS_STHREADS)
        -: 3444:  int result;
        -: 3445:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_sigsetmask (how, nsm, osm),
        -: 3446:                                       result),
        -: 3447:                     int, -1);
        -: 3448:# elif defined (ACE_HAS_PTHREADS)
        -: 3449:#   if !defined (ACE_LACKS_PTHREAD_SIGMASK)
        -: 3450:  int result;
        -: 3451:  //FUZZ: disable check_for_lack_ACE_OS
        -: 3452:#    if defined (ACE_HAS_NONCONST_PTHREAD_SIGMASK)
        -: 3453:  sigset_t *ncnsm = const_cast<sigset_t *>(nsm);
        -: 3454:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, ncnsm, osm),
        -: 3455:                                       result),
        -: 3456:                     int,
        -: 3457:                     -1);
        -: 3458:#    else
        -: 3459:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::pthread_sigmask (how, nsm, osm),
        -: 3460:                                       result),
        -: 3461:                     int,
        -: 3462:                     -1);
        -: 3463:#    endif /* ACE_HAS_NONCONST__PTHREAD_SIGMASK */
        -: 3464:  //FUZZ: enable check_for_lack_ACE_OS
        -: 3465:#   endif /* !ACE_LACKS_PTHREAD_SIGMASK */
        -: 3466:
        -: 3467:# elif defined (ACE_HAS_WTHREADS)
        -: 3468:  ACE_UNUSED_ARG (osm);
        -: 3469:  ACE_UNUSED_ARG (nsm);
        -: 3470:  ACE_UNUSED_ARG (how);
        -: 3471:
        -: 3472:  ACE_NOTSUP_RETURN (-1);
        -: 3473:# elif defined (ACE_VXWORKS)
        -: 3474:  int old_mask = 0;
        -: 3475:  switch (how)
        -: 3476:    {
        -: 3477:    case SIG_BLOCK:
        -: 3478:    case SIG_UNBLOCK:
        -: 3479:      {
        -: 3480:        // get the old mask
        -: 3481:        old_mask = ::sigsetmask (*nsm);
        -: 3482:        // create a new mask:  the following assumes that sigset_t is 4 bytes,
        -: 3483:        // which it is on VxWorks 5.2, so bit operations are done simply . . .
        -: 3484:        ::sigsetmask (how == SIG_BLOCK ? (old_mask |= *nsm) : (old_mask &= ~*nsm));
        -: 3485:        if (osm)
        -: 3486:          *osm = old_mask;
        -: 3487:        break;
        -: 3488:      }
        -: 3489:    case SIG_SETMASK:
        -: 3490:      old_mask = ::sigsetmask (*nsm);
        -: 3491:      if (osm)
        -: 3492:        *osm = old_mask;
        -: 3493:      break;
        -: 3494:    default:
        -: 3495:      return -1;
        -: 3496:    }
        -: 3497:
        -: 3498:  return 0;
        -: 3499:# else /* Should not happen. */
        -: 3500:  ACE_UNUSED_ARG (how);
        -: 3501:  ACE_UNUSED_ARG (nsm);
        -: 3502:  ACE_UNUSED_ARG (osm);
        -: 3503:  ACE_NOTSUP_RETURN (-1);
        -: 3504:# endif /* ACE_LACKS_PTHREAD_THR_SIGSETMASK */
        -: 3505:#else
        -: 3506:  ACE_UNUSED_ARG (how);
        -: 3507:  ACE_UNUSED_ARG (nsm);
        -: 3508:  ACE_UNUSED_ARG (osm);
        -: 3509:  ACE_NOTSUP_RETURN (-1);
        -: 3510:#endif /* ACE_HAS_THREADS */
        -: 3511:}
        -: 3512:
        -: 3513:ACE_INLINE int
        -: 3514:ACE_OS::thr_suspend (ACE_hthread_t target_thread)
        -: 3515:{
        -: 3516:  ACE_OS_TRACE ("ACE_OS::thr_suspend");
        -: 3517:#if defined (ACE_HAS_THREADS)
        -: 3518:# if defined (ACE_HAS_STHREADS)
        -: 3519:  int result;
        -: 3520:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (::thr_suspend (target_thread), result), int, -1);
        -: 3521:# elif defined (ACE_HAS_PTHREADS)
        -: 3522:#  if defined (ACE_HAS_PTHREAD_SUSPEND)
        -: 3523:  int result;
        -: 3524:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_suspend (target_thread),
        -: 3525:                                       result),
        -: 3526:                     int, -1);
        -: 3527:#  elif defined (ACE_HAS_PTHREAD_SUSPEND_NP)
        -: 3528:  int result;
        -: 3529:  ACE_OSCALL_RETURN (ACE_ADAPT_RETVAL (pthread_suspend_np (target_thread),
        -: 3530:                                       result),
        -: 3531:                     int, -1);
        -: 3532:#  else
        -: 3533:  ACE_UNUSED_ARG (target_thread);
        -: 3534:  ACE_NOTSUP_RETURN (-1);
        -: 3535:#  endif /* ACE_HAS_PTHREAD_SUSPEND */
        -: 3536:# elif defined (ACE_HAS_WTHREADS)
        -: 3537:  if (::SuspendThread (target_thread) != ACE_SYSCALL_FAILED)
        -: 3538:    return 0;
        -: 3539:  else
        -: 3540:    ACE_FAIL_RETURN (-1);
        -: 3541:  /* NOTREACHED */
        -: 3542:# elif defined (ACE_HAS_VXTHREADS)
        -: 3543:  ACE_OSCALL_RETURN (::taskSuspend (target_thread), int, -1);
        -: 3544:# endif /* ACE_HAS_STHREADS */
        -: 3545:#else
        -: 3546:  ACE_UNUSED_ARG (target_thread);
        -: 3547:  ACE_NOTSUP_RETURN (-1);
        -: 3548:#endif /* ACE_HAS_THREADS */
        -: 3549:}
        -: 3550:
        -: 3551:ACE_INLINE void
        -: 3552:ACE_OS::thr_testcancel (void)
        -: 3553:{
        -: 3554:  ACE_OS_TRACE ("ACE_OS::thr_testcancel");
        -: 3555:#if defined (ACE_HAS_THREADS)
        -: 3556:# if defined (ACE_HAS_PTHREADS) && !defined (ACE_LACKS_PTHREAD_CANCEL)
        -: 3557:  pthread_testcancel ();
        -: 3558:# elif defined (ACE_HAS_STHREADS)
        -: 3559:# elif defined (ACE_HAS_WTHREADS)
        -: 3560:# elif defined (ACE_HAS_VXTHREADS)
        -: 3561:# else
        -: 3562:  // no-op:  can't use ACE_NOTSUP_RETURN because there is no return value
        -: 3563:# endif /* ACE_HAS_PTHREADS */
        -: 3564:#else
        -: 3565:#endif /* ACE_HAS_THREADS */
        -: 3566:}
        -: 3567:
        -: 3568:ACE_INLINE void
        -: 3569:ACE_OS::thr_yield (void)
        -: 3570:{
        -: 3571:  ACE_OS_TRACE ("ACE_OS::thr_yield");
        -: 3572:#if defined (ACE_HAS_THREADS)
        -: 3573:# if defined (ACE_HAS_PTHREADS)
        -: 3574:  ::sched_yield ();
        -: 3575:# elif defined (ACE_HAS_STHREADS)
        -: 3576:  ::thr_yield ();
        -: 3577:# elif defined (ACE_HAS_WTHREADS)
        -: 3578:  ::Sleep (0);
        -: 3579:# elif defined (ACE_HAS_VXTHREADS)
        -: 3580:  // An argument of 0 to ::taskDelay doesn't appear to yield the
        -: 3581:  // current thread.
        -: 3582:  // Now, it does seem to work.  The context_switch_time test
        -: 3583:  // works fine with task_delay set to 0.
        -: 3584:  ::taskDelay (0);
        -: 3585:# endif /* ACE_HAS_STHREADS */
        -: 3586:#else
        -: 3587:  ;
        -: 3588:#endif /* ACE_HAS_THREADS */
        -: 3589:}
        -: 3590:
        -: 3591:ACE_INLINE int
        -: 3592:ACE_OS::thread_mutex_destroy (ACE_thread_mutex_t *m)
        -: 3593:{
        -: 3594:  ACE_OS_TRACE ("ACE_OS::thread_mutex_destroy");
        -: 3595:#if defined (ACE_HAS_THREADS)
        -: 3596:# if defined (ACE_HAS_WTHREADS)
        -: 3597:  ::DeleteCriticalSection (m);
        -: 3598:  return 0;
        -: 3599:# else
        -: 3600:  return ACE_OS::mutex_destroy (m);
        -: 3601:# endif /* ACE_HAS_WTHREADS */
        -: 3602:#else
        -: 3603:  ACE_UNUSED_ARG (m);
        -: 3604:  ACE_NOTSUP_RETURN (-1);
        -: 3605:
        -: 3606:#endif /* ACE_HAS_THREADS */
        -: 3607:}
        -: 3608:
        -: 3609:ACE_INLINE int
        -: 3610:ACE_OS::thread_mutex_init (ACE_thread_mutex_t *m,
        -: 3611:                           int lock_type,
        -: 3612:                           const char *name,
        -: 3613:                           ACE_mutexattr_t *arg)
        -: 3614:{
        -: 3615:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_init");
        -: 3616:#if defined (ACE_HAS_THREADS)
        -: 3617:# if defined (ACE_HAS_WTHREADS)
        -: 3618:  ACE_UNUSED_ARG (lock_type);
        -: 3619:  ACE_UNUSED_ARG (name);
        -: 3620:  ACE_UNUSED_ARG (arg);
        -: 3621:
        -: 3622:  ACE_SEH_TRY
        -: 3623:    {
        -: 3624:      ::InitializeCriticalSection (m);
        -: 3625:    }
        -: 3626:  ACE_SEH_EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        -: 3627:    {
        -: 3628:      errno = ENOMEM;
        -: 3629:      return -1;
        -: 3630:    }
        -: 3631:  return 0;
        -: 3632:
        -: 3633:# elif defined (ACE_HAS_STHREADS) || defined (ACE_HAS_PTHREADS)
        -: 3634:  // Force the use of USYNC_THREAD!
        -: 3635:  return ACE_OS::mutex_init (m, USYNC_THREAD, name, arg, 0, lock_type);
        -: 3636:# elif defined (ACE_HAS_VXTHREADS)
        -: 3637:  return mutex_init (m, lock_type, name, arg);
        -: 3638:
        -: 3639:# endif /* ACE_HAS_STHREADS || ACE_HAS_PTHREADS */
        -: 3640:
        -: 3641:#else
        -: 3642:  ACE_UNUSED_ARG (m);
        -: 3643:  ACE_UNUSED_ARG (lock_type);
        -: 3644:  ACE_UNUSED_ARG (name);
        -: 3645:  ACE_UNUSED_ARG (arg);
        -: 3646:  ACE_NOTSUP_RETURN (-1);
        -: 3647:
        -: 3648:#endif /* ACE_HAS_THREADS */
        -: 3649:}
        -: 3650:
        -: 3651:#if defined (ACE_HAS_WCHAR)
        -: 3652:ACE_INLINE int
        -: 3653:ACE_OS::thread_mutex_init (ACE_thread_mutex_t *m,
        -: 3654:                           int lock_type,
        -: 3655:                           const wchar_t *name,
        -: 3656:                           ACE_mutexattr_t *arg)
        -: 3657:{
        -: 3658:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_init");
        -: 3659:#if defined (ACE_HAS_THREADS)
        -: 3660:# if defined (ACE_HAS_WTHREADS)
        -: 3661:  ACE_UNUSED_ARG (lock_type);
        -: 3662:  ACE_UNUSED_ARG (name);
        -: 3663:  ACE_UNUSED_ARG (arg);
        -: 3664:
        -: 3665:  ACE_SEH_TRY
        -: 3666:    {
        -: 3667:      ::InitializeCriticalSection (m);
        -: 3668:    }
        -: 3669:  ACE_SEH_EXCEPT(EXCEPTION_EXECUTE_HANDLER)
        -: 3670:    {
        -: 3671:      errno = ENOMEM;
        -: 3672:      return -1;
        -: 3673:    }
        -: 3674:  return 0;
        -: 3675:
        -: 3676:# elif defined (ACE_HAS_STHREADS) || defined (ACE_HAS_PTHREADS)
        -: 3677:  // Force the use of USYNC_THREAD!
        -: 3678:  return ACE_OS::mutex_init (m, USYNC_THREAD, name, arg, 0, lock_type);
        -: 3679:# elif defined (ACE_HAS_VXTHREADS)
        -: 3680:  return mutex_init (m, lock_type, name, arg);
        -: 3681:# endif /* ACE_HAS_STHREADS || ACE_HAS_PTHREADS */
        -: 3682:#else
        -: 3683:  ACE_UNUSED_ARG (m);
        -: 3684:  ACE_UNUSED_ARG (lock_type);
        -: 3685:  ACE_UNUSED_ARG (name);
        -: 3686:  ACE_UNUSED_ARG (arg);
        -: 3687:  ACE_NOTSUP_RETURN (-1);
        -: 3688:
        -: 3689:#endif /* ACE_HAS_THREADS */
        -: 3690:}
        -: 3691:#endif /* ACE_HAS_WCHAR */
        -: 3692:
        -: 3693:ACE_INLINE int
    #####: 3694:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m)
        -: 3695:{
        -: 3696:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3697:#if defined (ACE_HAS_THREADS)
        -: 3698:# if defined (ACE_HAS_WTHREADS)
        -: 3699:  ::EnterCriticalSection (m);
        -: 3700:  return 0;
        -: 3701:# else
    #####: 3702:  return ACE_OS::mutex_lock (m);
        -: 3703:# endif /* ACE_HAS_WTHREADS */
        -: 3704:#else
        -: 3705:  ACE_UNUSED_ARG (m);
        -: 3706:  ACE_NOTSUP_RETURN (-1);
        -: 3707:#endif /* ACE_HAS_THREADS */
        -: 3708:}
        -: 3709:
        -: 3710:ACE_INLINE int
        -: 3711:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m,
        -: 3712:                           const ACE_Time_Value &timeout)
        -: 3713:{
        -: 3714:  // ACE_OS_TRACE ("ACE_OS::thread_mutex_lock");
        -: 3715:
        -: 3716:  // For all platforms, except MS Windows, this method is equivalent
        -: 3717:  // to calling ACE_OS::mutex_lock() since ACE_thread_mutex_t and
        -: 3718:  // ACE_mutex_t are the same type.  However, those typedefs evaluate
        -: 3719:  // to different types on MS Windows.  The "thread mutex"
        -: 3720:  // implementation in ACE for MS Windows cannot readily support
        -: 3721:  // timeouts due to a lack of timeout features for this type of MS
        -: 3722:  // Windows synchronization mechanism.
        -: 3723:
        -: 3724:#if defined (ACE_HAS_THREADS) && !defined (ACE_HAS_WTHREADS)
        -: 3725:  return ACE_OS::mutex_lock (m, timeout);
        -: 3726:#else
        -: 3727:  ACE_UNUSED_ARG (m);
        -: 3728:  ACE_UNUSED_ARG (timeout);
        -: 3729:  ACE_NOTSUP_RETURN (-1);
        -: 3730:#endif /* ACE_HAS_THREADS */
        -: 3731:}
        -: 3732:
        -: 3733:ACE_INLINE int
        -: 3734:ACE_OS::thread_mutex_lock (ACE_thread_mutex_t *m,
        -: 3735:                           const ACE_Time_Value *timeout)
        -: 3736:{
        -: 3737:  return timeout == 0
        -: 3738:    ? ACE_OS::thread_mutex_lock (m)
        -: 3739:    : ACE_OS::thread_mutex_lock (m, *timeout);
        -: 3740:}
        -: 3741:
        -: 3742:ACE_INLINE int
        -: 3743:ACE_OS::thread_mutex_trylock (ACE_thread_mutex_t *m)
        -: 3744:{
        -: 3745:  ACE_OS_TRACE ("ACE_OS::thread_mutex_trylock");
        -: 3746:
        -: 3747:#if defined (ACE_HAS_THREADS)
        -: 3748:# if defined (ACE_HAS_WTHREADS)
        -: 3749:#   if defined (ACE_HAS_WIN32_TRYLOCK)
        -: 3750:  BOOL result = ::TryEnterCriticalSection (m);
        -: 3751:  if (result == TRUE)
        -: 3752:    {
        -: 3753:      return 0;
        -: 3754:    }
        -: 3755:  else
        -: 3756:    {
        -: 3757:      errno = EBUSY;
        -: 3758:      return -1;
        -: 3759:    }
        -: 3760:#   else
        -: 3761:  ACE_UNUSED_ARG (m);
        -: 3762:  ACE_NOTSUP_RETURN (-1);
        -: 3763:#   endif /* ACE_HAS_WIN32_TRYLOCK */
        -: 3764:# elif defined (ACE_HAS_STHREADS) || defined (ACE_HAS_PTHREADS) || defined (ACE_VXWORKS)
        -: 3765:  return ACE_OS::mutex_trylock (m);
        -: 3766:#endif /* Threads variety case */
        -: 3767:
        -: 3768:#else
        -: 3769:  ACE_UNUSED_ARG (m);
        -: 3770:  ACE_NOTSUP_RETURN (-1);
        -: 3771:#endif /* ACE_HAS_THREADS */
        -: 3772:}
        -: 3773:
        -: 3774:ACE_INLINE int
    #####: 3775:ACE_OS::thread_mutex_unlock (ACE_thread_mutex_t *m)
        -: 3776:{
        -: 3777:  ACE_OS_TRACE ("ACE_OS::thread_mutex_unlock");
        -: 3778:#if defined (ACE_HAS_THREADS)
        -: 3779:# if defined (ACE_HAS_WTHREADS)
        -: 3780:  ::LeaveCriticalSection (m);
        -: 3781:  return 0;
        -: 3782:# else
    #####: 3783:  return ACE_OS::mutex_unlock (m);
        -: 3784:# endif /* ACE_HAS_WTHREADS */
        -: 3785:#else
        -: 3786:  ACE_UNUSED_ARG (m);
        -: 3787:  ACE_NOTSUP_RETURN (-1);
        -: 3788:#endif /* ACE_HAS_THREADS */
        -: 3789:}
        -: 3790:
        -: 3791:/*****************************************************************************/
        -: 3792:
        -: 3793:# if defined (ACE_IS_SPLITTING)
        -: 3794:#   define ACE_SPECIAL_INLINE
        -: 3795:# else
        -: 3796:#   define ACE_SPECIAL_INLINE ACE_INLINE
        -: 3797://#   define ACE_SPECIAL_INLINE inline
        -: 3798:# endif
        -: 3799:
        -: 3800:#if defined (ACE_MT_SAFE) && (ACE_MT_SAFE != 0)
        -: 3801:
        -: 3802:ACE_INLINE
        -: 3803:int
        -: 3804:ACE_OS_Thread_Mutex_Guard::acquire (void)
        -: 3805:{
        -: 3806:  return owner_ = ACE_OS::thread_mutex_lock (&lock_);
        -: 3807:}
        -: 3808:
        -: 3809:ACE_INLINE
        -: 3810:int
        -: 3811:ACE_OS_Thread_Mutex_Guard::release (void)
        -: 3812:{
        -: 3813:  if (owner_ == -1)
        -: 3814:    return 0;
        -: 3815:  else
        -: 3816:    {
        -: 3817:      owner_ = -1;
        -: 3818:      return ACE_OS::thread_mutex_unlock (&lock_);
        -: 3819:    }
        -: 3820:}
        -: 3821:
        -: 3822:ACE_INLINE
        -: 3823:ACE_OS_Thread_Mutex_Guard::ACE_OS_Thread_Mutex_Guard (ACE_thread_mutex_t &m)
        -: 3824:  : lock_ (m), owner_ (-1)
        -: 3825:{
        -: 3826:  if (!ACE_OS_Object_Manager::starting_up ())
        -: 3827:    acquire ();
        -: 3828:}
        -: 3829:
        -: 3830:ACE_INLINE
        -: 3831:ACE_OS_Thread_Mutex_Guard::~ACE_OS_Thread_Mutex_Guard ()
        -: 3832:{
        -: 3833:  release ();
        -: 3834:}
        -: 3835:
        -: 3836:/*****************************************************************************/
        -: 3837:
        -: 3838:ACE_INLINE
        -: 3839:int
        -: 3840:ACE_OS_Recursive_Thread_Mutex_Guard::acquire (void)
        -: 3841:{
        -: 3842:  return owner_ = ACE_OS::recursive_mutex_lock (&lock_);
        -: 3843:}
        -: 3844:
        -: 3845:ACE_INLINE
        -: 3846:int
        -: 3847:ACE_OS_Recursive_Thread_Mutex_Guard::release (void)
        -: 3848:{
        -: 3849:  if (owner_ == -1)
        -: 3850:    return 0;
        -: 3851:  else
        -: 3852:    {
        -: 3853:      owner_ = -1;
        -: 3854:      return ACE_OS::recursive_mutex_unlock (&lock_);
        -: 3855:    }
        -: 3856:}
        -: 3857:
        -: 3858:ACE_INLINE
        -: 3859:ACE_OS_Recursive_Thread_Mutex_Guard::ACE_OS_Recursive_Thread_Mutex_Guard (
        -: 3860:  ACE_recursive_thread_mutex_t &m)
        -: 3861:   : lock_ (m),
        -: 3862:     owner_ (-1)
        -: 3863:{
        -: 3864:  if (!ACE_OS_Object_Manager::starting_up ())
        -: 3865:    acquire ();
        -: 3866:}
        -: 3867:
        -: 3868:ACE_INLINE
        -: 3869:ACE_OS_Recursive_Thread_Mutex_Guard::~ACE_OS_Recursive_Thread_Mutex_Guard ()
        -: 3870:{
        -: 3871:  release ();
        -: 3872:}
        -: 3873:
        -: 3874:#endif /* ACE_MT_SAFE && ACE_MT_SAFE != 0 */
        -: 3875:
        -: 3876:
        -: 3877:/*****************************************************************************/
        -: 3878:
        -: 3879:ACE_INLINE
        -: 3880:ACE_Thread_ID::ACE_Thread_ID (ACE_thread_t thread_id,
        -: 3881:                              ACE_hthread_t thread_handle)
        -: 3882:  : thread_id_ (thread_id),
        -: 3883:    thread_handle_ (thread_handle)
        -: 3884:{
        -: 3885:}
        -: 3886:
        -: 3887:ACE_INLINE
        -: 3888:ACE_Thread_ID::ACE_Thread_ID (const ACE_Thread_ID &id)
        -: 3889:  : thread_id_ (id.thread_id_),
        -: 3890:    thread_handle_ (id.thread_handle_)
        -: 3891:{
        -: 3892:}
        -: 3893:
        -: 3894:ACE_INLINE
        -: 3895:ACE_Thread_ID&
        -: 3896:ACE_Thread_ID::operator= (const ACE_Thread_ID &id)
        -: 3897:{
        -: 3898:  if (this != &id)
        -: 3899:    {
        -: 3900:      this->thread_id_ = id.thread_id_;
        -: 3901:      this->thread_handle_ = id.thread_handle_;
        -: 3902:    }
        -: 3903:  return *this;
        -: 3904:}
        -: 3905:
        -: 3906:ACE_INLINE
        -: 3907:ACE_Thread_ID::ACE_Thread_ID (void)
        -: 3908:  : thread_id_ (ACE_OS::thr_self ())
        -: 3909:{
        -: 3910:  ACE_OS::thr_self (thread_handle_);
        -: 3911:}
        -: 3912:
        -: 3913:ACE_INLINE
        -: 3914:ACE_thread_t
        -: 3915:ACE_Thread_ID::id (void) const
        -: 3916:{
        -: 3917:  return this->thread_id_;
        -: 3918:}
        -: 3919:
        -: 3920:ACE_INLINE void
        -: 3921:ACE_Thread_ID::id (ACE_thread_t thread_id)
        -: 3922:{
        -: 3923:  this->thread_id_ = thread_id;
        -: 3924:}
        -: 3925:
        -: 3926:ACE_INLINE ACE_hthread_t
        -: 3927:ACE_Thread_ID::handle (void) const
        -: 3928:{
        -: 3929:  return this->thread_handle_;
        -: 3930:}
        -: 3931:
        -: 3932:ACE_INLINE void
        -: 3933:ACE_Thread_ID::handle (ACE_hthread_t thread_handle)
        -: 3934:{
        -: 3935:  this->thread_handle_ = thread_handle;
        -: 3936:}
        -: 3937:
        -: 3938:ACE_INLINE bool
        -: 3939:ACE_Thread_ID::operator== (const ACE_Thread_ID &rhs) const
        -: 3940:{
        -: 3941:  return
        -: 3942:    ACE_OS::thr_cmp (this->thread_handle_, rhs.thread_handle_)
        -: 3943:    && ACE_OS::thr_equal (this->thread_id_, rhs.thread_id_);
        -: 3944:}
        -: 3945:
        -: 3946:ACE_INLINE bool
        -: 3947:ACE_Thread_ID::operator!= (const ACE_Thread_ID &rhs) const
        -: 3948:{
        -: 3949:  return !(*this == rhs);
        -: 3950:}
        -: 3951:
        -: 3952:#if !defined (ACE_WIN32)
        -: 3953:
        -: 3954:ACE_INLINE
        -: 3955:ACE_event_t::ACE_event_t (void) :
        -: 3956:  name_ (0),
        -: 3957:  eventdata_ (0)
        -: 3958:{
        -: 3959:}
        -: 3960:
        -: 3961:#endif /* !ACE_WIN32 */
        -: 3962:
        -: 3963:ACE_END_VERSIONED_NAMESPACE_DECL
