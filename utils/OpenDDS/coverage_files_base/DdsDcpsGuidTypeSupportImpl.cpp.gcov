        -:    0:Source:DdsDcpsGuidTypeSupportImpl.cpp
        -:    0:Programs:72
        -:    1:/* Generated by /home/ryan/git/OpenDDS-debloat/bin/opendds_idl version 3.13 (ACE version 6.2a_p15) running on input file DdsDcpsGuid.idl */
        -:    2:#include "DCPS/DdsDcps_pch.h"
        -:    3:#include "DdsDcpsGuidTypeSupportImpl.h"
        -:    4:
        -:    5:#include <cstring>
        -:    6:#include <stdexcept>
        -:    7:#include "dds/DCPS/FilterEvaluator.h"
        -:    8:#include "dds/DCPS/PoolAllocator.h"
        -:    9:
        -:   10:
        -:   11:/* Begin MODULE: CORBA */
        -:   12:
        -:   13:
        -:   14:/* End MODULE: CORBA */
        -:   15:
        -:   16:
        -:   17:/* Begin MODULE: OpenDDS */
        -:   18:
        -:   19:
        -:   20:
        -:   21:/* Begin MODULE: DCPS */
        -:   22:
        -:   23:
        -:   24:
        -:   25:/* Begin TYPEDEF: GuidVendorId_t */
        -:   26:
        -:   27:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   28:namespace OpenDDS { namespace DCPS {
        -:   29:
    #####:   30:void gen_find_size(const OpenDDS::DCPS::GuidVendorId_t_forany& arr, size_t& size, size_t& padding)
        -:   31:{
        -:   32:  ACE_UNUSED_ARG(arr);
        -:   33:  ACE_UNUSED_ARG(size);
        -:   34:  ACE_UNUSED_ARG(padding);
    #####:   35:  size += 2 * max_marshaled_size_octet();
    #####:   36:}
        -:   37:
    #####:   38:bool operator<<(Serializer& strm, const OpenDDS::DCPS::GuidVendorId_t_forany& arr)
        -:   39:{
        -:   40:  ACE_UNUSED_ARG(strm);
        -:   41:  ACE_UNUSED_ARG(arr);
    #####:   42:  return strm.write_octet_array(arr.in(), 2);
        -:   43:}
        -:   44:
    #####:   45:bool operator>>(Serializer& strm, OpenDDS::DCPS::GuidVendorId_t_forany& arr)
        -:   46:{
        -:   47:  ACE_UNUSED_ARG(strm);
        -:   48:  ACE_UNUSED_ARG(arr);
    #####:   49:  return strm.read_octet_array(arr.out(), 2);
        -:   50:}
        -:   51:
        -:   52:}  }
        -:   53:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:   54:
        -:   55:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:   56:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   57:namespace OpenDDS { namespace DCPS {
        -:   58:
    #####:   59:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::GuidVendorId_t_forany*)
        -:   60:{
        -:   61:  ACE_UNUSED_ARG(ser);
    #####:   62:  return ser.skip(static_cast<ACE_UINT16>(2), 1);
        -:   63:}
        -:   64:
        -:   65:}  }
        -:   66:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:   67:
        -:   68:#endif
        -:   69:
        -:   70:/* End TYPEDEF: GuidVendorId_t */
        -:   71:
        -:   72:
        -:   73:/* Begin TYPEDEF: GuidPrefix_t */
        -:   74:
        -:   75:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   76:namespace OpenDDS { namespace DCPS {
        -:   77:
       30:   78:void gen_find_size(const OpenDDS::DCPS::GuidPrefix_t_forany& arr, size_t& size, size_t& padding)
        -:   79:{
        -:   80:  ACE_UNUSED_ARG(arr);
        -:   81:  ACE_UNUSED_ARG(size);
        -:   82:  ACE_UNUSED_ARG(padding);
       30:   83:  size += 12 * max_marshaled_size_octet();
       30:   84:}
        -:   85:
       96:   86:bool operator<<(Serializer& strm, const OpenDDS::DCPS::GuidPrefix_t_forany& arr)
        -:   87:{
        -:   88:  ACE_UNUSED_ARG(strm);
        -:   89:  ACE_UNUSED_ARG(arr);
       96:   90:  return strm.write_octet_array(arr.in(), 12);
        -:   91:}
        -:   92:
       30:   93:bool operator>>(Serializer& strm, OpenDDS::DCPS::GuidPrefix_t_forany& arr)
        -:   94:{
        -:   95:  ACE_UNUSED_ARG(strm);
        -:   96:  ACE_UNUSED_ARG(arr);
       30:   97:  return strm.read_octet_array(arr.out(), 12);
        -:   98:}
        -:   99:
        -:  100:}  }
        -:  101:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  102:
        -:  103:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  104:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  105:namespace OpenDDS { namespace DCPS {
        -:  106:
    #####:  107:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::GuidPrefix_t_forany*)
        -:  108:{
        -:  109:  ACE_UNUSED_ARG(ser);
    #####:  110:  return ser.skip(static_cast<ACE_UINT16>(12), 1);
        -:  111:}
        -:  112:
        -:  113:}  }
        -:  114:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  115:
        -:  116:#endif
        -:  117:
        -:  118:/* End TYPEDEF: GuidPrefix_t */
        -:  119:
        -:  120:
        -:  121:/* Begin TYPEDEF: EntityKey_t */
        -:  122:
        -:  123:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  124:namespace OpenDDS { namespace DCPS {
        -:  125:
       30:  126:void gen_find_size(const OpenDDS::DCPS::EntityKey_t_forany& arr, size_t& size, size_t& padding)
        -:  127:{
        -:  128:  ACE_UNUSED_ARG(arr);
        -:  129:  ACE_UNUSED_ARG(size);
        -:  130:  ACE_UNUSED_ARG(padding);
       30:  131:  size += 3 * max_marshaled_size_octet();
       30:  132:}
        -:  133:
       96:  134:bool operator<<(Serializer& strm, const OpenDDS::DCPS::EntityKey_t_forany& arr)
        -:  135:{
        -:  136:  ACE_UNUSED_ARG(strm);
        -:  137:  ACE_UNUSED_ARG(arr);
       96:  138:  return strm.write_octet_array(arr.in(), 3);
        -:  139:}
        -:  140:
       30:  141:bool operator>>(Serializer& strm, OpenDDS::DCPS::EntityKey_t_forany& arr)
        -:  142:{
        -:  143:  ACE_UNUSED_ARG(strm);
        -:  144:  ACE_UNUSED_ARG(arr);
       30:  145:  return strm.read_octet_array(arr.out(), 3);
        -:  146:}
        -:  147:
        -:  148:}  }
        -:  149:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  150:
        -:  151:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  152:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  153:namespace OpenDDS { namespace DCPS {
        -:  154:
    #####:  155:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::EntityKey_t_forany*)
        -:  156:{
        -:  157:  ACE_UNUSED_ARG(ser);
    #####:  158:  return ser.skip(static_cast<ACE_UINT16>(3), 1);
        -:  159:}
        -:  160:
        -:  161:}  }
        -:  162:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  163:
        -:  164:#endif
        -:  165:
        -:  166:/* End TYPEDEF: EntityKey_t */
        -:  167:
        -:  168:
        -:  169:/* Begin STRUCT: EntityId_t */
        -:  170:
        -:  171:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  172:namespace OpenDDS { namespace DCPS {
        -:  173:
       30:  174:void gen_find_size(const OpenDDS::DCPS::EntityId_t& stru, size_t& size, size_t& padding)
        -:  175:{
        -:  176:  ACE_UNUSED_ARG(stru);
        -:  177:  ACE_UNUSED_ARG(size);
        -:  178:  ACE_UNUSED_ARG(padding);
       60:  179:  OpenDDS::DCPS::EntityKey_t_forany stru_entityKey(const_cast<OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
       30:  180:  gen_find_size(stru_entityKey, size, padding);
       30:  181:  size += gen_max_marshaled_size(ACE_OutputCDR::from_octet(stru.entityKind));
       30:  182:}
        -:  183:
       96:  184:bool operator<<(Serializer& strm, const OpenDDS::DCPS::EntityId_t& stru)
        -:  185:{
        -:  186:  ACE_UNUSED_ARG(strm);
        -:  187:  ACE_UNUSED_ARG(stru);
      192:  188:  OpenDDS::DCPS::EntityKey_t_forany stru_entityKey(const_cast<OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
       96:  189:  return (strm << stru_entityKey)
      192:  190:    && (strm << ACE_OutputCDR::from_octet(stru.entityKind));
        -:  191:}
        -:  192:
       30:  193:bool operator>>(Serializer& strm, OpenDDS::DCPS::EntityId_t& stru)
        -:  194:{
        -:  195:  ACE_UNUSED_ARG(strm);
        -:  196:  ACE_UNUSED_ARG(stru);
       60:  197:  OpenDDS::DCPS::EntityKey_t_forany stru_entityKey(const_cast<OpenDDS::DCPS::EntityKey_t_slice*>(stru.entityKey));
       30:  198:  return (strm >> stru_entityKey)
       60:  199:    && (strm >> ACE_InputCDR::to_octet(stru.entityKind));
        -:  200:}
        -:  201:
        -:  202:}  }
        -:  203:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  204:
        -:  205:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  206:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  207:namespace OpenDDS { namespace DCPS {
        -:  208:
        -:  209:template<>
    #####:  210:struct MetaStructImpl<OpenDDS::DCPS::EntityId_t> : MetaStruct {
        -:  211:  typedef OpenDDS::DCPS::EntityId_t T;
        -:  212:
        -:  213:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  214:  void* allocate() const { return new T; }
        -:  215:
    #####:  216:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:  217:
    #####:  218:  size_t numDcpsKeys() const { return 0; }
        -:  219:
        -:  220:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  221:
    #####:  222:  bool isDcpsKey(const char* field) const
        -:  223:  {
        -:  224:    ACE_UNUSED_ARG(field);
    #####:  225:    return false;
        -:  226:  }
        -:  227:
    #####:  228:  Value getValue(const void* stru, const char* field) const
        -:  229:  {
    #####:  230:    const OpenDDS::DCPS::EntityId_t& typed = *static_cast<const OpenDDS::DCPS::EntityId_t*>(stru);
    #####:  231:    if (std::strcmp(field, "entityKind") == 0) {
    #####:  232:      return typed.entityKind;
        -:  233:    }
        -:  234:    ACE_UNUSED_ARG(typed);
    #####:  235:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::EntityId_t)");
        -:  236:  }
        -:  237:
    #####:  238:  Value getValue(Serializer& ser, const char* field) const
        -:  239:  {
    #####:  240:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityKey_t_forany*>(0))) {
    #####:  241:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -:  242:    }
    #####:  243:    if (std::strcmp(field, "entityKind") == 0) {
        -:  244:      ACE_CDR::Octet val;
    #####:  245:      if (!(ser >> ACE_InputCDR::to_octet(val))) {
    #####:  246:        throw std::runtime_error("Field 'entityKind' could not be deserialized");
        -:  247:      }
    #####:  248:      return val;
        -:  249:    } else {
    #####:  250:      if (!ser.skip(1, 1)) {
    #####:  251:        throw std::runtime_error("Field 'entityKind' could not be skipped");
        -:  252:      }
        -:  253:    }
    #####:  254:    if (!field[0]) {
    #####:  255:      return 0;
        -:  256:    }
    #####:  257:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::EntityId_t");
        -:  258:  }
        -:  259:
    #####:  260:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:  261:  {
        -:  262:    ACE_UNUSED_ARG(next);
    #####:  263:    if (std::strcmp(field, "entityKind") == 0) {
    #####:  264:      return make_field_cmp(&T::entityKind, next);
        -:  265:    }
    #####:  266:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::EntityId_t)");
        -:  267:  }
        -:  268:
        -:  269:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  270:  const char** getFieldNames() const
        -:  271:  {
        -:  272:    static const char* names[] = {"entityKey", "entityKind", 0};
    #####:  273:    return names;
        -:  274:  }
        -:  275:
    #####:  276:  const void* getRawField(const void* stru, const char* field) const
        -:  277:  {
    #####:  278:    if (std::strcmp(field, "entityKey") == 0) {
    #####:  279:      return &static_cast<const T*>(stru)->entityKey;
        -:  280:    }
    #####:  281:    if (std::strcmp(field, "entityKind") == 0) {
    #####:  282:      return &static_cast<const T*>(stru)->entityKind;
        -:  283:    }
    #####:  284:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::EntityId_t)");
        -:  285:  }
        -:  286:
    #####:  287:  void assign(void* lhs, const char* field, const void* rhs,
        -:  288:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:  289:  {
        -:  290:    ACE_UNUSED_ARG(lhs);
        -:  291:    ACE_UNUSED_ARG(field);
        -:  292:    ACE_UNUSED_ARG(rhs);
        -:  293:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:  294:    ACE_UNUSED_ARG(rhsMeta);
    #####:  295:    if (std::strcmp(field, "entityKey") == 0) {
    #####:  296:      OpenDDS::DCPS::EntityKey_t* lhsArr = &static_cast<T*>(lhs)->entityKey;
    #####:  297:      const OpenDDS::DCPS::EntityKey_t* rhsArr = static_cast<const OpenDDS::DCPS::EntityKey_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  298:      for (CORBA::ULong i0 = 0; i0 < 3; ++i0) {
    #####:  299:        (*lhsArr)[i0] = (*rhsArr)[i0];
        -:  300:      }
    #####:  301:      return;
        -:  302:    }
    #####:  303:    if (std::strcmp(field, "entityKind") == 0) {
    #####:  304:      static_cast<T*>(lhs)->entityKind = *static_cast<const CORBA::Octet*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  305:      return;
        -:  306:    }
    #####:  307:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::EntityId_t)");
        -:  308:  }
        -:  309:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  310:
    #####:  311:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:  312:  {
        -:  313:    ACE_UNUSED_ARG(lhs);
        -:  314:    ACE_UNUSED_ARG(field);
        -:  315:    ACE_UNUSED_ARG(rhs);
    #####:  316:    if (std::strcmp(field, "entityKind") == 0) {
    #####:  317:      return static_cast<const T*>(lhs)->entityKind == static_cast<const T*>(rhs)->entityKind;
        -:  318:    }
    #####:  319:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::EntityId_t)");
        -:  320:  }
        -:  321:};
        -:  322:
        -:  323:template<>
    #####:  324:const MetaStruct& getMetaStruct<OpenDDS::DCPS::EntityId_t>()
        -:  325:{
    #####:  326:  static MetaStructImpl<OpenDDS::DCPS::EntityId_t> msi;
    #####:  327:  return msi;
        -:  328:}
        -:  329:
    #####:  330:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::EntityId_t*)
        -:  331:{
        -:  332:  ACE_UNUSED_ARG(ser);
    #####:  333:  MetaStructImpl<OpenDDS::DCPS::EntityId_t>().getValue(ser, "");
    #####:  334:  return true;
        -:  335:}
        -:  336:
        -:  337:}  }
        -:  338:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  339:
        -:  340:#endif
        -:  341:
        -:  342:/* End STRUCT: EntityId_t */
        -:  343:
        -:  344:
        -:  345:/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */
        -:  346:
        -:  347:
        -:  348:/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */
        -:  349:
        -:  350:
        -:  351:/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */
        -:  352:
        -:  353:
        -:  354:/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */
        -:  355:
        -:  356:
        -:  357:/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */
        -:  358:
        -:  359:
        -:  360:/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */
        -:  361:
        -:  362:
        -:  363:/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */
        -:  364:
        -:  365:
        -:  366:/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */
        -:  367:
        -:  368:
        -:  369:/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */
        -:  370:
        -:  371:
        -:  372:/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */
        -:  373:
        -:  374:
        -:  375:/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */
        -:  376:
        -:  377:
        -:  378:/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */
        -:  379:
        -:  380:
        -:  381:/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */
        -:  382:
        -:  383:
        -:  384:/* End CONST: ENTITYKIND_BUILTIN_TOPIC */
        -:  385:
        -:  386:
        -:  387:/* Begin CONST: ENTITYKIND_USER_UNKNOWN */
        -:  388:
        -:  389:
        -:  390:/* End CONST: ENTITYKIND_USER_UNKNOWN */
        -:  391:
        -:  392:
        -:  393:/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */
        -:  394:
        -:  395:
        -:  396:/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */
        -:  397:
        -:  398:
        -:  399:/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */
        -:  400:
        -:  401:
        -:  402:/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */
        -:  403:
        -:  404:
        -:  405:/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */
        -:  406:
        -:  407:
        -:  408:/* End CONST: ENTITYKIND_USER_READER_NO_KEY */
        -:  409:
        -:  410:
        -:  411:/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */
        -:  412:
        -:  413:
        -:  414:/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */
        -:  415:
        -:  416:
        -:  417:/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */
        -:  418:
        -:  419:
        -:  420:/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */
        -:  421:
        -:  422:
        -:  423:/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */
        -:  424:
        -:  425:
        -:  426:/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */
        -:  427:
        -:  428:
        -:  429:/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */
        -:  430:
        -:  431:
        -:  432:/* End CONST: ENTITYKIND_OPENDDS_TOPIC */
        -:  433:
        -:  434:
        -:  435:/* Begin CONST: ENTITYKIND_OPENDDS_USER */
        -:  436:
        -:  437:
        -:  438:/* End CONST: ENTITYKIND_OPENDDS_USER */
        -:  439:
        -:  440:
        -:  441:/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */
        -:  442:
        -:  443:
        -:  444:/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */
        -:  445:
        -:  446:
        -:  447:/* Begin STRUCT: GUID_t */
        -:  448:
        -:  449:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  450:namespace OpenDDS { namespace DCPS {
        -:  451:
       30:  452:void gen_find_size(const OpenDDS::DCPS::GUID_t& stru, size_t& size, size_t& padding)
        -:  453:{
        -:  454:  ACE_UNUSED_ARG(stru);
        -:  455:  ACE_UNUSED_ARG(size);
        -:  456:  ACE_UNUSED_ARG(padding);
       60:  457:  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
       30:  458:  gen_find_size(stru_guidPrefix, size, padding);
       30:  459:  gen_find_size(stru.entityId, size, padding);
       30:  460:}
        -:  461:
       96:  462:bool operator<<(Serializer& strm, const OpenDDS::DCPS::GUID_t& stru)
        -:  463:{
        -:  464:  ACE_UNUSED_ARG(strm);
        -:  465:  ACE_UNUSED_ARG(stru);
      192:  466:  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
       96:  467:  return (strm << stru_guidPrefix)
      192:  468:    && (strm << stru.entityId);
        -:  469:}
        -:  470:
       30:  471:bool operator>>(Serializer& strm, OpenDDS::DCPS::GUID_t& stru)
        -:  472:{
        -:  473:  ACE_UNUSED_ARG(strm);
        -:  474:  ACE_UNUSED_ARG(stru);
       60:  475:  OpenDDS::DCPS::GuidPrefix_t_forany stru_guidPrefix(const_cast<OpenDDS::DCPS::GuidPrefix_t_slice*>(stru.guidPrefix));
       30:  476:  return (strm >> stru_guidPrefix)
       60:  477:    && (strm >> stru.entityId);
        -:  478:}
        -:  479:
        -:  480:}  }
        -:  481:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  482:
        -:  483:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  484:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  485:namespace OpenDDS { namespace DCPS {
        -:  486:
        -:  487:template<>
    #####:  488:struct MetaStructImpl<OpenDDS::DCPS::GUID_t> : MetaStruct {
        -:  489:  typedef OpenDDS::DCPS::GUID_t T;
        -:  490:
        -:  491:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  492:  void* allocate() const { return new T; }
        -:  493:
    #####:  494:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:  495:
    #####:  496:  size_t numDcpsKeys() const { return 0; }
        -:  497:
        -:  498:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  499:
    #####:  500:  bool isDcpsKey(const char* field) const
        -:  501:  {
        -:  502:    ACE_UNUSED_ARG(field);
    #####:  503:    return false;
        -:  504:  }
        -:  505:
    #####:  506:  Value getValue(const void* stru, const char* field) const
        -:  507:  {
    #####:  508:    const OpenDDS::DCPS::GUID_t& typed = *static_cast<const OpenDDS::DCPS::GUID_t*>(stru);
    #####:  509:    if (std::strncmp(field, "entityId.", 9) == 0) {
    #####:  510:      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(&typed.entityId, field + 9);
        -:  511:    }
        -:  512:    ACE_UNUSED_ARG(typed);
    #####:  513:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::GUID_t)");
        -:  514:  }
        -:  515:
    #####:  516:  Value getValue(Serializer& ser, const char* field) const
        -:  517:  {
    #####:  518:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GuidPrefix_t_forany*>(0))) {
    #####:  519:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -:  520:    }
    #####:  521:    if (std::strncmp(field, "entityId.", 9) == 0) {
    #####:  522:      return getMetaStruct<OpenDDS::DCPS::EntityId_t>().getValue(ser, field + 9);
        -:  523:    } else {
    #####:  524:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::EntityId_t*>(0))) {
    #####:  525:        throw std::runtime_error("Field 'entityId' could not be skipped");
        -:  526:      }
        -:  527:    }
    #####:  528:    if (!field[0]) {
    #####:  529:      return 0;
        -:  530:    }
    #####:  531:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::GUID_t");
        -:  532:  }
        -:  533:
    #####:  534:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:  535:  {
        -:  536:    ACE_UNUSED_ARG(next);
    #####:  537:    if (std::strncmp(field, "entityId.", 9) == 0) {
    #####:  538:      return make_struct_cmp(&T::entityId, getMetaStruct<OpenDDS::DCPS::EntityId_t>().create_qc_comparator(field + 9), next);
        -:  539:    }
    #####:  540:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::GUID_t)");
        -:  541:  }
        -:  542:
        -:  543:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  544:  const char** getFieldNames() const
        -:  545:  {
        -:  546:    static const char* names[] = {"guidPrefix", "entityId", 0};
    #####:  547:    return names;
        -:  548:  }
        -:  549:
    #####:  550:  const void* getRawField(const void* stru, const char* field) const
        -:  551:  {
    #####:  552:    if (std::strcmp(field, "guidPrefix") == 0) {
    #####:  553:      return &static_cast<const T*>(stru)->guidPrefix;
        -:  554:    }
    #####:  555:    if (std::strcmp(field, "entityId") == 0) {
    #####:  556:      return &static_cast<const T*>(stru)->entityId;
        -:  557:    }
    #####:  558:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::GUID_t)");
        -:  559:  }
        -:  560:
    #####:  561:  void assign(void* lhs, const char* field, const void* rhs,
        -:  562:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:  563:  {
        -:  564:    ACE_UNUSED_ARG(lhs);
        -:  565:    ACE_UNUSED_ARG(field);
        -:  566:    ACE_UNUSED_ARG(rhs);
        -:  567:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:  568:    ACE_UNUSED_ARG(rhsMeta);
    #####:  569:    if (std::strcmp(field, "guidPrefix") == 0) {
    #####:  570:      OpenDDS::DCPS::GuidPrefix_t* lhsArr = &static_cast<T*>(lhs)->guidPrefix;
    #####:  571:      const OpenDDS::DCPS::GuidPrefix_t* rhsArr = static_cast<const OpenDDS::DCPS::GuidPrefix_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  572:      for (CORBA::ULong i0 = 0; i0 < 12; ++i0) {
    #####:  573:        (*lhsArr)[i0] = (*rhsArr)[i0];
        -:  574:      }
    #####:  575:      return;
        -:  576:    }
    #####:  577:    if (std::strcmp(field, "entityId") == 0) {
    #####:  578:      static_cast<T*>(lhs)->entityId = *static_cast<const OpenDDS::DCPS::EntityId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  579:      return;
        -:  580:    }
    #####:  581:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::GUID_t)");
        -:  582:  }
        -:  583:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  584:
    #####:  585:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:  586:  {
        -:  587:    ACE_UNUSED_ARG(lhs);
        -:  588:    ACE_UNUSED_ARG(field);
        -:  589:    ACE_UNUSED_ARG(rhs);
    #####:  590:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::GUID_t)");
        -:  591:  }
        -:  592:};
        -:  593:
        -:  594:template<>
    #####:  595:const MetaStruct& getMetaStruct<OpenDDS::DCPS::GUID_t>()
        -:  596:{
    #####:  597:  static MetaStructImpl<OpenDDS::DCPS::GUID_t> msi;
    #####:  598:  return msi;
        -:  599:}
        -:  600:
    #####:  601:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::GUID_t*)
        -:  602:{
        -:  603:  ACE_UNUSED_ARG(ser);
    #####:  604:  MetaStructImpl<OpenDDS::DCPS::GUID_t>().getValue(ser, "");
    #####:  605:  return true;
        -:  606:}
        -:  607:
        -:  608:}  }
        -:  609:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  610:
        -:  611:#endif
        -:  612:
        -:  613:/* End STRUCT: GUID_t */
        -:  614:
        -:  615:
        -:  616:/* Begin TYPEDEF: GUIDSeq */
        -:  617:
        -:  618:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  619:namespace OpenDDS { namespace DCPS {
        -:  620:
    #####:  621:void gen_find_size(const OpenDDS::DCPS::GUIDSeq& seq, size_t& size, size_t& padding)
        -:  622:{
        -:  623:  ACE_UNUSED_ARG(seq);
        -:  624:  ACE_UNUSED_ARG(size);
        -:  625:  ACE_UNUSED_ARG(padding);
    #####:  626:  find_size_ulong(size, padding);
    #####:  627:  if (seq.length() == 0) {
    #####:  628:    return;
        -:  629:  }
    #####:  630:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####:  631:    gen_find_size(seq[i], size, padding);
        -:  632:  }
        -:  633:}
        -:  634:
    #####:  635:bool operator<<(Serializer& strm, const OpenDDS::DCPS::GUIDSeq& seq)
        -:  636:{
        -:  637:  ACE_UNUSED_ARG(strm);
        -:  638:  ACE_UNUSED_ARG(seq);
    #####:  639:  const CORBA::ULong length = seq.length();
    #####:  640:  if (!(strm << length)) {
    #####:  641:    return false;
        -:  642:  }
    #####:  643:  if (length == 0) {
    #####:  644:    return true;
        -:  645:  }
    #####:  646:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  647:    if (!(strm << seq[i])) {
    #####:  648:      return false;
        -:  649:    }
        -:  650:  }
    #####:  651:  return true;
        -:  652:}
        -:  653:
    #####:  654:bool operator>>(Serializer& strm, OpenDDS::DCPS::GUIDSeq& seq)
        -:  655:{
        -:  656:  ACE_UNUSED_ARG(strm);
        -:  657:  ACE_UNUSED_ARG(seq);
        -:  658:  CORBA::ULong length;
    #####:  659:  if (!(strm >> length)) {
    #####:  660:    return false;
        -:  661:  }
    #####:  662:  seq.length(length);
    #####:  663:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  664:    if (!(strm >> seq[i])) {
    #####:  665:      return false;
        -:  666:    }
        -:  667:  }
    #####:  668:  return true;
        -:  669:}
        -:  670:
        -:  671:}  }
        -:  672:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  673:
        -:  674:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  675:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  676:namespace OpenDDS { namespace DCPS {
        -:  677:
    #####:  678:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::GUIDSeq*)
        -:  679:{
        -:  680:  ACE_UNUSED_ARG(ser);
        -:  681:  ACE_CDR::ULong length;
    #####:  682:  if (!(ser >> length)) return false;
    #####:  683:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####:  684:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) return false;
        -:  685:  }
    #####:  686:  return true;
        -:  687:}
        -:  688:
        -:  689:}  }
        -:  690:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  691:
        -:  692:#endif
        -:  693:
        -:  694:/* End TYPEDEF: GUIDSeq */
        -:  695:
        -:  696:/* End MODULE: DCPS */
        -:  697:
        -:  698:/* End MODULE: OpenDDS */
