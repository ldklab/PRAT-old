        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/OS_NS_sys_socket.inl
        -:    0:Programs:51
        -:    1:// -*- C++ -*-
        -:    2://
        -:    3:// $Id: OS_NS_sys_socket.inl 2622 2015-08-13 18:30:00Z mitza $
        -:    4:
        -:    5:#include "ace/OS_NS_errno.h"
        -:    6:#include "ace/OS_NS_macros.h"
        -:    7:#include "ace/OS_NS_sys_uio.h"
        -:    8:#include "ace/OS_NS_stdio.h"
        -:    9:#include "ace/OS_QoS.h"
        -:   10:#include "ace/Global_Macros.h"
        -:   11:#include "ace/os_include/netinet/os_in.h"
        -:   12:
        -:   13:#if defined (ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO) \
        -:   14:         && (ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO == 1)
        -:   15:#include "ace/OS_NS_string.h"
        -:   16:#endif
        -:   17:
        -:   18:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   19:
        -:   20:#if defined (ACE_HAS_VOIDPTR_SOCKOPT)
        -:   21:typedef void *ACE_SOCKOPT_TYPE1;
        -:   22:#elif defined (ACE_HAS_CHARPTR_SOCKOPT)
        -:   23:typedef char *ACE_SOCKOPT_TYPE1;
        -:   24:#else
        -:   25:typedef const char *ACE_SOCKOPT_TYPE1;
        -:   26:#endif /* ACE_HAS_VOIDPTR_SOCKOPT */
        -:   27:
        -:   28:ACE_INLINE ACE_HANDLE
        -:   29:ACE_OS::accept (ACE_HANDLE handle,
        -:   30:                struct sockaddr *addr,
        -:   31:                int *addrlen)
        -:   32:{
        -:   33:  ACE_OS_TRACE ("ACE_OS::accept");
        -:   34:  // On a non-blocking socket with no connections to accept, this
        -:   35:  // system call will return EWOULDBLOCK or EAGAIN, depending on the
        -:   36:  // platform.  UNIX 98 allows either errno, and they may be the same
        -:   37:  // numeric value.  So to make life easier for upper ACE layers as
        -:   38:  // well as application programmers, always change EAGAIN to
        -:   39:  // EWOULDBLOCK.  Rather than hack the ACE_OSCALL_RETURN macro, it's
        -:   40:  // handled explicitly here.  If the ACE_OSCALL macro ever changes,
        -:   41:  // this function needs to be reviewed.  On Win32, the regular macros
        -:   42:  // can be used, as this is not an issue.
        -:   43:
        -:   44:#if defined (ACE_LACKS_ACCEPT)
        -:   45:  ACE_UNUSED_ARG (handle);
        -:   46:  ACE_UNUSED_ARG (addr);
        -:   47:  ACE_UNUSED_ARG (addrlen);
        -:   48:  ACE_NOTSUP_RETURN (ACE_INVALID_HANDLE);
        -:   49:#elif defined (ACE_WIN32)
        -:   50:  ACE_SOCKCALL_RETURN (::accept ((ACE_SOCKET) handle,
        -:   51:                                 addr,
        -:   52:                                 (ACE_SOCKET_LEN *) addrlen),
        -:   53:                       ACE_HANDLE,
        -:   54:                       ACE_INVALID_HANDLE);
        -:   55:#else
        -:   56:#  if defined (ACE_HAS_BROKEN_ACCEPT_ADDR)
        -:   57:  // Apparently some platforms like VxWorks can't correctly deal with
        -:   58:  // a NULL addr.
        -:   59:
        -:   60:   sockaddr_in fake_addr;
        -:   61:   int fake_addrlen;
        -:   62:
        -:   63:   if (addrlen == 0)
        -:   64:     addrlen = &fake_addrlen;
        -:   65:
        -:   66:   if (addr == 0)
        -:   67:     {
        -:   68:       addr = (sockaddr *) &fake_addr;
        -:   69:       *addrlen = sizeof fake_addr;
        -:   70:     }
        -:   71:#  endif /* ACE_HAS_BROKEN_ACCEPT_ADDR */
        -:   72:  ACE_HANDLE ace_result = ::accept ((ACE_SOCKET) handle,
        -:   73:                                    addr,
        -:   74:                                    (ACE_SOCKET_LEN *) addrlen);
        -:   75:
        -:   76:# if !(defined (EAGAIN) && defined (EWOULDBLOCK) && EAGAIN == EWOULDBLOCK)
        -:   77:  // Optimize this code out if we can detect that EAGAIN ==
        -:   78:  // EWOULDBLOCK at compile time.  If we cannot detect equality at
        -:   79:  // compile-time (e.g. if EAGAIN or EWOULDBLOCK are not preprocessor
        -:   80:  // macros) perform the check at run-time.  The goal is to avoid two
        -:   81:  // TSS accesses in the _REENTRANT case when EAGAIN == EWOULDBLOCK.
        -:   82:  if (ace_result == ACE_INVALID_HANDLE
        -:   83:#  if !defined (EAGAIN) || !defined (EWOULDBLOCK)
        -:   84:      && EAGAIN != EWOULDBLOCK
        -:   85:#  endif  /* !EAGAIN || !EWOULDBLOCK */
        -:   86:      && errno == EAGAIN)
        -:   87:    {
        -:   88:      errno = EWOULDBLOCK;
        -:   89:    }
        -:   90:# endif /* EAGAIN != EWOULDBLOCK*/
        -:   91:
        -:   92:  return ace_result;
        -:   93:
        -:   94:#endif /* defined (ACE_WIN32) */
        -:   95:}
        -:   96:
        -:   97:ACE_INLINE int
        -:   98:ACE_OS::bind (ACE_HANDLE handle, struct sockaddr *addr, int addrlen)
        -:   99:{
        -:  100:  ACE_OS_TRACE ("ACE_OS::bind");
        -:  101:#if defined (ACE_LACKS_BIND)
        -:  102:  ACE_UNUSED_ARG (handle);
        -:  103:  ACE_UNUSED_ARG (addr);
        -:  104:  ACE_UNUSED_ARG (addrlen);
        -:  105:  ACE_NOTSUP_RETURN (-1);
        -:  106:#elif defined (ACE_VXWORKS) && (ACE_VXWORKS <= 0x640)
        -:  107:  // VxWorks clears the sin_port member after a successful bind when
        -:  108:  // sin_addr != INADDR_ANY, so after the bind we do retrieve the
        -:  109:  // original address so that user code can safely check the addr
        -:  110:  // after the bind. See bugzilla 3107 for more details
        -:  111:  int result;
        -:  112:  ACE_SOCKCALL (::bind ((ACE_SOCKET) handle,
        -:  113:                        addr,
        -:  114:                        (ACE_SOCKET_LEN) addrlen), int, -1, result);
        -:  115:  if (result == -1)
        -:  116:    return -1;
        -:  117:  else
        -:  118:    return ACE_OS::getsockname (handle, addr, &addrlen);
        -:  119:#else
        -:  120:  ACE_SOCKCALL_RETURN (::bind ((ACE_SOCKET) handle,
        -:  121:                               addr,
        -:  122:                               (ACE_SOCKET_LEN) addrlen), int, -1);
        -:  123:#endif
        -:  124:}
        -:  125:
        -:  126:ACE_INLINE int
        -:  127:ACE_OS::closesocket (ACE_HANDLE handle)
        -:  128:{
        -:  129:  ACE_OS_TRACE ("ACE_OS::closesocket");
        -:  130:#if defined (ACE_WIN32)
        -:  131:  // @note Do not shutdown the write end here.  Doing so will break
        -:  132:  //       applications that duplicate a handle on fork(), for
        -:  133:  //       example, and expect to continue writing in the fork()ed
        -:  134:  //       process.
        -:  135:
        -:  136:  ACE_SOCKCALL_RETURN (::closesocket ((SOCKET) handle), int, -1);
        -:  137:#else
        -:  138:  //FUZZ: disable check_for_lack_ACE_OS
        -:  139:  ACE_OSCALL_RETURN (::close (handle), int, -1);
        -:  140:  //FUZZ: enable check_for_lack_ACE_OS
        -:  141:#endif /* ACE_WIN32 */
        -:  142:}
        -:  143:
        -:  144:ACE_INLINE int
        -:  145:ACE_OS::connect (ACE_HANDLE handle,
        -:  146:                 struct sockaddr *addr,
        -:  147:                 int addrlen)
        -:  148:{
        -:  149:  ACE_OS_TRACE ("ACE_OS::connect");
        -:  150:#if defined (ACE_LACKS_CONNECT)
        -:  151:  ACE_UNUSED_ARG (handle);
        -:  152:  ACE_UNUSED_ARG (addr);
        -:  153:  ACE_UNUSED_ARG (addrlen);
        -:  154:  ACE_NOTSUP_RETURN (-1);
        -:  155:#else
        -:  156:  ACE_SOCKCALL_RETURN (::connect ((ACE_SOCKET) handle,
        -:  157:                                  addr,
        -:  158:                                  (ACE_SOCKET_LEN) addrlen), int, -1);
        -:  159:#endif /* ACE_LACKS_CONNECT */
        -:  160:}
        -:  161:
        -:  162:ACE_INLINE int
        -:  163:ACE_OS::enum_protocols (int *protocols,
        -:  164:                        ACE_Protocol_Info *protocol_buffer,
        -:  165:                        u_long *buffer_length)
        -:  166:{
        -:  167:#if defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0)
        -:  168:
        -:  169:  ACE_SOCKCALL_RETURN (::WSAEnumProtocols (protocols,
        -:  170:                                           protocol_buffer,
        -:  171:                                           buffer_length),
        -:  172:                       int,
        -:  173:                       SOCKET_ERROR);
        -:  174:
        -:  175:#else
        -:  176:  ACE_UNUSED_ARG (protocols);
        -:  177:  ACE_UNUSED_ARG (protocol_buffer);
        -:  178:  ACE_UNUSED_ARG (buffer_length);
        -:  179:  ACE_NOTSUP_RETURN (-1);
        -:  180:#endif /* ACE_HAS_WINSOCK2 */
        -:  181:}
        -:  182:
        -:  183:ACE_INLINE int
        -:  184:ACE_OS::getpeername (ACE_HANDLE handle, struct sockaddr *addr,
        -:  185:                     int *addrlen)
        -:  186:{
        -:  187:  ACE_OS_TRACE ("ACE_OS::getpeername");
        -:  188:
        -:  189:#if defined (ACE_LACKS_GETPEERNAME)
        -:  190:  ACE_UNUSED_ARG (handle);
        -:  191:  ACE_UNUSED_ARG (addr);
        -:  192:  ACE_UNUSED_ARG (addrlen);
        -:  193:  ACE_NOTSUP_RETURN (-1);
        -:  194:#elif defined (ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO) \
        -:  195:           && (ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO == 1)
        -:  196:  int result;
        -:  197:  ACE_SOCKCALL (::getpeername ((ACE_SOCKET) handle,
        -:  198:                               addr,
        -:  199:                               (ACE_SOCKET_LEN *) addrlen),
        -:  200:               int,
        -:  201:                -1,
        -:  202:                result);
        -:  203:
        -:  204:  // Some platforms, like older versions of the Linux kernel, do not
        -:  205:  // initialize the sin_zero field since that field is generally only
        -:  206:  // used for padding/alignment purposes.  On those platforms
        -:  207:  // memcmp()-based comparisons of the sockaddr_in structure, such as
        -:  208:  // the one in the ACE_INET_Addr equality operator, may fail due to
        -:  209:  // random bytes in the sin_zero field even though that field is
        -:  210:  // unused.  Prevent equality comparison of two different sockaddr_in
        -:  211:  // instances that refer to the same socket from failing by
        -:  212:  // explicitly initializing the sockaddr_in::sin_zero field to a
        -:  213:  // consistent value, e.g. zero.
        -:  214:  if (result != -1 && addr->sa_family == AF_INET)
        -:  215:    {
        -:  216:      ACE_OS::memset (reinterpret_cast<struct sockaddr_in *> (addr)->sin_zero,
        -:  217:                      0,
        -:  218:                      sizeof (reinterpret_cast<struct sockaddr_in *> (addr)->sin_zero));
        -:  219:    }
        -:  220:
        -:  221:  return result;
        -:  222:#else
        -:  223:  ACE_SOCKCALL_RETURN (::getpeername ((ACE_SOCKET) handle,
        -:  224:                                      addr,
        -:  225:                                      (ACE_SOCKET_LEN *) addrlen),
        -:  226:                       int,
        -:  227:                       -1);
        -:  228:#endif /* ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO */
        -:  229:}
        -:  230:
        -:  231:ACE_INLINE int
        -:  232:ACE_OS::getsockname (ACE_HANDLE handle,
        -:  233:                     struct sockaddr *addr,
        -:  234:                     int *addrlen)
        -:  235:{
        -:  236:  ACE_OS_TRACE ("ACE_OS::getsockname");
        -:  237:#if defined (ACE_LACKS_GETSOCKNAME)
        -:  238:  ACE_UNUSED_ARG (handle);
        -:  239:  ACE_UNUSED_ARG (addr);
        -:  240:  ACE_UNUSED_ARG (addrlen);
        -:  241:  ACE_NOTSUP_RETURN (-1);
        -:  242:#elif defined (ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO) \
        -:  243:           && (ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO == 1)
        -:  244:  int result;
        -:  245:  ACE_SOCKCALL (::getsockname ((ACE_SOCKET) handle,
        -:  246:                               addr,
        -:  247:                               (ACE_SOCKET_LEN *) addrlen),
        -:  248:               int, -1, result);
        -:  249:
        -:  250:  // Some platforms, like older versions of the Linux kernel, do not
        -:  251:  // initialize the sin_zero field since that field is generally only
        -:  252:  // used for padding/alignment purposes.  On those platforms
        -:  253:  // memcmp()-based comparisons of the sockaddr_in structure, such as
        -:  254:  // the one in the ACE_INET_Addr equality operator, may fail due to
        -:  255:  // random bytes in the sin_zero field even though that field is
        -:  256:  // unused.  Prevent equality comparison of two different sockaddr_in
        -:  257:  // instances that refer to the same socket from failing by
        -:  258:  // explicitly initializing the sockaddr_in::sin_zero field to a
        -:  259:  // consistent value, e.g. zero.
        -:  260:  if (result != -1 && addr->sa_family == AF_INET)
        -:  261:    {
        -:  262:      ACE_OS::memset (reinterpret_cast<struct sockaddr_in *> (addr)->sin_zero,
        -:  263:                      0,
        -:  264:                      sizeof (reinterpret_cast<struct sockaddr_in *> (addr)->sin_zero));
        -:  265:    }
        -:  266:
        -:  267:  return result;
        -:  268:#else
        -:  269:  ACE_SOCKCALL_RETURN (::getsockname ((ACE_SOCKET) handle,
        -:  270:                                      addr,
        -:  271:                                      (ACE_SOCKET_LEN *) addrlen),
        -:  272:                       int, -1);
        -:  273:#endif /* ACE_GETNAME_RETURNS_RANDOM_SIN_ZERO */
        -:  274:}
        -:  275:
        -:  276:ACE_INLINE int
        -:  277:ACE_OS::getsockopt (ACE_HANDLE handle,
        -:  278:                    int level,
        -:  279:                    int optname,
        -:  280:                    char *optval,
        -:  281:                    int *optlen)
        -:  282:{
        -:  283:  ACE_OS_TRACE ("ACE_OS::getsockopt");
        -:  284:#if defined (ACE_LACKS_GETSOCKOPT)
        -:  285:  ACE_UNUSED_ARG (handle);
        -:  286:  ACE_UNUSED_ARG (level);
        -:  287:  ACE_UNUSED_ARG (optname);
        -:  288:  ACE_UNUSED_ARG (optval);
        -:  289:  ACE_UNUSED_ARG (optlen);
        -:  290:  ACE_NOTSUP_RETURN (-1);
        -:  291:#else
        -:  292:  ACE_SOCKCALL_RETURN (::getsockopt ((ACE_SOCKET) handle,
        -:  293:                                     level,
        -:  294:                                     optname,
        -:  295:                                     optval,
        -:  296:                                     (ACE_SOCKET_LEN *) optlen),
        -:  297:                       int,
        -:  298:                       -1);
        -:  299:#endif /* ACE_LACKS_GETSOCKOPT */
        -:  300:}
        -:  301:
        -:  302:ACE_INLINE int
        -:  303:ACE_OS::listen (ACE_HANDLE handle, int backlog)
        -:  304:{
        -:  305:  ACE_OS_TRACE ("ACE_OS::listen");
        -:  306:#if defined (ACE_LACKS_LISTEN)
        -:  307:  ACE_UNUSED_ARG (handle);
        -:  308:  ACE_UNUSED_ARG (backlog);
        -:  309:  ACE_NOTSUP_RETURN (-1);
        -:  310:#else
        -:  311:  ACE_SOCKCALL_RETURN (::listen ((ACE_SOCKET) handle, backlog), int, -1);
        -:  312:#endif /* ACE_LACKS_LISTEN */
        -:  313:}
        -:  314:
        -:  315:ACE_INLINE ssize_t
        -:  316:ACE_OS::recv (ACE_HANDLE handle, char *buf, size_t len, int flags)
        -:  317:{
        -:  318:  ACE_OS_TRACE ("ACE_OS::recv");
        -:  319:
        -:  320:  // On UNIX, a non-blocking socket with no data to receive, this
        -:  321:  // system call will return EWOULDBLOCK or EAGAIN, depending on the
        -:  322:  // platform.  UNIX 98 allows either errno, and they may be the same
        -:  323:  // numeric value.  So to make life easier for upper ACE layers as
        -:  324:  // well as application programmers, always change EAGAIN to
        -:  325:  // EWOULDBLOCK.  Rather than hack the ACE_OSCALL_RETURN macro, it's
        -:  326:  // handled explicitly here.  If the ACE_OSCALL macro ever changes,
        -:  327:  // this function needs to be reviewed.  On Win32, the regular macros
        -:  328:  // can be used, as this is not an issue.
        -:  329:#if defined (ACE_LACKS_RECV)
        -:  330:  ACE_UNUSED_ARG (handle);
        -:  331:  ACE_UNUSED_ARG (buf);
        -:  332:  ACE_UNUSED_ARG (len);
        -:  333:  ACE_UNUSED_ARG (flags);
        -:  334:  ACE_NOTSUP_RETURN (-1);
        -:  335:#elif defined (ACE_WIN32)
        -:  336:  ACE_SOCKCALL_RETURN (::recv ((ACE_SOCKET) handle, buf,
        -:  337:                               static_cast<int> (len), flags), ssize_t, -1);
        -:  338:#else
        -:  339:  ssize_t ace_result_;
        -:  340:  ace_result_ = ::recv ((ACE_SOCKET) handle, buf, len, flags);
        -:  341:
        -:  342:# if !(defined (EAGAIN) && defined (EWOULDBLOCK) && EAGAIN == EWOULDBLOCK)
        -:  343:  // Optimize this code out if we can detect that EAGAIN ==
        -:  344:  // EWOULDBLOCK at compile time.  If we cannot detect equality at
        -:  345:  // compile-time (e.g. if EAGAIN or EWOULDBLOCK are not preprocessor
        -:  346:  // macros) perform the check at run-time.  The goal is to avoid two
        -:  347:  // TSS accesses in the _REENTRANT case when EAGAIN == EWOULDBLOCK.
        -:  348:  if (ace_result_ == -1
        -:  349:#  if !defined (EAGAIN) || !defined (EWOULDBLOCK)
        -:  350:      && EAGAIN != EWOULDBLOCK
        -:  351:#  endif  /* !EAGAIN || !EWOULDBLOCK */
        -:  352:      && errno == EAGAIN)
        -:  353:    {
        -:  354:      errno = EWOULDBLOCK;
        -:  355:    }
        -:  356:# endif /* EAGAIN != EWOULDBLOCK*/
        -:  357:
        -:  358:  return ace_result_;
        -:  359:#endif /* ACE_LACKS_RECV */
        -:  360:}
        -:  361:
        -:  362:ACE_INLINE ssize_t
        -:  363:ACE_OS::recvfrom (ACE_HANDLE handle,
        -:  364:                  char *buf,
        -:  365:                  size_t len,
        -:  366:                  int flags,
        -:  367:                  struct sockaddr *addr,
        -:  368:                  int *addrlen)
        -:  369:{
        -:  370:  ACE_OS_TRACE ("ACE_OS::recvfrom");
        -:  371:#if defined (ACE_LACKS_RECVFROM)
        -:  372:  ACE_UNUSED_ARG (handle);
        -:  373:  ACE_UNUSED_ARG (buf);
        -:  374:  ACE_UNUSED_ARG (len);
        -:  375:  ACE_UNUSED_ARG (flags);
        -:  376:  ACE_UNUSED_ARG (addr);
        -:  377:  ACE_UNUSED_ARG (addrlen);
        -:  378:  ACE_NOTSUP_RETURN (-1);
        -:  379:#elif defined (ACE_WIN32)
        -:  380:  int const shortened_len = static_cast<int> (len);
        -:  381:  int const result = ::recvfrom ((ACE_SOCKET) handle,
        -:  382:                                 buf,
        -:  383:                                 shortened_len,
        -:  384:                                 flags,
        -:  385:                                 addr,
        -:  386:                                 (ACE_SOCKET_LEN *) addrlen);
        -:  387:  if (result == SOCKET_ERROR)
        -:  388:    {
        -:  389:      ACE_OS::set_errno_to_wsa_last_error ();
        -:  390:      if (errno == WSAEMSGSIZE &&
        -:  391:          ACE_BIT_ENABLED (flags, MSG_PEEK))
        -:  392:        return shortened_len;
        -:  393:      else
        -:  394:        return -1;
        -:  395:    }
        -:  396:  else
        -:  397:    {
        -:  398:#  if defined (ACE_HAS_PHARLAP)
        -:  399:      // Pharlap ETS (at least to v13) returns a legit address but doesn't
        -:  400:      // include the sin_zero[8] bytes in the count. Correct for this here.
        -:  401:      if (addrlen != 0 && addr != 0 &&
        -:  402:          *addrlen == 8 && addr->sa_family == AF_INET)
        -:  403:        *addrlen = sizeof(sockaddr_in);
        -:  404:#  endif /* ACE_HAS_PHARLAP */
        -:  405:      return result;
        -:  406:    }
        -:  407:#else /* non Win32 */
        -:  408:  ACE_SOCKCALL_RETURN (::recvfrom ((ACE_SOCKET) handle,
        -:  409:                                   buf,
        -:  410:                                   len,
        -:  411:                                   flags,
        -:  412:                                   addr,
        -:  413:                                   (ACE_SOCKET_LEN *) addrlen),
        -:  414:                       ssize_t, -1);
        -:  415:#endif /* ACE_LACKS_RECVFROM */
        -:  416:}
        -:  417:
        -:  418:ACE_INLINE ssize_t
        -:  419:ACE_OS::recvfrom (ACE_HANDLE handle,
        -:  420:                  iovec *buffers,
        -:  421:                  int buffer_count,
        -:  422:                  size_t &number_of_bytes_recvd,
        -:  423:                  int &flags,
        -:  424:                  struct sockaddr *addr,
        -:  425:                  int *addrlen,
        -:  426:                  ACE_OVERLAPPED *overlapped,
        -:  427:                  ACE_OVERLAPPED_COMPLETION_FUNC func)
        -:  428:{
        -:  429:  ACE_OS_TRACE ("ACE_OS::recvfrom");
        -:  430:
        -:  431:#if defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0)
        -:  432:  DWORD bytes_recvd;
        -:  433:  DWORD the_flags = flags;
        -:  434:  int result = ::WSARecvFrom ((SOCKET) handle,
        -:  435:                              (WSABUF*)buffers,
        -:  436:                              buffer_count,
        -:  437:                              &bytes_recvd,
        -:  438:                              &the_flags,
        -:  439:                              addr,
        -:  440:                              addrlen,
        -:  441:                              overlapped,
        -:  442:                              func);
        -:  443:  if (result != 0) {
        -:  444:    ACE_OS::set_errno_to_wsa_last_error ();
        -:  445:  }
        -:  446:  flags = the_flags;
        -:  447:  number_of_bytes_recvd = static_cast<size_t> (bytes_recvd);
        -:  448:  return result;
        -:  449:#else
        -:  450:  ACE_UNUSED_ARG (handle);
        -:  451:  ACE_UNUSED_ARG (buffers);
        -:  452:  ACE_UNUSED_ARG (buffer_count);
        -:  453:  ACE_UNUSED_ARG (number_of_bytes_recvd);
        -:  454:  ACE_UNUSED_ARG (flags);
        -:  455:  ACE_UNUSED_ARG (addr);
        -:  456:  ACE_UNUSED_ARG (addrlen);
        -:  457:  ACE_UNUSED_ARG (overlapped);
        -:  458:  ACE_UNUSED_ARG (func);
        -:  459:  ACE_NOTSUP_RETURN (-1);
        -:  460:#endif /* defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0) */
        -:  461:}
        -:  462:
        -:  463:ACE_INLINE ssize_t
        -:  464:ACE_OS::recvmsg (ACE_HANDLE handle, struct msghdr *msg, int flags)
        -:  465:{
        -:  466:  ACE_OS_TRACE ("ACE_OS::recvmsg");
        -:  467:#if !defined (ACE_LACKS_RECVMSG)
        -:  468:# if (defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0))
        -:  469:  DWORD bytes_received = 0;
        -:  470:
        -:  471:  int result = ::WSARecvFrom ((SOCKET) handle,
        -:  472:                              (WSABUF *) msg->msg_iov,
        -:  473:                              msg->msg_iovlen,
        -:  474:                              &bytes_received,
        -:  475:                              (DWORD *) &flags,
        -:  476:                              msg->msg_name,
        -:  477:                              &msg->msg_namelen,
        -:  478:                              0,
        -:  479:                              0);
        -:  480:
        -:  481:  if (result != 0)
        -:  482:    {
        -:  483:      ACE_OS::set_errno_to_wsa_last_error ();
        -:  484:      return -1;
        -:  485:    }
        -:  486:  else
        -:  487:    return bytes_received;
        -:  488:# else /* ACE_HAS_WINSOCK2 */
        -:  489:  ACE_SOCKCALL_RETURN (::recvmsg (handle, msg, flags), ssize_t, -1);
        -:  490:# endif /* ACE_HAS_WINSOCK2 */
        -:  491:#else
        -:  492:  ACE_UNUSED_ARG (flags);
        -:  493:  ACE_UNUSED_ARG (msg);
        -:  494:  ACE_UNUSED_ARG (handle);
        -:  495:
        -:  496:  ACE_NOTSUP_RETURN (-1);
        -:  497:#endif /* ACE_LACKS_RECVMSG */
        -:  498:}
        -:  499:
        -:  500:ACE_INLINE ssize_t
        -:  501:ACE_OS::recvv (ACE_HANDLE handle,
        -:  502:               iovec *buffers,
        -:  503:               int n)
        -:  504:{
        -:  505:#if defined (ACE_HAS_WINSOCK2)
        -:  506:
        -:  507:  DWORD bytes_received = 0;
        -:  508:  int result = 1;
        -:  509:
        -:  510:  // Winsock 2 has WSARecv and can do this directly, but Winsock 1 needs
        -:  511:  // to do the recvs piece-by-piece.
        -:  512:
        -:  513:# if (ACE_HAS_WINSOCK2 != 0)
        -:  514:  DWORD flags = 0;
        -:  515:  result = ::WSARecv ((SOCKET) handle,
        -:  516:                      (WSABUF *) buffers,
        -:  517:                      n,
        -:  518:                      &bytes_received,
        -:  519:                      &flags,
        -:  520:                      0,
        -:  521:                      0);
        -:  522:# else
        -:  523:  // Step through the buffers requested by caller; for each one, cycle
        -:  524:  // through reads until it's filled or an error occurs.
        -:  525:  for (int i = 0; i < n && result > 0; ++i)
        -:  526:    {
        -:  527:      char *chunkp = buffers[i].iov_base;     // Point to part of chunk being read
        -:  528:      int chunklen = buffers[i].iov_len;    // Track how much to read to chunk
        -:  529:      while (chunklen > 0 && result > 0)
        -:  530:        {
        -:  531:          result = ::recv ((SOCKET) handle, chunkp, chunklen, 0);
        -:  532:          if (result > 0)
        -:  533:            {
        -:  534:              chunkp += result;
        -:  535:              chunklen -= result;
        -:  536:              bytes_received += result;
        -:  537:            }
        -:  538:        }
        -:  539:    }
        -:  540:# endif /* ACE_HAS_WINSOCK2 != 0 */
        -:  541:
        -:  542:  if (result == SOCKET_ERROR)
        -:  543:    {
        -:  544:      ACE_OS::set_errno_to_wsa_last_error ();
        -:  545:      return -1;
        -:  546:    }
        -:  547:  else
        -:  548:    return (ssize_t) bytes_received;
        -:  549:#else
        -:  550:  return ACE_OS::readv (handle, buffers, n);
        -:  551:#endif /* ACE_HAS_WINSOCK2 */
        -:  552:}
        -:  553:
        -:  554:ACE_INLINE ssize_t
        -:  555:ACE_OS::send (ACE_HANDLE handle, const char *buf, size_t len, int flags)
        -:  556:{
        -:  557:  ACE_OS_TRACE ("ACE_OS::send");
        -:  558:
        -:  559:  // On UNIX, a non-blocking socket with no data to receive, this
        -:  560:  // system call will return EWOULDBLOCK or EAGAIN, depending on the
        -:  561:  // platform.  UNIX 98 allows either errno, and they may be the same
        -:  562:  // numeric value.  So to make life easier for upper ACE layers as
        -:  563:  // well as application programmers, always change EAGAIN to
        -:  564:  // EWOULDBLOCK.  Rather than hack the ACE_OSCALL_RETURN macro, it's
        -:  565:  // handled explicitly here.  If the ACE_OSCALL macro ever changes,
        -:  566:  // this function needs to be reviewed.  On Win32, the regular macros
        -:  567:  // can be used, as this is not an issue.
        -:  568:#if defined (ACE_LACKS_SEND)
        -:  569:  ACE_UNUSED_ARG (handle);
        -:  570:  ACE_UNUSED_ARG (buf);
        -:  571:  ACE_UNUSED_ARG (len);
        -:  572:  ACE_UNUSED_ARG (flags);
        -:  573:  ACE_NOTSUP_RETURN (-1);
        -:  574:#elif defined (ACE_WIN32)
        -:  575:  ssize_t result = ::send ((ACE_SOCKET) handle,
        -:  576:                           buf,
        -:  577:                           static_cast<int> (len),
        -:  578:                           flags);
        -:  579:  if (result == -1)
        -:  580:    {
        -:  581:      ACE_OS::set_errno_to_wsa_last_error();
        -:  582:      if (errno != ENOBUFS)
        -:  583:        return -1;
        -:  584:
        -:  585:      ACE_SOCKCALL_RETURN(send_partial_i(handle, buf, len, flags), ssize_t, -1);
        -:  586:    }
        -:  587:  else
        -:  588:    return result;
        -:  589:
        -:  590:#else
        -:  591:  ssize_t const ace_result_ = ::send ((ACE_SOCKET) handle, buf, len, flags);
        -:  592:
        -:  593:# if !(defined (EAGAIN) && defined (EWOULDBLOCK) && EAGAIN == EWOULDBLOCK)
        -:  594:  // Optimize this code out if we can detect that EAGAIN ==
        -:  595:  // EWOULDBLOCK at compile time.  If we cannot detect equality at
        -:  596:  // compile-time (e.g. if EAGAIN or EWOULDBLOCK are not preprocessor
        -:  597:  // macros) perform the check at run-time.  The goal is to avoid two
        -:  598:  // TSS accesses in the _REENTRANT case when EAGAIN == EWOULDBLOCK.
        -:  599:  if (ace_result_ == -1
        -:  600:#  if !defined (EAGAIN) || !defined (EWOULDBLOCK)
        -:  601:      && EAGAIN != EWOULDBLOCK
        -:  602:#  endif  /* !EAGAIN || !EWOULDBLOCK */
        -:  603:      && errno == EAGAIN)
        -:  604:    {
        -:  605:      errno = EWOULDBLOCK;
        -:  606:    }
        -:  607:# endif /* EAGAIN != EWOULDBLOCK*/
        -:  608:
        -:  609:  return ace_result_;
        -:  610:#endif /* defined (ACE_WIN32) */
        -:  611:}
        -:  612:
        -:  613:ACE_INLINE ssize_t
        -:  614:ACE_OS::sendmsg (ACE_HANDLE handle,
        -:  615:                 const struct msghdr *msg,
        -:  616:                 int flags)
        -:  617:{
        -:  618:  ACE_OS_TRACE ("ACE_OS::sendmsg");
        -:  619:#if !defined (ACE_LACKS_SENDMSG)
        -:  620:# if (defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0))
        -:  621:  DWORD bytes_sent = 0;
        -:  622:  int result = ::WSASendTo ((SOCKET) handle,
        -:  623:                            (WSABUF *) msg->msg_iov,
        -:  624:                            msg->msg_iovlen,
        -:  625:                            &bytes_sent,
        -:  626:                            flags,
        -:  627:                            msg->msg_name,
        -:  628:                            msg->msg_namelen,
        -:  629:                            0,
        -:  630:                            0);
        -:  631:
        -:  632:  if (result != 0)
        -:  633:    {
        -:  634:      ACE_OS::set_errno_to_wsa_last_error ();
        -:  635:      return -1;
        -:  636:    }
        -:  637:  else
        -:  638:    return (ssize_t) bytes_sent;
        -:  639:# elif defined (ACE_HAS_NONCONST_SENDMSG)
        -:  640:  ACE_SOCKCALL_RETURN (::sendmsg (handle,
        -:  641:                                  const_cast<struct msghdr *>(msg),
        -:  642:                                  flags), ssize_t, -1);
        -:  643:# else
        -:  644:  ACE_SOCKCALL_RETURN (::sendmsg (handle, msg, flags), ssize_t, -1);
        -:  645:# endif
        -:  646:#else
        -:  647:  ACE_UNUSED_ARG (flags);
        -:  648:  ACE_UNUSED_ARG (msg);
        -:  649:  ACE_UNUSED_ARG (handle);
        -:  650:
        -:  651:  ACE_NOTSUP_RETURN (-1);
        -:  652:#endif /* ACE_LACKS_SENDMSG */
        -:  653:}
        -:  654:
        -:  655:ACE_INLINE ssize_t
        -:  656:ACE_OS::sendto (ACE_HANDLE handle,
        -:  657:                const char *buf,
        -:  658:                size_t len,
        -:  659:                int flags,
        -:  660:                const struct sockaddr *addr,
        -:  661:                int addrlen)
        -:  662:{
        -:  663:  ACE_OS_TRACE ("ACE_OS::sendto");
        -:  664:#if defined (ACE_LACKS_SENDTO)
        -:  665:  ACE_UNUSED_ARG (handle);
        -:  666:  ACE_UNUSED_ARG (buf);
        -:  667:  ACE_UNUSED_ARG (len);
        -:  668:  ACE_UNUSED_ARG (flags);
        -:  669:  ACE_UNUSED_ARG (addr);
        -:  670:  ACE_UNUSED_ARG (addrlen);
        -:  671:  ACE_NOTSUP_RETURN (-1);
        -:  672:#elif defined (ACE_VXWORKS)
        -:  673:  ACE_SOCKCALL_RETURN (::sendto ((ACE_SOCKET) handle,
        -:  674:                                 const_cast <char *> (buf),
        -:  675:                                 len,
        -:  676:                                 flags,
        -:  677:                                 const_cast<struct sockaddr *> (addr),
        -:  678:                                 addrlen),
        -:  679:                       ssize_t, -1);
        -:  680:#elif defined (ACE_WIN32)
        -:  681:  ACE_SOCKCALL_RETURN (::sendto ((ACE_SOCKET) handle,
        -:  682:                                 buf,
        -:  683:                                 static_cast<int> (len),
        -:  684:                                 flags,
        -:  685:                                 const_cast<struct sockaddr *> (addr),
        -:  686:                                 addrlen),
        -:  687:                       ssize_t, -1);
        -:  688:#else
        -:  689:  ACE_SOCKCALL_RETURN (::sendto ((ACE_SOCKET) handle,
        -:  690:                                 buf,
        -:  691:                                 len,
        -:  692:                                 flags,
        -:  693:                                 const_cast<struct sockaddr *> (addr),
        -:  694:                                 addrlen),
        -:  695:                       ssize_t, -1);
        -:  696:#endif /* ACE_LACKS_SENDTO */
        -:  697:}
        -:  698:
        -:  699:ACE_INLINE ssize_t
        -:  700:ACE_OS::sendto (ACE_HANDLE handle,
        -:  701:                const iovec *buffers,
        -:  702:                int buffer_count,
        -:  703:                size_t &number_of_bytes_sent,
        -:  704:                int flags,
        -:  705:                const struct sockaddr *addr,
        -:  706:                int addrlen,
        -:  707:                ACE_OVERLAPPED *overlapped,
        -:  708:                ACE_OVERLAPPED_COMPLETION_FUNC func)
        -:  709:{
        -:  710:  ACE_OS_TRACE ("ACE_OS::sendto");
        -:  711:#if defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0)
        -:  712:  DWORD bytes_sent = 0;
        -:  713:  int result = ::WSASendTo ((SOCKET) handle,
        -:  714:                            (WSABUF*) buffers,
        -:  715:                            buffer_count,
        -:  716:                            &bytes_sent,
        -:  717:                            flags,
        -:  718:                            addr,
        -:  719:                            addrlen,
        -:  720:                            overlapped,
        -:  721:                            func);
        -:  722:  if (result != 0) {
        -:  723:    ACE_OS::set_errno_to_wsa_last_error ();
        -:  724:  }
        -:  725:  number_of_bytes_sent = static_cast<size_t> (bytes_sent);
        -:  726:  return (ssize_t) result;
        -:  727:#else
        -:  728:  ACE_UNUSED_ARG (overlapped);
        -:  729:  ACE_UNUSED_ARG (func);
        -:  730:
        -:  731:  number_of_bytes_sent = 0;
        -:  732:
        -:  733:  ssize_t result = 0;
        -:  734:
        -:  735:  for (int i = 0; i < buffer_count; ++i)
        -:  736:    {
        -:  737:       result = ACE_OS::sendto (handle,
        -:  738:                                reinterpret_cast<char *> (
        -:  739:                                                 buffers[i].iov_base),
        -:  740:                                buffers[i].iov_len,
        -:  741:                                flags,
        -:  742:                                addr,
        -:  743:                                addrlen);
        -:  744:       if (result == -1)
        -:  745:         break;
        -:  746:       number_of_bytes_sent += static_cast<size_t> (result);
        -:  747:    }
        -:  748:
        -:  749:  return result;
        -:  750:#endif /* defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0) */
        -:  751:}
        -:  752:
        -:  753:ACE_INLINE ssize_t
        -:  754:ACE_OS::sendv (ACE_HANDLE handle,
        -:  755:               const iovec *buffers,
        -:  756:               int n)
        -:  757:{
        -:  758:#if defined (ACE_HAS_WINSOCK2)
        -:  759:  DWORD bytes_sent = 0;
        -:  760:  ssize_t result = 0;
        -:  761:
        -:  762:  // Winsock 2 has WSASend and can do this directly, but Winsock 1
        -:  763:  // needs to do the sends one-by-one.
        -:  764:# if (ACE_HAS_WINSOCK2 != 0) && !defined (ACE_DONT_USE_WSASEND)
        -:  765:  result = ::WSASend ((SOCKET) handle,
        -:  766:                      (WSABUF *) buffers,
        -:  767:                      n,
        -:  768:                      &bytes_sent,
        -:  769:                      0,
        -:  770:                      0,
        -:  771:                      0);
        -:  772:  if (result == SOCKET_ERROR)
        -:  773:    {
        -:  774:      ACE_OS::set_errno_to_wsa_last_error ();
        -:  775:      if ((errno != ENOBUFS) ||
        -:  776:          (bytes_sent != 0))
        -:  777:        {
        -:  778:          return -1;
        -:  779:        }
        -:  780:      result = sendv_partial_i(handle, buffers, n);
        -:  781:      if (result == SOCKET_ERROR)
        -:  782:        {
        -:  783:          ACE_OS::set_errno_to_wsa_last_error ();
        -:  784:          return -1;
        -:  785:        }
        -:  786:      bytes_sent = static_cast<DWORD>(result);
        -:  787:    }
        -:  788:# else
        -:  789:  for (int i = 0; i < n; ++i)
        -:  790:    {
        -:  791:      result = ::send ((SOCKET) handle,
        -:  792:                       buffers[i].iov_base,
        -:  793:                       buffers[i].iov_len,
        -:  794:                       0);
        -:  795:
        -:  796:      if (result == SOCKET_ERROR)
        -:  797:        {
        -:  798:          // There is a subtle difference in behaviour depending on
        -:  799:          // whether or not any data was sent.  If no data was sent,
        -:  800:          // then always return -1.  Otherwise return bytes_sent.
        -:  801:          // This gives the caller an opportunity to keep track of
        -:  802:          // bytes that have already been sent.
        -:  803:          if (bytes_sent > 0)
        -:  804:            break;
        -:  805:          else
        -:  806:            {
        -:  807:              ACE_OS::set_errno_to_wsa_last_error ();
        -:  808:              return -1;
        -:  809:            }
        -:  810:        }
        -:  811:      else
        -:  812:        {
        -:  813:          // Gets ignored on error anyway
        -:  814:          bytes_sent += result;
        -:  815:
        -:  816:          // If the transfer isn't complete just drop out of the loop.
        -:  817:          if (result < (int)buffers[i].iov_len)
        -:  818:            break;
        -:  819:        }
        -:  820:    }
        -:  821:# endif /* ACE_HAS_WINSOCK2 != 0 */
        -:  822:
        -:  823:  return (ssize_t) bytes_sent;
        -:  824:
        -:  825:#elif defined (ACE_HAS_SOCK_BUF_SIZE_MAX)
        -:  826:
        -:  827:  // Platform limits the maximum socket message size.  Pare down the
        -:  828:  // iovec, if necessary, to obey the limit.
        -:  829:  iovec local_iov[ACE_IOV_MAX];
        -:  830:  long total = 0;
        -:  831:  long new_total = 0;
        -:  832:  for (int i = 0; i < n; i++)
        -:  833:    {
        -:  834:      local_iov[i].iov_base = buffers[i].iov_base;
        -:  835:      local_iov[i].iov_len  = buffers[i].iov_len;
        -:  836:
        -:  837:      new_total = total + buffers[i].iov_len;
        -:  838:      if (new_total >= ACE_HAS_SOCK_BUF_SIZE_MAX_VALUE)
        -:  839:        {
        -:  840:          local_iov[i].iov_len = ACE_HAS_SOCK_BUF_SIZE_MAX_VALUE - total;
        -:  841:          n = i+1;
        -:  842:          break;
        -:  843:        }
        -:  844:      total = new_total;
        -:  845:    }
        -:  846:  return ACE_OS::writev (handle, local_iov, n);
        -:  847:
        -:  848:#else
        -:  849:  return ACE_OS::writev (handle, buffers, n);
        -:  850:#endif /* ACE_HAS_WINSOCK2 */
        -:  851:}
        -:  852:
        -:  853:ACE_INLINE int
      139:  854:ACE_OS::setsockopt (ACE_HANDLE handle,
        -:  855:                    int level,
        -:  856:                    int optname,
        -:  857:                    const char *optval,
        -:  858:                    int optlen)
        -:  859:{
        -:  860:  ACE_OS_TRACE ("ACE_OS::setsockopt");
        -:  861:#if defined (ACE_LACKS_SETSOCKOPT)
        -:  862:  ACE_UNUSED_ARG (handle);
        -:  863:  ACE_UNUSED_ARG (level);
        -:  864:  ACE_UNUSED_ARG (optname);
        -:  865:  ACE_UNUSED_ARG (optval);
        -:  866:  ACE_UNUSED_ARG (optlen);
        -:  867:  ACE_NOTSUP_RETURN (-1);
        -:  868:#else
        -:  869:#if defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0) && defined(SO_REUSEPORT)
        -:  870:  // To work around an inconsistency with Microsofts implementation of
        -:  871:  // sockets, we will check for SO_REUSEADDR, and ignore it. Winsock
        -:  872:  // always behaves as if SO_REUSEADDR=1. Some implementations have
        -:  873:  // the same behaviour as Winsock, but use a new name for
        -:  874:  // it. SO_REUSEPORT.  If you want the normal behaviour for
        -:  875:  // SO_REUSEADDR=0, then NT 4 sp4 and later supports
        -:  876:  // SO_EXCLUSIVEADDRUSE. This also requires using an updated Platform
        -:  877:  // SDK so it was decided to ignore the option for now. (Especially
        -:  878:  // since Windows always sets SO_REUSEADDR=1, which we can mimic by doing
        -:  879:  // nothing.)
        -:  880:  if (level == SOL_SOCKET) {
        -:  881:    if (optname == SO_REUSEADDR) {
        -:  882:      return 0; // Not supported by Winsock
        -:  883:    }
        -:  884:    if (optname == SO_REUSEPORT) {
        -:  885:      optname = SO_REUSEADDR;
        -:  886:    }
        -:  887:  }
        -:  888:#endif /*ACE_HAS_WINSOCK2*/
        -:  889:
        -:  890:  int result;
      139:  891:  ACE_SOCKCALL (::setsockopt ((ACE_SOCKET) handle,
        -:  892:                              level,
        -:  893:                              optname,
        -:  894:                              (ACE_SOCKOPT_TYPE1) optval,
        -:  895:                              optlen),
        -:  896:                int,
        -:  897:                -1,
        -:  898:                result);
        -:  899:#if defined (WSAEOPNOTSUPP)
        -:  900:  if (result == -1 && (errno == WSAEOPNOTSUPP || errno == WSAENOPROTOOPT))
        -:  901:#else
      139:  902:  if (result == -1)
        -:  903:#endif /* WSAEOPNOTSUPP */
    #####:  904:    errno = ENOTSUP;
      139:  905:  return result;
        -:  906:#endif
        -:  907:}
        -:  908:
        -:  909:ACE_INLINE int
        -:  910:ACE_OS::shutdown (ACE_HANDLE handle, int how)
        -:  911:{
        -:  912:  ACE_OS_TRACE ("ACE_OS::shutdown");
        -:  913:#if defined (ACE_LACKS_SHUTDOWN)
        -:  914:  ACE_UNUSED_ARG (handle);
        -:  915:  ACE_UNUSED_ARG (how);
        -:  916:  ACE_NOTSUP_RETURN (-1);
        -:  917:#else
        -:  918:  ACE_SOCKCALL_RETURN (::shutdown ((ACE_SOCKET) handle, how), int, -1);
        -:  919:#endif /* ACE_LACKS_SHUTDOWN */
        -:  920:}
        -:  921:
        -:  922:ACE_INLINE ACE_HANDLE
        -:  923:ACE_OS::socket (int domain,
        -:  924:                int type,
        -:  925:                int proto)
        -:  926:{
        -:  927:  ACE_OS_TRACE ("ACE_OS::socket");
        -:  928:#if defined (ACE_LACKS_SOCKET)
        -:  929:  ACE_UNUSED_ARG (domain);
        -:  930:  ACE_UNUSED_ARG (type);
        -:  931:  ACE_UNUSED_ARG (proto);
        -:  932:  ACE_NOTSUP_RETURN (ACE_INVALID_HANDLE);
        -:  933:#else
        -:  934:  ACE_SOCKCALL_RETURN (::socket (domain,
        -:  935:                                 type,
        -:  936:                                 proto),
        -:  937:                       ACE_HANDLE,
        -:  938:                       ACE_INVALID_HANDLE);
        -:  939:#endif /* ACE_LACKS_SOCKET */
        -:  940:}
        -:  941:
        -:  942:ACE_INLINE ACE_HANDLE
        -:  943:ACE_OS::socket (int domain,
        -:  944:                int type,
        -:  945:                int proto,
        -:  946:                ACE_Protocol_Info *protocolinfo,
        -:  947:                ACE_SOCK_GROUP g,
        -:  948:                u_long flags)
        -:  949:{
        -:  950:  ACE_OS_TRACE ("ACE_OS::socket");
        -:  951:
        -:  952:#if defined (ACE_HAS_WINSOCK2) && (ACE_HAS_WINSOCK2 != 0)
        -:  953:  ACE_SOCKCALL_RETURN (::WSASocket (domain,
        -:  954:                                    type,
        -:  955:                                    proto,
        -:  956:                                    protocolinfo,
        -:  957:                                    g,
        -:  958:                                    flags),
        -:  959:                       ACE_HANDLE,
        -:  960:                       ACE_INVALID_HANDLE);
        -:  961:#else
        -:  962:  ACE_UNUSED_ARG (protocolinfo);
        -:  963:  ACE_UNUSED_ARG (g);
        -:  964:  ACE_UNUSED_ARG (flags);
        -:  965:
        -:  966:  return ACE_OS::socket (domain,
        -:  967:                         type,
        -:  968:                         proto);
        -:  969:#endif /* ACE_HAS_WINSOCK2 */
        -:  970:}
        -:  971:
        -:  972:ACE_INLINE int
        -:  973:ACE_OS::socketpair (int domain, int type,
        -:  974:                    int protocol, ACE_HANDLE sv[2])
        -:  975:{
        -:  976:  ACE_OS_TRACE ("ACE_OS::socketpair");
        -:  977:#if defined (ACE_LACKS_SOCKETPAIR)
        -:  978:  ACE_UNUSED_ARG (domain);
        -:  979:  ACE_UNUSED_ARG (type);
        -:  980:  ACE_UNUSED_ARG (protocol);
        -:  981:  ACE_UNUSED_ARG (sv);
        -:  982:
        -:  983:  ACE_NOTSUP_RETURN (-1);
        -:  984:#else
        -:  985:  ACE_OSCALL_RETURN (::socketpair (domain, type, protocol, sv),
        -:  986:                     int, -1);
        -:  987:#endif /* ACE_LACKS_SOCKETPAIR */
        -:  988:}
        -:  989:
        -:  990:#if defined (ACE_LINUX) && defined (ACE_HAS_IPV6)
        -:  991:ACE_INLINE unsigned int
        -:  992:ACE_OS::if_nametoindex (const char *ifname)
        -:  993:{
        -:  994:  ACE_OS_TRACE ("ACE_OS::if_nametoindex");
        -:  995:#if defined (ACE_LACKS_IF_NAME_INDEX)
        -:  996:  ACE_UNUSED_ARG (ifname);
        -:  997:  ACE_NOTSUP_RETURN (0);
        -:  998:#else
        -:  999:  ACE_OSCALL_RETURN (::if_nametoindex (ifname), int, 0);
        -: 1000:#endif /* ACE_LACKS_IF_NAME_INDEX */
        -: 1001:}
        -: 1002:
        -: 1003:ACE_INLINE char *
        -: 1004:ACE_OS::if_indextoname (unsigned int ifindex, char *ifname)
        -: 1005:{
        -: 1006:  ACE_OS_TRACE ("ACE_OS::if_indextoname");
        -: 1007:#if defined (ACE_LACKS_IF_NAME_INDEX)
        -: 1008:  ACE_UNUSED_ARG (ifindex);
        -: 1009:  ACE_UNUSED_ARG (ifname);
        -: 1010:  ACE_NOTSUP_RETURN (0);
        -: 1011:#else
        -: 1012:  ACE_OSCALL_RETURN (::if_indextoname (ifindex, ifname), char *, 0);
        -: 1013:#endif /* ACE_LACKS_IF_NAME_INDEX */
        -: 1014:}
        -: 1015:
        -: 1016:ACE_INLINE struct if_nameindex *
        -: 1017:ACE_OS::if_nameindex (void)
        -: 1018:{
        -: 1019:  ACE_OS_TRACE ("ACE_OS::if_nameindex");
        -: 1020:#if defined (ACE_LACKS_IF_NAME_INDEX)
        -: 1021:  ACE_NOTSUP_RETURN (0);
        -: 1022:#else
        -: 1023:  ACE_OSCALL_RETURN (::if_nameindex (), struct if_nameindex *, 0);
        -: 1024:#endif /* ACE_LACKS_IF_NAME_INDEX */
        -: 1025:}
        -: 1026:
        -: 1027:ACE_INLINE void
        -: 1028:ACE_OS::if_freenameindex (struct if_nameindex *ptr)
        -: 1029:{
        -: 1030:  ACE_OS_TRACE ("ACE_OS::if_freenameindex");
        -: 1031:#if defined (ACE_LACKS_IF_NAME_INDEX)
        -: 1032:  ACE_UNUSED_ARG (ptr);
        -: 1033:#else
        -: 1034:  if (ptr != 0)
        -: 1035:    ::if_freenameindex (ptr);
        -: 1036:#endif /* ACE_LACKS_IF_NAME_INDEX */
        -: 1037:}
        -: 1038:#endif /* ACE_LINUX && ACE_HAS_IPV6 */
        -: 1039:
        -: 1040:ACE_END_VERSIONED_NAMESPACE_DECL
