        -:    0:Source:../dds/DCPS/RakeResults_T.cpp
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:#ifndef RAKERESULTS_T_CPP
        -:    8:#define RAKERESULTS_T_CPP
        -:    9:
        -:   10:#include "dds/DCPS/RakeResults_T.h"
        -:   11:#include "dds/DCPS/SubscriptionInstance.h"
        -:   12:#include "dds/DCPS/DataReaderImpl.h"
        -:   13:#include "dds/DCPS/QueryConditionImpl.h"
        -:   14:#include "dds/DCPS/PoolAllocator.h"
        -:   15:
        -:   16:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   17:
        -:   18:namespace OpenDDS {
        -:   19:namespace DCPS {
        -:   20:
        -:   21:template <class SampleSeq>
    #####:   22:RakeResults<SampleSeq>::RakeResults(DataReaderImpl* reader,
        -:   23:                                    SampleSeq& received_data,
        -:   24:                                    DDS::SampleInfoSeq& info_seq,
        -:   25:                                    CORBA::Long max_samples,
        -:   26:                                    DDS::PresentationQosPolicy presentation,
        -:   27:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:   28:                                    DDS::QueryCondition_ptr cond,
        -:   29:#endif
        -:   30:                                    Operation_t oper)
        -:   31:  : reader_(reader)
        -:   32:  , received_data_(received_data)
        -:   33:  , info_seq_(info_seq)
        -:   34:  , max_samples_(max_samples)
        -:   35:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:   36:  , cond_(cond)
        -:   37:#endif
        -:   38:  , oper_(oper)
        -:   39:  , do_sort_(false)
    #####:   40:  , do_filter_(false)
        -:   41:{
        -:   42:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:   43:
    #####:   44:  if (cond_) {
    #####:   45:    const QueryConditionImpl* qci = dynamic_cast<QueryConditionImpl*>(cond_);
    #####:   46:    if (!qci) {
    #####:   47:      ACE_ERROR((LM_DEBUG, ACE_TEXT("(%P|%t) ERROR: RakeResults(): ")
        -:   48:        ACE_TEXT("failed to obtain QueryConditionImpl\n")));
    #####:   49:      return;
        -:   50:    }
    #####:   51:    do_filter_ = qci->hasFilter();
    #####:   52:    std::vector<OPENDDS_STRING> order_bys = qci->getOrderBys();
    #####:   53:    do_sort_ = order_bys.size() > 0;
        -:   54:
    #####:   55:    if (do_sort_) {
    #####:   56:      ComparatorBase::Ptr cmp;
        -:   57:
        -:   58:      // Iterate in reverse over the comma-separated fields so that the
        -:   59:      // top-level comparison is the leftmost.  The others will be chained.
    #####:   60:      for (size_t i = order_bys.size(); i > 0; --i) {
    #####:   61:        const OPENDDS_STRING& fieldspec = order_bys[i - 1];
        -:   62:        //FUTURE: handle ASC / DESC as an extension to the DDS spec?
    #####:   63:        cmp = getMetaStruct<typename SampleSeq::value_type>()
        -:   64:          .create_qc_comparator(fieldspec.c_str(), cmp);
        -:   65:      }
        -:   66:
    #####:   67:      SortedSetCmp comparator(cmp);
    #####:   68:      SortedSet actual_sort(comparator);
    #####:   69:      sorted_.swap(actual_sort);
        -:   70:    }
        -:   71:
        -:   72:  } else {
        -:   73:#endif
        -:   74:    // PRESENTATION ordered access (TOPIC)
    #####:   75:    this->do_sort_ = presentation.ordered_access == true &&
    #####:   76:                     presentation.access_scope == DDS::TOPIC_PRESENTATION_QOS;
        -:   77:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:   78:  }
        -:   79:
        -:   80:#endif
        -:   81:}
        -:   82:
        -:   83:template <class SampleSeq>
    #####:   84:bool RakeResults<SampleSeq>::insert_sample(ReceivedDataElement* sample,
        -:   85:                                           SubscriptionInstance_rch instance,
        -:   86:                                           size_t index_in_instance)
        -:   87:{
        -:   88:#ifndef OPENDDS_NO_QUERY_CONDITION
        -:   89:
    #####:   90:  if (do_filter_) {
    #####:   91:    const QueryConditionImpl* qci = dynamic_cast<QueryConditionImpl*>(cond_);
        -:   92:    typedef typename SampleSeq::value_type VT;
    #####:   93:    const VT* typed_sample = static_cast<VT*>(sample->registered_data_);
    #####:   94:    if (!qci || !typed_sample || !qci->filter(*typed_sample, !sample->valid_data_)) {
    #####:   95:      return false;
        -:   96:    }
        -:   97:  }
        -:   98:
        -:   99:#endif
        -:  100:
    #####:  101:  if (do_sort_) {
        -:  102:    // N.B. Until a better heuristic is found, non-valid
        -:  103:    // samples are elided when sorting by QueryCondition.
        -:  104:#ifndef OPENDDS_NO_QUERY_CONDITION
    #####:  105:    if (cond_ && !sample->registered_data_) return false;
        -:  106:#endif
        -:  107:
    #####:  108:    RakeData rd = {sample, instance, index_in_instance};
    #####:  109:    sorted_.insert(rd);
        -:  110:
        -:  111:  } else {
    #####:  112:    if (unsorted_.size() == max_samples_) return false;
        -:  113:
    #####:  114:    RakeData rd = {sample, instance, index_in_instance};
    #####:  115:    unsorted_.push_back(rd);
        -:  116:  }
        -:  117:
    #####:  118:  return true;
        -:  119:}
        -:  120:
        -:  121:template <class SampleSeq>
        -:  122:template <class FwdIter>
    #####:  123:bool RakeResults<SampleSeq>::copy_into(FwdIter iter, FwdIter end,
        -:  124:                                       typename SampleSeq::PrivateMemberAccess& received_data_p)
        -:  125:{
        -:  126:  typedef typename SampleSeq::value_type Sample;
        -:  127:  typedef OPENDDS_MAP(SubscriptionInstance*, InstanceData) InstanceMap;
    #####:  128:  InstanceMap inst_map;
        -:  129:
        -:  130:  typedef OPENDDS_SET(SubscriptionInstance*) InstanceSet;
    #####:  131:  InstanceSet released_instances;
        -:  132:
    #####:  133:  for (CORBA::ULong idx = 0; iter != end && idx < max_samples_; ++idx, ++iter) {
        -:  134:    // 1. Populate the Received Data sequence
    #####:  135:    ReceivedDataElement* rde = iter->rde_;
        -:  136:
    #####:  137:    if (received_data_.maximum() != 0) {
    #####:  138:      if (rde->registered_data_ == 0) {
    #####:  139:        received_data_p.assign_sample(idx, Sample());
        -:  140:
        -:  141:      } else {
    #####:  142:        received_data_p.assign_sample(idx,
    #####:  143:                                      *static_cast<Sample*>(rde->registered_data_));
        -:  144:      }
        -:  145:
        -:  146:    } else {
    #####:  147:      received_data_p.assign_ptr(idx, rde);
        -:  148:    }
        -:  149:
        -:  150:    // 2. Per-sample SampleInfo (not the three *_rank variables) and state
    #####:  151:    SubscriptionInstance& inst = *iter->si_;
    #####:  152:    inst.instance_state_.sample_info(info_seq_[idx], rde);
    #####:  153:    rde->sample_state_ = DDS::READ_SAMPLE_STATE;
        -:  154:
        -:  155:    // 3. Record some info about per-instance SampleInfo (*_rank) so that
        -:  156:    //    we can fill in the ranks after the loop has completed
    #####:  157:    std::pair<typename InstanceMap::iterator, bool> result =
        -:  158:      inst_map.insert(std::make_pair(&inst, InstanceData()));
    #####:  159:    InstanceData& id = result.first->second;
        -:  160:
    #####:  161:    if (result.second) { // first time we've seen this Instance
    #####:  162:      ReceivedDataElement& mrs = *inst.rcvd_samples_.tail_;
    #####:  163:      id.MRS_disposed_gc_ =
    #####:  164:        static_cast<CORBA::Long>(mrs.disposed_generation_count_);
    #####:  165:      id.MRS_nowriters_gc_ =
    #####:  166:        static_cast<CORBA::Long>(mrs.no_writers_generation_count_);
        -:  167:    }
        -:  168:
    #####:  169:    if (iter->index_in_instance_ >= id.MRSIC_index_) {
    #####:  170:      id.MRSIC_index_ = iter->index_in_instance_;
    #####:  171:      id.MRSIC_disposed_gc_ =
    #####:  172:        static_cast<CORBA::Long>(rde->disposed_generation_count_);
    #####:  173:      id.MRSIC_nowriters_gc_ =
    #####:  174:        static_cast<CORBA::Long>(rde->no_writers_generation_count_);
        -:  175:    }
        -:  176:
    #####:  177:    if (!id.most_recent_generation_) {
    #####:  178:      id.most_recent_generation_ =
    #####:  179:        inst.instance_state_.most_recent_generation(rde);
        -:  180:    }
        -:  181:
    #####:  182:    id.sampleinfo_positions_.push_back(idx);
        -:  183:
        -:  184:    // 4. Take
    #####:  185:    if (oper_ == DDS_OPERATION_TAKE) {
        -:  186:      // If removing the sample releases it
    #####:  187:      if (inst.rcvd_samples_.remove(rde)) {
        -:  188:        // Prevent access of the SampleInfo, below
    #####:  189:        released_instances.insert(&inst);
        -:  190:      }
    #####:  191:      rde->dec_ref();
        -:  192:    }
        -:  193:  }
        -:  194:
        -:  195:  // Fill in the *_ranks in the SampleInfo, and set instance state (mrg)
    #####:  196:  for (typename InstanceMap::iterator i_iter(inst_map.begin()),
    #####:  197:       i_end(inst_map.end()); i_iter != i_end; ++i_iter) {
        -:  198:
    #####:  199:    InstanceData& id = i_iter->second;
        -:  200:    {  // Danger, limit visibility of inst
    #####:  201:      SubscriptionInstance& inst = *i_iter->first;
        -:  202:      // If this instance has not been released
    #####:  203:      if (released_instances.find(&inst) == released_instances.end()) {
    #####:  204:        if (id.most_recent_generation_) {
    #####:  205:          inst.instance_state_.accessed();
        -:  206:        }
        -:  207:      }
        -:  208:    }
        -:  209:
    #####:  210:    CORBA::Long sample_rank =
    #####:  211:      static_cast<CORBA::Long>(id.sampleinfo_positions_.size());
        -:  212:
    #####:  213:    for (IndexList::iterator s_iter(id.sampleinfo_positions_.begin()),
    #####:  214:         s_end(id.sampleinfo_positions_.end()); s_iter != s_end; ++s_iter) {
    #####:  215:      DDS::SampleInfo& si = info_seq_[*s_iter];
    #####:  216:      si.sample_rank = --sample_rank;
    #####:  217:      si.generation_rank = id.MRSIC_disposed_gc_
    #####:  218:                           + id.MRSIC_nowriters_gc_ - si.generation_rank;
    #####:  219:      si.absolute_generation_rank = id.MRS_disposed_gc_ +
    #####:  220:                                    id.MRS_nowriters_gc_ - si.absolute_generation_rank;
        -:  221:    }
        -:  222:  }
        -:  223:
    #####:  224:  return true;
        -:  225:}
        -:  226:
        -:  227:template <class SampleSeq>
    #####:  228:bool RakeResults<SampleSeq>::copy_to_user()
        -:  229:{
    #####:  230:  typename SampleSeq::PrivateMemberAccess received_data_p(received_data_);
        -:  231:
    #####:  232:  if (do_sort_) {
    #####:  233:    size_t len = std::min(static_cast<size_t>(sorted_.size()),
    #####:  234:                          static_cast<size_t>(max_samples_));
    #####:  235:    received_data_p.internal_set_length(static_cast<CORBA::ULong>(len));
    #####:  236:    info_seq_.length(static_cast<CORBA::ULong>(len));
    #####:  237:    return copy_into(sorted_.begin(), sorted_.end(), received_data_p);
        -:  238:
        -:  239:  } else {
    #####:  240:    size_t len = unsorted_.size(); //can't be larger than max_samples_
    #####:  241:    received_data_p.internal_set_length(static_cast<CORBA::ULong>(len));
    #####:  242:    info_seq_.length(static_cast<CORBA::ULong>(len));
    #####:  243:    return copy_into(unsorted_.begin(), unsorted_.end(), received_data_p);
        -:  244:  }
        -:  245:}
        -:  246:
        -:  247:} // namespace DCPS
        -:  248:} // namespace OpenDDS
        -:  249:
        -:  250:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  251:
        -:  252:#endif /* RAKERESULTS_H  */
