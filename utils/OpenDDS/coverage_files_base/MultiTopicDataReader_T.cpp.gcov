        -:    0:Source:../dds/DCPS/MultiTopicDataReader_T.cpp
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:#ifndef OPENDDS_DCPS_MULTITOPICDATAREADER_T_CPP
        -:    9:#define OPENDDS_DCPS_MULTITOPICDATAREADER_T_CPP
        -:   10:
        -:   11:#ifndef OPENDDS_NO_MULTI_TOPIC
        -:   12:
        -:   13:#include <stdexcept>
        -:   14:#include <sstream>
        -:   15:
        -:   16:
        -:   17:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   18:
        -:   19:namespace OpenDDS {
        -:   20:namespace DCPS {
        -:   21:
        -:   22:template<typename Sample, typename TypedDataReader>
        -:   23:void
    #####:   24:MultiTopicDataReader_T<Sample, TypedDataReader>::init_typed(DataReaderEx* dr)
        -:   25:{
    #####:   26:  typed_reader_ = TypedDataReader::Interface::_narrow(dr);
    #####:   27:}
        -:   28:
        -:   29:template<typename Sample, typename TypedDataReader>
        -:   30:const MetaStruct&
    #####:   31:MultiTopicDataReader_T<Sample, TypedDataReader>::getResultingMeta()
        -:   32:{
    #####:   33:  return getMetaStruct<Sample>();
        -:   34:}
        -:   35:
        -:   36:template<typename Sample, typename TypedDataReader>
        -:   37:void
    #####:   38:MultiTopicDataReader_T<Sample, TypedDataReader>::assign_fields(void* incoming,
        -:   39:  Sample& resulting, const MultiTopicDataReaderBase::QueryPlan& qp,
        -:   40:  const MetaStruct& meta)
        -:   41:{
        -:   42:  using namespace std;
    #####:   43:  const vector<SubjectFieldSpec>& proj = qp.projection_;
    #####:   44:  const MetaStruct& resulting_meta = getResultingMeta();
        -:   45:  typedef vector<SubjectFieldSpec>::const_iterator iter_t;
    #####:   46:  for (iter_t iter = proj.begin(); iter != proj.end(); ++iter) {
    #####:   47:    const SubjectFieldSpec& sfs = *iter;
    #####:   48:    resulting_meta.assign(&resulting, sfs.resulting_name_.c_str(),
        -:   49:                          incoming, sfs.incoming_name_.c_str(), meta);
        -:   50:  }
        -:   51:
    #####:   52:  const vector<OPENDDS_STRING>& proj_out = qp.keys_projected_out_;
    #####:   53:  for (vector<OPENDDS_STRING>::const_iterator iter = proj_out.begin();
    #####:   54:       iter != proj_out.end(); ++iter) {
    #####:   55:    resulting_meta.assign(&resulting, iter->c_str(),
        -:   56:                          incoming, iter->c_str(), meta);
        -:   57:  }
    #####:   58:}
        -:   59:
        -:   60:template<typename Sample, typename TypedDataReader>
        -:   61:void
    #####:   62:MultiTopicDataReader_T<Sample, TypedDataReader>::assign_resulting_fields(
        -:   63:  Sample& target, const Sample& source, const TopicSet& other_topics)
        -:   64:{
        -:   65:  using namespace std;
    #####:   66:  const MetaStruct& meta = getResultingMeta();
    #####:   67:  for (TopicSet::const_iterator iterTopic = other_topics.begin();
    #####:   68:       iterTopic != other_topics.end(); ++iterTopic) {
    #####:   69:    const QueryPlan& qp = query_plans_[*iterTopic];
    #####:   70:    const vector<SubjectFieldSpec>& proj = qp.projection_;
        -:   71:    typedef vector<SubjectFieldSpec>::const_iterator iter_t;
    #####:   72:    for (iter_t iter = proj.begin(); iter != proj.end(); ++iter) {
    #####:   73:      const SubjectFieldSpec& sfs = *iter;
    #####:   74:      meta.assign(&target, sfs.resulting_name_.c_str(),
        -:   75:                  &source, sfs.resulting_name_.c_str(), meta);
        -:   76:    }
        -:   77:  }
    #####:   78:}
        -:   79:
        -:   80:template<typename Sample, typename TypedDataReader>
        -:   81:void
    #####:   82:MultiTopicDataReader_T<Sample, TypedDataReader>::join(
        -:   83:  SampleVec& resulting, const SampleWithInfo& prototype,
        -:   84:  const std::vector<OPENDDS_STRING>& key_names, const void* key_data,
        -:   85:  DDS::DataReader_ptr other_dr, const MetaStruct& other_meta)
        -:   86:{
        -:   87:  using namespace DDS;
    #####:   88:  DataReaderImpl* other_dri = dynamic_cast<DataReaderImpl*>(other_dr);
        -:   89:
    #####:   90:  if (!other_dri) {
    #####:   91:    ACE_ERROR((LM_ERROR,
        -:   92:      ACE_TEXT("(%P|%t) ERROR: ")
        -:   93:      ACE_TEXT("MultiTopicDataReader_T::join, ")
        -:   94:      ACE_TEXT("Failed to get DataReaderImpl.\n")));
    #####:   95:    return;
        -:   96:  }
        -:   97:
    #####:   98:  TopicDescription_var other_td = other_dri->get_topicdescription();
    #####:   99:  CORBA::String_var other_topic = other_td->get_name();
    #####:  100:  const QueryPlan& other_qp = query_plans_[other_topic.in()];
    #####:  101:  const size_t n_keys = key_names.size();
        -:  102:
    #####:  103:  if (n_keys > 0 && other_meta.numDcpsKeys() == n_keys) { // complete key
    #####:  104:    InstanceHandle_t ih = other_dri->lookup_instance_generic(key_data);
    #####:  105:    if (ih != HANDLE_NIL) {
    #####:  106:      GenericData other_data(other_meta, false);
        -:  107:      SampleInfo info;
    #####:  108:      ReturnCode_t ret = other_dri->read_instance_generic(other_data.ptr_,
        -:  109:        info, ih, READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
    #####:  110:      if (ret != RETCODE_OK && ret != RETCODE_NO_DATA) {
    #####:  111:        std::ostringstream rc_ss;
    #####:  112:        rc_ss << ret;
        -:  113:        throw std::runtime_error("In join(), incoming DataReader for " +
    #####:  114:          OPENDDS_STRING(other_topic) + " read_instance_generic, error #" +
    #####:  115:          rc_ss.str());
    #####:  116:      } else if (ret == DDS::RETCODE_OK) {
    #####:  117:        resulting.push_back(prototype);
    #####:  118:        resulting.back().combine(SampleWithInfo(other_topic.in(), info));
    #####:  119:        assign_fields(other_data.ptr_, resulting.back().sample_,
        -:  120:                      other_qp, other_meta);
        -:  121:      }
        -:  122:    }
        -:  123:  } else { // incomplete key or cross-join (0 key fields)
    #####:  124:    SampleVec new_resulting;
    #####:  125:    ReturnCode_t ret = RETCODE_OK;
    #####:  126:    for (InstanceHandle_t ih = HANDLE_NIL; ret != RETCODE_NO_DATA;) {
    #####:  127:      GenericData other_data(other_meta, false);
        -:  128:      SampleInfo info;
    #####:  129:      ret = other_dri->read_next_instance_generic(other_data.ptr_, info, ih,
        -:  130:        READ_SAMPLE_STATE, ANY_VIEW_STATE, ALIVE_INSTANCE_STATE);
    #####:  131:      if (ret != RETCODE_OK && ret != RETCODE_NO_DATA) {
    #####:  132:        std::ostringstream rc_ss;
    #####:  133:        rc_ss << ret;
        -:  134:        throw std::runtime_error("In join(), incoming DataReader for " +
    #####:  135:          OPENDDS_STRING(other_topic) + " read_next_instance_generic, error #" +
    #####:  136:          rc_ss.str());
    #####:  137:      } else if (ret == RETCODE_NO_DATA) {
    #####:  138:        break;
        -:  139:      }
    #####:  140:      ih = info.instance_handle;
        -:  141:
    #####:  142:      bool match = true;
    #####:  143:      for (size_t i = 0; match && i < key_names.size(); ++i) {
    #####:  144:        if (!other_meta.compare(key_data, other_data.ptr_,
    #####:  145:                                key_names[i].c_str())) {
    #####:  146:          match = false;
        -:  147:        }
        -:  148:      }
        -:  149:
    #####:  150:      if (match) {
    #####:  151:        resulting.push_back(prototype);
    #####:  152:        resulting.back().combine(SampleWithInfo(other_topic.in(), info));
    #####:  153:        assign_fields(other_data.ptr_, resulting.back().sample_,
        -:  154:                      other_qp, other_meta);
        -:  155:      }
        -:  156:    }
        -:  157:  }
        -:  158:}
        -:  159:
        -:  160:template<typename Sample, typename TypedDataReader>
        -:  161:void
    #####:  162:MultiTopicDataReader_T<Sample, TypedDataReader>::combine(
        -:  163:  SampleVec& resulting, const SampleVec& other,
        -:  164:  const std::vector<OPENDDS_STRING>& key_names, const TopicSet& other_topics)
        -:  165:{
    #####:  166:  const MetaStruct& meta = getResultingMeta();
    #####:  167:  SampleVec newData;
    #####:  168:  for (typename SampleVec::iterator iterRes = resulting.begin();
    #####:  169:       iterRes != resulting.end(); /*incremented in loop*/) {
    #####:  170:    bool foundOneMatch = false;
    #####:  171:    for (typename SampleVec::const_iterator iterOther = other.begin();
    #####:  172:         iterOther != other.end(); ++iterOther) {
    #####:  173:      bool match = true;
    #####:  174:      for (size_t i = 0; match && i < key_names.size(); ++i) {
    #####:  175:        if (!meta.compare(&*iterRes, &*iterOther, key_names[i].c_str())) {
    #####:  176:          match = false;
        -:  177:        }
        -:  178:      }
    #####:  179:      if (!match) {
    #####:  180:        continue;
        -:  181:      }
    #####:  182:      if (foundOneMatch) {
    #####:  183:        newData.push_back(*iterRes);
    #####:  184:        newData.back().combine(*iterOther);
    #####:  185:        assign_resulting_fields(newData.back().sample_,
    #####:  186:                                iterOther->sample_, other_topics);
        -:  187:      } else {
    #####:  188:        foundOneMatch = true;
    #####:  189:        iterRes->combine(*iterOther);
    #####:  190:        assign_resulting_fields(iterRes->sample_,
    #####:  191:                                iterOther->sample_, other_topics);
        -:  192:      }
        -:  193:    }
    #####:  194:    if (foundOneMatch) {
    #####:  195:      ++iterRes;
        -:  196:    } else {
        -:  197:      // no match found in 'other' so data must not appear in result set
    #####:  198:      iterRes = resulting.erase(iterRes);
        -:  199:    }
        -:  200:  }
    #####:  201:  resulting.insert(resulting.end(), newData.begin(), newData.end());
    #####:  202:}
        -:  203:
        -:  204:template<typename Sample, typename TypedDataReader>
        -:  205:void
    #####:  206:MultiTopicDataReader_T<Sample, TypedDataReader>::process_joins(
        -:  207:  std::map<TopicSet, SampleVec>& partialResults, SampleVec starting,
        -:  208:  const TopicSet& seen, const QueryPlan& qp)
        -:  209:{
        -:  210:  using namespace std;
    #####:  211:  const MetaStruct& resulting_meta = getResultingMeta();
    #####:  212:  const OPENDDS_STRING this_topic = topicNameFor(qp.data_reader_);
        -:  213:  typedef multimap<OPENDDS_STRING, OPENDDS_STRING>::const_iterator iter_t;
    #####:  214:  for (iter_t iter = qp.adjacent_joins_.begin();
    #####:  215:       iter != qp.adjacent_joins_.end();) { // for each topic we're joining
    #####:  216:    const OPENDDS_STRING& other_topic = iter->first;
    #####:  217:    iter_t range_end = qp.adjacent_joins_.upper_bound(other_topic);
    #####:  218:    const QueryPlan& other_qp = query_plans_[other_topic];
    #####:  219:    DDS::DataReader_ptr other_dr = other_qp.data_reader_;
        -:  220:
        -:  221:    try {
    #####:  222:      const MetaStruct& other_meta = metaStructFor(other_dr);
        -:  223:
    #####:  224:      vector<OPENDDS_STRING> keys;
    #####:  225:      for (; iter != range_end; ++iter) { // for each key in common w/ this topic
    #####:  226:        keys.push_back(iter->second);
        -:  227:      }
        -:  228:
    #####:  229:      typename std::map<TopicSet, SampleVec>::iterator found =
    #####:  230:        find_if(partialResults.begin(), partialResults.end(),
        -:  231:          Contains(other_topic));
        -:  232:
    #####:  233:      if (found == partialResults.end()) { // haven't seen this topic yet
        -:  234:
    #####:  235:        partialResults.erase(seen);
    #####:  236:        TopicSet withJoin(seen);
    #####:  237:        withJoin.insert(other_topic);
    #####:  238:        SampleVec& join_result = partialResults[withJoin];
    #####:  239:        for (size_t i = 0; i < starting.size(); ++i) {
    #####:  240:          GenericData other_key(other_meta);
    #####:  241:          for (size_t j = 0; j < keys.size(); ++j) {
    #####:  242:            other_meta.assign(other_key.ptr_, keys[j].c_str(),
    #####:  243:              &starting[i], keys[j].c_str(), resulting_meta);
        -:  244:          }
    #####:  245:          join(join_result, starting[i], keys,
    #####:  246:            other_key.ptr_, other_dr, other_meta);
        -:  247:        }
        -:  248:
    #####:  249:        if (!join_result.empty() && !seen.count(other_topic)) {
        -:  250:          // recurse
    #####:  251:          process_joins(partialResults, join_result, withJoin, other_qp);
        -:  252:        }
        -:  253:
    #####:  254:      } else if (!found->first.count(this_topic) /*avoid looping back*/) {
        -:  255:        // we have partialResults for this topic, use them instead of recursing
        -:  256:
    #####:  257:        combine(starting, found->second, keys, found->first);
    #####:  258:        TopicSet newKey(found->first);
    #####:  259:        for (set<OPENDDS_STRING>::const_iterator i3 = found->first.begin();
    #####:  260:          i3 != found->first.end(); ++i3) {
    #####:  261:          newKey.insert(*i3);
        -:  262:        }
    #####:  263:        partialResults.erase(found);
    #####:  264:        partialResults[newKey] = starting;
        -:  265:
        -:  266:      }
    =====:  267:    } catch (const std::runtime_error& e) {
    =====:  268:      ACE_ERROR((LM_ERROR, "(%P|%t) MultiTopicDataReader_T::process_joins: "
        -:  269:        "%C", e.what()));
        -:  270:    }
        -:  271:  }
    #####:  272:}
        -:  273:
        -:  274:template<typename Sample, typename TypedDataReader>
        -:  275:void
    #####:  276:MultiTopicDataReader_T<Sample, TypedDataReader>::cross_join(
        -:  277:  std::map<TopicSet, SampleVec>& partialResults, const TopicSet& seen,
        -:  278:  const QueryPlan& qp)
        -:  279:{
        -:  280:  using namespace std;
        -:  281:  try {
    #####:  282:    const MetaStruct& other_meta = metaStructFor(qp.data_reader_);
    #####:  283:    vector<OPENDDS_STRING> no_keys;
    #####:  284:    for (typename std::map<TopicSet, SampleVec>::iterator iterPR =
    #####:  285:      partialResults.begin(); iterPR != partialResults.end(); ++iterPR) {
    #####:  286:      SampleVec resulting;
    #####:  287:      for (typename SampleVec::iterator i = iterPR->second.begin();
    #####:  288:        i != iterPR->second.end(); ++i) {
    #####:  289:        join(resulting, *i, no_keys, NULL, qp.data_reader_, other_meta);
        -:  290:      }
    #####:  291:      resulting.swap(iterPR->second);
        -:  292:    }
    #####:  293:    TopicSet withJoin(seen);
    #####:  294:    withJoin.insert(topicNameFor(qp.data_reader_));
    #####:  295:    partialResults[withJoin].swap(partialResults[seen]);
    #####:  296:    partialResults.erase(seen);
    #####:  297:    process_joins(partialResults, partialResults[withJoin], withJoin, qp);
    =====:  298:  } catch (const std::runtime_error& e) {
    =====:  299:    if (OpenDDS::DCPS::DCPS_debug_level) {
    =====:  300:      ACE_ERROR((LM_ERROR, "(%P|%t) MultiTopicDataReader_T::cross_join: %C", e.what()));
        -:  301:    }
        -:  302:  }
    #####:  303:}
        -:  304:
        -:  305:template<typename Sample, typename TypedDataReader>
        -:  306:void
    #####:  307:MultiTopicDataReader_T<Sample, TypedDataReader>::incoming_sample(void* sample,
        -:  308:  const DDS::SampleInfo& info, const char* topic, const MetaStruct& meta)
        -:  309:{
        -:  310:  using namespace std;
        -:  311:  using namespace DDS;
    #####:  312:  const QueryPlan& qp = query_plans_[topic];
        -:  313:
        -:  314:  // Track results of joins along multiple paths through the MultiTopic keys.
    #####:  315:  std::map<TopicSet, SampleVec> partialResults;
    #####:  316:  TopicSet seen;
    #####:  317:  seen.insert(topic);
    #####:  318:  partialResults[seen].push_back(SampleWithInfo(topic, info));
    #####:  319:  assign_fields(sample, partialResults[seen].back().sample_, qp, meta);
        -:  320:
    #####:  321:  process_joins(partialResults, partialResults[seen], seen, qp);
        -:  322:
        -:  323:  // Any topic we haven't seen needs to be cross-joined
    #####:  324:  for (std::map<OPENDDS_STRING, QueryPlan>::iterator iter = query_plans_.begin();
    #####:  325:       iter != query_plans_.end(); ++iter) {
    #####:  326:    typename std::map<TopicSet, SampleVec>::iterator found =
    #####:  327:      find_if(partialResults.begin(), partialResults.end(),
    #####:  328:              Contains(iter->first));
    #####:  329:    if (found == partialResults.end()) {
    #####:  330:      cross_join(partialResults, seen, iter->second);
        -:  331:    }
        -:  332:  }
        -:  333:
    #####:  334:  TypedDataReader* tdr = dynamic_cast<TypedDataReader*>(typed_reader_.in());
        -:  335:
    #####:  336:  if (!tdr) {
    #####:  337:    ACE_ERROR((LM_ERROR,
        -:  338:      ACE_TEXT("(%P|%t) ERROR: ")
        -:  339:      ACE_TEXT("MultiTopicDataReader_T::incoming_sample, ")
        -:  340:      ACE_TEXT("Failed to get TypedDataReader.\n")));
    #####:  341:    return;
        -:  342:  }
        -:  343:
    #####:  344:  for (typename std::map<TopicSet, SampleVec>::iterator iterPR =
    #####:  345:       partialResults.begin(); iterPR != partialResults.end(); ++iterPR) {
    #####:  346:    for (typename SampleVec::iterator i = iterPR->second.begin();
    #####:  347:         i != iterPR->second.end(); ++i) {
    #####:  348:      InstanceHandle_t ih = tdr->store_synthetic_data(i->sample_, i->view_);
    #####:  349:      if (ih != HANDLE_NIL) {
        -:  350:        typedef std::map<OPENDDS_STRING, InstanceHandle_t>::iterator mapiter_t;
    #####:  351:        for (mapiter_t iterMap = i->info_.begin(); iterMap != i->info_.end();
        -:  352:             ++iterMap) {
    #####:  353:          query_plans_[iterMap->first].instances_.insert(
    #####:  354:            make_pair(iterMap->second, ih));
        -:  355:        }
        -:  356:      }
        -:  357:    }
        -:  358:  }
        -:  359:}
        -:  360:
        -:  361:// The following methods implement the FooDataReader API by delegating
        -:  362:// to the typed_reader_.
        -:  363:
        -:  364:template<typename Sample, typename TypedDataReader>
        -:  365:DDS::ReturnCode_t
    #####:  366:MultiTopicDataReader_T<Sample, TypedDataReader>::read(SampleSeq& received_data,
        -:  367:  DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples,
        -:  368:  DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  369:  DDS::InstanceStateMask instance_states)
        -:  370:{
    #####:  371:  return typed_reader_->read(received_data, info_seq, max_samples,
    #####:  372:    sample_states, view_states, instance_states);
        -:  373:}
        -:  374:
        -:  375:template<typename Sample, typename TypedDataReader>
        -:  376:DDS::ReturnCode_t
    #####:  377:MultiTopicDataReader_T<Sample, TypedDataReader>::take(SampleSeq& received_data,
        -:  378:  DDS::SampleInfoSeq& info_seq, CORBA::Long max_samples,
        -:  379:  DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  380:  DDS::InstanceStateMask instance_states)
        -:  381:{
    #####:  382:  return typed_reader_->take(received_data, info_seq, max_samples,
    #####:  383:    sample_states, view_states, instance_states);
        -:  384:}
        -:  385:
        -:  386:template<typename Sample, typename TypedDataReader>
        -:  387:DDS::ReturnCode_t
    #####:  388:MultiTopicDataReader_T<Sample, TypedDataReader>::read_w_condition(
        -:  389:  SampleSeq& data_values, DDS::SampleInfoSeq& sample_infos,
        -:  390:  CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition)
        -:  391:{
    #####:  392:  return typed_reader_->read_w_condition(data_values, sample_infos,
    #####:  393:    max_samples, a_condition);
        -:  394:}
        -:  395:
        -:  396:template<typename Sample, typename TypedDataReader>
        -:  397:DDS::ReturnCode_t
    #####:  398:MultiTopicDataReader_T<Sample, TypedDataReader>::take_w_condition(
        -:  399:  SampleSeq& data_values, DDS::SampleInfoSeq& sample_infos,
        -:  400:  CORBA::Long max_samples, DDS::ReadCondition_ptr a_condition)
        -:  401:{
    #####:  402:  return typed_reader_->take_w_condition(data_values, sample_infos,
    #####:  403:    max_samples, a_condition);
        -:  404:}
        -:  405:
        -:  406:template<typename Sample, typename TypedDataReader>
        -:  407:DDS::ReturnCode_t
    #####:  408:MultiTopicDataReader_T<Sample, TypedDataReader>::read_next_sample(
        -:  409:  Sample& received_data, DDS::SampleInfo& sample_info)
        -:  410:{
    #####:  411:  return typed_reader_->read_next_sample(received_data, sample_info);
        -:  412:}
        -:  413:
        -:  414:template<typename Sample, typename TypedDataReader>
        -:  415:DDS::ReturnCode_t
    #####:  416:MultiTopicDataReader_T<Sample, TypedDataReader>::take_next_sample(
        -:  417:  Sample& received_data, DDS::SampleInfo& sample_info)
        -:  418:{
    #####:  419:  return typed_reader_->take_next_sample(received_data, sample_info);
        -:  420:}
        -:  421:
        -:  422:template<typename Sample, typename TypedDataReader>
        -:  423:DDS::ReturnCode_t
    #####:  424:MultiTopicDataReader_T<Sample, TypedDataReader>::read_instance(
        -:  425:  SampleSeq& received_data, DDS::SampleInfoSeq& info_seq,
        -:  426:  CORBA::Long max_samples, DDS::InstanceHandle_t a_handle,
        -:  427:  DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  428:  DDS::InstanceStateMask instance_states)
        -:  429:{
    #####:  430:  return typed_reader_->read_instance(received_data, info_seq, max_samples,
    #####:  431:    a_handle, sample_states, view_states, instance_states);
        -:  432:}
        -:  433:
        -:  434:template<typename Sample, typename TypedDataReader>
        -:  435:DDS::ReturnCode_t
    #####:  436:MultiTopicDataReader_T<Sample, TypedDataReader>::take_instance(
        -:  437:  SampleSeq& received_data, DDS::SampleInfoSeq& info_seq,
        -:  438:  CORBA::Long max_samples, DDS::InstanceHandle_t a_handle,
        -:  439:  DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  440:  DDS::InstanceStateMask instance_states)
        -:  441:{
    #####:  442:  return typed_reader_->take_instance(received_data, info_seq, max_samples,
    #####:  443:    a_handle, sample_states, view_states, instance_states);
        -:  444:}
        -:  445:
        -:  446:template<typename Sample, typename TypedDataReader>
        -:  447:DDS::ReturnCode_t
    #####:  448:MultiTopicDataReader_T<Sample, TypedDataReader>::read_instance_w_condition(
        -:  449:  SampleSeq& data_values, DDS::SampleInfoSeq& sample_infos,
        -:  450:  CORBA::Long max_samples, DDS::InstanceHandle_t handle,
        -:  451:  DDS::ReadCondition_ptr a_condition)
        -:  452:{
    #####:  453:  return typed_reader_->read_instance_w_condition(data_values,
    #####:  454:    sample_infos, max_samples, handle, a_condition);
        -:  455:}
        -:  456:
        -:  457:template<typename Sample, typename TypedDataReader>
        -:  458:DDS::ReturnCode_t
    #####:  459:MultiTopicDataReader_T<Sample, TypedDataReader>::take_instance_w_condition(
        -:  460:  SampleSeq& data_values, DDS::SampleInfoSeq& sample_infos,
        -:  461:  CORBA::Long max_samples, DDS::InstanceHandle_t handle,
        -:  462:  DDS::ReadCondition_ptr a_condition)
        -:  463:{
    #####:  464:  return typed_reader_->take_instance_w_condition(data_values,
    #####:  465:    sample_infos, max_samples, handle, a_condition);
        -:  466:}
        -:  467:
        -:  468:template<typename Sample, typename TypedDataReader>
        -:  469:DDS::ReturnCode_t
    #####:  470:MultiTopicDataReader_T<Sample, TypedDataReader>::read_next_instance(
        -:  471:  SampleSeq& received_data, DDS::SampleInfoSeq& info_seq,
        -:  472:  CORBA::Long max_samples, DDS::InstanceHandle_t a_handle,
        -:  473:  DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  474:  DDS::InstanceStateMask instance_states)
        -:  475:{
    #####:  476:  return typed_reader_->read_next_instance(received_data, info_seq, max_samples,
    #####:  477:    a_handle, sample_states, view_states, instance_states);
        -:  478:}
        -:  479:
        -:  480:template<typename Sample, typename TypedDataReader>
        -:  481:DDS::ReturnCode_t
    #####:  482:MultiTopicDataReader_T<Sample, TypedDataReader>::take_next_instance(
        -:  483:  SampleSeq& received_data, DDS::SampleInfoSeq& info_seq,
        -:  484:  CORBA::Long max_samples, DDS::InstanceHandle_t a_handle,
        -:  485:  DDS::SampleStateMask sample_states, DDS::ViewStateMask view_states,
        -:  486:  DDS::InstanceStateMask instance_states)
        -:  487:{
    #####:  488:  return typed_reader_->take_next_instance(received_data, info_seq, max_samples,
    #####:  489:    a_handle, sample_states, view_states, instance_states);
        -:  490:}
        -:  491:
        -:  492:template<typename Sample, typename TypedDataReader>
        -:  493:DDS::ReturnCode_t
    #####:  494:MultiTopicDataReader_T<Sample, TypedDataReader>::read_next_instance_w_condition(
        -:  495:  SampleSeq& data_values, DDS::SampleInfoSeq& sample_infos,
        -:  496:  CORBA::Long max_samples, DDS::InstanceHandle_t previous_handle,
        -:  497:  DDS::ReadCondition_ptr a_condition)
        -:  498:{
    #####:  499:  return typed_reader_->read_next_instance_w_condition(data_values,
    #####:  500:    sample_infos, max_samples, previous_handle, a_condition);
        -:  501:}
        -:  502:
        -:  503:template<typename Sample, typename TypedDataReader>
        -:  504:DDS::ReturnCode_t
    #####:  505:MultiTopicDataReader_T<Sample, TypedDataReader>::take_next_instance_w_condition(
        -:  506:  SampleSeq& data_values, DDS::SampleInfoSeq& sample_infos,
        -:  507:  CORBA::Long max_samples, DDS::InstanceHandle_t previous_handle,
        -:  508:  DDS::ReadCondition_ptr a_condition)
        -:  509:{
    #####:  510:  return typed_reader_->take_next_instance_w_condition(data_values,
    #####:  511:    sample_infos, max_samples, previous_handle, a_condition);
        -:  512:}
        -:  513:
        -:  514:template<typename Sample, typename TypedDataReader>
        -:  515:DDS::ReturnCode_t
    #####:  516:MultiTopicDataReader_T<Sample, TypedDataReader>::return_loan(
        -:  517:  SampleSeq& received_data, DDS::SampleInfoSeq& info_seq)
        -:  518:{
    #####:  519:  return typed_reader_->return_loan(received_data, info_seq);
        -:  520:}
        -:  521:
        -:  522:template<typename Sample, typename TypedDataReader>
        -:  523:DDS::ReturnCode_t
    #####:  524:MultiTopicDataReader_T<Sample, TypedDataReader>::get_key_value(
        -:  525:  Sample& key_holder, DDS::InstanceHandle_t handle)
        -:  526:{
    #####:  527:  return typed_reader_->get_key_value(key_holder, handle);
        -:  528:}
        -:  529:
        -:  530:template<typename Sample, typename TypedDataReader>
        -:  531:DDS::InstanceHandle_t
    #####:  532:MultiTopicDataReader_T<Sample, TypedDataReader>::lookup_instance(
        -:  533:  const Sample& instance_data)
        -:  534:{
    #####:  535:  return typed_reader_->lookup_instance(instance_data);
        -:  536:}
        -:  537:
        -:  538:}
        -:  539:}
        -:  540:
        -:  541:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  542:
        -:  543:#endif
        -:  544:#endif
