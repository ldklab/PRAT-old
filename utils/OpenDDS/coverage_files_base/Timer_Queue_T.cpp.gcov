        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Timer_Queue_T.cpp
        -:    0:Programs:51
        -:    1:// $Id: Timer_Queue_T.cpp 2179 2013-05-28 22:16:51Z mesnierp $
        -:    2:
        -:    3:#ifndef ACE_TIMER_QUEUE_T_CPP
        -:    4:#define ACE_TIMER_QUEUE_T_CPP
        -:    5:
        -:    6:#include "ace/config-all.h"
        -:    7:
        -:    8:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:    9:# pragma once
        -:   10:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   11:
        -:   12:/*
        -:   13: * Hook to specialize to add includes
        -:   14: */
        -:   15://@@ REACTOR_SPL_INCLUDE_FORWARD_DECL_ADD_HOOK
        -:   16:
        -:   17:#include "ace/Timer_Queue_T.h"
        -:   18:#include "ace/Guard_T.h"
        -:   19:#include "ace/Reverse_Lock_T.h"
        -:   20:#include "ace/Log_Category.h"
        -:   21:#include "ace/Null_Mutex.h"
        -:   22:#include "ace/OS_NS_sys_time.h"
        -:   23:#include "ace/Functor.h"
        -:   24:
        -:   25:#if !defined (__ACE_INLINE__)
        -:   26:#include "ace/Timer_Queue_T.inl"
        -:   27:#endif /* __ACE_INLINE__ */
        -:   28:
        -:   29:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   30:
        -:   31:// This fudge factor can be overriden for timers that need it, such as on
        -:   32:// Solaris, by defining the ACE_TIMER_SKEW symbol in the appropriate config
        -:   33:// header.
        -:   34:#if !defined (ACE_TIMER_SKEW)
        -:   35:#  define ACE_TIMER_SKEW 0
        -:   36:#endif /* ACE_TIMER_SKEW */
        -:   37:
        -:   38:template <class TYPE, class FUNCTOR> ACE_INLINE
    #####:   39:ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::ACE_Timer_Queue_Upcall_Base (FUNCTOR * upcall_functor)
        -:   40:  : ACE_Abstract_Timer_Queue<TYPE>()
        -:   41:  , ACE_Copy_Disabled()
        -:   42:  , upcall_functor_(upcall_functor)
    #####:   43:  , delete_upcall_functor_ (upcall_functor == 0)
        -:   44:{
        -:   45:  ACE_TRACE ("ACE_Timer_Queue_Upcall_Base::ACE_Timer_Queue_Upcall_Base");
        -:   46:
    #####:   47:  if (upcall_functor != 0)
        -:   48:    {
    #####:   49:      return;
        -:   50:    }
        -:   51:
    #####:   52:  ACE_NEW (upcall_functor_, FUNCTOR);
        -:   53:}
        -:   54:
        -:   55:template <class TYPE, class FUNCTOR> ACE_INLINE
    #####:   56:ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::~ACE_Timer_Queue_Upcall_Base ()
        -:   57:{
        -:   58:  ACE_TRACE ("ACE_Timer_Queue_Upcall_Base::~ACE_Timer_Queue_Upcall_Base");
    #####:   59:  if (this->delete_upcall_functor_)
        -:   60:    {
    #####:   61:      delete this->upcall_functor_;
        -:   62:    }
    #####:   63:}
        -:   64:
        -:   65:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value
    #####:   66:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::gettimeofday()
        -:   67:{
    #####:   68:  return this->gettimeofday_static();
        -:   69:}
        -:   70:
        -:   71:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
    #####:   72:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::gettimeofday (ACE_Time_Value (*gettimeofday)(void))
        -:   73:{
    #####:   74:  this->time_policy_.set_gettimeofday (gettimeofday);
    #####:   75:}
        -:   76:
        -:   77:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value *
    #####:   78:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::calculate_timeout (ACE_Time_Value *max_wait_time)
        -:   79:{
        -:   80:  ACE_TRACE ("ACE_Timer_Queue_T::calculate_timeout");
    #####:   81:  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, max_wait_time));
        -:   82:
    #####:   83:  if (this->is_empty ())
        -:   84:    // Nothing on the Timer_Queue, so use whatever the caller gave us.
    #####:   85:    return max_wait_time;
        -:   86:  else
        -:   87:    {
    #####:   88:      ACE_Time_Value const cur_time = this->gettimeofday_static ();
        -:   89:
    #####:   90:      if (this->earliest_time () > cur_time)
        -:   91:        {
        -:   92:          // The earliest item on the Timer_Queue is still in the
        -:   93:          // future.  Therefore, use the smaller of (1) caller's wait
        -:   94:          // time or (2) the delta time between now and the earliest
        -:   95:          // time on the Timer_Queue.
        -:   96:
    #####:   97:          this->timeout_ = this->earliest_time () - cur_time;
    #####:   98:          if (max_wait_time == 0 || *max_wait_time > timeout_)
    #####:   99:            return &this->timeout_;
        -:  100:          else
    #####:  101:            return max_wait_time;
        -:  102:        }
        -:  103:      else
        -:  104:        {
        -:  105:          // The earliest item on the Timer_Queue is now in the past.
        -:  106:          // Therefore, we've got to "poll" the Reactor, i.e., it must
        -:  107:          // just check the descriptors and then dispatch timers, etc.
    #####:  108:          this->timeout_ = ACE_Time_Value::zero;
    #####:  109:          return &this->timeout_;
        -:  110:        }
        -:  111:    }
        -:  112:}
        -:  113:
        -:  114:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value *
    #####:  115:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::calculate_timeout (ACE_Time_Value *max_wait_time,
        -:  116:                                                               ACE_Time_Value *the_timeout)
        -:  117:{
        -:  118:  ACE_TRACE ("ACE_Timer_Queue_T::calculate_timeout");
        -:  119:
    #####:  120:  if (the_timeout == 0)
    #####:  121:    return 0;
        -:  122:
    #####:  123:  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, max_wait_time));
        -:  124:
    #####:  125:  if (this->is_empty ())
        -:  126:    {
        -:  127:      // Nothing on the Timer_Queue, so use whatever the caller gave us.
    #####:  128:      if (max_wait_time)
    #####:  129:        *the_timeout = *max_wait_time;
        -:  130:      else
    #####:  131:        return 0;
        -:  132:    }
        -:  133:  else
        -:  134:    {
    #####:  135:      ACE_Time_Value cur_time = this->gettimeofday_static ();
        -:  136:
    #####:  137:      if (this->earliest_time () > cur_time)
        -:  138:        {
        -:  139:          // The earliest item on the Timer_Queue is still in the
        -:  140:          // future.  Therefore, use the smaller of (1) caller's wait
        -:  141:          // time or (2) the delta time between now and the earliest
        -:  142:          // time on the Timer_Queue.
        -:  143:
    #####:  144:          *the_timeout = this->earliest_time () - cur_time;
    #####:  145:          if (!(max_wait_time == 0 || *max_wait_time > *the_timeout))
    #####:  146:            *the_timeout = *max_wait_time;
        -:  147:        }
        -:  148:      else
        -:  149:        {
        -:  150:          // The earliest item on the Timer_Queue is now in the past.
        -:  151:          // Therefore, we've got to "poll" the Reactor, i.e., it must
        -:  152:          // just check the descriptors and then dispatch timers, etc.
    #####:  153:          *the_timeout = ACE_Time_Value::zero;
        -:  154:        }
        -:  155:    }
    #####:  156:  return the_timeout;
        -:  157:}
        -:  158:
        -:  159:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Time_Value
    #####:  160:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::current_time()
        -:  161:{
    #####:  162:  ACE_Time_Value tv = this->gettimeofday_static ();
    #####:  163:  tv += this->timer_skew();
    #####:  164:  return tv;
        -:  165:}
        -:  166:
        -:  167:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
    #####:  168:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dump (void) const
        -:  169:{
        -:  170:#if defined (ACE_HAS_DUMP)
        -:  171:  ACE_TRACE ("ACE_Timer_Queue_T::dump");
        -:  172:  ACELIB_DEBUG ((LM_DEBUG, ACE_BEGIN_DUMP, this));
        -:  173:  this->timeout_.dump ();
        -:  174:  this->timer_skew_.dump ();
        -:  175:  ACELIB_DEBUG ((LM_DEBUG, ACE_END_DUMP));
        -:  176:#endif /* ACE_HAS_DUMP */
    #####:  177:}
        -:  178:
        -:  179:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
    #####:  180:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::ACE_Timer_Queue_T (FUNCTOR *upcall_functor,
        -:  181:                                          ACE_Free_List<ACE_Timer_Node_T <TYPE> > *freelist,
        -:  182:                                          TIME_POLICY const & time_policy)
        -:  183:  : ACE_Timer_Queue_Upcall_Base<TYPE,FUNCTOR>(upcall_functor),
        -:  184:    time_policy_ (time_policy),
    #####:  185:    delete_free_list_ (freelist == 0),
    #####:  186:    timer_skew_ (0, ACE_TIMER_SKEW)
        -:  187:{
        -:  188:  ACE_TRACE ("ACE_Timer_Queue_T::ACE_Timer_Queue_T");
        -:  189:
    #####:  190:  if (!freelist)
    #####:  191:    ACE_NEW (free_list_,
        -:  192:             (ACE_Locked_Free_List<ACE_Timer_Node_T<TYPE>,ACE_Null_Mutex>));
        -:  193:  else
    #####:  194:    free_list_ = freelist;
        -:  195:}
        -:  196:
        -:  197:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY>
    #####:  198:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::~ACE_Timer_Queue_T (void)
        -:  199:{
        -:  200:  ACE_TRACE ("ACE_Timer_Queue_T::~ACE_Timer_Queue_T");
        -:  201:
        -:  202:  // Cleanup the free_list on the way out
    #####:  203:  if (this->delete_free_list_)
    #####:  204:    delete this->free_list_;
    #####:  205:}
        -:  206:
        -:  207:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_Timer_Node_T<TYPE> *
    #####:  208:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::alloc_node (void)
        -:  209:{
    #####:  210:  return this->free_list_->remove ();
        -:  211:}
        -:  212:
        -:  213:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
    #####:  214:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::free_node (ACE_Timer_Node_T<TYPE> *node)
        -:  215:{
    #####:  216:  this->free_list_->add (node);
    #####:  217:}
        -:  218:
        -:  219:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> ACE_LOCK &
        -:  220:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::mutex (void)
        -:  221:{
        -:  222:  return this->mutex_;
        -:  223:}
        -:  224:
        -:  225:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> long
    #####:  226:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::schedule (const TYPE &type,
        -:  227:                                                      const void *act,
        -:  228:                                                      const ACE_Time_Value &future_time,
        -:  229:                                                      const ACE_Time_Value &interval)
        -:  230:{
    #####:  231:  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
        -:  232:
        -:  233:  // Schedule the timer.
    #####:  234:  long const result =
        -:  235:    this->schedule_i (type,
        -:  236:                      act,
        -:  237:                      future_time,
        -:  238:                      interval);
        -:  239:
        -:  240:  // Return on failure.
    #####:  241:  if (result == -1)
    #####:  242:    return result;
        -:  243:
        -:  244:  // Inform upcall functor of successful registration.
    #####:  245:  this->upcall_functor ().registration (*this,
        -:  246:                                        type,
        -:  247:                                        act);
        -:  248:
        -:  249:  // Return result;
    #####:  250:  return result;
        -:  251:}
        -:  252:
        -:  253:// Run the <handle_timeout> method for all Timers whose values are <=
        -:  254:// <cur_time>.
        -:  255:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
    #####:  256:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire (const ACE_Time_Value &cur_time)
        -:  257:{
        -:  258:  ACE_TRACE ("ACE_Timer_Queue_T::expire");
    #####:  259:  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
        -:  260:
        -:  261:  // Keep looping while there are timers remaining and the earliest
        -:  262:  // timer is <= the <cur_time> passed in to the method.
        -:  263:
    #####:  264:  if (this->is_empty ())
    #####:  265:    return 0;
        -:  266:
    #####:  267:  int number_of_timers_expired = 0;
    #####:  268:  int result = 0;
        -:  269:
        -:  270:  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
        -:  271:
    #####:  272:  while ((result = this->dispatch_info_i (cur_time, info)) != 0)
        -:  273:    {
    #####:  274:      ACE_MT (ACE_Reverse_Lock<ACE_LOCK> rev_lk(this->mutex_));
    #####:  275:      ACE_MT (ACE_GUARD_RETURN (ACE_Reverse_Lock<ACE_LOCK>, rmon, rev_lk, -1));
        -:  276:
    #####:  277:      const void *upcall_act = 0;
        -:  278:
    #####:  279:      this->preinvoke (info, cur_time, upcall_act);
        -:  280:
    #####:  281:      this->upcall (info, cur_time);
        -:  282:
    #####:  283:      this->postinvoke (info, cur_time, upcall_act);
        -:  284:
    #####:  285:      ++number_of_timers_expired;
        -:  286:
        -:  287:    }
        -:  288:
        -:  289:  ACE_UNUSED_ARG (result);
    #####:  290:  return number_of_timers_expired;
        -:  291:}
        -:  292:
        -:  293:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
    #####:  294:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recompute_next_abs_interval_time
        -:  295:    (ACE_Timer_Node_T<TYPE> *expired,
        -:  296:     const ACE_Time_Value &cur_time)
        -:  297:{
    #####:  298:  if ( expired->get_timer_value () <= cur_time )
        -:  299:    {
        -:  300:      /*
        -:  301:       * Somehow the current time is past when this time was
        -:  302:       * supposed to expire (e.g., timer took too long,
        -:  303:       * somebody changed system time, etc.).  There used to
        -:  304:       * be a simple loop here that skipped ahead one timer
        -:  305:       * interval at a time, but that was horribly inefficient
        -:  306:       * (an O(n) algorithm) when the timer duration was small
        -:  307:       * relative to the amount of time skipped.
        -:  308:       *
        -:  309:       * So, we replace the loop with a simple computation,
        -:  310:       * which also happens to be O(1).  All times get
        -:  311:       * normalized in the computation to microseconds.
        -:  312:       *
        -:  313:       * For reference, the loop looked like this:
        -:  314:       *
        -:  315:       *   do
        -:  316:       *     expired->set_timer_value (expired->get_timer_value () +
        -:  317:       *                               expired->get_interval ());
        -:  318:       *   while (expired->get_timer_value () <= cur_time);
        -:  319:       *
        -:  320:       */
        -:  321:
        -:  322:      // Compute the duration of the timer's interval
        -:  323:      ACE_UINT64 interval_usec;
    #####:  324:      expired->get_interval ().to_usec (interval_usec);
        -:  325:
        -:  326:      // Compute the span between the current time and when
        -:  327:      // the timer would have expired in the past (and
        -:  328:      // normalize to microseconds).
    #####:  329:      ACE_Time_Value old_diff = cur_time - expired->get_timer_value ();
        -:  330:      ACE_UINT64 old_diff_usec;
    #####:  331:      old_diff.to_usec (old_diff_usec);
        -:  332:
        -:  333:      // Compute the delta time in the future when the timer
        -:  334:      // should fire as if it had advanced incrementally.  The
        -:  335:      // modulo arithmetic accomodates the likely case that
        -:  336:      // the current time doesn't fall precisely on a timer
        -:  337:      // firing interval.
    #####:  338:      ACE_UINT64 new_timer_usec =
    #####:  339:        interval_usec - (old_diff_usec % interval_usec);
        -:  340:
        -:  341:      // Compute the absolute time in the future when this
        -:  342:      // interval timer should expire.
    #####:  343:      ACE_Time_Value new_timer_value
    #####:  344:        (cur_time.sec ()
    #####:  345:         + static_cast<time_t>(new_timer_usec / ACE_ONE_SECOND_IN_USECS),
    #####:  346:         cur_time.usec ()
    #####:  347:         + static_cast<suseconds_t>(new_timer_usec % ACE_ONE_SECOND_IN_USECS));
        -:  348:
    #####:  349:      expired->set_timer_value (new_timer_value);
        -:  350:    }
    #####:  351:}
        -:  352:
        -:  353:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
    #####:  354:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire_single (
        -:  355:    ACE_Command_Base & pre_dispatch_command)
        -:  356:{
        -:  357:  ACE_TRACE ("ACE_Timer_Queue_T::expire_single");
        -:  358:  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
    #####:  359:  ACE_Time_Value cur_time;
        -:  360:  {
        -:  361:    // Create a scope for the lock ...
    #####:  362:    ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
        -:  363:
    #####:  364:    if (this->is_empty ())
    #####:  365:      return 0;
        -:  366:
        -:  367:    // Get the current time
    #####:  368:    cur_time = this->gettimeofday_static () + this->timer_skew ();
        -:  369:
        -:  370:    // Look for a node in the timer queue whose timer <= the present
        -:  371:    // time.
    #####:  372:    if (!this->dispatch_info_i (cur_time, info))
        -:  373:      {
    #####:  374:        return 0;
        -:  375:      }
        -:  376:  }
        -:  377:  // We do not need the lock anymore, all these operations take place
        -:  378:  // with local variables.
    #####:  379:  const void *upcall_act = 0;
        -:  380:
        -:  381:  // Preinvoke (handles refcount if needed, etc.)
    #####:  382:  this->preinvoke (info, cur_time, upcall_act);
        -:  383:
        -:  384:  // Release the token before expiration upcall.
    #####:  385:  pre_dispatch_command.execute();
        -:  386:
        -:  387:  // call the functor
    #####:  388:  this->upcall (info, cur_time);
        -:  389:
        -:  390:  // Postinvoke (undo refcount if needed, etc.)
    #####:  391:  this->postinvoke (info, cur_time, upcall_act);
        -:  392:
        -:  393:  // We have dispatched a timer
    #####:  394:  return 1;
        -:  395:}
        -:  396:
        -:  397:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
    #####:  398:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dispatch_info_i (const ACE_Time_Value &cur_time,
        -:  399:                                                             ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
        -:  400:{
        -:  401:  ACE_TRACE ("ACE_Timer_Queue_T::dispatch_info_i");
        -:  402:
    #####:  403:  if (this->is_empty ())
    #####:  404:    return 0;
        -:  405:
    #####:  406:  ACE_Timer_Node_T<TYPE> *expired = 0;
        -:  407:
    #####:  408:  if (this->earliest_time () <= cur_time)
        -:  409:    {
    #####:  410:      expired = this->remove_first ();
        -:  411:
        -:  412:      // Get the dispatch info
    #####:  413:      expired->get_dispatch_info (info);
        -:  414:
        -:  415:      // Check if this is an interval timer.
    #####:  416:      if (expired->get_interval () > ACE_Time_Value::zero)
        -:  417:        {
        -:  418:          // Make sure that we skip past values that have already
        -:  419:          // "expired".
    #####:  420:          this->recompute_next_abs_interval_time (expired, cur_time);
        -:  421:
        -:  422:          // Since this is an interval timer, we need to reschedule
        -:  423:          // it.
    #####:  424:          this->reschedule (expired);
        -:  425:        }
        -:  426:      else
        -:  427:        {
        -:  428:          // Call the factory method to free up the node.
    #####:  429:          this->free_node (expired);
        -:  430:        }
        -:  431:
    #####:  432:      return 1;
        -:  433:    }
        -:  434:
    #####:  435:  return 0;
        -:  436:}
        -:  437:
        -:  438:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
    #####:  439:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::return_node (ACE_Timer_Node_T<TYPE> *node)
        -:  440:{
    #####:  441:  ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
    #####:  442:  this->free_node (node);
        -:  443:}
        -:  444:
        -:  445:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  446:
        -:  447:#endif /* ACE_TIMER_QUEUE_T_CPP */
