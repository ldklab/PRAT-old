        -:    0:Source:DdsDcpsInfoUtilsTypeSupportImpl.cpp
        -:    0:Programs:72
        -:    1:/* Generated by /home/ryan/git/OpenDDS-debloat/bin/opendds_idl version 3.13 (ACE version 6.2a_p15) running on input file DdsDcpsInfoUtils.idl */
        -:    2:#include "DCPS/DdsDcps_pch.h"
        -:    3:#include "DdsDcpsInfoUtilsTypeSupportImpl.h"
        -:    4:
        -:    5:#include <cstring>
        -:    6:#include <stdexcept>
        -:    7:#include "dds/DCPS/FilterEvaluator.h"
        -:    8:#include "dds/DCPS/PoolAllocator.h"
        -:    9:#include "dds/DdsDcpsCoreTypeSupportImpl.h"
        -:   10:#include "dds/DdsDcpsGuidTypeSupportImpl.h"
        -:   11:
        -:   12:
        -:   13:/* Begin MODULE: CORBA */
        -:   14:
        -:   15:
        -:   16:/* End MODULE: CORBA */
        -:   17:
        -:   18:
        -:   19:/* Begin MODULE: CORBA */
        -:   20:
        -:   21:
        -:   22:
        -:   23:/* Begin TYPEDEF: StringSeq */
        -:   24:
        -:   25:
        -:   26:/* End TYPEDEF: StringSeq */
        -:   27:
        -:   28:/* End MODULE: CORBA */
        -:   29:
        -:   30:
        -:   31:/* Begin MODULE: CORBA */
        -:   32:
        -:   33:
        -:   34:
        -:   35:/* Begin TYPEDEF: LongSeq */
        -:   36:
        -:   37:
        -:   38:/* End TYPEDEF: LongSeq */
        -:   39:
        -:   40:/* End MODULE: CORBA */
        -:   41:
        -:   42:
        -:   43:/* Begin MODULE: DDS */
        -:   44:
        -:   45:
        -:   46:
        -:   47:/* Begin TYPEDEF: StringSeq */
        -:   48:
        -:   49:
        -:   50:/* End TYPEDEF: StringSeq */
        -:   51:
        -:   52:
        -:   53:/* Begin TYPEDEF: InstanceHandle_t */
        -:   54:
        -:   55:
        -:   56:/* End TYPEDEF: InstanceHandle_t */
        -:   57:
        -:   58:
        -:   59:/* Begin TYPEDEF: BuiltinTopicKeyValue */
        -:   60:
        -:   61:
        -:   62:/* End TYPEDEF: BuiltinTopicKeyValue */
        -:   63:
        -:   64:
        -:   65:/* Begin TYPEDEF: InstanceHandleSeq */
        -:   66:
        -:   67:
        -:   68:/* End TYPEDEF: InstanceHandleSeq */
        -:   69:
        -:   70:
        -:   71:/* Begin TYPEDEF: QosPolicyId_t */
        -:   72:
        -:   73:
        -:   74:/* End TYPEDEF: QosPolicyId_t */
        -:   75:
        -:   76:
        -:   77:/* Begin STRUCT: QosPolicyCount */
        -:   78:
        -:   79:
        -:   80:/* End STRUCT: QosPolicyCount */
        -:   81:
        -:   82:
        -:   83:/* Begin TYPEDEF: QosPolicyCountSeq */
        -:   84:
        -:   85:
        -:   86:/* End TYPEDEF: QosPolicyCountSeq */
        -:   87:
        -:   88:
        -:   89:/* Begin TYPEDEF: OctetSeq */
        -:   90:
        -:   91:
        -:   92:/* End TYPEDEF: OctetSeq */
        -:   93:
        -:   94:
        -:   95:/* Begin STRUCT: Duration_t */
        -:   96:
        -:   97:
        -:   98:/* End STRUCT: Duration_t */
        -:   99:
        -:  100:
        -:  101:/* Begin CONST: DURATION_INFINITE_SEC */
        -:  102:
        -:  103:
        -:  104:/* End CONST: DURATION_INFINITE_SEC */
        -:  105:
        -:  106:
        -:  107:/* Begin CONST: DURATION_INFINITE_NSEC */
        -:  108:
        -:  109:
        -:  110:/* End CONST: DURATION_INFINITE_NSEC */
        -:  111:
        -:  112:
        -:  113:/* Begin CONST: DURATION_ZERO_SEC */
        -:  114:
        -:  115:
        -:  116:/* End CONST: DURATION_ZERO_SEC */
        -:  117:
        -:  118:
        -:  119:/* Begin CONST: DURATION_ZERO_NSEC */
        -:  120:
        -:  121:
        -:  122:/* End CONST: DURATION_ZERO_NSEC */
        -:  123:
        -:  124:
        -:  125:/* Begin STRUCT: Property_t */
        -:  126:
        -:  127:
        -:  128:/* End STRUCT: Property_t */
        -:  129:
        -:  130:
        -:  131:/* Begin TYPEDEF: PropertySeq */
        -:  132:
        -:  133:
        -:  134:/* End TYPEDEF: PropertySeq */
        -:  135:
        -:  136:
        -:  137:/* Begin STRUCT: BinaryProperty_t */
        -:  138:
        -:  139:
        -:  140:/* End STRUCT: BinaryProperty_t */
        -:  141:
        -:  142:
        -:  143:/* Begin TYPEDEF: BinaryPropertySeq */
        -:  144:
        -:  145:
        -:  146:/* End TYPEDEF: BinaryPropertySeq */
        -:  147:
        -:  148:
        -:  149:/* Begin STRUCT: PropertyQosPolicy */
        -:  150:
        -:  151:
        -:  152:/* End STRUCT: PropertyQosPolicy */
        -:  153:
        -:  154:
        -:  155:/* Begin STRUCT: UserDataQosPolicy */
        -:  156:
        -:  157:
        -:  158:/* End STRUCT: UserDataQosPolicy */
        -:  159:
        -:  160:
        -:  161:/* Begin STRUCT: GroupDataQosPolicy */
        -:  162:
        -:  163:
        -:  164:/* End STRUCT: GroupDataQosPolicy */
        -:  165:
        -:  166:
        -:  167:/* Begin STRUCT: TopicDataQosPolicy */
        -:  168:
        -:  169:
        -:  170:/* End STRUCT: TopicDataQosPolicy */
        -:  171:
        -:  172:
        -:  173:/* Begin STRUCT: PartitionQosPolicy */
        -:  174:
        -:  175:
        -:  176:/* End STRUCT: PartitionQosPolicy */
        -:  177:
        -:  178:
        -:  179:/* Begin ENUM: HistoryQosPolicyKind */
        -:  180:
        -:  181:
        -:  182:/* End ENUM: HistoryQosPolicyKind */
        -:  183:
        -:  184:
        -:  185:/* Begin ENUM: DurabilityQosPolicyKind */
        -:  186:
        -:  187:
        -:  188:/* End ENUM: DurabilityQosPolicyKind */
        -:  189:
        -:  190:
        -:  191:/* Begin STRUCT: DurabilityQosPolicy */
        -:  192:
        -:  193:
        -:  194:/* End STRUCT: DurabilityQosPolicy */
        -:  195:
        -:  196:
        -:  197:/* Begin STRUCT: DurabilityServiceQosPolicy */
        -:  198:
        -:  199:
        -:  200:/* End STRUCT: DurabilityServiceQosPolicy */
        -:  201:
        -:  202:
        -:  203:/* Begin STRUCT: DeadlineQosPolicy */
        -:  204:
        -:  205:
        -:  206:/* End STRUCT: DeadlineQosPolicy */
        -:  207:
        -:  208:
        -:  209:/* Begin STRUCT: LatencyBudgetQosPolicy */
        -:  210:
        -:  211:
        -:  212:/* End STRUCT: LatencyBudgetQosPolicy */
        -:  213:
        -:  214:
        -:  215:/* Begin ENUM: LivelinessQosPolicyKind */
        -:  216:
        -:  217:
        -:  218:/* End ENUM: LivelinessQosPolicyKind */
        -:  219:
        -:  220:
        -:  221:/* Begin STRUCT: LivelinessQosPolicy */
        -:  222:
        -:  223:
        -:  224:/* End STRUCT: LivelinessQosPolicy */
        -:  225:
        -:  226:
        -:  227:/* Begin ENUM: ReliabilityQosPolicyKind */
        -:  228:
        -:  229:
        -:  230:/* End ENUM: ReliabilityQosPolicyKind */
        -:  231:
        -:  232:
        -:  233:/* Begin STRUCT: ReliabilityQosPolicy */
        -:  234:
        -:  235:
        -:  236:/* End STRUCT: ReliabilityQosPolicy */
        -:  237:
        -:  238:
        -:  239:/* Begin ENUM: DestinationOrderQosPolicyKind */
        -:  240:
        -:  241:
        -:  242:/* End ENUM: DestinationOrderQosPolicyKind */
        -:  243:
        -:  244:
        -:  245:/* Begin STRUCT: DestinationOrderQosPolicy */
        -:  246:
        -:  247:
        -:  248:/* End STRUCT: DestinationOrderQosPolicy */
        -:  249:
        -:  250:
        -:  251:/* Begin STRUCT: HistoryQosPolicy */
        -:  252:
        -:  253:
        -:  254:/* End STRUCT: HistoryQosPolicy */
        -:  255:
        -:  256:
        -:  257:/* Begin STRUCT: ResourceLimitsQosPolicy */
        -:  258:
        -:  259:
        -:  260:/* End STRUCT: ResourceLimitsQosPolicy */
        -:  261:
        -:  262:
        -:  263:/* Begin STRUCT: TransportPriorityQosPolicy */
        -:  264:
        -:  265:
        -:  266:/* End STRUCT: TransportPriorityQosPolicy */
        -:  267:
        -:  268:
        -:  269:/* Begin STRUCT: LifespanQosPolicy */
        -:  270:
        -:  271:
        -:  272:/* End STRUCT: LifespanQosPolicy */
        -:  273:
        -:  274:
        -:  275:/* Begin ENUM: OwnershipQosPolicyKind */
        -:  276:
        -:  277:
        -:  278:/* End ENUM: OwnershipQosPolicyKind */
        -:  279:
        -:  280:
        -:  281:/* Begin STRUCT: OwnershipQosPolicy */
        -:  282:
        -:  283:
        -:  284:/* End STRUCT: OwnershipQosPolicy */
        -:  285:
        -:  286:
        -:  287:/* Begin STRUCT: OwnershipStrengthQosPolicy */
        -:  288:
        -:  289:
        -:  290:/* End STRUCT: OwnershipStrengthQosPolicy */
        -:  291:
        -:  292:
        -:  293:/* Begin ENUM: PresentationQosPolicyAccessScopeKind */
        -:  294:
        -:  295:
        -:  296:/* End ENUM: PresentationQosPolicyAccessScopeKind */
        -:  297:
        -:  298:
        -:  299:/* Begin STRUCT: PresentationQosPolicy */
        -:  300:
        -:  301:
        -:  302:/* End STRUCT: PresentationQosPolicy */
        -:  303:
        -:  304:
        -:  305:/* Begin STRUCT: TimeBasedFilterQosPolicy */
        -:  306:
        -:  307:
        -:  308:/* End STRUCT: TimeBasedFilterQosPolicy */
        -:  309:
        -:  310:
        -:  311:/* Begin STRUCT: TopicQos */
        -:  312:
        -:  313:
        -:  314:/* End STRUCT: TopicQos */
        -:  315:
        -:  316:
        -:  317:/* Begin STRUCT: WriterDataLifecycleQosPolicy */
        -:  318:
        -:  319:
        -:  320:/* End STRUCT: WriterDataLifecycleQosPolicy */
        -:  321:
        -:  322:
        -:  323:/* Begin STRUCT: DataWriterQos */
        -:  324:
        -:  325:
        -:  326:/* End STRUCT: DataWriterQos */
        -:  327:
        -:  328:
        -:  329:/* Begin STRUCT: EntityFactoryQosPolicy */
        -:  330:
        -:  331:
        -:  332:/* End STRUCT: EntityFactoryQosPolicy */
        -:  333:
        -:  334:
        -:  335:/* Begin STRUCT: PublisherQos */
        -:  336:
        -:  337:
        -:  338:/* End STRUCT: PublisherQos */
        -:  339:
        -:  340:
        -:  341:/* Begin STRUCT: ReaderDataLifecycleQosPolicy */
        -:  342:
        -:  343:
        -:  344:/* End STRUCT: ReaderDataLifecycleQosPolicy */
        -:  345:
        -:  346:
        -:  347:/* Begin STRUCT: DataReaderQos */
        -:  348:
        -:  349:
        -:  350:/* End STRUCT: DataReaderQos */
        -:  351:
        -:  352:
        -:  353:/* Begin STRUCT: SubscriberQos */
        -:  354:
        -:  355:
        -:  356:/* End STRUCT: SubscriberQos */
        -:  357:
        -:  358:
        -:  359:/* Begin STRUCT: DomainParticipantFactoryQos */
        -:  360:
        -:  361:
        -:  362:/* End STRUCT: DomainParticipantFactoryQos */
        -:  363:
        -:  364:
        -:  365:/* Begin STRUCT: DomainParticipantQos */
        -:  366:
        -:  367:
        -:  368:/* End STRUCT: DomainParticipantQos */
        -:  369:
        -:  370:
        -:  371:/* Begin STRUCT: BuiltinTopicKey_t */
        -:  372:
        -:  373:
        -:  374:/* End STRUCT: BuiltinTopicKey_t */
        -:  375:
        -:  376:
        -:  377:/* Begin STRUCT: ParticipantBuiltinTopicData */
        -:  378:
        -:  379:
        -:  380:/* End STRUCT: ParticipantBuiltinTopicData */
        -:  381:
        -:  382:
        -:  383:/* Begin STRUCT: PublicationBuiltinTopicData */
        -:  384:
        -:  385:
        -:  386:/* End STRUCT: PublicationBuiltinTopicData */
        -:  387:
        -:  388:
        -:  389:/* Begin STRUCT: SubscriptionBuiltinTopicData */
        -:  390:
        -:  391:
        -:  392:/* End STRUCT: SubscriptionBuiltinTopicData */
        -:  393:
        -:  394:
        -:  395:/* Begin STRUCT: TopicBuiltinTopicData */
        -:  396:
        -:  397:
        -:  398:/* End STRUCT: TopicBuiltinTopicData */
        -:  399:
        -:  400:
        -:  401:/* Begin TYPEDEF: SampleStateKind */
        -:  402:
        -:  403:
        -:  404:/* End TYPEDEF: SampleStateKind */
        -:  405:
        -:  406:
        -:  407:/* Begin CONST: READ_SAMPLE_STATE */
        -:  408:
        -:  409:
        -:  410:/* End CONST: READ_SAMPLE_STATE */
        -:  411:
        -:  412:
        -:  413:/* Begin CONST: NOT_READ_SAMPLE_STATE */
        -:  414:
        -:  415:
        -:  416:/* End CONST: NOT_READ_SAMPLE_STATE */
        -:  417:
        -:  418:
        -:  419:/* Begin TYPEDEF: SampleStateMask */
        -:  420:
        -:  421:
        -:  422:/* End TYPEDEF: SampleStateMask */
        -:  423:
        -:  424:
        -:  425:/* Begin CONST: ANY_SAMPLE_STATE */
        -:  426:
        -:  427:
        -:  428:/* End CONST: ANY_SAMPLE_STATE */
        -:  429:
        -:  430:
        -:  431:/* Begin TYPEDEF: ViewStateKind */
        -:  432:
        -:  433:
        -:  434:/* End TYPEDEF: ViewStateKind */
        -:  435:
        -:  436:
        -:  437:/* Begin CONST: NEW_VIEW_STATE */
        -:  438:
        -:  439:
        -:  440:/* End CONST: NEW_VIEW_STATE */
        -:  441:
        -:  442:
        -:  443:/* Begin CONST: NOT_NEW_VIEW_STATE */
        -:  444:
        -:  445:
        -:  446:/* End CONST: NOT_NEW_VIEW_STATE */
        -:  447:
        -:  448:
        -:  449:/* Begin TYPEDEF: ViewStateMask */
        -:  450:
        -:  451:
        -:  452:/* End TYPEDEF: ViewStateMask */
        -:  453:
        -:  454:
        -:  455:/* Begin CONST: ANY_VIEW_STATE */
        -:  456:
        -:  457:
        -:  458:/* End CONST: ANY_VIEW_STATE */
        -:  459:
        -:  460:
        -:  461:/* Begin TYPEDEF: InstanceStateKind */
        -:  462:
        -:  463:
        -:  464:/* End TYPEDEF: InstanceStateKind */
        -:  465:
        -:  466:
        -:  467:/* Begin CONST: ALIVE_INSTANCE_STATE */
        -:  468:
        -:  469:
        -:  470:/* End CONST: ALIVE_INSTANCE_STATE */
        -:  471:
        -:  472:
        -:  473:/* Begin CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */
        -:  474:
        -:  475:
        -:  476:/* End CONST: NOT_ALIVE_DISPOSED_INSTANCE_STATE */
        -:  477:
        -:  478:
        -:  479:/* Begin CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */
        -:  480:
        -:  481:
        -:  482:/* End CONST: NOT_ALIVE_NO_WRITERS_INSTANCE_STATE */
        -:  483:
        -:  484:
        -:  485:/* Begin TYPEDEF: InstanceStateMask */
        -:  486:
        -:  487:
        -:  488:/* End TYPEDEF: InstanceStateMask */
        -:  489:
        -:  490:
        -:  491:/* Begin CONST: ANY_INSTANCE_STATE */
        -:  492:
        -:  493:
        -:  494:/* End CONST: ANY_INSTANCE_STATE */
        -:  495:
        -:  496:
        -:  497:/* Begin CONST: NOT_ALIVE_INSTANCE_STATE */
        -:  498:
        -:  499:
        -:  500:/* End CONST: NOT_ALIVE_INSTANCE_STATE */
        -:  501:
        -:  502:
        -:  503:/* Begin STRUCT: Time_t */
        -:  504:
        -:  505:
        -:  506:/* End STRUCT: Time_t */
        -:  507:
        -:  508:
        -:  509:/* Begin CONST: TIME_INVALID_SEC */
        -:  510:
        -:  511:
        -:  512:/* End CONST: TIME_INVALID_SEC */
        -:  513:
        -:  514:
        -:  515:/* Begin CONST: TIME_INVALID_NSEC */
        -:  516:
        -:  517:
        -:  518:/* End CONST: TIME_INVALID_NSEC */
        -:  519:
        -:  520:
        -:  521:/* Begin STRUCT: SampleInfo */
        -:  522:
        -:  523:
        -:  524:/* End STRUCT: SampleInfo */
        -:  525:
        -:  526:
        -:  527:/* Begin TYPEDEF: SampleInfoSeq */
        -:  528:
        -:  529:
        -:  530:/* End TYPEDEF: SampleInfoSeq */
        -:  531:
        -:  532:/* End MODULE: DDS */
        -:  533:
        -:  534:
        -:  535:/* Begin MODULE: OpenDDS */
        -:  536:
        -:  537:
        -:  538:
        -:  539:/* Begin MODULE: DCPS */
        -:  540:
        -:  541:
        -:  542:
        -:  543:/* Begin TYPEDEF: GuidVendorId_t */
        -:  544:
        -:  545:
        -:  546:/* End TYPEDEF: GuidVendorId_t */
        -:  547:
        -:  548:
        -:  549:/* Begin TYPEDEF: GuidPrefix_t */
        -:  550:
        -:  551:
        -:  552:/* End TYPEDEF: GuidPrefix_t */
        -:  553:
        -:  554:
        -:  555:/* Begin TYPEDEF: EntityKey_t */
        -:  556:
        -:  557:
        -:  558:/* End TYPEDEF: EntityKey_t */
        -:  559:
        -:  560:
        -:  561:/* Begin STRUCT: EntityId_t */
        -:  562:
        -:  563:
        -:  564:/* End STRUCT: EntityId_t */
        -:  565:
        -:  566:
        -:  567:/* Begin CONST: ENTITYKIND_BUILTIN_UNKNOWN */
        -:  568:
        -:  569:
        -:  570:/* End CONST: ENTITYKIND_BUILTIN_UNKNOWN */
        -:  571:
        -:  572:
        -:  573:/* Begin CONST: ENTITYKIND_BUILTIN_PARTICIPANT */
        -:  574:
        -:  575:
        -:  576:/* End CONST: ENTITYKIND_BUILTIN_PARTICIPANT */
        -:  577:
        -:  578:
        -:  579:/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */
        -:  580:
        -:  581:
        -:  582:/* End CONST: ENTITYKIND_BUILTIN_WRITER_WITH_KEY */
        -:  583:
        -:  584:
        -:  585:/* Begin CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */
        -:  586:
        -:  587:
        -:  588:/* End CONST: ENTITYKIND_BUILTIN_WRITER_NO_KEY */
        -:  589:
        -:  590:
        -:  591:/* Begin CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */
        -:  592:
        -:  593:
        -:  594:/* End CONST: ENTITYKIND_BUILTIN_READER_NO_KEY */
        -:  595:
        -:  596:
        -:  597:/* Begin CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */
        -:  598:
        -:  599:
        -:  600:/* End CONST: ENTITYKIND_BUILTIN_READER_WITH_KEY */
        -:  601:
        -:  602:
        -:  603:/* Begin CONST: ENTITYKIND_BUILTIN_TOPIC */
        -:  604:
        -:  605:
        -:  606:/* End CONST: ENTITYKIND_BUILTIN_TOPIC */
        -:  607:
        -:  608:
        -:  609:/* Begin CONST: ENTITYKIND_USER_UNKNOWN */
        -:  610:
        -:  611:
        -:  612:/* End CONST: ENTITYKIND_USER_UNKNOWN */
        -:  613:
        -:  614:
        -:  615:/* Begin CONST: ENTITYKIND_USER_WRITER_WITH_KEY */
        -:  616:
        -:  617:
        -:  618:/* End CONST: ENTITYKIND_USER_WRITER_WITH_KEY */
        -:  619:
        -:  620:
        -:  621:/* Begin CONST: ENTITYKIND_USER_WRITER_NO_KEY */
        -:  622:
        -:  623:
        -:  624:/* End CONST: ENTITYKIND_USER_WRITER_NO_KEY */
        -:  625:
        -:  626:
        -:  627:/* Begin CONST: ENTITYKIND_USER_READER_NO_KEY */
        -:  628:
        -:  629:
        -:  630:/* End CONST: ENTITYKIND_USER_READER_NO_KEY */
        -:  631:
        -:  632:
        -:  633:/* Begin CONST: ENTITYKIND_USER_READER_WITH_KEY */
        -:  634:
        -:  635:
        -:  636:/* End CONST: ENTITYKIND_USER_READER_WITH_KEY */
        -:  637:
        -:  638:
        -:  639:/* Begin CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */
        -:  640:
        -:  641:
        -:  642:/* End CONST: ENTITYKIND_OPENDDS_SUBSCRIBER */
        -:  643:
        -:  644:
        -:  645:/* Begin CONST: ENTITYKIND_OPENDDS_PUBLISHER */
        -:  646:
        -:  647:
        -:  648:/* End CONST: ENTITYKIND_OPENDDS_PUBLISHER */
        -:  649:
        -:  650:
        -:  651:/* Begin CONST: ENTITYKIND_OPENDDS_TOPIC */
        -:  652:
        -:  653:
        -:  654:/* End CONST: ENTITYKIND_OPENDDS_TOPIC */
        -:  655:
        -:  656:
        -:  657:/* Begin CONST: ENTITYKIND_OPENDDS_USER */
        -:  658:
        -:  659:
        -:  660:/* End CONST: ENTITYKIND_OPENDDS_USER */
        -:  661:
        -:  662:
        -:  663:/* Begin CONST: ENTITYKIND_OPENDDS_NIL_WRITER */
        -:  664:
        -:  665:
        -:  666:/* End CONST: ENTITYKIND_OPENDDS_NIL_WRITER */
        -:  667:
        -:  668:
        -:  669:/* Begin STRUCT: GUID_t */
        -:  670:
        -:  671:
        -:  672:/* End STRUCT: GUID_t */
        -:  673:
        -:  674:
        -:  675:/* Begin TYPEDEF: GUIDSeq */
        -:  676:
        -:  677:
        -:  678:/* End TYPEDEF: GUIDSeq */
        -:  679:
        -:  680:/* End MODULE: DCPS */
        -:  681:
        -:  682:/* End MODULE: OpenDDS */
        -:  683:
        -:  684:
        -:  685:/* Begin MODULE: OpenDDS */
        -:  686:
        -:  687:
        -:  688:
        -:  689:/* Begin MODULE: DCPS */
        -:  690:
        -:  691:
        -:  692:
        -:  693:/* Begin TYPEDEF: RepoId */
        -:  694:
        -:  695:
        -:  696:/* End TYPEDEF: RepoId */
        -:  697:
        -:  698:
        -:  699:/* Begin TYPEDEF: TransportBLOB */
        -:  700:
        -:  701:
        -:  702:/* End TYPEDEF: TransportBLOB */
        -:  703:
        -:  704:
        -:  705:/* Begin STRUCT: TransportLocator */
        -:  706:
        -:  707:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  708:namespace OpenDDS { namespace DCPS {
        -:  709:
    #####:  710:void gen_find_size(const OpenDDS::DCPS::TransportLocator& stru, size_t& size, size_t& padding)
        -:  711:{
        -:  712:  ACE_UNUSED_ARG(stru);
        -:  713:  ACE_UNUSED_ARG(size);
        -:  714:  ACE_UNUSED_ARG(padding);
    #####:  715:  find_size_ulong(size, padding);
    #####:  716:  size += ACE_OS::strlen(stru.transport_type.in()) + 1;
    #####:  717:  gen_find_size(stru.data, size, padding);
    #####:  718:}
        -:  719:
    #####:  720:bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportLocator& stru)
        -:  721:{
        -:  722:  ACE_UNUSED_ARG(strm);
        -:  723:  ACE_UNUSED_ARG(stru);
    #####:  724:  return (strm << stru.transport_type.in())
    #####:  725:    && (strm << stru.data);
        -:  726:}
        -:  727:
    #####:  728:bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportLocator& stru)
        -:  729:{
        -:  730:  ACE_UNUSED_ARG(strm);
        -:  731:  ACE_UNUSED_ARG(stru);
    #####:  732:  return (strm >> stru.transport_type.out())
    #####:  733:    && (strm >> stru.data);
        -:  734:}
        -:  735:
        -:  736:}  }
        -:  737:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  738:
        -:  739:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  740:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  741:namespace OpenDDS { namespace DCPS {
        -:  742:
        -:  743:template<>
    #####:  744:struct MetaStructImpl<OpenDDS::DCPS::TransportLocator> : MetaStruct {
        -:  745:  typedef OpenDDS::DCPS::TransportLocator T;
        -:  746:
        -:  747:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  748:  void* allocate() const { return new T; }
        -:  749:
    #####:  750:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -:  751:
    #####:  752:  size_t numDcpsKeys() const { return 0; }
        -:  753:
        -:  754:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  755:
    #####:  756:  bool isDcpsKey(const char* field) const
        -:  757:  {
        -:  758:    ACE_UNUSED_ARG(field);
    #####:  759:    return false;
        -:  760:  }
        -:  761:
    #####:  762:  Value getValue(const void* stru, const char* field) const
        -:  763:  {
    #####:  764:    const OpenDDS::DCPS::TransportLocator& typed = *static_cast<const OpenDDS::DCPS::TransportLocator*>(stru);
    #####:  765:    if (std::strcmp(field, "transport_type") == 0) {
    #####:  766:      return typed.transport_type.in();
        -:  767:    }
        -:  768:    ACE_UNUSED_ARG(typed);
    #####:  769:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
        -:  770:  }
        -:  771:
    #####:  772:  Value getValue(Serializer& ser, const char* field) const
        -:  773:  {
    #####:  774:    if (std::strcmp(field, "transport_type") == 0) {
    #####:  775:      TAO::String_Manager val;
    #####:  776:      if (!(ser >> val.out())) {
    #####:  777:        throw std::runtime_error("Field 'transport_type' could not be deserialized");
        -:  778:      }
    #####:  779:      return val;
        -:  780:    } else {
        -:  781:      ACE_CDR::ULong len;
    #####:  782:      if (!(ser >> len)) {
    #####:  783:        throw std::runtime_error("String 'transport_type' length could not be deserialized");
        -:  784:      }
    #####:  785:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####:  786:        throw std::runtime_error("String 'transport_type' contents could not be skipped");
        -:  787:      }
        -:  788:    }
    #####:  789:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportBLOB*>(0))) {
    #####:  790:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -:  791:    }
    #####:  792:    if (!field[0]) {
    #####:  793:      return 0;
        -:  794:    }
    #####:  795:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::TransportLocator");
        -:  796:  }
        -:  797:
    #####:  798:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -:  799:  {
        -:  800:    ACE_UNUSED_ARG(next);
    #####:  801:    if (std::strcmp(field, "transport_type") == 0) {
    #####:  802:      return make_field_cmp(&T::transport_type, next);
        -:  803:    }
    #####:  804:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
        -:  805:  }
        -:  806:
        -:  807:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####:  808:  const char** getFieldNames() const
        -:  809:  {
        -:  810:    static const char* names[] = {"transport_type", "data", 0};
    #####:  811:    return names;
        -:  812:  }
        -:  813:
    #####:  814:  const void* getRawField(const void* stru, const char* field) const
        -:  815:  {
    #####:  816:    if (std::strcmp(field, "transport_type") == 0) {
    #####:  817:      return &static_cast<const T*>(stru)->transport_type;
        -:  818:    }
    #####:  819:    if (std::strcmp(field, "data") == 0) {
    #####:  820:      return &static_cast<const T*>(stru)->data;
        -:  821:    }
    #####:  822:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
        -:  823:  }
        -:  824:
    #####:  825:  void assign(void* lhs, const char* field, const void* rhs,
        -:  826:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -:  827:  {
        -:  828:    ACE_UNUSED_ARG(lhs);
        -:  829:    ACE_UNUSED_ARG(field);
        -:  830:    ACE_UNUSED_ARG(rhs);
        -:  831:    ACE_UNUSED_ARG(rhsFieldSpec);
        -:  832:    ACE_UNUSED_ARG(rhsMeta);
    #####:  833:    if (std::strcmp(field, "transport_type") == 0) {
    #####:  834:      static_cast<T*>(lhs)->transport_type = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  835:      return;
        -:  836:    }
    #####:  837:    if (std::strcmp(field, "data") == 0) {
    #####:  838:      static_cast<T*>(lhs)->data = *static_cast<const OpenDDS::DCPS::TransportBLOB*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####:  839:      return;
        -:  840:    }
    #####:  841:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
        -:  842:  }
        -:  843:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -:  844:
    #####:  845:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -:  846:  {
        -:  847:    ACE_UNUSED_ARG(lhs);
        -:  848:    ACE_UNUSED_ARG(field);
        -:  849:    ACE_UNUSED_ARG(rhs);
    #####:  850:    if (std::strcmp(field, "transport_type") == 0) {
    #####:  851:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->transport_type.in(), static_cast<const T*>(rhs)->transport_type.in());
        -:  852:    }
    #####:  853:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::TransportLocator)");
        -:  854:  }
        -:  855:};
        -:  856:
        -:  857:template<>
    #####:  858:const MetaStruct& getMetaStruct<OpenDDS::DCPS::TransportLocator>()
        -:  859:{
    #####:  860:  static MetaStructImpl<OpenDDS::DCPS::TransportLocator> msi;
    #####:  861:  return msi;
        -:  862:}
        -:  863:
    #####:  864:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportLocator*)
        -:  865:{
        -:  866:  ACE_UNUSED_ARG(ser);
    #####:  867:  MetaStructImpl<OpenDDS::DCPS::TransportLocator>().getValue(ser, "");
    #####:  868:  return true;
        -:  869:}
        -:  870:
        -:  871:}  }
        -:  872:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  873:
        -:  874:#endif
        -:  875:
        -:  876:/* End STRUCT: TransportLocator */
        -:  877:
        -:  878:
        -:  879:/* Begin TYPEDEF: TransportLocatorSeq */
        -:  880:
        -:  881:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  882:namespace OpenDDS { namespace DCPS {
        -:  883:
    #####:  884:void gen_find_size(const OpenDDS::DCPS::TransportLocatorSeq& seq, size_t& size, size_t& padding)
        -:  885:{
        -:  886:  ACE_UNUSED_ARG(seq);
        -:  887:  ACE_UNUSED_ARG(size);
        -:  888:  ACE_UNUSED_ARG(padding);
    #####:  889:  find_size_ulong(size, padding);
    #####:  890:  if (seq.length() == 0) {
    #####:  891:    return;
        -:  892:  }
    #####:  893:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####:  894:    gen_find_size(seq[i], size, padding);
        -:  895:  }
        -:  896:}
        -:  897:
    #####:  898:bool operator<<(Serializer& strm, const OpenDDS::DCPS::TransportLocatorSeq& seq)
        -:  899:{
        -:  900:  ACE_UNUSED_ARG(strm);
        -:  901:  ACE_UNUSED_ARG(seq);
    #####:  902:  const CORBA::ULong length = seq.length();
    #####:  903:  if (!(strm << length)) {
    #####:  904:    return false;
        -:  905:  }
    #####:  906:  if (length == 0) {
    #####:  907:    return true;
        -:  908:  }
    #####:  909:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  910:    if (!(strm << seq[i])) {
    #####:  911:      return false;
        -:  912:    }
        -:  913:  }
    #####:  914:  return true;
        -:  915:}
        -:  916:
    #####:  917:bool operator>>(Serializer& strm, OpenDDS::DCPS::TransportLocatorSeq& seq)
        -:  918:{
        -:  919:  ACE_UNUSED_ARG(strm);
        -:  920:  ACE_UNUSED_ARG(seq);
        -:  921:  CORBA::ULong length;
    #####:  922:  if (!(strm >> length)) {
    #####:  923:    return false;
        -:  924:  }
    #####:  925:  seq.length(length);
    #####:  926:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####:  927:    if (!(strm >> seq[i])) {
    #####:  928:      return false;
        -:  929:    }
        -:  930:  }
    #####:  931:  return true;
        -:  932:}
        -:  933:
        -:  934:}  }
        -:  935:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  936:
        -:  937:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -:  938:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  939:namespace OpenDDS { namespace DCPS {
        -:  940:
    #####:  941:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::TransportLocatorSeq*)
        -:  942:{
        -:  943:  ACE_UNUSED_ARG(ser);
        -:  944:  ACE_CDR::ULong length;
    #####:  945:  if (!(ser >> length)) return false;
    #####:  946:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####:  947:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocator*>(0))) return false;
        -:  948:  }
    #####:  949:  return true;
        -:  950:}
        -:  951:
        -:  952:}  }
        -:  953:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -:  954:
        -:  955:#endif
        -:  956:
        -:  957:/* End TYPEDEF: TransportLocatorSeq */
        -:  958:
        -:  959:
        -:  960:/* Begin STRUCT: IncompatibleQosStatus */
        -:  961:
        -:  962:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -:  963:namespace OpenDDS { namespace DCPS {
        -:  964:
    #####:  965:void gen_find_size(const OpenDDS::DCPS::IncompatibleQosStatus& stru, size_t& size, size_t& padding)
        -:  966:{
        -:  967:  ACE_UNUSED_ARG(stru);
        -:  968:  ACE_UNUSED_ARG(size);
        -:  969:  ACE_UNUSED_ARG(padding);
    #####:  970:  if ((size + padding) % 4) {
    #####:  971:    padding += 4 - ((size + padding) % 4);
        -:  972:  }
    #####:  973:  size += gen_max_marshaled_size(stru.total_count);
    #####:  974:  if ((size + padding) % 4) {
    #####:  975:    padding += 4 - ((size + padding) % 4);
        -:  976:  }
    #####:  977:  size += gen_max_marshaled_size(stru.count_since_last_send);
    #####:  978:  if ((size + padding) % 4) {
    #####:  979:    padding += 4 - ((size + padding) % 4);
        -:  980:  }
    #####:  981:  size += gen_max_marshaled_size(stru.last_policy_id);
    #####:  982:  gen_find_size(stru.policies, size, padding);
    #####:  983:}
        -:  984:
    #####:  985:bool operator<<(Serializer& strm, const OpenDDS::DCPS::IncompatibleQosStatus& stru)
        -:  986:{
        -:  987:  ACE_UNUSED_ARG(strm);
        -:  988:  ACE_UNUSED_ARG(stru);
    #####:  989:  return (strm << stru.total_count)
    #####:  990:    && (strm << stru.count_since_last_send)
    #####:  991:    && (strm << stru.last_policy_id)
    #####:  992:    && (strm << stru.policies);
        -:  993:}
        -:  994:
    #####:  995:bool operator>>(Serializer& strm, OpenDDS::DCPS::IncompatibleQosStatus& stru)
        -:  996:{
        -:  997:  ACE_UNUSED_ARG(strm);
        -:  998:  ACE_UNUSED_ARG(stru);
    #####:  999:  return (strm >> stru.total_count)
    #####: 1000:    && (strm >> stru.count_since_last_send)
    #####: 1001:    && (strm >> stru.last_policy_id)
    #####: 1002:    && (strm >> stru.policies);
        -: 1003:}
        -: 1004:
        -: 1005:}  }
        -: 1006:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1007:
        -: 1008:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1009:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1010:namespace OpenDDS { namespace DCPS {
        -: 1011:
        -: 1012:template<>
    #####: 1013:struct MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus> : MetaStruct {
        -: 1014:  typedef OpenDDS::DCPS::IncompatibleQosStatus T;
        -: 1015:
        -: 1016:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1017:  void* allocate() const { return new T; }
        -: 1018:
    #####: 1019:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1020:
    #####: 1021:  size_t numDcpsKeys() const { return 0; }
        -: 1022:
        -: 1023:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1024:
    #####: 1025:  bool isDcpsKey(const char* field) const
        -: 1026:  {
        -: 1027:    ACE_UNUSED_ARG(field);
    #####: 1028:    return false;
        -: 1029:  }
        -: 1030:
    #####: 1031:  Value getValue(const void* stru, const char* field) const
        -: 1032:  {
    #####: 1033:    const OpenDDS::DCPS::IncompatibleQosStatus& typed = *static_cast<const OpenDDS::DCPS::IncompatibleQosStatus*>(stru);
    #####: 1034:    if (std::strcmp(field, "total_count") == 0) {
    #####: 1035:      return typed.total_count;
        -: 1036:    }
    #####: 1037:    if (std::strcmp(field, "count_since_last_send") == 0) {
    #####: 1038:      return typed.count_since_last_send;
        -: 1039:    }
    #####: 1040:    if (std::strcmp(field, "last_policy_id") == 0) {
    #####: 1041:      return typed.last_policy_id;
        -: 1042:    }
        -: 1043:    ACE_UNUSED_ARG(typed);
    #####: 1044:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
        -: 1045:  }
        -: 1046:
    #####: 1047:  Value getValue(Serializer& ser, const char* field) const
        -: 1048:  {
    #####: 1049:    if (std::strcmp(field, "total_count") == 0) {
        -: 1050:      ACE_CDR::Long val;
    #####: 1051:      if (!(ser >> val)) {
    #####: 1052:        throw std::runtime_error("Field 'total_count' could not be deserialized");
        -: 1053:      }
    #####: 1054:      return val;
        -: 1055:    } else {
    #####: 1056:      if (!ser.skip(1, 4)) {
    #####: 1057:        throw std::runtime_error("Field 'total_count' could not be skipped");
        -: 1058:      }
        -: 1059:    }
    #####: 1060:    if (std::strcmp(field, "count_since_last_send") == 0) {
        -: 1061:      ACE_CDR::Long val;
    #####: 1062:      if (!(ser >> val)) {
    #####: 1063:        throw std::runtime_error("Field 'count_since_last_send' could not be deserialized");
        -: 1064:      }
    #####: 1065:      return val;
        -: 1066:    } else {
    #####: 1067:      if (!ser.skip(1, 4)) {
    #####: 1068:        throw std::runtime_error("Field 'count_since_last_send' could not be skipped");
        -: 1069:      }
        -: 1070:    }
    #####: 1071:    if (std::strcmp(field, "last_policy_id") == 0) {
        -: 1072:      ACE_CDR::Long val;
    #####: 1073:      if (!(ser >> val)) {
    #####: 1074:        throw std::runtime_error("Field 'last_policy_id' could not be deserialized");
        -: 1075:      }
    #####: 1076:      return val;
        -: 1077:    } else {
    #####: 1078:      if (!ser.skip(1, 4)) {
    #####: 1079:        throw std::runtime_error("Field 'last_policy_id' could not be skipped");
        -: 1080:      }
        -: 1081:    }
    #####: 1082:    if (!gen_skip_over(ser, static_cast<DDS::QosPolicyCountSeq*>(0))) {
    #####: 1083:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1084:    }
    #####: 1085:    if (!field[0]) {
    #####: 1086:      return 0;
        -: 1087:    }
    #####: 1088:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::IncompatibleQosStatus");
        -: 1089:  }
        -: 1090:
    #####: 1091:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1092:  {
        -: 1093:    ACE_UNUSED_ARG(next);
    #####: 1094:    if (std::strcmp(field, "total_count") == 0) {
    #####: 1095:      return make_field_cmp(&T::total_count, next);
        -: 1096:    }
    #####: 1097:    if (std::strcmp(field, "count_since_last_send") == 0) {
    #####: 1098:      return make_field_cmp(&T::count_since_last_send, next);
        -: 1099:    }
    #####: 1100:    if (std::strcmp(field, "last_policy_id") == 0) {
    #####: 1101:      return make_field_cmp(&T::last_policy_id, next);
        -: 1102:    }
    #####: 1103:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
        -: 1104:  }
        -: 1105:
        -: 1106:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1107:  const char** getFieldNames() const
        -: 1108:  {
        -: 1109:    static const char* names[] = {"total_count", "count_since_last_send", "last_policy_id", "policies", 0};
    #####: 1110:    return names;
        -: 1111:  }
        -: 1112:
    #####: 1113:  const void* getRawField(const void* stru, const char* field) const
        -: 1114:  {
    #####: 1115:    if (std::strcmp(field, "total_count") == 0) {
    #####: 1116:      return &static_cast<const T*>(stru)->total_count;
        -: 1117:    }
    #####: 1118:    if (std::strcmp(field, "count_since_last_send") == 0) {
    #####: 1119:      return &static_cast<const T*>(stru)->count_since_last_send;
        -: 1120:    }
    #####: 1121:    if (std::strcmp(field, "last_policy_id") == 0) {
    #####: 1122:      return &static_cast<const T*>(stru)->last_policy_id;
        -: 1123:    }
    #####: 1124:    if (std::strcmp(field, "policies") == 0) {
    #####: 1125:      return &static_cast<const T*>(stru)->policies;
        -: 1126:    }
    #####: 1127:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
        -: 1128:  }
        -: 1129:
    #####: 1130:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1131:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1132:  {
        -: 1133:    ACE_UNUSED_ARG(lhs);
        -: 1134:    ACE_UNUSED_ARG(field);
        -: 1135:    ACE_UNUSED_ARG(rhs);
        -: 1136:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1137:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1138:    if (std::strcmp(field, "total_count") == 0) {
    #####: 1139:      static_cast<T*>(lhs)->total_count = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1140:      return;
        -: 1141:    }
    #####: 1142:    if (std::strcmp(field, "count_since_last_send") == 0) {
    #####: 1143:      static_cast<T*>(lhs)->count_since_last_send = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1144:      return;
        -: 1145:    }
    #####: 1146:    if (std::strcmp(field, "last_policy_id") == 0) {
    #####: 1147:      static_cast<T*>(lhs)->last_policy_id = *static_cast<const DDS::QosPolicyId_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1148:      return;
        -: 1149:    }
    #####: 1150:    if (std::strcmp(field, "policies") == 0) {
    #####: 1151:      static_cast<T*>(lhs)->policies = *static_cast<const DDS::QosPolicyCountSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1152:      return;
        -: 1153:    }
    #####: 1154:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
        -: 1155:  }
        -: 1156:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1157:
    #####: 1158:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1159:  {
        -: 1160:    ACE_UNUSED_ARG(lhs);
        -: 1161:    ACE_UNUSED_ARG(field);
        -: 1162:    ACE_UNUSED_ARG(rhs);
    #####: 1163:    if (std::strcmp(field, "total_count") == 0) {
    #####: 1164:      return static_cast<const T*>(lhs)->total_count == static_cast<const T*>(rhs)->total_count;
        -: 1165:    }
    #####: 1166:    if (std::strcmp(field, "count_since_last_send") == 0) {
    #####: 1167:      return static_cast<const T*>(lhs)->count_since_last_send == static_cast<const T*>(rhs)->count_since_last_send;
        -: 1168:    }
    #####: 1169:    if (std::strcmp(field, "last_policy_id") == 0) {
    #####: 1170:      return static_cast<const T*>(lhs)->last_policy_id == static_cast<const T*>(rhs)->last_policy_id;
        -: 1171:    }
    #####: 1172:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::IncompatibleQosStatus)");
        -: 1173:  }
        -: 1174:};
        -: 1175:
        -: 1176:template<>
    #####: 1177:const MetaStruct& getMetaStruct<OpenDDS::DCPS::IncompatibleQosStatus>()
        -: 1178:{
    #####: 1179:  static MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus> msi;
    #####: 1180:  return msi;
        -: 1181:}
        -: 1182:
    #####: 1183:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::IncompatibleQosStatus*)
        -: 1184:{
        -: 1185:  ACE_UNUSED_ARG(ser);
    #####: 1186:  MetaStructImpl<OpenDDS::DCPS::IncompatibleQosStatus>().getValue(ser, "");
    #####: 1187:  return true;
        -: 1188:}
        -: 1189:
        -: 1190:}  }
        -: 1191:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1192:
        -: 1193:#endif
        -: 1194:
        -: 1195:/* End STRUCT: IncompatibleQosStatus */
        -: 1196:
        -: 1197:
        -: 1198:/* Begin STRUCT: AddDomainStatus */
        -: 1199:
        -: 1200:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1201:namespace OpenDDS { namespace DCPS {
        -: 1202:
    #####: 1203:void gen_find_size(const OpenDDS::DCPS::AddDomainStatus& stru, size_t& size, size_t& padding)
        -: 1204:{
        -: 1205:  ACE_UNUSED_ARG(stru);
        -: 1206:  ACE_UNUSED_ARG(size);
        -: 1207:  ACE_UNUSED_ARG(padding);
    #####: 1208:  gen_find_size(stru.id, size, padding);
    #####: 1209:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.federated));
    #####: 1210:}
        -: 1211:
    #####: 1212:bool operator<<(Serializer& strm, const OpenDDS::DCPS::AddDomainStatus& stru)
        -: 1213:{
        -: 1214:  ACE_UNUSED_ARG(strm);
        -: 1215:  ACE_UNUSED_ARG(stru);
    #####: 1216:  return (strm << stru.id)
    #####: 1217:    && (strm << ACE_OutputCDR::from_boolean(stru.federated));
        -: 1218:}
        -: 1219:
    #####: 1220:bool operator>>(Serializer& strm, OpenDDS::DCPS::AddDomainStatus& stru)
        -: 1221:{
        -: 1222:  ACE_UNUSED_ARG(strm);
        -: 1223:  ACE_UNUSED_ARG(stru);
    #####: 1224:  return (strm >> stru.id)
    #####: 1225:    && (strm >> ACE_InputCDR::to_boolean(stru.federated));
        -: 1226:}
        -: 1227:
        -: 1228:}  }
        -: 1229:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1230:
        -: 1231:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1232:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1233:namespace OpenDDS { namespace DCPS {
        -: 1234:
        -: 1235:template<>
    #####: 1236:struct MetaStructImpl<OpenDDS::DCPS::AddDomainStatus> : MetaStruct {
        -: 1237:  typedef OpenDDS::DCPS::AddDomainStatus T;
        -: 1238:
        -: 1239:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1240:  void* allocate() const { return new T; }
        -: 1241:
    #####: 1242:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1243:
    #####: 1244:  size_t numDcpsKeys() const { return 0; }
        -: 1245:
        -: 1246:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1247:
    #####: 1248:  bool isDcpsKey(const char* field) const
        -: 1249:  {
        -: 1250:    ACE_UNUSED_ARG(field);
    #####: 1251:    return false;
        -: 1252:  }
        -: 1253:
    #####: 1254:  Value getValue(const void* stru, const char* field) const
        -: 1255:  {
    #####: 1256:    const OpenDDS::DCPS::AddDomainStatus& typed = *static_cast<const OpenDDS::DCPS::AddDomainStatus*>(stru);
    #####: 1257:    if (std::strncmp(field, "id.", 3) == 0) {
    #####: 1258:      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.id, field + 3);
        -: 1259:    }
    #####: 1260:    if (std::strcmp(field, "federated") == 0) {
    #####: 1261:      return typed.federated;
        -: 1262:    }
        -: 1263:    ACE_UNUSED_ARG(typed);
    #####: 1264:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
        -: 1265:  }
        -: 1266:
    #####: 1267:  Value getValue(Serializer& ser, const char* field) const
        -: 1268:  {
    #####: 1269:    if (std::strncmp(field, "id.", 3) == 0) {
    #####: 1270:      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 3);
        -: 1271:    } else {
    #####: 1272:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) {
    #####: 1273:        throw std::runtime_error("Field 'id' could not be skipped");
        -: 1274:      }
        -: 1275:    }
    #####: 1276:    if (std::strcmp(field, "federated") == 0) {
        -: 1277:      ACE_CDR::Boolean val;
    #####: 1278:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 1279:        throw std::runtime_error("Field 'federated' could not be deserialized");
        -: 1280:      }
    #####: 1281:      return val;
        -: 1282:    } else {
    #####: 1283:      if (!ser.skip(1, 1)) {
    #####: 1284:        throw std::runtime_error("Field 'federated' could not be skipped");
        -: 1285:      }
        -: 1286:    }
    #####: 1287:    if (!field[0]) {
    #####: 1288:      return 0;
        -: 1289:    }
    #####: 1290:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::AddDomainStatus");
        -: 1291:  }
        -: 1292:
    #####: 1293:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1294:  {
        -: 1295:    ACE_UNUSED_ARG(next);
    #####: 1296:    if (std::strncmp(field, "id.", 3) == 0) {
    #####: 1297:      return make_struct_cmp(&T::id, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 3), next);
        -: 1298:    }
    #####: 1299:    if (std::strcmp(field, "federated") == 0) {
    #####: 1300:      return make_field_cmp(&T::federated, next);
        -: 1301:    }
    #####: 1302:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
        -: 1303:  }
        -: 1304:
        -: 1305:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1306:  const char** getFieldNames() const
        -: 1307:  {
        -: 1308:    static const char* names[] = {"id", "federated", 0};
    #####: 1309:    return names;
        -: 1310:  }
        -: 1311:
    #####: 1312:  const void* getRawField(const void* stru, const char* field) const
        -: 1313:  {
    #####: 1314:    if (std::strcmp(field, "id") == 0) {
    #####: 1315:      return &static_cast<const T*>(stru)->id;
        -: 1316:    }
    #####: 1317:    if (std::strcmp(field, "federated") == 0) {
    #####: 1318:      return &static_cast<const T*>(stru)->federated;
        -: 1319:    }
    #####: 1320:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
        -: 1321:  }
        -: 1322:
    #####: 1323:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1324:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1325:  {
        -: 1326:    ACE_UNUSED_ARG(lhs);
        -: 1327:    ACE_UNUSED_ARG(field);
        -: 1328:    ACE_UNUSED_ARG(rhs);
        -: 1329:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1330:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1331:    if (std::strcmp(field, "id") == 0) {
    #####: 1332:      static_cast<T*>(lhs)->id = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1333:      return;
        -: 1334:    }
    #####: 1335:    if (std::strcmp(field, "federated") == 0) {
    #####: 1336:      static_cast<T*>(lhs)->federated = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1337:      return;
        -: 1338:    }
    #####: 1339:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
        -: 1340:  }
        -: 1341:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1342:
    #####: 1343:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1344:  {
        -: 1345:    ACE_UNUSED_ARG(lhs);
        -: 1346:    ACE_UNUSED_ARG(field);
        -: 1347:    ACE_UNUSED_ARG(rhs);
    #####: 1348:    if (std::strcmp(field, "federated") == 0) {
    #####: 1349:      return static_cast<const T*>(lhs)->federated == static_cast<const T*>(rhs)->federated;
        -: 1350:    }
    #####: 1351:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::AddDomainStatus)");
        -: 1352:  }
        -: 1353:};
        -: 1354:
        -: 1355:template<>
    #####: 1356:const MetaStruct& getMetaStruct<OpenDDS::DCPS::AddDomainStatus>()
        -: 1357:{
    #####: 1358:  static MetaStructImpl<OpenDDS::DCPS::AddDomainStatus> msi;
    #####: 1359:  return msi;
        -: 1360:}
        -: 1361:
    #####: 1362:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::AddDomainStatus*)
        -: 1363:{
        -: 1364:  ACE_UNUSED_ARG(ser);
    #####: 1365:  MetaStructImpl<OpenDDS::DCPS::AddDomainStatus>().getValue(ser, "");
    #####: 1366:  return true;
        -: 1367:}
        -: 1368:
        -: 1369:}  }
        -: 1370:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1371:
        -: 1372:#endif
        -: 1373:
        -: 1374:/* End STRUCT: AddDomainStatus */
        -: 1375:
        -: 1376:
        -: 1377:/* Begin ENUM: TopicStatus */
        -: 1378:
        -: 1379:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1380:namespace OpenDDS { namespace DCPS {
        -: 1381:
    #####: 1382:bool operator<<(Serializer& strm, const OpenDDS::DCPS::TopicStatus& enumval)
        -: 1383:{
        -: 1384:  ACE_UNUSED_ARG(strm);
        -: 1385:  ACE_UNUSED_ARG(enumval);
    #####: 1386:  return strm << static_cast<CORBA::ULong>(enumval);
        -: 1387:}
        -: 1388:
    #####: 1389:bool operator>>(Serializer& strm, OpenDDS::DCPS::TopicStatus& enumval)
        -: 1390:{
        -: 1391:  ACE_UNUSED_ARG(strm);
        -: 1392:  ACE_UNUSED_ARG(enumval);
    #####: 1393:  CORBA::ULong temp = 0;
    #####: 1394:  if (strm >> temp) {
    #####: 1395:    enumval = static_cast<OpenDDS::DCPS::TopicStatus>(temp);
    #####: 1396:    return true;
        -: 1397:  }
    #####: 1398:  return false;
        -: 1399:}
        -: 1400:
        -: 1401:}  }
        -: 1402:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1403:
        -: 1404:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1405:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1406:namespace OpenDDS { namespace DCPS {
        -: 1407:
        -: 1408:const char* gen_OpenDDS_DCPS_TopicStatus_names[] = {
        -: 1409:  "CREATED",
        -: 1410:  "ENABLED",
        -: 1411:  "FOUND",
        -: 1412:  "NOT_FOUND",
        -: 1413:  "REMOVED",
        -: 1414:  "CONFLICTING_TYPENAME",
        -: 1415:  "PRECONDITION_NOT_MET",
        -: 1416:  "INTERNAL_ERROR",
        -: 1417:  "TOPIC_DISABLED"
        -: 1418:};
        -: 1419:const size_t gen_OpenDDS_DCPS_TopicStatus_names_size = 9;
        -: 1420:}  }
        -: 1421:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1422:
        -: 1423:#endif
        -: 1424:
        -: 1425:/* End ENUM: TopicStatus */
        -: 1426:
        -: 1427:
        -: 1428:/* Begin STRUCT: WriterAssociation */
        -: 1429:
        -: 1430:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1431:namespace OpenDDS { namespace DCPS {
        -: 1432:
    #####: 1433:void gen_find_size(const OpenDDS::DCPS::WriterAssociation& stru, size_t& size, size_t& padding)
        -: 1434:{
        -: 1435:  ACE_UNUSED_ARG(stru);
        -: 1436:  ACE_UNUSED_ARG(size);
        -: 1437:  ACE_UNUSED_ARG(padding);
    #####: 1438:  gen_find_size(stru.writerTransInfo, size, padding);
    #####: 1439:  gen_find_size(stru.writerId, size, padding);
    #####: 1440:  gen_find_size(stru.pubQos, size, padding);
    #####: 1441:  gen_find_size(stru.writerQos, size, padding);
    #####: 1442:}
        -: 1443:
    #####: 1444:bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterAssociation& stru)
        -: 1445:{
        -: 1446:  ACE_UNUSED_ARG(strm);
        -: 1447:  ACE_UNUSED_ARG(stru);
    #####: 1448:  return (strm << stru.writerTransInfo)
    #####: 1449:    && (strm << stru.writerId)
    #####: 1450:    && (strm << stru.pubQos)
    #####: 1451:    && (strm << stru.writerQos);
        -: 1452:}
        -: 1453:
    #####: 1454:bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterAssociation& stru)
        -: 1455:{
        -: 1456:  ACE_UNUSED_ARG(strm);
        -: 1457:  ACE_UNUSED_ARG(stru);
    #####: 1458:  return (strm >> stru.writerTransInfo)
    #####: 1459:    && (strm >> stru.writerId)
    #####: 1460:    && (strm >> stru.pubQos)
    #####: 1461:    && (strm >> stru.writerQos);
        -: 1462:}
        -: 1463:
        -: 1464:}  }
        -: 1465:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1466:
        -: 1467:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1468:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1469:namespace OpenDDS { namespace DCPS {
        -: 1470:
        -: 1471:template<>
    #####: 1472:struct MetaStructImpl<OpenDDS::DCPS::WriterAssociation> : MetaStruct {
        -: 1473:  typedef OpenDDS::DCPS::WriterAssociation T;
        -: 1474:
        -: 1475:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1476:  void* allocate() const { return new T; }
        -: 1477:
    #####: 1478:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1479:
    #####: 1480:  size_t numDcpsKeys() const { return 0; }
        -: 1481:
        -: 1482:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1483:
    #####: 1484:  bool isDcpsKey(const char* field) const
        -: 1485:  {
        -: 1486:    ACE_UNUSED_ARG(field);
    #####: 1487:    return false;
        -: 1488:  }
        -: 1489:
    #####: 1490:  Value getValue(const void* stru, const char* field) const
        -: 1491:  {
    #####: 1492:    const OpenDDS::DCPS::WriterAssociation& typed = *static_cast<const OpenDDS::DCPS::WriterAssociation*>(stru);
    #####: 1493:    if (std::strncmp(field, "writerId.", 9) == 0) {
    #####: 1494:      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.writerId, field + 9);
        -: 1495:    }
    #####: 1496:    if (std::strncmp(field, "pubQos.", 7) == 0) {
    #####: 1497:      return getMetaStruct<DDS::PublisherQos>().getValue(&typed.pubQos, field + 7);
        -: 1498:    }
    #####: 1499:    if (std::strncmp(field, "writerQos.", 10) == 0) {
    #####: 1500:      return getMetaStruct<DDS::DataWriterQos>().getValue(&typed.writerQos, field + 10);
        -: 1501:    }
        -: 1502:    ACE_UNUSED_ARG(typed);
    #####: 1503:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
        -: 1504:  }
        -: 1505:
    #####: 1506:  Value getValue(Serializer& ser, const char* field) const
        -: 1507:  {
    #####: 1508:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
    #####: 1509:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1510:    }
    #####: 1511:    if (std::strncmp(field, "writerId.", 9) == 0) {
    #####: 1512:      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 9);
        -: 1513:    } else {
    #####: 1514:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) {
    #####: 1515:        throw std::runtime_error("Field 'writerId' could not be skipped");
        -: 1516:      }
        -: 1517:    }
    #####: 1518:    if (std::strncmp(field, "pubQos.", 7) == 0) {
    #####: 1519:      return getMetaStruct<DDS::PublisherQos>().getValue(ser, field + 7);
        -: 1520:    } else {
    #####: 1521:      if (!gen_skip_over(ser, static_cast<DDS::PublisherQos*>(0))) {
    #####: 1522:        throw std::runtime_error("Field 'pubQos' could not be skipped");
        -: 1523:      }
        -: 1524:    }
    #####: 1525:    if (std::strncmp(field, "writerQos.", 10) == 0) {
    #####: 1526:      return getMetaStruct<DDS::DataWriterQos>().getValue(ser, field + 10);
        -: 1527:    } else {
    #####: 1528:      if (!gen_skip_over(ser, static_cast<DDS::DataWriterQos*>(0))) {
    #####: 1529:        throw std::runtime_error("Field 'writerQos' could not be skipped");
        -: 1530:      }
        -: 1531:    }
    #####: 1532:    if (!field[0]) {
    #####: 1533:      return 0;
        -: 1534:    }
    #####: 1535:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::WriterAssociation");
        -: 1536:  }
        -: 1537:
    #####: 1538:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1539:  {
        -: 1540:    ACE_UNUSED_ARG(next);
    #####: 1541:    if (std::strncmp(field, "writerId.", 9) == 0) {
    #####: 1542:      return make_struct_cmp(&T::writerId, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9), next);
        -: 1543:    }
    #####: 1544:    if (std::strncmp(field, "pubQos.", 7) == 0) {
    #####: 1545:      return make_struct_cmp(&T::pubQos, getMetaStruct<DDS::PublisherQos>().create_qc_comparator(field + 7), next);
        -: 1546:    }
    #####: 1547:    if (std::strncmp(field, "writerQos.", 10) == 0) {
    #####: 1548:      return make_struct_cmp(&T::writerQos, getMetaStruct<DDS::DataWriterQos>().create_qc_comparator(field + 10), next);
        -: 1549:    }
    #####: 1550:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
        -: 1551:  }
        -: 1552:
        -: 1553:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1554:  const char** getFieldNames() const
        -: 1555:  {
        -: 1556:    static const char* names[] = {"writerTransInfo", "writerId", "pubQos", "writerQos", 0};
    #####: 1557:    return names;
        -: 1558:  }
        -: 1559:
    #####: 1560:  const void* getRawField(const void* stru, const char* field) const
        -: 1561:  {
    #####: 1562:    if (std::strcmp(field, "writerTransInfo") == 0) {
    #####: 1563:      return &static_cast<const T*>(stru)->writerTransInfo;
        -: 1564:    }
    #####: 1565:    if (std::strcmp(field, "writerId") == 0) {
    #####: 1566:      return &static_cast<const T*>(stru)->writerId;
        -: 1567:    }
    #####: 1568:    if (std::strcmp(field, "pubQos") == 0) {
    #####: 1569:      return &static_cast<const T*>(stru)->pubQos;
        -: 1570:    }
    #####: 1571:    if (std::strcmp(field, "writerQos") == 0) {
    #####: 1572:      return &static_cast<const T*>(stru)->writerQos;
        -: 1573:    }
    #####: 1574:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
        -: 1575:  }
        -: 1576:
    #####: 1577:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1578:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1579:  {
        -: 1580:    ACE_UNUSED_ARG(lhs);
        -: 1581:    ACE_UNUSED_ARG(field);
        -: 1582:    ACE_UNUSED_ARG(rhs);
        -: 1583:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1584:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1585:    if (std::strcmp(field, "writerTransInfo") == 0) {
    #####: 1586:      static_cast<T*>(lhs)->writerTransInfo = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1587:      return;
        -: 1588:    }
    #####: 1589:    if (std::strcmp(field, "writerId") == 0) {
    #####: 1590:      static_cast<T*>(lhs)->writerId = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1591:      return;
        -: 1592:    }
    #####: 1593:    if (std::strcmp(field, "pubQos") == 0) {
    #####: 1594:      static_cast<T*>(lhs)->pubQos = *static_cast<const DDS::PublisherQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1595:      return;
        -: 1596:    }
    #####: 1597:    if (std::strcmp(field, "writerQos") == 0) {
    #####: 1598:      static_cast<T*>(lhs)->writerQos = *static_cast<const DDS::DataWriterQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1599:      return;
        -: 1600:    }
    #####: 1601:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
        -: 1602:  }
        -: 1603:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1604:
    #####: 1605:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1606:  {
        -: 1607:    ACE_UNUSED_ARG(lhs);
        -: 1608:    ACE_UNUSED_ARG(field);
        -: 1609:    ACE_UNUSED_ARG(rhs);
    #####: 1610:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterAssociation)");
        -: 1611:  }
        -: 1612:};
        -: 1613:
        -: 1614:template<>
    #####: 1615:const MetaStruct& getMetaStruct<OpenDDS::DCPS::WriterAssociation>()
        -: 1616:{
    #####: 1617:  static MetaStructImpl<OpenDDS::DCPS::WriterAssociation> msi;
    #####: 1618:  return msi;
        -: 1619:}
        -: 1620:
    #####: 1621:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterAssociation*)
        -: 1622:{
        -: 1623:  ACE_UNUSED_ARG(ser);
    #####: 1624:  MetaStructImpl<OpenDDS::DCPS::WriterAssociation>().getValue(ser, "");
    #####: 1625:  return true;
        -: 1626:}
        -: 1627:
        -: 1628:}  }
        -: 1629:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1630:
        -: 1631:#endif
        -: 1632:
        -: 1633:/* End STRUCT: WriterAssociation */
        -: 1634:
        -: 1635:
        -: 1636:/* Begin STRUCT: ReaderAssociation */
        -: 1637:
        -: 1638:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1639:namespace OpenDDS { namespace DCPS {
        -: 1640:
    #####: 1641:void gen_find_size(const OpenDDS::DCPS::ReaderAssociation& stru, size_t& size, size_t& padding)
        -: 1642:{
        -: 1643:  ACE_UNUSED_ARG(stru);
        -: 1644:  ACE_UNUSED_ARG(size);
        -: 1645:  ACE_UNUSED_ARG(padding);
    #####: 1646:  gen_find_size(stru.readerTransInfo, size, padding);
    #####: 1647:  gen_find_size(stru.readerId, size, padding);
    #####: 1648:  gen_find_size(stru.subQos, size, padding);
    #####: 1649:  gen_find_size(stru.readerQos, size, padding);
    #####: 1650:  find_size_ulong(size, padding);
    #####: 1651:  size += ACE_OS::strlen(stru.filterClassName.in()) + 1;
    #####: 1652:  find_size_ulong(size, padding);
    #####: 1653:  size += ACE_OS::strlen(stru.filterExpression.in()) + 1;
    #####: 1654:  gen_find_size(stru.exprParams, size, padding);
    #####: 1655:}
        -: 1656:
    #####: 1657:bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderAssociation& stru)
        -: 1658:{
        -: 1659:  ACE_UNUSED_ARG(strm);
        -: 1660:  ACE_UNUSED_ARG(stru);
    #####: 1661:  return (strm << stru.readerTransInfo)
    #####: 1662:    && (strm << stru.readerId)
    #####: 1663:    && (strm << stru.subQos)
    #####: 1664:    && (strm << stru.readerQos)
    #####: 1665:    && (strm << stru.filterClassName.in())
    #####: 1666:    && (strm << stru.filterExpression.in())
    #####: 1667:    && (strm << stru.exprParams);
        -: 1668:}
        -: 1669:
    #####: 1670:bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderAssociation& stru)
        -: 1671:{
        -: 1672:  ACE_UNUSED_ARG(strm);
        -: 1673:  ACE_UNUSED_ARG(stru);
    #####: 1674:  return (strm >> stru.readerTransInfo)
    #####: 1675:    && (strm >> stru.readerId)
    #####: 1676:    && (strm >> stru.subQos)
    #####: 1677:    && (strm >> stru.readerQos)
    #####: 1678:    && (strm >> stru.filterClassName.out())
    #####: 1679:    && (strm >> stru.filterExpression.out())
    #####: 1680:    && (strm >> stru.exprParams);
        -: 1681:}
        -: 1682:
        -: 1683:}  }
        -: 1684:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1685:
        -: 1686:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1687:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1688:namespace OpenDDS { namespace DCPS {
        -: 1689:
        -: 1690:template<>
    #####: 1691:struct MetaStructImpl<OpenDDS::DCPS::ReaderAssociation> : MetaStruct {
        -: 1692:  typedef OpenDDS::DCPS::ReaderAssociation T;
        -: 1693:
        -: 1694:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1695:  void* allocate() const { return new T; }
        -: 1696:
    #####: 1697:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 1698:
    #####: 1699:  size_t numDcpsKeys() const { return 0; }
        -: 1700:
        -: 1701:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1702:
    #####: 1703:  bool isDcpsKey(const char* field) const
        -: 1704:  {
        -: 1705:    ACE_UNUSED_ARG(field);
    #####: 1706:    return false;
        -: 1707:  }
        -: 1708:
    #####: 1709:  Value getValue(const void* stru, const char* field) const
        -: 1710:  {
    #####: 1711:    const OpenDDS::DCPS::ReaderAssociation& typed = *static_cast<const OpenDDS::DCPS::ReaderAssociation*>(stru);
    #####: 1712:    if (std::strncmp(field, "readerId.", 9) == 0) {
    #####: 1713:      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(&typed.readerId, field + 9);
        -: 1714:    }
    #####: 1715:    if (std::strncmp(field, "subQos.", 7) == 0) {
    #####: 1716:      return getMetaStruct<DDS::SubscriberQos>().getValue(&typed.subQos, field + 7);
        -: 1717:    }
    #####: 1718:    if (std::strncmp(field, "readerQos.", 10) == 0) {
    #####: 1719:      return getMetaStruct<DDS::DataReaderQos>().getValue(&typed.readerQos, field + 10);
        -: 1720:    }
    #####: 1721:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 1722:      return typed.filterClassName.in();
        -: 1723:    }
    #####: 1724:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 1725:      return typed.filterExpression.in();
        -: 1726:    }
        -: 1727:    ACE_UNUSED_ARG(typed);
    #####: 1728:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
        -: 1729:  }
        -: 1730:
    #####: 1731:  Value getValue(Serializer& ser, const char* field) const
        -: 1732:  {
    #####: 1733:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
    #####: 1734:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1735:    }
    #####: 1736:    if (std::strncmp(field, "readerId.", 9) == 0) {
    #####: 1737:      return getMetaStruct<OpenDDS::DCPS::RepoId>().getValue(ser, field + 9);
        -: 1738:    } else {
    #####: 1739:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) {
    #####: 1740:        throw std::runtime_error("Field 'readerId' could not be skipped");
        -: 1741:      }
        -: 1742:    }
    #####: 1743:    if (std::strncmp(field, "subQos.", 7) == 0) {
    #####: 1744:      return getMetaStruct<DDS::SubscriberQos>().getValue(ser, field + 7);
        -: 1745:    } else {
    #####: 1746:      if (!gen_skip_over(ser, static_cast<DDS::SubscriberQos*>(0))) {
    #####: 1747:        throw std::runtime_error("Field 'subQos' could not be skipped");
        -: 1748:      }
        -: 1749:    }
    #####: 1750:    if (std::strncmp(field, "readerQos.", 10) == 0) {
    #####: 1751:      return getMetaStruct<DDS::DataReaderQos>().getValue(ser, field + 10);
        -: 1752:    } else {
    #####: 1753:      if (!gen_skip_over(ser, static_cast<DDS::DataReaderQos*>(0))) {
    #####: 1754:        throw std::runtime_error("Field 'readerQos' could not be skipped");
        -: 1755:      }
        -: 1756:    }
    #####: 1757:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 1758:      TAO::String_Manager val;
    #####: 1759:      if (!(ser >> val.out())) {
    #####: 1760:        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
        -: 1761:      }
    #####: 1762:      return val;
        -: 1763:    } else {
        -: 1764:      ACE_CDR::ULong len;
    #####: 1765:      if (!(ser >> len)) {
    #####: 1766:        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
        -: 1767:      }
    #####: 1768:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 1769:        throw std::runtime_error("String 'filterClassName' contents could not be skipped");
        -: 1770:      }
        -: 1771:    }
    #####: 1772:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 1773:      TAO::String_Manager val;
    #####: 1774:      if (!(ser >> val.out())) {
    #####: 1775:        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
        -: 1776:      }
    #####: 1777:      return val;
        -: 1778:    } else {
        -: 1779:      ACE_CDR::ULong len;
    #####: 1780:      if (!(ser >> len)) {
    #####: 1781:        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
        -: 1782:      }
    #####: 1783:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 1784:        throw std::runtime_error("String 'filterExpression' contents could not be skipped");
        -: 1785:      }
        -: 1786:    }
    #####: 1787:    if (!gen_skip_over(ser, static_cast<DDS::StringSeq*>(0))) {
    #####: 1788:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 1789:    }
    #####: 1790:    if (!field[0]) {
    #####: 1791:      return 0;
        -: 1792:    }
    #####: 1793:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ReaderAssociation");
        -: 1794:  }
        -: 1795:
    #####: 1796:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 1797:  {
        -: 1798:    ACE_UNUSED_ARG(next);
    #####: 1799:    if (std::strncmp(field, "readerId.", 9) == 0) {
    #####: 1800:      return make_struct_cmp(&T::readerId, getMetaStruct<OpenDDS::DCPS::RepoId>().create_qc_comparator(field + 9), next);
        -: 1801:    }
    #####: 1802:    if (std::strncmp(field, "subQos.", 7) == 0) {
    #####: 1803:      return make_struct_cmp(&T::subQos, getMetaStruct<DDS::SubscriberQos>().create_qc_comparator(field + 7), next);
        -: 1804:    }
    #####: 1805:    if (std::strncmp(field, "readerQos.", 10) == 0) {
    #####: 1806:      return make_struct_cmp(&T::readerQos, getMetaStruct<DDS::DataReaderQos>().create_qc_comparator(field + 10), next);
        -: 1807:    }
    #####: 1808:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 1809:      return make_field_cmp(&T::filterClassName, next);
        -: 1810:    }
    #####: 1811:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 1812:      return make_field_cmp(&T::filterExpression, next);
        -: 1813:    }
    #####: 1814:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
        -: 1815:  }
        -: 1816:
        -: 1817:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 1818:  const char** getFieldNames() const
        -: 1819:  {
        -: 1820:    static const char* names[] = {"readerTransInfo", "readerId", "subQos", "readerQos", "filterClassName", "filterExpression", "exprParams", 0};
    #####: 1821:    return names;
        -: 1822:  }
        -: 1823:
    #####: 1824:  const void* getRawField(const void* stru, const char* field) const
        -: 1825:  {
    #####: 1826:    if (std::strcmp(field, "readerTransInfo") == 0) {
    #####: 1827:      return &static_cast<const T*>(stru)->readerTransInfo;
        -: 1828:    }
    #####: 1829:    if (std::strcmp(field, "readerId") == 0) {
    #####: 1830:      return &static_cast<const T*>(stru)->readerId;
        -: 1831:    }
    #####: 1832:    if (std::strcmp(field, "subQos") == 0) {
    #####: 1833:      return &static_cast<const T*>(stru)->subQos;
        -: 1834:    }
    #####: 1835:    if (std::strcmp(field, "readerQos") == 0) {
    #####: 1836:      return &static_cast<const T*>(stru)->readerQos;
        -: 1837:    }
    #####: 1838:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 1839:      return &static_cast<const T*>(stru)->filterClassName;
        -: 1840:    }
    #####: 1841:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 1842:      return &static_cast<const T*>(stru)->filterExpression;
        -: 1843:    }
    #####: 1844:    if (std::strcmp(field, "exprParams") == 0) {
    #####: 1845:      return &static_cast<const T*>(stru)->exprParams;
        -: 1846:    }
    #####: 1847:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
        -: 1848:  }
        -: 1849:
    #####: 1850:  void assign(void* lhs, const char* field, const void* rhs,
        -: 1851:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 1852:  {
        -: 1853:    ACE_UNUSED_ARG(lhs);
        -: 1854:    ACE_UNUSED_ARG(field);
        -: 1855:    ACE_UNUSED_ARG(rhs);
        -: 1856:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 1857:    ACE_UNUSED_ARG(rhsMeta);
    #####: 1858:    if (std::strcmp(field, "readerTransInfo") == 0) {
    #####: 1859:      static_cast<T*>(lhs)->readerTransInfo = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1860:      return;
        -: 1861:    }
    #####: 1862:    if (std::strcmp(field, "readerId") == 0) {
    #####: 1863:      static_cast<T*>(lhs)->readerId = *static_cast<const OpenDDS::DCPS::RepoId*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1864:      return;
        -: 1865:    }
    #####: 1866:    if (std::strcmp(field, "subQos") == 0) {
    #####: 1867:      static_cast<T*>(lhs)->subQos = *static_cast<const DDS::SubscriberQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1868:      return;
        -: 1869:    }
    #####: 1870:    if (std::strcmp(field, "readerQos") == 0) {
    #####: 1871:      static_cast<T*>(lhs)->readerQos = *static_cast<const DDS::DataReaderQos*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1872:      return;
        -: 1873:    }
    #####: 1874:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 1875:      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1876:      return;
        -: 1877:    }
    #####: 1878:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 1879:      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1880:      return;
        -: 1881:    }
    #####: 1882:    if (std::strcmp(field, "exprParams") == 0) {
    #####: 1883:      static_cast<T*>(lhs)->exprParams = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 1884:      return;
        -: 1885:    }
    #####: 1886:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
        -: 1887:  }
        -: 1888:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 1889:
    #####: 1890:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 1891:  {
        -: 1892:    ACE_UNUSED_ARG(lhs);
        -: 1893:    ACE_UNUSED_ARG(field);
        -: 1894:    ACE_UNUSED_ARG(rhs);
    #####: 1895:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 1896:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName.in(), static_cast<const T*>(rhs)->filterClassName.in());
        -: 1897:    }
    #####: 1898:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 1899:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression.in(), static_cast<const T*>(rhs)->filterExpression.in());
        -: 1900:    }
    #####: 1901:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderAssociation)");
        -: 1902:  }
        -: 1903:};
        -: 1904:
        -: 1905:template<>
    #####: 1906:const MetaStruct& getMetaStruct<OpenDDS::DCPS::ReaderAssociation>()
        -: 1907:{
    #####: 1908:  static MetaStructImpl<OpenDDS::DCPS::ReaderAssociation> msi;
    #####: 1909:  return msi;
        -: 1910:}
        -: 1911:
    #####: 1912:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderAssociation*)
        -: 1913:{
        -: 1914:  ACE_UNUSED_ARG(ser);
    #####: 1915:  MetaStructImpl<OpenDDS::DCPS::ReaderAssociation>().getValue(ser, "");
    #####: 1916:  return true;
        -: 1917:}
        -: 1918:
        -: 1919:}  }
        -: 1920:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1921:
        -: 1922:#endif
        -: 1923:
        -: 1924:/* End STRUCT: ReaderAssociation */
        -: 1925:
        -: 1926:
        -: 1927:/* Begin TYPEDEF: WriterIdSeq */
        -: 1928:
        -: 1929:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1930:namespace OpenDDS { namespace DCPS {
        -: 1931:
    #####: 1932:void gen_find_size(const OpenDDS::DCPS::WriterIdSeq& seq, size_t& size, size_t& padding)
        -: 1933:{
        -: 1934:  ACE_UNUSED_ARG(seq);
        -: 1935:  ACE_UNUSED_ARG(size);
        -: 1936:  ACE_UNUSED_ARG(padding);
    #####: 1937:  find_size_ulong(size, padding);
    #####: 1938:  if (seq.length() == 0) {
    #####: 1939:    return;
        -: 1940:  }
    #####: 1941:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 1942:    gen_find_size(seq[i], size, padding);
        -: 1943:  }
        -: 1944:}
        -: 1945:
    #####: 1946:bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterIdSeq& seq)
        -: 1947:{
        -: 1948:  ACE_UNUSED_ARG(strm);
        -: 1949:  ACE_UNUSED_ARG(seq);
    #####: 1950:  const CORBA::ULong length = seq.length();
    #####: 1951:  if (!(strm << length)) {
    #####: 1952:    return false;
        -: 1953:  }
    #####: 1954:  if (length == 0) {
    #####: 1955:    return true;
        -: 1956:  }
    #####: 1957:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 1958:    if (!(strm << seq[i])) {
    #####: 1959:      return false;
        -: 1960:    }
        -: 1961:  }
    #####: 1962:  return true;
        -: 1963:}
        -: 1964:
    #####: 1965:bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterIdSeq& seq)
        -: 1966:{
        -: 1967:  ACE_UNUSED_ARG(strm);
        -: 1968:  ACE_UNUSED_ARG(seq);
        -: 1969:  CORBA::ULong length;
    #####: 1970:  if (!(strm >> length)) {
    #####: 1971:    return false;
        -: 1972:  }
    #####: 1973:  seq.length(length);
    #####: 1974:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 1975:    if (!(strm >> seq[i])) {
    #####: 1976:      return false;
        -: 1977:    }
        -: 1978:  }
    #####: 1979:  return true;
        -: 1980:}
        -: 1981:
        -: 1982:}  }
        -: 1983:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 1984:
        -: 1985:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 1986:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 1987:namespace OpenDDS { namespace DCPS {
        -: 1988:
    #####: 1989:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterIdSeq*)
        -: 1990:{
        -: 1991:  ACE_UNUSED_ARG(ser);
        -: 1992:  ACE_CDR::ULong length;
    #####: 1993:  if (!(ser >> length)) return false;
    #####: 1994:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####: 1995:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) return false;
        -: 1996:  }
    #####: 1997:  return true;
        -: 1998:}
        -: 1999:
        -: 2000:}  }
        -: 2001:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2002:
        -: 2003:#endif
        -: 2004:
        -: 2005:/* End TYPEDEF: WriterIdSeq */
        -: 2006:
        -: 2007:
        -: 2008:/* Begin TYPEDEF: ReaderIdSeq */
        -: 2009:
        -: 2010:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2011:namespace OpenDDS { namespace DCPS {
        -: 2012:
    #####: 2013:void gen_find_size(const OpenDDS::DCPS::ReaderIdSeq& seq, size_t& size, size_t& padding)
        -: 2014:{
        -: 2015:  ACE_UNUSED_ARG(seq);
        -: 2016:  ACE_UNUSED_ARG(size);
        -: 2017:  ACE_UNUSED_ARG(padding);
    #####: 2018:  find_size_ulong(size, padding);
    #####: 2019:  if (seq.length() == 0) {
    #####: 2020:    return;
        -: 2021:  }
    #####: 2022:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 2023:    gen_find_size(seq[i], size, padding);
        -: 2024:  }
        -: 2025:}
        -: 2026:
    #####: 2027:bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderIdSeq& seq)
        -: 2028:{
        -: 2029:  ACE_UNUSED_ARG(strm);
        -: 2030:  ACE_UNUSED_ARG(seq);
    #####: 2031:  const CORBA::ULong length = seq.length();
    #####: 2032:  if (!(strm << length)) {
    #####: 2033:    return false;
        -: 2034:  }
    #####: 2035:  if (length == 0) {
    #####: 2036:    return true;
        -: 2037:  }
    #####: 2038:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 2039:    if (!(strm << seq[i])) {
    #####: 2040:      return false;
        -: 2041:    }
        -: 2042:  }
    #####: 2043:  return true;
        -: 2044:}
        -: 2045:
    #####: 2046:bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderIdSeq& seq)
        -: 2047:{
        -: 2048:  ACE_UNUSED_ARG(strm);
        -: 2049:  ACE_UNUSED_ARG(seq);
        -: 2050:  CORBA::ULong length;
    #####: 2051:  if (!(strm >> length)) {
    #####: 2052:    return false;
        -: 2053:  }
    #####: 2054:  seq.length(length);
    #####: 2055:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 2056:    if (!(strm >> seq[i])) {
    #####: 2057:      return false;
        -: 2058:    }
        -: 2059:  }
    #####: 2060:  return true;
        -: 2061:}
        -: 2062:
        -: 2063:}  }
        -: 2064:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2065:
        -: 2066:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2067:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2068:namespace OpenDDS { namespace DCPS {
        -: 2069:
    #####: 2070:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderIdSeq*)
        -: 2071:{
        -: 2072:  ACE_UNUSED_ARG(ser);
        -: 2073:  ACE_CDR::ULong length;
    #####: 2074:  if (!(ser >> length)) return false;
    #####: 2075:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####: 2076:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::RepoId*>(0))) return false;
        -: 2077:  }
    #####: 2078:  return true;
        -: 2079:}
        -: 2080:
        -: 2081:}  }
        -: 2082:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2083:
        -: 2084:#endif
        -: 2085:
        -: 2086:/* End TYPEDEF: ReaderIdSeq */
        -: 2087:
        -: 2088:
        -: 2089:/* Begin TYPEDEF: OctetArray16 */
        -: 2090:
        -: 2091:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2092:namespace OpenDDS { namespace DCPS {
        -: 2093:
    #####: 2094:void gen_find_size(const OpenDDS::DCPS::OctetArray16_forany& arr, size_t& size, size_t& padding)
        -: 2095:{
        -: 2096:  ACE_UNUSED_ARG(arr);
        -: 2097:  ACE_UNUSED_ARG(size);
        -: 2098:  ACE_UNUSED_ARG(padding);
    #####: 2099:  size += 16 * max_marshaled_size_octet();
    #####: 2100:}
        -: 2101:
    #####: 2102:bool operator<<(Serializer& strm, const OpenDDS::DCPS::OctetArray16_forany& arr)
        -: 2103:{
        -: 2104:  ACE_UNUSED_ARG(strm);
        -: 2105:  ACE_UNUSED_ARG(arr);
    #####: 2106:  return strm.write_octet_array(arr.in(), 16);
        -: 2107:}
        -: 2108:
    #####: 2109:bool operator>>(Serializer& strm, OpenDDS::DCPS::OctetArray16_forany& arr)
        -: 2110:{
        -: 2111:  ACE_UNUSED_ARG(strm);
        -: 2112:  ACE_UNUSED_ARG(arr);
    #####: 2113:  return strm.read_octet_array(arr.out(), 16);
        -: 2114:}
        -: 2115:
        -: 2116:}  }
        -: 2117:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2118:
        -: 2119:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2120:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2121:namespace OpenDDS { namespace DCPS {
        -: 2122:
    #####: 2123:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::OctetArray16_forany*)
        -: 2124:{
        -: 2125:  ACE_UNUSED_ARG(ser);
    #####: 2126:  return ser.skip(static_cast<ACE_UINT16>(16), 1);
        -: 2127:}
        -: 2128:
        -: 2129:}  }
        -: 2130:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2131:
        -: 2132:#endif
        -: 2133:
        -: 2134:/* End TYPEDEF: OctetArray16 */
        -: 2135:
        -: 2136:
        -: 2137:/* Begin STRUCT: Locator_t */
        -: 2138:
        -: 2139:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2140:namespace OpenDDS { namespace DCPS {
        -: 2141:
    #####: 2142:void gen_find_size(const OpenDDS::DCPS::Locator_t& stru, size_t& size, size_t& padding)
        -: 2143:{
        -: 2144:  ACE_UNUSED_ARG(stru);
        -: 2145:  ACE_UNUSED_ARG(size);
        -: 2146:  ACE_UNUSED_ARG(padding);
    #####: 2147:  OpenDDS::DCPS::OctetArray16_forany stru_address(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.address));
    #####: 2148:  if ((size + padding) % 4) {
    #####: 2149:    padding += 4 - ((size + padding) % 4);
        -: 2150:  }
    #####: 2151:  size += gen_max_marshaled_size(stru.kind);
    #####: 2152:  if ((size + padding) % 4) {
    #####: 2153:    padding += 4 - ((size + padding) % 4);
        -: 2154:  }
    #####: 2155:  size += gen_max_marshaled_size(stru.port);
    #####: 2156:  gen_find_size(stru_address, size, padding);
    #####: 2157:}
        -: 2158:
    #####: 2159:bool operator<<(Serializer& strm, const OpenDDS::DCPS::Locator_t& stru)
        -: 2160:{
        -: 2161:  ACE_UNUSED_ARG(strm);
        -: 2162:  ACE_UNUSED_ARG(stru);
    #####: 2163:  OpenDDS::DCPS::OctetArray16_forany stru_address(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.address));
    #####: 2164:  return (strm << stru.kind)
    #####: 2165:    && (strm << stru.port)
    #####: 2166:    && (strm << stru_address);
        -: 2167:}
        -: 2168:
    #####: 2169:bool operator>>(Serializer& strm, OpenDDS::DCPS::Locator_t& stru)
        -: 2170:{
        -: 2171:  ACE_UNUSED_ARG(strm);
        -: 2172:  ACE_UNUSED_ARG(stru);
    #####: 2173:  OpenDDS::DCPS::OctetArray16_forany stru_address(const_cast<OpenDDS::DCPS::OctetArray16_slice*>(stru.address));
    #####: 2174:  return (strm >> stru.kind)
    #####: 2175:    && (strm >> stru.port)
    #####: 2176:    && (strm >> stru_address);
        -: 2177:}
        -: 2178:
        -: 2179:}  }
        -: 2180:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2181:
        -: 2182:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2183:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2184:namespace OpenDDS { namespace DCPS {
        -: 2185:
        -: 2186:template<>
    #####: 2187:struct MetaStructImpl<OpenDDS::DCPS::Locator_t> : MetaStruct {
        -: 2188:  typedef OpenDDS::DCPS::Locator_t T;
        -: 2189:
        -: 2190:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2191:  void* allocate() const { return new T; }
        -: 2192:
    #####: 2193:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2194:
    #####: 2195:  size_t numDcpsKeys() const { return 0; }
        -: 2196:
        -: 2197:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2198:
    #####: 2199:  bool isDcpsKey(const char* field) const
        -: 2200:  {
        -: 2201:    ACE_UNUSED_ARG(field);
    #####: 2202:    return false;
        -: 2203:  }
        -: 2204:
    #####: 2205:  Value getValue(const void* stru, const char* field) const
        -: 2206:  {
    #####: 2207:    const OpenDDS::DCPS::Locator_t& typed = *static_cast<const OpenDDS::DCPS::Locator_t*>(stru);
    #####: 2208:    if (std::strcmp(field, "kind") == 0) {
    #####: 2209:      return typed.kind;
        -: 2210:    }
    #####: 2211:    if (std::strcmp(field, "port") == 0) {
    #####: 2212:      return typed.port;
        -: 2213:    }
        -: 2214:    ACE_UNUSED_ARG(typed);
    #####: 2215:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
        -: 2216:  }
        -: 2217:
    #####: 2218:  Value getValue(Serializer& ser, const char* field) const
        -: 2219:  {
    #####: 2220:    if (std::strcmp(field, "kind") == 0) {
        -: 2221:      ACE_CDR::Long val;
    #####: 2222:      if (!(ser >> val)) {
    #####: 2223:        throw std::runtime_error("Field 'kind' could not be deserialized");
        -: 2224:      }
    #####: 2225:      return val;
        -: 2226:    } else {
    #####: 2227:      if (!ser.skip(1, 4)) {
    #####: 2228:        throw std::runtime_error("Field 'kind' could not be skipped");
        -: 2229:      }
        -: 2230:    }
    #####: 2231:    if (std::strcmp(field, "port") == 0) {
        -: 2232:      ACE_CDR::ULong val;
    #####: 2233:      if (!(ser >> val)) {
    #####: 2234:        throw std::runtime_error("Field 'port' could not be deserialized");
        -: 2235:      }
    #####: 2236:      return val;
        -: 2237:    } else {
    #####: 2238:      if (!ser.skip(1, 4)) {
    #####: 2239:        throw std::runtime_error("Field 'port' could not be skipped");
        -: 2240:      }
        -: 2241:    }
    #####: 2242:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::OctetArray16_forany*>(0))) {
    #####: 2243:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2244:    }
    #####: 2245:    if (!field[0]) {
    #####: 2246:      return 0;
        -: 2247:    }
    #####: 2248:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::Locator_t");
        -: 2249:  }
        -: 2250:
    #####: 2251:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2252:  {
        -: 2253:    ACE_UNUSED_ARG(next);
    #####: 2254:    if (std::strcmp(field, "kind") == 0) {
    #####: 2255:      return make_field_cmp(&T::kind, next);
        -: 2256:    }
    #####: 2257:    if (std::strcmp(field, "port") == 0) {
    #####: 2258:      return make_field_cmp(&T::port, next);
        -: 2259:    }
    #####: 2260:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
        -: 2261:  }
        -: 2262:
        -: 2263:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2264:  const char** getFieldNames() const
        -: 2265:  {
        -: 2266:    static const char* names[] = {"kind", "port", "address", 0};
    #####: 2267:    return names;
        -: 2268:  }
        -: 2269:
    #####: 2270:  const void* getRawField(const void* stru, const char* field) const
        -: 2271:  {
    #####: 2272:    if (std::strcmp(field, "kind") == 0) {
    #####: 2273:      return &static_cast<const T*>(stru)->kind;
        -: 2274:    }
    #####: 2275:    if (std::strcmp(field, "port") == 0) {
    #####: 2276:      return &static_cast<const T*>(stru)->port;
        -: 2277:    }
    #####: 2278:    if (std::strcmp(field, "address") == 0) {
    #####: 2279:      return &static_cast<const T*>(stru)->address;
        -: 2280:    }
    #####: 2281:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
        -: 2282:  }
        -: 2283:
    #####: 2284:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2285:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2286:  {
        -: 2287:    ACE_UNUSED_ARG(lhs);
        -: 2288:    ACE_UNUSED_ARG(field);
        -: 2289:    ACE_UNUSED_ARG(rhs);
        -: 2290:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2291:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2292:    if (std::strcmp(field, "kind") == 0) {
    #####: 2293:      static_cast<T*>(lhs)->kind = *static_cast<const CORBA::Long*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2294:      return;
        -: 2295:    }
    #####: 2296:    if (std::strcmp(field, "port") == 0) {
    #####: 2297:      static_cast<T*>(lhs)->port = *static_cast<const CORBA::ULong*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2298:      return;
        -: 2299:    }
    #####: 2300:    if (std::strcmp(field, "address") == 0) {
    #####: 2301:      OpenDDS::DCPS::OctetArray16* lhsArr = &static_cast<T*>(lhs)->address;
    #####: 2302:      const OpenDDS::DCPS::OctetArray16* rhsArr = static_cast<const OpenDDS::DCPS::OctetArray16*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2303:      for (CORBA::ULong i0 = 0; i0 < 16; ++i0) {
    #####: 2304:        (*lhsArr)[i0] = (*rhsArr)[i0];
        -: 2305:      }
    #####: 2306:      return;
        -: 2307:    }
    #####: 2308:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
        -: 2309:  }
        -: 2310:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2311:
    #####: 2312:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2313:  {
        -: 2314:    ACE_UNUSED_ARG(lhs);
        -: 2315:    ACE_UNUSED_ARG(field);
        -: 2316:    ACE_UNUSED_ARG(rhs);
    #####: 2317:    if (std::strcmp(field, "kind") == 0) {
    #####: 2318:      return static_cast<const T*>(lhs)->kind == static_cast<const T*>(rhs)->kind;
        -: 2319:    }
    #####: 2320:    if (std::strcmp(field, "port") == 0) {
    #####: 2321:      return static_cast<const T*>(lhs)->port == static_cast<const T*>(rhs)->port;
        -: 2322:    }
    #####: 2323:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::Locator_t)");
        -: 2324:  }
        -: 2325:};
        -: 2326:
        -: 2327:template<>
    #####: 2328:const MetaStruct& getMetaStruct<OpenDDS::DCPS::Locator_t>()
        -: 2329:{
    #####: 2330:  static MetaStructImpl<OpenDDS::DCPS::Locator_t> msi;
    #####: 2331:  return msi;
        -: 2332:}
        -: 2333:
    #####: 2334:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::Locator_t*)
        -: 2335:{
        -: 2336:  ACE_UNUSED_ARG(ser);
    #####: 2337:  MetaStructImpl<OpenDDS::DCPS::Locator_t>().getValue(ser, "");
    #####: 2338:  return true;
        -: 2339:}
        -: 2340:
        -: 2341:}  }
        -: 2342:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2343:
        -: 2344:#endif
        -: 2345:
        -: 2346:/* End STRUCT: Locator_t */
        -: 2347:
        -: 2348:
        -: 2349:/* Begin TYPEDEF: LocatorSeq */
        -: 2350:
        -: 2351:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2352:namespace OpenDDS { namespace DCPS {
        -: 2353:
    #####: 2354:void gen_find_size(const OpenDDS::DCPS::LocatorSeq& seq, size_t& size, size_t& padding)
        -: 2355:{
        -: 2356:  ACE_UNUSED_ARG(seq);
        -: 2357:  ACE_UNUSED_ARG(size);
        -: 2358:  ACE_UNUSED_ARG(padding);
    #####: 2359:  find_size_ulong(size, padding);
    #####: 2360:  if (seq.length() == 0) {
    #####: 2361:    return;
        -: 2362:  }
    #####: 2363:  for (CORBA::ULong i = 0; i < seq.length(); ++i) {
    #####: 2364:    gen_find_size(seq[i], size, padding);
        -: 2365:  }
        -: 2366:}
        -: 2367:
    #####: 2368:bool operator<<(Serializer& strm, const OpenDDS::DCPS::LocatorSeq& seq)
        -: 2369:{
        -: 2370:  ACE_UNUSED_ARG(strm);
        -: 2371:  ACE_UNUSED_ARG(seq);
    #####: 2372:  const CORBA::ULong length = seq.length();
    #####: 2373:  if (!(strm << length)) {
    #####: 2374:    return false;
        -: 2375:  }
    #####: 2376:  if (length == 0) {
    #####: 2377:    return true;
        -: 2378:  }
    #####: 2379:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 2380:    if (!(strm << seq[i])) {
    #####: 2381:      return false;
        -: 2382:    }
        -: 2383:  }
    #####: 2384:  return true;
        -: 2385:}
        -: 2386:
    #####: 2387:bool operator>>(Serializer& strm, OpenDDS::DCPS::LocatorSeq& seq)
        -: 2388:{
        -: 2389:  ACE_UNUSED_ARG(strm);
        -: 2390:  ACE_UNUSED_ARG(seq);
        -: 2391:  CORBA::ULong length;
    #####: 2392:  if (!(strm >> length)) {
    #####: 2393:    return false;
        -: 2394:  }
    #####: 2395:  seq.length(length);
    #####: 2396:  for (CORBA::ULong i = 0; i < length; ++i) {
    #####: 2397:    if (!(strm >> seq[i])) {
    #####: 2398:      return false;
        -: 2399:    }
        -: 2400:  }
    #####: 2401:  return true;
        -: 2402:}
        -: 2403:
        -: 2404:}  }
        -: 2405:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2406:
        -: 2407:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2408:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2409:namespace OpenDDS { namespace DCPS {
        -: 2410:
    #####: 2411:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::LocatorSeq*)
        -: 2412:{
        -: 2413:  ACE_UNUSED_ARG(ser);
        -: 2414:  ACE_CDR::ULong length;
    #####: 2415:  if (!(ser >> length)) return false;
    #####: 2416:  for (ACE_CDR::ULong i = 0; i < length; ++i) {
    #####: 2417:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::Locator_t*>(0))) return false;
        -: 2418:  }
    #####: 2419:  return true;
        -: 2420:}
        -: 2421:
        -: 2422:}  }
        -: 2423:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2424:
        -: 2425:#endif
        -: 2426:
        -: 2427:/* End TYPEDEF: LocatorSeq */
        -: 2428:
        -: 2429:
        -: 2430:/* Begin TYPEDEF: String256 */
        -: 2431:
        -: 2432:
        -: 2433:/* End TYPEDEF: String256 */
        -: 2434:
        -: 2435:
        -: 2436:/* Begin STRUCT: ContentFilterProperty_t */
        -: 2437:
        -: 2438:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2439:namespace OpenDDS { namespace DCPS {
        -: 2440:
    #####: 2441:void gen_find_size(const OpenDDS::DCPS::ContentFilterProperty_t& stru, size_t& size, size_t& padding)
        -: 2442:{
        -: 2443:  ACE_UNUSED_ARG(stru);
        -: 2444:  ACE_UNUSED_ARG(size);
        -: 2445:  ACE_UNUSED_ARG(padding);
    #####: 2446:  find_size_ulong(size, padding);
    #####: 2447:  size += ACE_OS::strlen(stru.contentFilteredTopicName.in()) + 1;
    #####: 2448:  find_size_ulong(size, padding);
    #####: 2449:  size += ACE_OS::strlen(stru.relatedTopicName.in()) + 1;
    #####: 2450:  find_size_ulong(size, padding);
    #####: 2451:  size += ACE_OS::strlen(stru.filterClassName.in()) + 1;
    #####: 2452:  find_size_ulong(size, padding);
    #####: 2453:  size += ACE_OS::strlen(stru.filterExpression.in()) + 1;
    #####: 2454:  gen_find_size(stru.expressionParameters, size, padding);
    #####: 2455:}
        -: 2456:
    #####: 2457:bool operator<<(Serializer& strm, const OpenDDS::DCPS::ContentFilterProperty_t& stru)
        -: 2458:{
        -: 2459:  ACE_UNUSED_ARG(strm);
        -: 2460:  ACE_UNUSED_ARG(stru);
    #####: 2461:  return (strm << ACE_OutputCDR::from_string(stru.contentFilteredTopicName.in(), 256))
    #####: 2462:    && (strm << ACE_OutputCDR::from_string(stru.relatedTopicName.in(), 256))
    #####: 2463:    && (strm << ACE_OutputCDR::from_string(stru.filterClassName.in(), 256))
    #####: 2464:    && (strm << stru.filterExpression.in())
    #####: 2465:    && (strm << stru.expressionParameters);
        -: 2466:}
        -: 2467:
    #####: 2468:bool operator>>(Serializer& strm, OpenDDS::DCPS::ContentFilterProperty_t& stru)
        -: 2469:{
        -: 2470:  ACE_UNUSED_ARG(strm);
        -: 2471:  ACE_UNUSED_ARG(stru);
    #####: 2472:  return (strm >> ACE_InputCDR::to_string(stru.contentFilteredTopicName.out(), 256))
    #####: 2473:    && (strm >> ACE_InputCDR::to_string(stru.relatedTopicName.out(), 256))
    #####: 2474:    && (strm >> ACE_InputCDR::to_string(stru.filterClassName.out(), 256))
    #####: 2475:    && (strm >> stru.filterExpression.out())
    #####: 2476:    && (strm >> stru.expressionParameters);
        -: 2477:}
        -: 2478:
        -: 2479:}  }
        -: 2480:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2481:
        -: 2482:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2483:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2484:namespace OpenDDS { namespace DCPS {
        -: 2485:
        -: 2486:template<>
    #####: 2487:struct MetaStructImpl<OpenDDS::DCPS::ContentFilterProperty_t> : MetaStruct {
        -: 2488:  typedef OpenDDS::DCPS::ContentFilterProperty_t T;
        -: 2489:
        -: 2490:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2491:  void* allocate() const { return new T; }
        -: 2492:
    #####: 2493:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2494:
    #####: 2495:  size_t numDcpsKeys() const { return 0; }
        -: 2496:
        -: 2497:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2498:
    #####: 2499:  bool isDcpsKey(const char* field) const
        -: 2500:  {
        -: 2501:    ACE_UNUSED_ARG(field);
    #####: 2502:    return false;
        -: 2503:  }
        -: 2504:
    #####: 2505:  Value getValue(const void* stru, const char* field) const
        -: 2506:  {
    #####: 2507:    const OpenDDS::DCPS::ContentFilterProperty_t& typed = *static_cast<const OpenDDS::DCPS::ContentFilterProperty_t*>(stru);
    #####: 2508:    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
    #####: 2509:      return typed.contentFilteredTopicName.in();
        -: 2510:    }
    #####: 2511:    if (std::strcmp(field, "relatedTopicName") == 0) {
    #####: 2512:      return typed.relatedTopicName.in();
        -: 2513:    }
    #####: 2514:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 2515:      return typed.filterClassName.in();
        -: 2516:    }
    #####: 2517:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 2518:      return typed.filterExpression.in();
        -: 2519:    }
        -: 2520:    ACE_UNUSED_ARG(typed);
    #####: 2521:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
        -: 2522:  }
        -: 2523:
    #####: 2524:  Value getValue(Serializer& ser, const char* field) const
        -: 2525:  {
    #####: 2526:    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
    #####: 2527:      TAO::String_Manager val;
    #####: 2528:      if (!(ser >> val.out())) {
    #####: 2529:        throw std::runtime_error("Field 'contentFilteredTopicName' could not be deserialized");
        -: 2530:      }
    #####: 2531:      return val;
        -: 2532:    } else {
        -: 2533:      ACE_CDR::ULong len;
    #####: 2534:      if (!(ser >> len)) {
    #####: 2535:        throw std::runtime_error("String 'contentFilteredTopicName' length could not be deserialized");
        -: 2536:      }
    #####: 2537:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 2538:        throw std::runtime_error("String 'contentFilteredTopicName' contents could not be skipped");
        -: 2539:      }
        -: 2540:    }
    #####: 2541:    if (std::strcmp(field, "relatedTopicName") == 0) {
    #####: 2542:      TAO::String_Manager val;
    #####: 2543:      if (!(ser >> val.out())) {
    #####: 2544:        throw std::runtime_error("Field 'relatedTopicName' could not be deserialized");
        -: 2545:      }
    #####: 2546:      return val;
        -: 2547:    } else {
        -: 2548:      ACE_CDR::ULong len;
    #####: 2549:      if (!(ser >> len)) {
    #####: 2550:        throw std::runtime_error("String 'relatedTopicName' length could not be deserialized");
        -: 2551:      }
    #####: 2552:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 2553:        throw std::runtime_error("String 'relatedTopicName' contents could not be skipped");
        -: 2554:      }
        -: 2555:    }
    #####: 2556:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 2557:      TAO::String_Manager val;
    #####: 2558:      if (!(ser >> val.out())) {
    #####: 2559:        throw std::runtime_error("Field 'filterClassName' could not be deserialized");
        -: 2560:      }
    #####: 2561:      return val;
        -: 2562:    } else {
        -: 2563:      ACE_CDR::ULong len;
    #####: 2564:      if (!(ser >> len)) {
    #####: 2565:        throw std::runtime_error("String 'filterClassName' length could not be deserialized");
        -: 2566:      }
    #####: 2567:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 2568:        throw std::runtime_error("String 'filterClassName' contents could not be skipped");
        -: 2569:      }
        -: 2570:    }
    #####: 2571:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 2572:      TAO::String_Manager val;
    #####: 2573:      if (!(ser >> val.out())) {
    #####: 2574:        throw std::runtime_error("Field 'filterExpression' could not be deserialized");
        -: 2575:      }
    #####: 2576:      return val;
        -: 2577:    } else {
        -: 2578:      ACE_CDR::ULong len;
    #####: 2579:      if (!(ser >> len)) {
    #####: 2580:        throw std::runtime_error("String 'filterExpression' length could not be deserialized");
        -: 2581:      }
    #####: 2582:      if (!ser.skip(static_cast<ACE_UINT16>(len))) {
    #####: 2583:        throw std::runtime_error("String 'filterExpression' contents could not be skipped");
        -: 2584:      }
        -: 2585:    }
    #####: 2586:    if (!gen_skip_over(ser, static_cast<DDS::StringSeq*>(0))) {
    #####: 2587:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2588:    }
    #####: 2589:    if (!field[0]) {
    #####: 2590:      return 0;
        -: 2591:    }
    #####: 2592:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ContentFilterProperty_t");
        -: 2593:  }
        -: 2594:
    #####: 2595:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2596:  {
        -: 2597:    ACE_UNUSED_ARG(next);
    #####: 2598:    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
    #####: 2599:      return make_field_cmp(&T::contentFilteredTopicName, next);
        -: 2600:    }
    #####: 2601:    if (std::strcmp(field, "relatedTopicName") == 0) {
    #####: 2602:      return make_field_cmp(&T::relatedTopicName, next);
        -: 2603:    }
    #####: 2604:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 2605:      return make_field_cmp(&T::filterClassName, next);
        -: 2606:    }
    #####: 2607:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 2608:      return make_field_cmp(&T::filterExpression, next);
        -: 2609:    }
    #####: 2610:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
        -: 2611:  }
        -: 2612:
        -: 2613:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2614:  const char** getFieldNames() const
        -: 2615:  {
        -: 2616:    static const char* names[] = {"contentFilteredTopicName", "relatedTopicName", "filterClassName", "filterExpression", "expressionParameters", 0};
    #####: 2617:    return names;
        -: 2618:  }
        -: 2619:
    #####: 2620:  const void* getRawField(const void* stru, const char* field) const
        -: 2621:  {
    #####: 2622:    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
    #####: 2623:      return &static_cast<const T*>(stru)->contentFilteredTopicName;
        -: 2624:    }
    #####: 2625:    if (std::strcmp(field, "relatedTopicName") == 0) {
    #####: 2626:      return &static_cast<const T*>(stru)->relatedTopicName;
        -: 2627:    }
    #####: 2628:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 2629:      return &static_cast<const T*>(stru)->filterClassName;
        -: 2630:    }
    #####: 2631:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 2632:      return &static_cast<const T*>(stru)->filterExpression;
        -: 2633:    }
    #####: 2634:    if (std::strcmp(field, "expressionParameters") == 0) {
    #####: 2635:      return &static_cast<const T*>(stru)->expressionParameters;
        -: 2636:    }
    #####: 2637:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
        -: 2638:  }
        -: 2639:
    #####: 2640:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2641:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2642:  {
        -: 2643:    ACE_UNUSED_ARG(lhs);
        -: 2644:    ACE_UNUSED_ARG(field);
        -: 2645:    ACE_UNUSED_ARG(rhs);
        -: 2646:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2647:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2648:    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
    #####: 2649:      static_cast<T*>(lhs)->contentFilteredTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2650:      return;
        -: 2651:    }
    #####: 2652:    if (std::strcmp(field, "relatedTopicName") == 0) {
    #####: 2653:      static_cast<T*>(lhs)->relatedTopicName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2654:      return;
        -: 2655:    }
    #####: 2656:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 2657:      static_cast<T*>(lhs)->filterClassName = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2658:      return;
        -: 2659:    }
    #####: 2660:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 2661:      static_cast<T*>(lhs)->filterExpression = *static_cast<const TAO::String_Manager*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2662:      return;
        -: 2663:    }
    #####: 2664:    if (std::strcmp(field, "expressionParameters") == 0) {
    #####: 2665:      static_cast<T*>(lhs)->expressionParameters = *static_cast<const DDS::StringSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2666:      return;
        -: 2667:    }
    #####: 2668:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
        -: 2669:  }
        -: 2670:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2671:
    #####: 2672:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2673:  {
        -: 2674:    ACE_UNUSED_ARG(lhs);
        -: 2675:    ACE_UNUSED_ARG(field);
        -: 2676:    ACE_UNUSED_ARG(rhs);
    #####: 2677:    if (std::strcmp(field, "contentFilteredTopicName") == 0) {
    #####: 2678:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->contentFilteredTopicName.in(), static_cast<const T*>(rhs)->contentFilteredTopicName.in());
        -: 2679:    }
    #####: 2680:    if (std::strcmp(field, "relatedTopicName") == 0) {
    #####: 2681:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->relatedTopicName.in(), static_cast<const T*>(rhs)->relatedTopicName.in());
        -: 2682:    }
    #####: 2683:    if (std::strcmp(field, "filterClassName") == 0) {
    #####: 2684:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterClassName.in(), static_cast<const T*>(rhs)->filterClassName.in());
        -: 2685:    }
    #####: 2686:    if (std::strcmp(field, "filterExpression") == 0) {
    #####: 2687:      return 0 == ACE_OS::strcmp(static_cast<const T*>(lhs)->filterExpression.in(), static_cast<const T*>(rhs)->filterExpression.in());
        -: 2688:    }
    #####: 2689:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ContentFilterProperty_t)");
        -: 2690:  }
        -: 2691:};
        -: 2692:
        -: 2693:template<>
    #####: 2694:const MetaStruct& getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>()
        -: 2695:{
    #####: 2696:  static MetaStructImpl<OpenDDS::DCPS::ContentFilterProperty_t> msi;
    #####: 2697:  return msi;
        -: 2698:}
        -: 2699:
    #####: 2700:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ContentFilterProperty_t*)
        -: 2701:{
        -: 2702:  ACE_UNUSED_ARG(ser);
    #####: 2703:  MetaStructImpl<OpenDDS::DCPS::ContentFilterProperty_t>().getValue(ser, "");
    #####: 2704:  return true;
        -: 2705:}
        -: 2706:
        -: 2707:}  }
        -: 2708:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2709:
        -: 2710:#endif
        -: 2711:
        -: 2712:/* End STRUCT: ContentFilterProperty_t */
        -: 2713:
        -: 2714:
        -: 2715:/* Begin STRUCT: ReaderProxy_t */
        -: 2716:
        -: 2717:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2718:namespace OpenDDS { namespace DCPS {
        -: 2719:
    #####: 2720:void gen_find_size(const OpenDDS::DCPS::ReaderProxy_t& stru, size_t& size, size_t& padding)
        -: 2721:{
        -: 2722:  ACE_UNUSED_ARG(stru);
        -: 2723:  ACE_UNUSED_ARG(size);
        -: 2724:  ACE_UNUSED_ARG(padding);
    #####: 2725:  gen_find_size(stru.remoteReaderGuid, size, padding);
    #####: 2726:  size += gen_max_marshaled_size(ACE_OutputCDR::from_boolean(stru.expectsInlineQos));
    #####: 2727:  gen_find_size(stru.unicastLocatorList, size, padding);
    #####: 2728:  gen_find_size(stru.multicastLocatorList, size, padding);
    #####: 2729:  gen_find_size(stru.allLocators, size, padding);
    #####: 2730:  gen_find_size(stru.associatedWriters, size, padding);
    #####: 2731:}
        -: 2732:
    #####: 2733:bool operator<<(Serializer& strm, const OpenDDS::DCPS::ReaderProxy_t& stru)
        -: 2734:{
        -: 2735:  ACE_UNUSED_ARG(strm);
        -: 2736:  ACE_UNUSED_ARG(stru);
    #####: 2737:  return (strm << stru.remoteReaderGuid)
    #####: 2738:    && (strm << ACE_OutputCDR::from_boolean(stru.expectsInlineQos))
    #####: 2739:    && (strm << stru.unicastLocatorList)
    #####: 2740:    && (strm << stru.multicastLocatorList)
    #####: 2741:    && (strm << stru.allLocators)
    #####: 2742:    && (strm << stru.associatedWriters);
        -: 2743:}
        -: 2744:
    #####: 2745:bool operator>>(Serializer& strm, OpenDDS::DCPS::ReaderProxy_t& stru)
        -: 2746:{
        -: 2747:  ACE_UNUSED_ARG(strm);
        -: 2748:  ACE_UNUSED_ARG(stru);
    #####: 2749:  return (strm >> stru.remoteReaderGuid)
    #####: 2750:    && (strm >> ACE_InputCDR::to_boolean(stru.expectsInlineQos))
    #####: 2751:    && (strm >> stru.unicastLocatorList)
    #####: 2752:    && (strm >> stru.multicastLocatorList)
    #####: 2753:    && (strm >> stru.allLocators)
    #####: 2754:    && (strm >> stru.associatedWriters);
        -: 2755:}
        -: 2756:
        -: 2757:}  }
        -: 2758:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2759:
        -: 2760:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2761:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2762:namespace OpenDDS { namespace DCPS {
        -: 2763:
        -: 2764:template<>
    #####: 2765:struct MetaStructImpl<OpenDDS::DCPS::ReaderProxy_t> : MetaStruct {
        -: 2766:  typedef OpenDDS::DCPS::ReaderProxy_t T;
        -: 2767:
        -: 2768:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2769:  void* allocate() const { return new T; }
        -: 2770:
    #####: 2771:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2772:
    #####: 2773:  size_t numDcpsKeys() const { return 0; }
        -: 2774:
        -: 2775:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2776:
    #####: 2777:  bool isDcpsKey(const char* field) const
        -: 2778:  {
        -: 2779:    ACE_UNUSED_ARG(field);
    #####: 2780:    return false;
        -: 2781:  }
        -: 2782:
    #####: 2783:  Value getValue(const void* stru, const char* field) const
        -: 2784:  {
    #####: 2785:    const OpenDDS::DCPS::ReaderProxy_t& typed = *static_cast<const OpenDDS::DCPS::ReaderProxy_t*>(stru);
    #####: 2786:    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
    #####: 2787:      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.remoteReaderGuid, field + 17);
        -: 2788:    }
    #####: 2789:    if (std::strcmp(field, "expectsInlineQos") == 0) {
    #####: 2790:      return typed.expectsInlineQos;
        -: 2791:    }
        -: 2792:    ACE_UNUSED_ARG(typed);
    #####: 2793:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
        -: 2794:  }
        -: 2795:
    #####: 2796:  Value getValue(Serializer& ser, const char* field) const
        -: 2797:  {
    #####: 2798:    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
    #####: 2799:      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 17);
        -: 2800:    } else {
    #####: 2801:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) {
    #####: 2802:        throw std::runtime_error("Field 'remoteReaderGuid' could not be skipped");
        -: 2803:      }
        -: 2804:    }
    #####: 2805:    if (std::strcmp(field, "expectsInlineQos") == 0) {
        -: 2806:      ACE_CDR::Boolean val;
    #####: 2807:      if (!(ser >> ACE_InputCDR::to_boolean(val))) {
    #####: 2808:        throw std::runtime_error("Field 'expectsInlineQos' could not be deserialized");
        -: 2809:      }
    #####: 2810:      return val;
        -: 2811:    } else {
    #####: 2812:      if (!ser.skip(1, 1)) {
    #####: 2813:        throw std::runtime_error("Field 'expectsInlineQos' could not be skipped");
        -: 2814:      }
        -: 2815:    }
    #####: 2816:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
    #####: 2817:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2818:    }
    #####: 2819:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
    #####: 2820:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2821:    }
    #####: 2822:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
    #####: 2823:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2824:    }
    #####: 2825:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUIDSeq*>(0))) {
    #####: 2826:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 2827:    }
    #####: 2828:    if (!field[0]) {
    #####: 2829:      return 0;
        -: 2830:    }
    #####: 2831:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::ReaderProxy_t");
        -: 2832:  }
        -: 2833:
    #####: 2834:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 2835:  {
        -: 2836:    ACE_UNUSED_ARG(next);
    #####: 2837:    if (std::strncmp(field, "remoteReaderGuid.", 17) == 0) {
    #####: 2838:      return make_struct_cmp(&T::remoteReaderGuid, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 17), next);
        -: 2839:    }
    #####: 2840:    if (std::strcmp(field, "expectsInlineQos") == 0) {
    #####: 2841:      return make_field_cmp(&T::expectsInlineQos, next);
        -: 2842:    }
    #####: 2843:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
        -: 2844:  }
        -: 2845:
        -: 2846:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2847:  const char** getFieldNames() const
        -: 2848:  {
        -: 2849:    static const char* names[] = {"remoteReaderGuid", "expectsInlineQos", "unicastLocatorList", "multicastLocatorList", "allLocators", "associatedWriters", 0};
    #####: 2850:    return names;
        -: 2851:  }
        -: 2852:
    #####: 2853:  const void* getRawField(const void* stru, const char* field) const
        -: 2854:  {
    #####: 2855:    if (std::strcmp(field, "remoteReaderGuid") == 0) {
    #####: 2856:      return &static_cast<const T*>(stru)->remoteReaderGuid;
        -: 2857:    }
    #####: 2858:    if (std::strcmp(field, "expectsInlineQos") == 0) {
    #####: 2859:      return &static_cast<const T*>(stru)->expectsInlineQos;
        -: 2860:    }
    #####: 2861:    if (std::strcmp(field, "unicastLocatorList") == 0) {
    #####: 2862:      return &static_cast<const T*>(stru)->unicastLocatorList;
        -: 2863:    }
    #####: 2864:    if (std::strcmp(field, "multicastLocatorList") == 0) {
    #####: 2865:      return &static_cast<const T*>(stru)->multicastLocatorList;
        -: 2866:    }
    #####: 2867:    if (std::strcmp(field, "allLocators") == 0) {
    #####: 2868:      return &static_cast<const T*>(stru)->allLocators;
        -: 2869:    }
    #####: 2870:    if (std::strcmp(field, "associatedWriters") == 0) {
    #####: 2871:      return &static_cast<const T*>(stru)->associatedWriters;
        -: 2872:    }
    #####: 2873:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
        -: 2874:  }
        -: 2875:
    #####: 2876:  void assign(void* lhs, const char* field, const void* rhs,
        -: 2877:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 2878:  {
        -: 2879:    ACE_UNUSED_ARG(lhs);
        -: 2880:    ACE_UNUSED_ARG(field);
        -: 2881:    ACE_UNUSED_ARG(rhs);
        -: 2882:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 2883:    ACE_UNUSED_ARG(rhsMeta);
    #####: 2884:    if (std::strcmp(field, "remoteReaderGuid") == 0) {
    #####: 2885:      static_cast<T*>(lhs)->remoteReaderGuid = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2886:      return;
        -: 2887:    }
    #####: 2888:    if (std::strcmp(field, "expectsInlineQos") == 0) {
    #####: 2889:      static_cast<T*>(lhs)->expectsInlineQos = *static_cast<const CORBA::Boolean*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2890:      return;
        -: 2891:    }
    #####: 2892:    if (std::strcmp(field, "unicastLocatorList") == 0) {
    #####: 2893:      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2894:      return;
        -: 2895:    }
    #####: 2896:    if (std::strcmp(field, "multicastLocatorList") == 0) {
    #####: 2897:      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2898:      return;
        -: 2899:    }
    #####: 2900:    if (std::strcmp(field, "allLocators") == 0) {
    #####: 2901:      static_cast<T*>(lhs)->allLocators = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2902:      return;
        -: 2903:    }
    #####: 2904:    if (std::strcmp(field, "associatedWriters") == 0) {
    #####: 2905:      static_cast<T*>(lhs)->associatedWriters = *static_cast<const OpenDDS::DCPS::GUIDSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 2906:      return;
        -: 2907:    }
    #####: 2908:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
        -: 2909:  }
        -: 2910:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2911:
    #####: 2912:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 2913:  {
        -: 2914:    ACE_UNUSED_ARG(lhs);
        -: 2915:    ACE_UNUSED_ARG(field);
        -: 2916:    ACE_UNUSED_ARG(rhs);
    #####: 2917:    if (std::strcmp(field, "expectsInlineQos") == 0) {
    #####: 2918:      return static_cast<const T*>(lhs)->expectsInlineQos == static_cast<const T*>(rhs)->expectsInlineQos;
        -: 2919:    }
    #####: 2920:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::ReaderProxy_t)");
        -: 2921:  }
        -: 2922:};
        -: 2923:
        -: 2924:template<>
    #####: 2925:const MetaStruct& getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>()
        -: 2926:{
    #####: 2927:  static MetaStructImpl<OpenDDS::DCPS::ReaderProxy_t> msi;
    #####: 2928:  return msi;
        -: 2929:}
        -: 2930:
    #####: 2931:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::ReaderProxy_t*)
        -: 2932:{
        -: 2933:  ACE_UNUSED_ARG(ser);
    #####: 2934:  MetaStructImpl<OpenDDS::DCPS::ReaderProxy_t>().getValue(ser, "");
    #####: 2935:  return true;
        -: 2936:}
        -: 2937:
        -: 2938:}  }
        -: 2939:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2940:
        -: 2941:#endif
        -: 2942:
        -: 2943:/* End STRUCT: ReaderProxy_t */
        -: 2944:
        -: 2945:
        -: 2946:/* Begin STRUCT: DiscoveredReaderData */
        -: 2947:
        -: 2948:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2949:namespace OpenDDS { namespace DCPS {
        -: 2950:
    #####: 2951:void gen_find_size(const OpenDDS::DCPS::DiscoveredReaderData& stru, size_t& size, size_t& padding)
        -: 2952:{
        -: 2953:  ACE_UNUSED_ARG(stru);
        -: 2954:  ACE_UNUSED_ARG(size);
        -: 2955:  ACE_UNUSED_ARG(padding);
    #####: 2956:  gen_find_size(stru.ddsSubscriptionData, size, padding);
    #####: 2957:  gen_find_size(stru.readerProxy, size, padding);
    #####: 2958:  gen_find_size(stru.contentFilterProperty, size, padding);
    #####: 2959:}
        -: 2960:
    #####: 2961:bool operator<<(Serializer& strm, const OpenDDS::DCPS::DiscoveredReaderData& stru)
        -: 2962:{
        -: 2963:  ACE_UNUSED_ARG(strm);
        -: 2964:  ACE_UNUSED_ARG(stru);
    #####: 2965:  return (strm << stru.ddsSubscriptionData)
    #####: 2966:    && (strm << stru.readerProxy)
    #####: 2967:    && (strm << stru.contentFilterProperty);
        -: 2968:}
        -: 2969:
    #####: 2970:bool operator>>(Serializer& strm, OpenDDS::DCPS::DiscoveredReaderData& stru)
        -: 2971:{
        -: 2972:  ACE_UNUSED_ARG(strm);
        -: 2973:  ACE_UNUSED_ARG(stru);
    #####: 2974:  return (strm >> stru.ddsSubscriptionData)
    #####: 2975:    && (strm >> stru.readerProxy)
    #####: 2976:    && (strm >> stru.contentFilterProperty);
        -: 2977:}
        -: 2978:
        -: 2979:}  }
        -: 2980:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 2981:
        -: 2982:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 2983:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 2984:namespace OpenDDS { namespace DCPS {
        -: 2985:
        -: 2986:template<>
    #####: 2987:struct MetaStructImpl<OpenDDS::DCPS::DiscoveredReaderData> : MetaStruct {
        -: 2988:  typedef OpenDDS::DCPS::DiscoveredReaderData T;
        -: 2989:
        -: 2990:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 2991:  void* allocate() const { return new T; }
        -: 2992:
    #####: 2993:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 2994:
    #####: 2995:  size_t numDcpsKeys() const { return 0; }
        -: 2996:
        -: 2997:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 2998:
    #####: 2999:  bool isDcpsKey(const char* field) const
        -: 3000:  {
        -: 3001:    ACE_UNUSED_ARG(field);
    #####: 3002:    return false;
        -: 3003:  }
        -: 3004:
    #####: 3005:  Value getValue(const void* stru, const char* field) const
        -: 3006:  {
    #####: 3007:    const OpenDDS::DCPS::DiscoveredReaderData& typed = *static_cast<const OpenDDS::DCPS::DiscoveredReaderData*>(stru);
    #####: 3008:    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
    #####: 3009:      return getMetaStruct<DDS::SubscriptionBuiltinTopicData>().getValue(&typed.ddsSubscriptionData, field + 20);
        -: 3010:    }
    #####: 3011:    if (std::strncmp(field, "readerProxy.", 12) == 0) {
    #####: 3012:      return getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>().getValue(&typed.readerProxy, field + 12);
        -: 3013:    }
    #####: 3014:    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
    #####: 3015:      return getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>().getValue(&typed.contentFilterProperty, field + 22);
        -: 3016:    }
        -: 3017:    ACE_UNUSED_ARG(typed);
    #####: 3018:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
        -: 3019:  }
        -: 3020:
    #####: 3021:  Value getValue(Serializer& ser, const char* field) const
        -: 3022:  {
    #####: 3023:    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
    #####: 3024:      return getMetaStruct<DDS::SubscriptionBuiltinTopicData>().getValue(ser, field + 20);
        -: 3025:    } else {
    #####: 3026:      if (!gen_skip_over(ser, static_cast<DDS::SubscriptionBuiltinTopicData*>(0))) {
    #####: 3027:        throw std::runtime_error("Field 'ddsSubscriptionData' could not be skipped");
        -: 3028:      }
        -: 3029:    }
    #####: 3030:    if (std::strncmp(field, "readerProxy.", 12) == 0) {
    #####: 3031:      return getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>().getValue(ser, field + 12);
        -: 3032:    } else {
    #####: 3033:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::ReaderProxy_t*>(0))) {
    #####: 3034:        throw std::runtime_error("Field 'readerProxy' could not be skipped");
        -: 3035:      }
        -: 3036:    }
    #####: 3037:    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
    #####: 3038:      return getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>().getValue(ser, field + 22);
        -: 3039:    } else {
    #####: 3040:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::ContentFilterProperty_t*>(0))) {
    #####: 3041:        throw std::runtime_error("Field 'contentFilterProperty' could not be skipped");
        -: 3042:      }
        -: 3043:    }
    #####: 3044:    if (!field[0]) {
    #####: 3045:      return 0;
        -: 3046:    }
    #####: 3047:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DiscoveredReaderData");
        -: 3048:  }
        -: 3049:
    #####: 3050:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3051:  {
        -: 3052:    ACE_UNUSED_ARG(next);
    #####: 3053:    if (std::strncmp(field, "ddsSubscriptionData.", 20) == 0) {
    #####: 3054:      return make_struct_cmp(&T::ddsSubscriptionData, getMetaStruct<DDS::SubscriptionBuiltinTopicData>().create_qc_comparator(field + 20), next);
        -: 3055:    }
    #####: 3056:    if (std::strncmp(field, "readerProxy.", 12) == 0) {
    #####: 3057:      return make_struct_cmp(&T::readerProxy, getMetaStruct<OpenDDS::DCPS::ReaderProxy_t>().create_qc_comparator(field + 12), next);
        -: 3058:    }
    #####: 3059:    if (std::strncmp(field, "contentFilterProperty.", 22) == 0) {
    #####: 3060:      return make_struct_cmp(&T::contentFilterProperty, getMetaStruct<OpenDDS::DCPS::ContentFilterProperty_t>().create_qc_comparator(field + 22), next);
        -: 3061:    }
    #####: 3062:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
        -: 3063:  }
        -: 3064:
        -: 3065:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3066:  const char** getFieldNames() const
        -: 3067:  {
        -: 3068:    static const char* names[] = {"ddsSubscriptionData", "readerProxy", "contentFilterProperty", 0};
    #####: 3069:    return names;
        -: 3070:  }
        -: 3071:
    #####: 3072:  const void* getRawField(const void* stru, const char* field) const
        -: 3073:  {
    #####: 3074:    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
    #####: 3075:      return &static_cast<const T*>(stru)->ddsSubscriptionData;
        -: 3076:    }
    #####: 3077:    if (std::strcmp(field, "readerProxy") == 0) {
    #####: 3078:      return &static_cast<const T*>(stru)->readerProxy;
        -: 3079:    }
    #####: 3080:    if (std::strcmp(field, "contentFilterProperty") == 0) {
    #####: 3081:      return &static_cast<const T*>(stru)->contentFilterProperty;
        -: 3082:    }
    #####: 3083:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
        -: 3084:  }
        -: 3085:
    #####: 3086:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3087:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3088:  {
        -: 3089:    ACE_UNUSED_ARG(lhs);
        -: 3090:    ACE_UNUSED_ARG(field);
        -: 3091:    ACE_UNUSED_ARG(rhs);
        -: 3092:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3093:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3094:    if (std::strcmp(field, "ddsSubscriptionData") == 0) {
    #####: 3095:      static_cast<T*>(lhs)->ddsSubscriptionData = *static_cast<const DDS::SubscriptionBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3096:      return;
        -: 3097:    }
    #####: 3098:    if (std::strcmp(field, "readerProxy") == 0) {
    #####: 3099:      static_cast<T*>(lhs)->readerProxy = *static_cast<const OpenDDS::DCPS::ReaderProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3100:      return;
        -: 3101:    }
    #####: 3102:    if (std::strcmp(field, "contentFilterProperty") == 0) {
    #####: 3103:      static_cast<T*>(lhs)->contentFilterProperty = *static_cast<const OpenDDS::DCPS::ContentFilterProperty_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3104:      return;
        -: 3105:    }
    #####: 3106:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
        -: 3107:  }
        -: 3108:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3109:
    #####: 3110:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3111:  {
        -: 3112:    ACE_UNUSED_ARG(lhs);
        -: 3113:    ACE_UNUSED_ARG(field);
        -: 3114:    ACE_UNUSED_ARG(rhs);
    #####: 3115:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredReaderData)");
        -: 3116:  }
        -: 3117:};
        -: 3118:
        -: 3119:template<>
    #####: 3120:const MetaStruct& getMetaStruct<OpenDDS::DCPS::DiscoveredReaderData>()
        -: 3121:{
    #####: 3122:  static MetaStructImpl<OpenDDS::DCPS::DiscoveredReaderData> msi;
    #####: 3123:  return msi;
        -: 3124:}
        -: 3125:
    #####: 3126:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DiscoveredReaderData*)
        -: 3127:{
        -: 3128:  ACE_UNUSED_ARG(ser);
    #####: 3129:  MetaStructImpl<OpenDDS::DCPS::DiscoveredReaderData>().getValue(ser, "");
    #####: 3130:  return true;
        -: 3131:}
        -: 3132:
        -: 3133:}  }
        -: 3134:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3135:
        -: 3136:#endif
        -: 3137:
        -: 3138:/* End STRUCT: DiscoveredReaderData */
        -: 3139:
        -: 3140:
        -: 3141:/* Begin STRUCT: WriterProxy_t */
        -: 3142:
        -: 3143:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3144:namespace OpenDDS { namespace DCPS {
        -: 3145:
    #####: 3146:void gen_find_size(const OpenDDS::DCPS::WriterProxy_t& stru, size_t& size, size_t& padding)
        -: 3147:{
        -: 3148:  ACE_UNUSED_ARG(stru);
        -: 3149:  ACE_UNUSED_ARG(size);
        -: 3150:  ACE_UNUSED_ARG(padding);
    #####: 3151:  gen_find_size(stru.remoteWriterGuid, size, padding);
    #####: 3152:  gen_find_size(stru.unicastLocatorList, size, padding);
    #####: 3153:  gen_find_size(stru.multicastLocatorList, size, padding);
    #####: 3154:  gen_find_size(stru.allLocators, size, padding);
    #####: 3155:}
        -: 3156:
    #####: 3157:bool operator<<(Serializer& strm, const OpenDDS::DCPS::WriterProxy_t& stru)
        -: 3158:{
        -: 3159:  ACE_UNUSED_ARG(strm);
        -: 3160:  ACE_UNUSED_ARG(stru);
    #####: 3161:  return (strm << stru.remoteWriterGuid)
    #####: 3162:    && (strm << stru.unicastLocatorList)
    #####: 3163:    && (strm << stru.multicastLocatorList)
    #####: 3164:    && (strm << stru.allLocators);
        -: 3165:}
        -: 3166:
    #####: 3167:bool operator>>(Serializer& strm, OpenDDS::DCPS::WriterProxy_t& stru)
        -: 3168:{
        -: 3169:  ACE_UNUSED_ARG(strm);
        -: 3170:  ACE_UNUSED_ARG(stru);
    #####: 3171:  return (strm >> stru.remoteWriterGuid)
    #####: 3172:    && (strm >> stru.unicastLocatorList)
    #####: 3173:    && (strm >> stru.multicastLocatorList)
    #####: 3174:    && (strm >> stru.allLocators);
        -: 3175:}
        -: 3176:
        -: 3177:}  }
        -: 3178:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3179:
        -: 3180:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3181:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3182:namespace OpenDDS { namespace DCPS {
        -: 3183:
        -: 3184:template<>
    #####: 3185:struct MetaStructImpl<OpenDDS::DCPS::WriterProxy_t> : MetaStruct {
        -: 3186:  typedef OpenDDS::DCPS::WriterProxy_t T;
        -: 3187:
        -: 3188:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3189:  void* allocate() const { return new T; }
        -: 3190:
    #####: 3191:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3192:
    #####: 3193:  size_t numDcpsKeys() const { return 0; }
        -: 3194:
        -: 3195:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3196:
    #####: 3197:  bool isDcpsKey(const char* field) const
        -: 3198:  {
        -: 3199:    ACE_UNUSED_ARG(field);
    #####: 3200:    return false;
        -: 3201:  }
        -: 3202:
    #####: 3203:  Value getValue(const void* stru, const char* field) const
        -: 3204:  {
    #####: 3205:    const OpenDDS::DCPS::WriterProxy_t& typed = *static_cast<const OpenDDS::DCPS::WriterProxy_t*>(stru);
    #####: 3206:    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
    #####: 3207:      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(&typed.remoteWriterGuid, field + 17);
        -: 3208:    }
        -: 3209:    ACE_UNUSED_ARG(typed);
    #####: 3210:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
        -: 3211:  }
        -: 3212:
    #####: 3213:  Value getValue(Serializer& ser, const char* field) const
        -: 3214:  {
    #####: 3215:    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
    #####: 3216:      return getMetaStruct<OpenDDS::DCPS::GUID_t>().getValue(ser, field + 17);
        -: 3217:    } else {
    #####: 3218:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::GUID_t*>(0))) {
    #####: 3219:        throw std::runtime_error("Field 'remoteWriterGuid' could not be skipped");
        -: 3220:      }
        -: 3221:    }
    #####: 3222:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
    #####: 3223:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 3224:    }
    #####: 3225:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::LocatorSeq*>(0))) {
    #####: 3226:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 3227:    }
    #####: 3228:    if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::TransportLocatorSeq*>(0))) {
    #####: 3229:      throw std::runtime_error("Field " + OPENDDS_STRING(field) + " could not be skipped");
        -: 3230:    }
    #####: 3231:    if (!field[0]) {
    #####: 3232:      return 0;
        -: 3233:    }
    #####: 3234:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::WriterProxy_t");
        -: 3235:  }
        -: 3236:
    #####: 3237:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3238:  {
        -: 3239:    ACE_UNUSED_ARG(next);
    #####: 3240:    if (std::strncmp(field, "remoteWriterGuid.", 17) == 0) {
    #####: 3241:      return make_struct_cmp(&T::remoteWriterGuid, getMetaStruct<OpenDDS::DCPS::GUID_t>().create_qc_comparator(field + 17), next);
        -: 3242:    }
    #####: 3243:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
        -: 3244:  }
        -: 3245:
        -: 3246:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3247:  const char** getFieldNames() const
        -: 3248:  {
        -: 3249:    static const char* names[] = {"remoteWriterGuid", "unicastLocatorList", "multicastLocatorList", "allLocators", 0};
    #####: 3250:    return names;
        -: 3251:  }
        -: 3252:
    #####: 3253:  const void* getRawField(const void* stru, const char* field) const
        -: 3254:  {
    #####: 3255:    if (std::strcmp(field, "remoteWriterGuid") == 0) {
    #####: 3256:      return &static_cast<const T*>(stru)->remoteWriterGuid;
        -: 3257:    }
    #####: 3258:    if (std::strcmp(field, "unicastLocatorList") == 0) {
    #####: 3259:      return &static_cast<const T*>(stru)->unicastLocatorList;
        -: 3260:    }
    #####: 3261:    if (std::strcmp(field, "multicastLocatorList") == 0) {
    #####: 3262:      return &static_cast<const T*>(stru)->multicastLocatorList;
        -: 3263:    }
    #####: 3264:    if (std::strcmp(field, "allLocators") == 0) {
    #####: 3265:      return &static_cast<const T*>(stru)->allLocators;
        -: 3266:    }
    #####: 3267:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
        -: 3268:  }
        -: 3269:
    #####: 3270:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3271:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3272:  {
        -: 3273:    ACE_UNUSED_ARG(lhs);
        -: 3274:    ACE_UNUSED_ARG(field);
        -: 3275:    ACE_UNUSED_ARG(rhs);
        -: 3276:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3277:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3278:    if (std::strcmp(field, "remoteWriterGuid") == 0) {
    #####: 3279:      static_cast<T*>(lhs)->remoteWriterGuid = *static_cast<const OpenDDS::DCPS::GUID_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3280:      return;
        -: 3281:    }
    #####: 3282:    if (std::strcmp(field, "unicastLocatorList") == 0) {
    #####: 3283:      static_cast<T*>(lhs)->unicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3284:      return;
        -: 3285:    }
    #####: 3286:    if (std::strcmp(field, "multicastLocatorList") == 0) {
    #####: 3287:      static_cast<T*>(lhs)->multicastLocatorList = *static_cast<const OpenDDS::DCPS::LocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3288:      return;
        -: 3289:    }
    #####: 3290:    if (std::strcmp(field, "allLocators") == 0) {
    #####: 3291:      static_cast<T*>(lhs)->allLocators = *static_cast<const OpenDDS::DCPS::TransportLocatorSeq*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3292:      return;
        -: 3293:    }
    #####: 3294:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
        -: 3295:  }
        -: 3296:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3297:
    #####: 3298:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3299:  {
        -: 3300:    ACE_UNUSED_ARG(lhs);
        -: 3301:    ACE_UNUSED_ARG(field);
        -: 3302:    ACE_UNUSED_ARG(rhs);
    #####: 3303:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::WriterProxy_t)");
        -: 3304:  }
        -: 3305:};
        -: 3306:
        -: 3307:template<>
    #####: 3308:const MetaStruct& getMetaStruct<OpenDDS::DCPS::WriterProxy_t>()
        -: 3309:{
    #####: 3310:  static MetaStructImpl<OpenDDS::DCPS::WriterProxy_t> msi;
    #####: 3311:  return msi;
        -: 3312:}
        -: 3313:
    #####: 3314:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::WriterProxy_t*)
        -: 3315:{
        -: 3316:  ACE_UNUSED_ARG(ser);
    #####: 3317:  MetaStructImpl<OpenDDS::DCPS::WriterProxy_t>().getValue(ser, "");
    #####: 3318:  return true;
        -: 3319:}
        -: 3320:
        -: 3321:}  }
        -: 3322:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3323:
        -: 3324:#endif
        -: 3325:
        -: 3326:/* End STRUCT: WriterProxy_t */
        -: 3327:
        -: 3328:
        -: 3329:/* Begin STRUCT: DiscoveredWriterData */
        -: 3330:
        -: 3331:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3332:namespace OpenDDS { namespace DCPS {
        -: 3333:
    #####: 3334:void gen_find_size(const OpenDDS::DCPS::DiscoveredWriterData& stru, size_t& size, size_t& padding)
        -: 3335:{
        -: 3336:  ACE_UNUSED_ARG(stru);
        -: 3337:  ACE_UNUSED_ARG(size);
        -: 3338:  ACE_UNUSED_ARG(padding);
    #####: 3339:  gen_find_size(stru.ddsPublicationData, size, padding);
    #####: 3340:  gen_find_size(stru.writerProxy, size, padding);
    #####: 3341:}
        -: 3342:
    #####: 3343:bool operator<<(Serializer& strm, const OpenDDS::DCPS::DiscoveredWriterData& stru)
        -: 3344:{
        -: 3345:  ACE_UNUSED_ARG(strm);
        -: 3346:  ACE_UNUSED_ARG(stru);
    #####: 3347:  return (strm << stru.ddsPublicationData)
    #####: 3348:    && (strm << stru.writerProxy);
        -: 3349:}
        -: 3350:
    #####: 3351:bool operator>>(Serializer& strm, OpenDDS::DCPS::DiscoveredWriterData& stru)
        -: 3352:{
        -: 3353:  ACE_UNUSED_ARG(strm);
        -: 3354:  ACE_UNUSED_ARG(stru);
    #####: 3355:  return (strm >> stru.ddsPublicationData)
    #####: 3356:    && (strm >> stru.writerProxy);
        -: 3357:}
        -: 3358:
        -: 3359:}  }
        -: 3360:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3361:
        -: 3362:#ifndef OPENDDS_NO_CONTENT_SUBSCRIPTION_PROFILE
        -: 3363:OPENDDS_BEGIN_VERSIONED_NAMESPACE_DECL
        -: 3364:namespace OpenDDS { namespace DCPS {
        -: 3365:
        -: 3366:template<>
    #####: 3367:struct MetaStructImpl<OpenDDS::DCPS::DiscoveredWriterData> : MetaStruct {
        -: 3368:  typedef OpenDDS::DCPS::DiscoveredWriterData T;
        -: 3369:
        -: 3370:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3371:  void* allocate() const { return new T; }
        -: 3372:
    #####: 3373:  void deallocate(void* stru) const { delete static_cast<T*>(stru); }
        -: 3374:
    #####: 3375:  size_t numDcpsKeys() const { return 0; }
        -: 3376:
        -: 3377:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3378:
    #####: 3379:  bool isDcpsKey(const char* field) const
        -: 3380:  {
        -: 3381:    ACE_UNUSED_ARG(field);
    #####: 3382:    return false;
        -: 3383:  }
        -: 3384:
    #####: 3385:  Value getValue(const void* stru, const char* field) const
        -: 3386:  {
    #####: 3387:    const OpenDDS::DCPS::DiscoveredWriterData& typed = *static_cast<const OpenDDS::DCPS::DiscoveredWriterData*>(stru);
    #####: 3388:    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
    #####: 3389:      return getMetaStruct<DDS::PublicationBuiltinTopicData>().getValue(&typed.ddsPublicationData, field + 19);
        -: 3390:    }
    #####: 3391:    if (std::strncmp(field, "writerProxy.", 12) == 0) {
    #####: 3392:      return getMetaStruct<OpenDDS::DCPS::WriterProxy_t>().getValue(&typed.writerProxy, field + 12);
        -: 3393:    }
        -: 3394:    ACE_UNUSED_ARG(typed);
    #####: 3395:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
        -: 3396:  }
        -: 3397:
    #####: 3398:  Value getValue(Serializer& ser, const char* field) const
        -: 3399:  {
    #####: 3400:    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
    #####: 3401:      return getMetaStruct<DDS::PublicationBuiltinTopicData>().getValue(ser, field + 19);
        -: 3402:    } else {
    #####: 3403:      if (!gen_skip_over(ser, static_cast<DDS::PublicationBuiltinTopicData*>(0))) {
    #####: 3404:        throw std::runtime_error("Field 'ddsPublicationData' could not be skipped");
        -: 3405:      }
        -: 3406:    }
    #####: 3407:    if (std::strncmp(field, "writerProxy.", 12) == 0) {
    #####: 3408:      return getMetaStruct<OpenDDS::DCPS::WriterProxy_t>().getValue(ser, field + 12);
        -: 3409:    } else {
    #####: 3410:      if (!gen_skip_over(ser, static_cast<OpenDDS::DCPS::WriterProxy_t*>(0))) {
    #####: 3411:        throw std::runtime_error("Field 'writerProxy' could not be skipped");
        -: 3412:      }
        -: 3413:    }
    #####: 3414:    if (!field[0]) {
    #####: 3415:      return 0;
        -: 3416:    }
    #####: 3417:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not valid for struct OpenDDS::DCPS::DiscoveredWriterData");
        -: 3418:  }
        -: 3419:
    #####: 3420:  ComparatorBase::Ptr create_qc_comparator(const char* field, ComparatorBase::Ptr next) const
        -: 3421:  {
        -: 3422:    ACE_UNUSED_ARG(next);
    #####: 3423:    if (std::strncmp(field, "ddsPublicationData.", 19) == 0) {
    #####: 3424:      return make_struct_cmp(&T::ddsPublicationData, getMetaStruct<DDS::PublicationBuiltinTopicData>().create_qc_comparator(field + 19), next);
        -: 3425:    }
    #####: 3426:    if (std::strncmp(field, "writerProxy.", 12) == 0) {
    #####: 3427:      return make_struct_cmp(&T::writerProxy, getMetaStruct<OpenDDS::DCPS::WriterProxy_t>().create_qc_comparator(field + 12), next);
        -: 3428:    }
    #####: 3429:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
        -: 3430:  }
        -: 3431:
        -: 3432:#ifndef OPENDDS_NO_MULTI_TOPIC
    #####: 3433:  const char** getFieldNames() const
        -: 3434:  {
        -: 3435:    static const char* names[] = {"ddsPublicationData", "writerProxy", 0};
    #####: 3436:    return names;
        -: 3437:  }
        -: 3438:
    #####: 3439:  const void* getRawField(const void* stru, const char* field) const
        -: 3440:  {
    #####: 3441:    if (std::strcmp(field, "ddsPublicationData") == 0) {
    #####: 3442:      return &static_cast<const T*>(stru)->ddsPublicationData;
        -: 3443:    }
    #####: 3444:    if (std::strcmp(field, "writerProxy") == 0) {
    #####: 3445:      return &static_cast<const T*>(stru)->writerProxy;
        -: 3446:    }
    #####: 3447:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
        -: 3448:  }
        -: 3449:
    #####: 3450:  void assign(void* lhs, const char* field, const void* rhs,
        -: 3451:    const char* rhsFieldSpec, const MetaStruct& rhsMeta) const
        -: 3452:  {
        -: 3453:    ACE_UNUSED_ARG(lhs);
        -: 3454:    ACE_UNUSED_ARG(field);
        -: 3455:    ACE_UNUSED_ARG(rhs);
        -: 3456:    ACE_UNUSED_ARG(rhsFieldSpec);
        -: 3457:    ACE_UNUSED_ARG(rhsMeta);
    #####: 3458:    if (std::strcmp(field, "ddsPublicationData") == 0) {
    #####: 3459:      static_cast<T*>(lhs)->ddsPublicationData = *static_cast<const DDS::PublicationBuiltinTopicData*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3460:      return;
        -: 3461:    }
    #####: 3462:    if (std::strcmp(field, "writerProxy") == 0) {
    #####: 3463:      static_cast<T*>(lhs)->writerProxy = *static_cast<const OpenDDS::DCPS::WriterProxy_t*>(rhsMeta.getRawField(rhs, rhsFieldSpec));
    #####: 3464:      return;
        -: 3465:    }
    #####: 3466:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
        -: 3467:  }
        -: 3468:#endif /* OPENDDS_NO_MULTI_TOPIC */
        -: 3469:
    #####: 3470:  bool compare(const void* lhs, const void* rhs, const char* field) const
        -: 3471:  {
        -: 3472:    ACE_UNUSED_ARG(lhs);
        -: 3473:    ACE_UNUSED_ARG(field);
        -: 3474:    ACE_UNUSED_ARG(rhs);
    #####: 3475:    throw std::runtime_error("Field " + OPENDDS_STRING(field) + " not found or its type is not supported (in struct OpenDDS::DCPS::DiscoveredWriterData)");
        -: 3476:  }
        -: 3477:};
        -: 3478:
        -: 3479:template<>
    #####: 3480:const MetaStruct& getMetaStruct<OpenDDS::DCPS::DiscoveredWriterData>()
        -: 3481:{
    #####: 3482:  static MetaStructImpl<OpenDDS::DCPS::DiscoveredWriterData> msi;
    #####: 3483:  return msi;
        -: 3484:}
        -: 3485:
    #####: 3486:bool gen_skip_over(Serializer& ser, OpenDDS::DCPS::DiscoveredWriterData*)
        -: 3487:{
        -: 3488:  ACE_UNUSED_ARG(ser);
    #####: 3489:  MetaStructImpl<OpenDDS::DCPS::DiscoveredWriterData>().getValue(ser, "");
    #####: 3490:  return true;
        -: 3491:}
        -: 3492:
        -: 3493:}  }
        -: 3494:OPENDDS_END_VERSIONED_NAMESPACE_DECL
        -: 3495:
        -: 3496:#endif
        -: 3497:
        -: 3498:/* End STRUCT: DiscoveredWriterData */
        -: 3499:
        -: 3500:/* End MODULE: DCPS */
        -: 3501:
        -: 3502:/* End MODULE: OpenDDS */
