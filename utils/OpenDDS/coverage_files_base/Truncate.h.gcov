        -:    0:Source:/home/ryan/git/TARGETS/OpenDDS-debloat/ACE_wrappers/ace/Truncate.h
        -:    0:Programs:70
        -:    1:// -*- C++ -*-
        -:    2:
        -:    3://=============================================================================
        -:    4:/**
        -:    5: * @file Truncate.h
        -:    6: *
        -:    7: * $Id$
        -:    8: *
        -:    9: * @author Steve Huston  <shuston@riverace.com>
        -:   10: * @author Ossama Othman <ossama_othman@symantec.com>
        -:   11: * @author Russell Mora  <russell_mora@symantec.com>
        -:   12: */
        -:   13://=============================================================================
        -:   14:
        -:   15:#ifndef ACE_TRUNCATE_H
        -:   16:#define ACE_TRUNCATE_H
        -:   17:
        -:   18:#include /**/ "ace/pre.h"
        -:   19:
        -:   20:#include "ace/config-all.h"
        -:   21:
        -:   22:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   23:# pragma once
        -:   24:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   25:
        -:   26:#include "ace/Global_Macros.h"
        -:   27:#include "ace/If_Then_Else.h"
        -:   28:#include "ace/Numeric_Limits.h"
        -:   29:
        -:   30:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   31:
        -:   32:namespace ACE_Utils
        -:   33:{
        -:   34:  template<typename T> struct Sign_Check;
        -:   35:
        -:   36:  // Specialize the unsigned signed cases.
        -:   37:  template<> struct Sign_Check<unsigned char>  { ACE_STATIC_CONSTANT (bool, is_signed = 0); };
        -:   38:  template<> struct Sign_Check<unsigned short> { ACE_STATIC_CONSTANT (bool, is_signed = 0); };
        -:   39:  template<> struct Sign_Check<unsigned int>   { ACE_STATIC_CONSTANT (bool, is_signed = 0); };
        -:   40:  template<> struct Sign_Check<unsigned long>  { ACE_STATIC_CONSTANT (bool, is_signed = 0); };
        -:   41:# ifdef __GNUC__
        -:   42:  // Silence g++ "-pedantic" warnings regarding use of "long long"
        -:   43:  // type.
        -:   44:  __extension__
        -:   45:# endif  /* __GNUC__ */
        -:   46:  template<> struct Sign_Check<unsigned long long> { ACE_STATIC_CONSTANT (bool, is_signed = 0); };
        -:   47:
        -:   48:  // Specialize the signed cases.
        -:   49:  template<> struct Sign_Check<signed char>  { ACE_STATIC_CONSTANT (bool, is_signed = 1); };
        -:   50:  template<> struct Sign_Check<signed short> { ACE_STATIC_CONSTANT (bool, is_signed = 1); };
        -:   51:  template<> struct Sign_Check<signed int>   { ACE_STATIC_CONSTANT (bool, is_signed = 1); };
        -:   52:  template<> struct Sign_Check<signed long>  { ACE_STATIC_CONSTANT (bool, is_signed = 1); };
        -:   53:# ifdef __GNUC__
        -:   54:  // Silence g++ "-pedantic" warnings regarding use of "long long"
        -:   55:  // type.
        -:   56:  __extension__
        -:   57:# endif  /* __GNUC__ */
        -:   58:  template<> struct Sign_Check<signed long long> { ACE_STATIC_CONSTANT (bool, is_signed = 1); };
        -:   59:
        -:   60:  // -----------------------------------------------------
        -:   61:
        -:   62:  /**
        -:   63:   * @struct To_Unsigned
        -:   64:   *
        -:   65:   * @brief Retrieve unsigned counterpart to given type or value.
        -:   66:   *
        -:   67:   * Retrieve unsigned counterpart to given type or value.
        -:   68:   */
        -:   69:  template<typename T> struct To_Unsigned;
        -:   70:
        -:   71:  template<>
        -:   72:  struct To_Unsigned<unsigned char>
        -:   73:  {
        -:   74:    typedef unsigned char unsigned_type;
        -:   75:
        -:   76:    unsigned_type operator() (unsigned_type x) { return x; }
        -:   77:  };
        -:   78:
        -:   79:  template<>
        -:   80:  struct To_Unsigned<unsigned short>
        -:   81:  {
        -:   82:    typedef unsigned short unsigned_type;
        -:   83:
        -:   84:    unsigned_type operator() (unsigned_type x) { return x; }
        -:   85:  };
        -:   86:
        -:   87:  template<>
        -:   88:  struct To_Unsigned<unsigned int>
        -:   89:  {
        -:   90:    typedef unsigned int unsigned_type;
        -:   91:
        -:   92:    unsigned_type operator() (unsigned_type x) { return x; }
        -:   93:  };
        -:   94:
        -:   95:  template<>
        -:   96:  struct To_Unsigned<unsigned long>
        -:   97:  {
        -:   98:    typedef unsigned long unsigned_type;
        -:   99:
        -:  100:    unsigned_type operator() (unsigned_type x) { return x; }
        -:  101:  };
        -:  102:
        -:  103:# ifdef __GNUC__
        -:  104:  // Silence g++ "-pedantic" warnings regarding use of "long long"
        -:  105:  // type.
        -:  106:  __extension__
        -:  107:# endif  /* __GNUC__ */
        -:  108:  template<>
        -:  109:  struct To_Unsigned<unsigned long long>
        -:  110:  {
        -:  111:    typedef unsigned long long unsigned_type;
        -:  112:
        -:  113:    unsigned_type operator() (unsigned_type x) { return x; }
        -:  114:  };
        -:  115:
        -:  116:  // ----------------
        -:  117:
        -:  118:  template<>
        -:  119:  struct To_Unsigned<signed char>
        -:  120:  {
        -:  121:    typedef signed char   signed_type;
        -:  122:    typedef unsigned char unsigned_type;
        -:  123:
        -:  124:    unsigned_type operator() (signed_type x)
        -:  125:    {
        -:  126:      return static_cast<unsigned_type> (x);
        -:  127:    }
        -:  128:  };
        -:  129:
        -:  130:  template<>
        -:  131:  struct To_Unsigned<signed short>
        -:  132:  {
        -:  133:    typedef signed short   signed_type;
        -:  134:    typedef unsigned short unsigned_type;
        -:  135:
        -:  136:    unsigned_type operator() (signed_type x)
        -:  137:    {
        -:  138:      return static_cast<unsigned_type> (x);
        -:  139:    }
        -:  140:  };
        -:  141:
        -:  142:  template<>
        -:  143:  struct To_Unsigned<signed int>
        -:  144:  {
        -:  145:    typedef signed int   signed_type;
        -:  146:    typedef unsigned int unsigned_type;
        -:  147:
        -:  148:    unsigned_type operator() (signed_type x)
        -:  149:    {
        -:  150:      return static_cast<unsigned_type> (x);
        -:  151:    }
        -:  152:  };
        -:  153:
        -:  154:  template<>
        -:  155:  struct To_Unsigned<signed long>
        -:  156:  {
        -:  157:    typedef signed long   signed_type;
        -:  158:    typedef unsigned long unsigned_type;
        -:  159:
      381:  160:    unsigned_type operator() (signed_type x)
        -:  161:    {
      381:  162:      return static_cast<unsigned_type> (x);
        -:  163:    }
        -:  164:  };
        -:  165:
        -:  166:# ifdef __GNUC__
        -:  167:  // Silence g++ "-pedantic" warnings regarding use of "long long"
        -:  168:  // type.
        -:  169:  __extension__
        -:  170:# endif  /* __GNUC__ */
        -:  171:  template<>
        -:  172:  struct To_Unsigned<signed long long>
        -:  173:  {
        -:  174:    typedef signed long long   signed_type;
        -:  175:    typedef unsigned long long unsigned_type;
        -:  176:
        -:  177:    unsigned_type operator() (signed_type x)
        -:  178:    {
        -:  179:      return static_cast<unsigned_type> (x);
        -:  180:    }
        -:  181:  };
        -:  182:
        -:  183:  // -----------------------------------------------------
        -:  184:
        -:  185:  /**
        -:  186:   * @struct Safe_Comparator
        -:  187:   *
        -:  188:   * @brief Conservative comparison of types that may not be safely
        -:  189:   *        promoted and/or converted to each other.
        -:  190:   *
        -:  191:   * The comparison operations provided by this structure perform
        -:  192:   * negative value checking when necessary to prevent wrap-around
        -:  193:   * when explicitly casting to an unsigned type.
        -:  194:   *
        -:  195:   * @internal This structure is not meant for general use.
        -:  196:   */
        -:  197:  template<typename LEFT,
        -:  198:           typename RIGHT,
        -:  199:           bool IS_LEFT_SIGNED,
        -:  200:           bool IS_RIGHT_SIGNED> struct Safe_Comparator;
        -:  201:
        -:  202:  // LEFT: signed, RIGHT: unsigned
        -:  203:  template<typename LEFT, typename RIGHT>
        -:  204:  struct Safe_Comparator<LEFT, RIGHT, true, false>
        -:  205:  {
      381:  206:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  207:    {
        -:  208:      // Prevent wrap-around when casting to unsigned.
      381:  209:      if (lhs < 0)
    #####:  210:        return false;  // since rhs is always positive
        -:  211:      else
        -:  212:        {
        -:  213:          // Implicit promotion of unsigned LEFT and RIGHT types here.
      381:  214:          return To_Unsigned<LEFT>() (lhs) > rhs;
        -:  215:        }
        -:  216:    }
        -:  217:  };
        -:  218:
        -:  219:  // LEFT: unsigned, RIGHT: signed
        -:  220:  template<typename LEFT, typename RIGHT>
        -:  221:  struct Safe_Comparator<LEFT, RIGHT, false, true>
        -:  222:  {
        -:  223:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  224:    {
        -:  225:      // Prevent wrap-around when casting to unsigned.
        -:  226:      if (rhs < 0)
        -:  227:        return true;  // since lhs is always positive
        -:  228:      else
        -:  229:        {
        -:  230:          // Implicit promotion of unsigned LEFT and RIGHT types here.
        -:  231:          return lhs > To_Unsigned<RIGHT>() (rhs);
        -:  232:        }
        -:  233:    }
        -:  234:  };
        -:  235:
        -:  236:  // LEFT: unsigned, RIGHT: unsigned
        -:  237:  template<typename LEFT, typename RIGHT>
        -:  238:  struct Safe_Comparator<LEFT, RIGHT, false, false>
        -:  239:  {
        -:  240:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  241:    {
        -:  242:      // Implicit promotion of unsigned LEFT and RIGHT types here.
        -:  243:      return lhs > rhs;
        -:  244:    }
        -:  245:  };
        -:  246:
        -:  247:  // LEFT: signed, RIGHT: signed
        -:  248:  template<typename LEFT, typename RIGHT>
        -:  249:  struct Safe_Comparator<LEFT, RIGHT, true, true>
        -:  250:  {
        -:  251:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  252:    {
        -:  253:      // Implicit promotion of signed LEFT and RIGHT types here.
        -:  254:      return lhs > rhs;
        -:  255:    }
        -:  256:  };
        -:  257:
        -:  258:  // -----------------------------------------------------
        -:  259:
        -:  260:  /**
        -:  261:   * @struct Fast_Comparator
        -:  262:   *
        -:  263:   * @brief Quick comparison of types that can be safely promoted
        -:  264:   *        and/or converted to each other.
        -:  265:   *
        -:  266:   * The comparison operations provided by this structure perform no
        -:  267:   * negative value checking, meaning it is not applicable to all
        -:  268:   * types.  Check the value of the @c USABLE enumerator to determine
        -:  269:   * if it applies to the types in question.
        -:  270:   *
        -:  271:   * @internal This structure is not meant for general use.
        -:  272:   */
        -:  273:  template<typename LEFT, typename RIGHT>
        -:  274:  struct Fast_Comparator
        -:  275:  {
        -:  276:    ACE_STATIC_CONSTANT (
        -:  277:      bool,
        -:  278:      USE_LEFT  = ((sizeof (LEFT) > sizeof (RIGHT)
        -:  279:                    && (Sign_Check<LEFT>::is_signed == 1
        -:  280:                        || Sign_Check<RIGHT>::is_signed == 0))
        -:  281:
        -:  282:                   // The following is basically the case where LEFT
        -:  283:                   // and RIGHT are the same integral type.
        -:  284:                   || (sizeof (LEFT) == sizeof (RIGHT)
        -:  285:                       // Can't portably do
        -:  286:                       // Sign_Check<LEFT>::is_signed ==
        -:  287:                       // Sign_Check<RIGHT>::is_signed,
        -:  288:                       // i.e. comparison of anonymous enumerations,
        -:  289:                       // without triggering a compiler diagnostic
        -:  290:                       // so expand the comparison.
        -:  291:                       && ((Sign_Check<LEFT>::is_signed == 1
        -:  292:                            && Sign_Check<RIGHT>::is_signed == 1)
        -:  293:                           || (Sign_Check<LEFT>::is_signed == 0
        -:  294:                               && Sign_Check<RIGHT>::is_signed == 0)))));
        -:  295:
        -:  296:    ACE_STATIC_CONSTANT (
        -:  297:      bool,
        -:  298:      USE_RIGHT = (sizeof (RIGHT) > sizeof (LEFT)
        -:  299:                   && (Sign_Check<RIGHT>::is_signed == 1
        -:  300:                       || Sign_Check<LEFT>::is_signed == 0)));
        -:  301:
        -:  302:    ACE_STATIC_CONSTANT (bool, USABLE = (USE_LEFT || USE_RIGHT));
        -:  303:
        -:  304:    typedef typename ACE::If_Then_Else<
        -:  305:      USE_LEFT,
        -:  306:      LEFT,
        -:  307:      typename ACE::If_Then_Else<
        -:  308:        USE_RIGHT,
        -:  309:        RIGHT,
        -:  310:        void>::result_type>::result_type promote_type;
        -:  311:
    #####:  312:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  313:    {
        -:  314:      // The explicit cast is assumed to change the type of rhs without
        -:  315:      // changing its value.
        -:  316:      return
    #####:  317:        (static_cast<promote_type> (lhs) > static_cast<promote_type> (rhs));
        -:  318:    }
------------------
_ZN9ACE_Utils15Fast_ComparatorIllE12greater_thanEll:
    #####:  312:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  313:    {
        -:  314:      // The explicit cast is assumed to change the type of rhs without
        -:  315:      // changing its value.
        -:  316:      return
    #####:  317:        (static_cast<promote_type> (lhs) > static_cast<promote_type> (rhs));
        -:  318:    }
------------------
_ZN9ACE_Utils15Fast_ComparatorIllE12greater_thanEll:
    #####:  312:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  313:    {
        -:  314:      // The explicit cast is assumed to change the type of rhs without
        -:  315:      // changing its value.
        -:  316:      return
    #####:  317:        (static_cast<promote_type> (lhs) > static_cast<promote_type> (rhs));
        -:  318:    }
------------------
_ZN9ACE_Utils15Fast_ComparatorIllE12greater_thanEll:
    #####:  312:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  313:    {
        -:  314:      // The explicit cast is assumed to change the type of rhs without
        -:  315:      // changing its value.
        -:  316:      return
    #####:  317:        (static_cast<promote_type> (lhs) > static_cast<promote_type> (rhs));
        -:  318:    }
------------------
_ZN9ACE_Utils15Fast_ComparatorIllE12greater_thanEll:
    #####:  312:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  313:    {
        -:  314:      // The explicit cast is assumed to change the type of rhs without
        -:  315:      // changing its value.
        -:  316:      return
    #####:  317:        (static_cast<promote_type> (lhs) > static_cast<promote_type> (rhs));
        -:  318:    }
------------------
_ZN9ACE_Utils15Fast_ComparatorIllE12greater_thanEll:
    #####:  312:    static bool greater_than (LEFT lhs, RIGHT rhs)
        -:  313:    {
        -:  314:      // The explicit cast is assumed to change the type of rhs without
        -:  315:      // changing its value.
        -:  316:      return
    #####:  317:        (static_cast<promote_type> (lhs) > static_cast<promote_type> (rhs));
        -:  318:    }
------------------
        -:  319:
        -:  320:  };
        -:  321:
        -:  322:  // -----------------------------------------------------
        -:  323:
        -:  324:  /**
        -:  325:   * @struct Comparator
        -:  326:   *
        -:  327:   * @brief Structure that provides optimal comparison operation for
        -:  328:   *        given types.
        -:  329:   *
        -:  330:   * The comparison operations provided by this structure are chosen
        -:  331:   * at compile time based on the signs and sizes of types being
        -:  332:   * compared.
        -:  333:   * @par
        -:  334:   * Comparisons of values with the same sign or those with types that
        -:  335:   * can be promoted safely are done quickly, without any range
        -:  336:   * checking.
        -:  337:   * @par
        -:  338:   * Comparisons of values of different types that cannot be safely
        -:  339:   * promoted incur an additional check for a negative value to allow
        -:  340:   * the compiler to perform the appropriate implicit unsigned type
        -:  341:   * promotion.
        -:  342:   *
        -:  343:   * @note In general, the operations found in this structure should
        -:  344:   *       not be used to work around compiler diagnostics regarding
        -:  345:   *       comparison of signed and unsigned types.  Verify that your
        -:  346:   *       types are correct before relying on those operations.
        -:  347:   *
        -:  348:   * @internal This structure is not meant for general use.
        -:  349:   */
        -:  350:  template<typename LEFT, typename RIGHT>
        -:  351:  struct Comparator
        -:  352:  {
        -:  353:    typedef typename ACE::If_Then_Else<
        -:  354:      Fast_Comparator<LEFT, RIGHT>::USABLE,
        -:  355:      Fast_Comparator<LEFT, RIGHT>,
        -:  356:      Safe_Comparator<LEFT,
        -:  357:                      RIGHT,
        -:  358:                      Sign_Check<LEFT>::is_signed,
        -:  359:                      Sign_Check<RIGHT>::is_signed> >::result_type comp_type;
        -:  360:  };
        -:  361:
        -:  362:  // -----------------------------------------------------
        -:  363:
        -:  364:  /**
        -:  365:   * @struct Truncator
        -:  366:   *
        -:  367:   * @brief Truncate value of type @c FROM to value of type @c TO.
        -:  368:   *
        -:  369:   * Truncate a value of type @c FROM to value of type @c TO, if the
        -:  370:   * value is larger than the maximum of value of type @c TO.
        -:  371:   */
        -:  372:  template<typename FROM, typename TO>
        -:  373:  struct Truncator
        -:  374:  {
        -:  375:    ACE_STATIC_CONSTANT (
        -:  376:      bool,
        -:  377:      // max FROM always greater than max TO
        -:  378:      MAX_FROM_GT_MAX_TO = (sizeof(FROM) > sizeof (TO)
        -:  379:                            || (sizeof(FROM) == sizeof (TO)
        -:  380:                                && Sign_Check<FROM>::is_signed == 0)));
        -:  381:
        -:  382:    typedef typename ACE::If_Then_Else<
        -:  383:      MAX_FROM_GT_MAX_TO,
        -:  384:      FROM,
        -:  385:      TO>::result_type comp_to_type;
        -:  386:
        -:  387:    // Take advantage of knowledge that we're casting a positive value
        -:  388:    // to a type large enough to hold it so that we can bypass
        -:  389:    // negative value checks at compile-time.  Otherwise fallback on
        -:  390:    // the safer comparison.
        -:  391:    typedef typename ACE::If_Then_Else<
        -:  392:      MAX_FROM_GT_MAX_TO,
        -:  393:      Fast_Comparator<FROM, comp_to_type>,
        -:  394:      typename Comparator<FROM, comp_to_type>::comp_type>::result_type comparator;
        -:  395:
        -:  396:    /// Truncate a value of type @c FROM to value of type @c TO, if
        -:  397:    /// the value is larger than the maximum of value of type @c TO.
     381*:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
     381*:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
     381*:  402:         ? ACE_Numeric_Limits<TO>::max ()
     381*:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
_ZN9ACE_Utils9TruncatorIliEclEl:
    #####:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
    #####:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
    #####:  402:         ? ACE_Numeric_Limits<TO>::max ()
    #####:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
_ZN9ACE_Utils9TruncatorIlmEclEl:
      381:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
      381:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
     381*:  402:         ? ACE_Numeric_Limits<TO>::max ()
      381:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
_ZN9ACE_Utils9TruncatorIliEclEl:
    #####:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
    #####:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
    #####:  402:         ? ACE_Numeric_Limits<TO>::max ()
    #####:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
_ZN9ACE_Utils9TruncatorIliEclEl:
    #####:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
    #####:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
    #####:  402:         ? ACE_Numeric_Limits<TO>::max ()
    #####:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
_ZN9ACE_Utils9TruncatorIliEclEl:
    #####:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
    #####:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
    #####:  402:         ? ACE_Numeric_Limits<TO>::max ()
    #####:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
_ZN9ACE_Utils9TruncatorIliEclEl:
    #####:  398:    TO operator() (FROM val)
        -:  399:    {
        -:  400:      return
    #####:  401:        (comparator::greater_than (val, ACE_Numeric_Limits<TO>::max ())
    #####:  402:         ? ACE_Numeric_Limits<TO>::max ()
    #####:  403:         : static_cast<TO> (val));
        -:  404:    }
------------------
        -:  405:
        -:  406:  };
        -:  407:
        -:  408:  // Partial specialization for the case where the types are the same.
        -:  409:  // No truncation is necessary.
        -:  410:  template<typename T>
        -:  411:  struct Truncator<T, T>
        -:  412:  {
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
_ZN9ACE_Utils9TruncatorIllEclEl:
    #####:  413:    T operator() (T val)
        -:  414:    {
    #####:  415:      return val;
        -:  416:    }
------------------
        -:  417:  };
        -:  418:
        -:  419:
        -:  420:  // -----------------------------------------------------
        -:  421:  /**
        -:  422:   * @struct Noop_Truncator
        -:  423:   *
        -:  424:   * @brief No-op truncation.
        -:  425:   *
        -:  426:   * This structure/functor performs no truncation since it assumes
        -:  427:   * that @c sizeof(FROM) @c < @c sizeof(TO), meaning that
        -:  428:   * @c numeric_limits<FROM>::max() @c < @c numeric_limits<TO>::max().
        -:  429:   */
        -:  430:  template<typename FROM, typename TO>
        -:  431:  struct Noop_Truncator
        -:  432:  {
        -:  433:    TO operator() (FROM val)
        -:  434:    {
        -:  435:      return static_cast<TO> (val);
        -:  436:    }
        -:  437:  };
        -:  438:  // -----------------------------------------------------
        -:  439:
        -:  440:  /**
        -:  441:   * @class truncate_cast
        -:  442:   *
        -:  443:   * @brief Helper function to truncate an integral value to the
        -:  444:   *        maximum  value of the given type.
        -:  445:   *
        -:  446:   *        Very useful since ACE methods return @c int very often and
        -:  447:   *        the value's source is often a different-size integral
        -:  448:   *        type, such as @c size_t.  This function hides the
        -:  449:   *        truncation logic and resolves compiler diagnostics.
        -:  450:   *
        -:  451:   * @internal Internal use only.
        -:  452:   */
        -:  453:  template<typename TO, typename FROM>
     381*:  454:  inline TO truncate_cast (FROM val)
        -:  455:  {
        -:  456:    // If the size of FROM is less than the size of TO, "val" will
        -:  457:    // never be greater than the maximum "TO" value, so there is no
        -:  458:    // need to attempt to truncate.
        -:  459:    typedef typename ACE::If_Then_Else<
        -:  460:      (sizeof (FROM) < sizeof (TO)),
        -:  461:      Noop_Truncator<FROM, TO>,
        -:  462:      Truncator<FROM, TO> >::result_type truncator;
        -:  463:
     381*:  464:    return truncator() (val);
        -:  465:  }
        -:  466:
        -:  467:} // namespace ACE_Utils
        -:  468:
        -:  469:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  470:
        -:  471:#include /**/ "ace/post.h"
        -:  472:
        -:  473:#endif /* ACE_TRUNCATE_H*/
