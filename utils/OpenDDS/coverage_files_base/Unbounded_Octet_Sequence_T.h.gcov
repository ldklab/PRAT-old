        -:    0:Source:/home/ryan/git/TARGETS/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Octet_Sequence_T.h
        -:    0:Programs:51
        -:    1:#ifndef guard_unbounded_octet_sequence_hpp
        -:    2:#define guard_unbounded_octet_sequence_hpp
        -:    3:/**
        -:    4: * @file
        -:    5: *
        -:    6: * @brief Implement octet sequences
        -:    7: *
        -:    8: * $Id$
        -:    9: *
        -:   10: * @author Johnny Willemsen
        -:   11: */
        -:   12:#include "tao/orbconf.h"
        -:   13:
        -:   14:#include "tao/Unbounded_Value_Sequence_T.h"
        -:   15:#include "ace/OS_NS_string.h"
        -:   16:
        -:   17:#if (TAO_NO_COPY_OCTET_SEQUENCES == 1)
        -:   18:
        -:   19:#include /**/ "tao/TAO_Export.h"
        -:   20:#include "tao/Unbounded_Value_Allocation_Traits_T.h"
        -:   21:#include "tao/Value_Traits_T.h"
        -:   22:#include "tao/Range_Checking_T.h"
        -:   23:
        -:   24:#include "tao/Basic_Types.h"
        -:   25:#include "ace/Message_Block.h"
        -:   26:#include "ace/OS_Memory.h"
        -:   27:#include "ace/checked_iterator.h"
        -:   28:
        -:   29:TAO_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   30:
        -:   31:namespace TAO
        -:   32:{
        -:   33:template<>
        -:   34:class TAO_Export unbounded_value_sequence<CORBA::Octet>
        -:   35:{
        -:   36:public:
        -:   37:  typedef CORBA::Octet value_type;
        -:   38:  typedef CORBA::Octet element_type;
        -:   39:  typedef CORBA::Octet const const_value_type;
        -:   40:  typedef value_type & subscript_type;
        -:   41:  typedef value_type const & const_subscript_type;
        -:   42:  typedef ::CORBA::ULong size_type;
        -:   43:
        -:   44:  typedef details::unbounded_value_allocation_traits<value_type,true> allocation_traits;
        -:   45:  typedef details::value_traits<value_type,true> element_traits;
        -:   46:  typedef details::generic_sequence<value_type, allocation_traits, element_traits> implementation_type;
        -:   47:  typedef details::range_checking<value_type,true> range;
        -:   48:
        -:   49:  inline unbounded_value_sequence<CORBA::Octet>()
        -:   50:    : maximum_ (allocation_traits::default_maximum())
        -:   51:    , length_ (0)
        -:   52:    , buffer_ (allocation_traits::default_buffer_allocation())
        -:   53:    , release_ (buffer_ != 0)
        -:   54:    , mb_ (0)
        -:   55:  {}
    #####:   56:  inline explicit unbounded_value_sequence<CORBA::Octet>(CORBA::ULong maximum)
    #####:   57:    : maximum_(maximum)
        -:   58:    , length_(0)
    #####:   59:    , buffer_(allocbuf(maximum_))
        -:   60:    , release_(true)
    #####:   61:    , mb_ (0)
    #####:   62:  {}
------------------
_ZN3TAO24unbounded_value_sequenceIhEC2Ej:
    #####:   56:  inline explicit unbounded_value_sequence<CORBA::Octet>(CORBA::ULong maximum)
    #####:   57:    : maximum_(maximum)
        -:   58:    , length_(0)
    #####:   59:    , buffer_(allocbuf(maximum_))
        -:   60:    , release_(true)
    #####:   61:    , mb_ (0)
    #####:   62:  {}
------------------
_ZN3TAO24unbounded_value_sequenceIhEC2Ej:
    #####:   56:  inline explicit unbounded_value_sequence<CORBA::Octet>(CORBA::ULong maximum)
    #####:   57:    : maximum_(maximum)
        -:   58:    , length_(0)
    #####:   59:    , buffer_(allocbuf(maximum_))
        -:   60:    , release_(true)
    #####:   61:    , mb_ (0)
    #####:   62:  {}
------------------
_ZN3TAO24unbounded_value_sequenceIhEC2Ej:
    #####:   56:  inline explicit unbounded_value_sequence<CORBA::Octet>(CORBA::ULong maximum)
    #####:   57:    : maximum_(maximum)
        -:   58:    , length_(0)
    #####:   59:    , buffer_(allocbuf(maximum_))
        -:   60:    , release_(true)
    #####:   61:    , mb_ (0)
    #####:   62:  {}
------------------
        -:   63:  inline unbounded_value_sequence<CORBA::Octet>(
        -:   64:      CORBA::ULong maximum,
        -:   65:      CORBA::ULong length,
        -:   66:      value_type * data,
        -:   67:      CORBA::Boolean release = false)
        -:   68:    : maximum_ (maximum),
        -:   69:      length_ (length),
        -:   70:      buffer_ (data),
        -:   71:      release_ (release),
        -:   72:      mb_ (0)
        -:   73:  {}
    #####:   74:  inline ~unbounded_value_sequence<CORBA::Octet>() {
    #####:   75:    if (mb_)
    #####:   76:      ACE_Message_Block::release (mb_);
    #####:   77:    if (release_)
    #####:   78:      freebuf(buffer_);
    #####:   79:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhED2Ev:
    #####:   74:  inline ~unbounded_value_sequence<CORBA::Octet>() {
    #####:   75:    if (mb_)
    #####:   76:      ACE_Message_Block::release (mb_);
    #####:   77:    if (release_)
    #####:   78:      freebuf(buffer_);
    #####:   79:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhED2Ev:
    #####:   74:  inline ~unbounded_value_sequence<CORBA::Octet>() {
    #####:   75:    if (mb_)
    #####:   76:      ACE_Message_Block::release (mb_);
    #####:   77:    if (release_)
    #####:   78:      freebuf(buffer_);
    #####:   79:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhED2Ev:
    #####:   74:  inline ~unbounded_value_sequence<CORBA::Octet>() {
    #####:   75:    if (mb_)
    #####:   76:      ACE_Message_Block::release (mb_);
    #####:   77:    if (release_)
    #####:   78:      freebuf(buffer_);
    #####:   79:  }
------------------
        -:   80:  /// Create a sequence of octets from a single message block (i.e. it
        -:   81:  /// ignores any chaining in the message block).
        -:   82:  inline unbounded_value_sequence<CORBA::Octet> (CORBA::ULong length,
        -:   83:                                                 const ACE_Message_Block* mb)
        -:   84:    : maximum_ (length)
        -:   85:    , length_ (length)
        -:   86:    , buffer_ (reinterpret_cast <CORBA::Octet *>(mb->rd_ptr ()))
        -:   87:    , release_ (false)
        -:   88:    , mb_(0) {
        -:   89:    // Get the message block flags.
        -:   90:    ACE_Message_Block::Message_Flags const flg = mb->self_flags ();
        -:   91:
        -:   92:    // If the DONT_DELETE flag is disabled just a duplicate would
        -:   93:    // help. If the DONT_DELETE flag is enabled a deep copy is needed as
        -:   94:    // the contents would be on stack. Just incrementing the ref count
        -:   95:    // on the stack based data block would only crash the program when
        -:   96:    // the stack unwinds
        -:   97:    if (ACE_BIT_DISABLED (flg,
        -:   98:                          ACE_Message_Block::DONT_DELETE))
        -:   99:      {
        -:  100:        this->mb_ = ACE_Message_Block::duplicate (mb);
        -:  101:      }
        -:  102:    else
        -:  103:      {
        -:  104:        // As we are in CORBA mode, all the data blocks would be aligned
        -:  105:        // on an 8 byte boundary
        -:  106:        ACE_Message_Block msgb (*mb, ACE_CDR::MAX_ALIGNMENT);
        -:  107:
        -:  108:        // Get the base pointer of the incoming message block
        -:  109:        char *start = ACE_ptr_align_binary (mb->base (),
        -:  110:                                            ACE_CDR::MAX_ALIGNMENT);
        -:  111:
        -:  112:        // Get the read and write displacements in the incoming stream
        -:  113:        size_t const rd_pos = mb->rd_ptr () - start;
        -:  114:        size_t const wr_pos = mb->wr_ptr () - start;
        -:  115:
        -:  116:        this->mb_ = ACE_Message_Block::duplicate (&msgb);
        -:  117:
        -:  118:        this->mb_->rd_ptr (rd_pos);
        -:  119:        this->mb_->wr_ptr (wr_pos);
        -:  120:      }
        -:  121:  }
        -:  122:  inline CORBA::ULong maximum() const {
        -:  123:    return maximum_;
        -:  124:  }
        -:  125:  inline CORBA::Boolean release() const {
        -:  126:    return release_;
        -:  127:  }
        -:  128:  inline CORBA::ULong length() const {
        -:  129:    return length_;
        -:  130:  }
        -:  131:  inline void length(CORBA::ULong length) {
        -:  132:    if (length <= maximum_)
        -:  133:      {
        -:  134:        if (this->mb_ == 0)
        -:  135:          {
        -:  136:            length_ = length;
        -:  137:          }
        -:  138:        else
        -:  139:          {
        -:  140:            unbounded_value_sequence<CORBA::Octet> tmp(length);
        -:  141:            tmp.length_ = length;
        -:  142:            element_traits::copy_range(
        -:  143:              buffer_,
        -:  144:              buffer_ + length,
        -:  145:              ACE_make_checked_array_iterator (tmp.buffer_, tmp.length_));
        -:  146:            swap(tmp);
        -:  147:          }
        -:  148:        return;
        -:  149:      }
        -:  150:
        -:  151:    unbounded_value_sequence<CORBA::Octet> tmp(length);
        -:  152:    tmp.length_ = length;
        -:  153:    element_traits::copy_range(
        -:  154:      buffer_,
        -:  155:      buffer_ + length_,
        -:  156:      ACE_make_checked_array_iterator (tmp.buffer_, tmp.length_));
        -:  157:    swap(tmp);
        -:  158:  }
        -:  159:  inline value_type const & operator[](CORBA::ULong i) const {
        -:  160:    range::check(i, length_, maximum_, "operator[]() const");
        -:  161:    return buffer_[i];
        -:  162:  }
        -:  163:  inline value_type & operator[](CORBA::ULong i) {
        -:  164:    range::check(i, length_, maximum_, "operator[]() non-const");
        -:  165:    return buffer_[i];
        -:  166:  }
        -:  167:  inline void replace(
        -:  168:      CORBA::ULong maximum,
        -:  169:      CORBA::ULong length,
        -:  170:      value_type * data,
        -:  171:      CORBA::Boolean release = false) {
        -:  172:    unbounded_value_sequence<CORBA::Octet> tmp(maximum, length, data, release);
        -:  173:    swap(tmp);
        -:  174:  }
        -:  175:  inline value_type const * get_buffer() const {
        -:  176:    if (buffer_ == 0)
        -:  177:      {
        -:  178:        buffer_ = allocbuf(maximum_);
        -:  179:        release_ = true;
        -:  180:      }
        -:  181:    return buffer_;
        -:  182:  }
        -:  183:  inline value_type * get_buffer(CORBA::Boolean orphan = false) {
        -:  184:    if (orphan && !release_)
        -:  185:    {
        -:  186:      return 0;
        -:  187:    }
        -:  188:    if (buffer_ == 0)
        -:  189:    {
        -:  190:      buffer_ = allocbuf(maximum_);
        -:  191:      if (!orphan)
        -:  192:        {
        -:  193:          release_ = true;
        -:  194:        }
        -:  195:    }
        -:  196:    if (!orphan)
        -:  197:    {
        -:  198:      return buffer_;
        -:  199:    }
        -:  200:
        -:  201:    unbounded_value_sequence<CORBA::Octet> tmp;
        -:  202:    swap(tmp);
        -:  203:    tmp.release_ = false;
        -:  204:
        -:  205:    return tmp.buffer_;
        -:  206:  }
        -:  207:
        -:  208:  // moved inside the class to resolve namespace lookup issues.
        -:  209:  // This is a replacement for the commented block below.
        -:  210:  inline bool operator== (const unbounded_value_sequence<CORBA::Octet> & rhs) const {
        -:  211:    unbounded_value_sequence<CORBA::Octet> const & lhs = *this;
        -:  212:    CORBA::ULong const len = lhs.length();
        -:  213:
        -:  214:    // We use the subscript operator instead of get_buffer() to avoid a
        -:  215:    // potential buffer allocation.
        -:  216:    return
        -:  217:      (len == rhs.length()
        -:  218:       && (len == 0
        -:  219:           ? true
        -:  220:           : ACE_OS::memcmp(&lhs[0], &rhs[0], len) == 0));
        -:  221:  }
        -:  222:
        -:  223:  inline bool operator!= (const unbounded_value_sequence<CORBA::Octet> & rhs) const
        -:  224:  {
        -:  225:    return !this->operator==(rhs);
        -:  226:  }
        -:  227:
    #####:  228:  inline void swap(unbounded_value_sequence & rhs) throw() {
    #####:  229:    std::swap (mb_, rhs.mb_);
    #####:  230:    std::swap (maximum_, rhs.maximum_);
    #####:  231:    std::swap (length_, rhs.length_);
    #####:  232:    std::swap (buffer_, rhs.buffer_);
    #####:  233:    std::swap (release_, rhs.release_);
    #####:  234:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE4swapERS1_:
    #####:  228:  inline void swap(unbounded_value_sequence & rhs) throw() {
    #####:  229:    std::swap (mb_, rhs.mb_);
    #####:  230:    std::swap (maximum_, rhs.maximum_);
    #####:  231:    std::swap (length_, rhs.length_);
    #####:  232:    std::swap (buffer_, rhs.buffer_);
    #####:  233:    std::swap (release_, rhs.release_);
    #####:  234:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE4swapERS1_:
    #####:  228:  inline void swap(unbounded_value_sequence & rhs) throw() {
    #####:  229:    std::swap (mb_, rhs.mb_);
    #####:  230:    std::swap (maximum_, rhs.maximum_);
    #####:  231:    std::swap (length_, rhs.length_);
    #####:  232:    std::swap (buffer_, rhs.buffer_);
    #####:  233:    std::swap (release_, rhs.release_);
    #####:  234:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE4swapERS1_:
    #####:  228:  inline void swap(unbounded_value_sequence & rhs) throw() {
    #####:  229:    std::swap (mb_, rhs.mb_);
    #####:  230:    std::swap (maximum_, rhs.maximum_);
    #####:  231:    std::swap (length_, rhs.length_);
    #####:  232:    std::swap (buffer_, rhs.buffer_);
    #####:  233:    std::swap (release_, rhs.release_);
    #####:  234:  }
------------------
    #####:  235:  static value_type * allocbuf(CORBA::ULong maximum) {
    #####:  236:    return allocation_traits::allocbuf(maximum);
        -:  237:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE8allocbufEj:
    #####:  235:  static value_type * allocbuf(CORBA::ULong maximum) {
    #####:  236:    return allocation_traits::allocbuf(maximum);
        -:  237:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE8allocbufEj:
    #####:  235:  static value_type * allocbuf(CORBA::ULong maximum) {
    #####:  236:    return allocation_traits::allocbuf(maximum);
        -:  237:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE8allocbufEj:
    #####:  235:  static value_type * allocbuf(CORBA::ULong maximum) {
    #####:  236:    return allocation_traits::allocbuf(maximum);
        -:  237:  }
------------------
    #####:  238:  static void freebuf(value_type * buffer) {
    #####:  239:    allocation_traits::freebuf(buffer);
    #####:  240:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE7freebufEPh:
    #####:  238:  static void freebuf(value_type * buffer) {
    #####:  239:    allocation_traits::freebuf(buffer);
    #####:  240:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE7freebufEPh:
    #####:  238:  static void freebuf(value_type * buffer) {
    #####:  239:    allocation_traits::freebuf(buffer);
    #####:  240:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhE7freebufEPh:
    #####:  238:  static void freebuf(value_type * buffer) {
    #####:  239:    allocation_traits::freebuf(buffer);
    #####:  240:  }
------------------
        -:  241:
        -:  242:  /// Returns the underlying message block, the caller must *not*
        -:  243:  /// release the copy.
        -:  244:  inline ACE_Message_Block* mb (void) const {
        -:  245:    return mb_;
        -:  246:  }
        -:  247:
        -:  248:  /// Replaces the current buffer with @a mb, using only @a length bytes.
        -:  249:  /// It takes a duplicate of <mb> so the user still owns it.
        -:  250:  inline void replace (CORBA::ULong length, const ACE_Message_Block* mb) {
        -:  251:    unbounded_value_sequence<CORBA::Octet> s (length, mb);
        -:  252:    swap (s);
        -:  253:  }
        -:  254:
    #####:  255:  unbounded_value_sequence<CORBA::Octet> (
        -:  256:    const unbounded_value_sequence<CORBA::Octet> &rhs)
    #####:  257:    : maximum_ (0)
        -:  258:    , length_ (0)
        -:  259:    , buffer_(0)
        -:  260:    , release_(false)
    #####:  261:    , mb_ (0)
        -:  262:  {
    #####:  263:    if (rhs.maximum_ == 0 || rhs.buffer_ == 0)
        -:  264:    {
    #####:  265:      maximum_ = rhs.maximum_;
    #####:  266:      length_ = rhs.length_;
    #####:  267:      return;
        -:  268:    }
    #####:  269:    unbounded_value_sequence<CORBA::Octet> tmp(rhs.maximum_);
    #####:  270:    tmp.length_ = rhs.length_;
    #####:  271:    if (rhs.mb_ == 0)
        -:  272:      {
    #####:  273:        ACE_OS::memcpy (tmp.buffer_,
    #####:  274:                        rhs.buffer_,
    #####:  275:                        rhs.length_);
        -:  276:      }
        -:  277:    else
        -:  278:      {
    #####:  279:        size_t offset = 0;
    #####:  280:        for (const ACE_Message_Block *i = rhs.mb_; i != 0; i = i->cont ())
        -:  281:          {
    #####:  282:            ACE_OS::memcpy (tmp.buffer_ + offset,
    #####:  283:                            i->rd_ptr (),
        -:  284:                            i->length ());
        -:  285:
    #####:  286:            offset += i->length ();
        -:  287:          }
        -:  288:      }
    #####:  289:    swap(tmp);
        -:  290:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhEC2ERKS1_:
    #####:  255:  unbounded_value_sequence<CORBA::Octet> (
        -:  256:    const unbounded_value_sequence<CORBA::Octet> &rhs)
    #####:  257:    : maximum_ (0)
        -:  258:    , length_ (0)
        -:  259:    , buffer_(0)
        -:  260:    , release_(false)
    #####:  261:    , mb_ (0)
        -:  262:  {
    #####:  263:    if (rhs.maximum_ == 0 || rhs.buffer_ == 0)
        -:  264:    {
    #####:  265:      maximum_ = rhs.maximum_;
    #####:  266:      length_ = rhs.length_;
    #####:  267:      return;
        -:  268:    }
    #####:  269:    unbounded_value_sequence<CORBA::Octet> tmp(rhs.maximum_);
    #####:  270:    tmp.length_ = rhs.length_;
    #####:  271:    if (rhs.mb_ == 0)
        -:  272:      {
    #####:  273:        ACE_OS::memcpy (tmp.buffer_,
    #####:  274:                        rhs.buffer_,
    #####:  275:                        rhs.length_);
        -:  276:      }
        -:  277:    else
        -:  278:      {
    #####:  279:        size_t offset = 0;
    #####:  280:        for (const ACE_Message_Block *i = rhs.mb_; i != 0; i = i->cont ())
        -:  281:          {
    #####:  282:            ACE_OS::memcpy (tmp.buffer_ + offset,
    #####:  283:                            i->rd_ptr (),
        -:  284:                            i->length ());
        -:  285:
    #####:  286:            offset += i->length ();
        -:  287:          }
        -:  288:      }
    #####:  289:    swap(tmp);
        -:  290:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhEC2ERKS1_:
    #####:  255:  unbounded_value_sequence<CORBA::Octet> (
        -:  256:    const unbounded_value_sequence<CORBA::Octet> &rhs)
    #####:  257:    : maximum_ (0)
        -:  258:    , length_ (0)
        -:  259:    , buffer_(0)
        -:  260:    , release_(false)
    #####:  261:    , mb_ (0)
        -:  262:  {
    #####:  263:    if (rhs.maximum_ == 0 || rhs.buffer_ == 0)
        -:  264:    {
    #####:  265:      maximum_ = rhs.maximum_;
    #####:  266:      length_ = rhs.length_;
    #####:  267:      return;
        -:  268:    }
    #####:  269:    unbounded_value_sequence<CORBA::Octet> tmp(rhs.maximum_);
    #####:  270:    tmp.length_ = rhs.length_;
    #####:  271:    if (rhs.mb_ == 0)
        -:  272:      {
    #####:  273:        ACE_OS::memcpy (tmp.buffer_,
    #####:  274:                        rhs.buffer_,
    #####:  275:                        rhs.length_);
        -:  276:      }
        -:  277:    else
        -:  278:      {
    #####:  279:        size_t offset = 0;
    #####:  280:        for (const ACE_Message_Block *i = rhs.mb_; i != 0; i = i->cont ())
        -:  281:          {
    #####:  282:            ACE_OS::memcpy (tmp.buffer_ + offset,
    #####:  283:                            i->rd_ptr (),
        -:  284:                            i->length ());
        -:  285:
    #####:  286:            offset += i->length ();
        -:  287:          }
        -:  288:      }
    #####:  289:    swap(tmp);
        -:  290:  }
------------------
_ZN3TAO24unbounded_value_sequenceIhEC2ERKS1_:
    #####:  255:  unbounded_value_sequence<CORBA::Octet> (
        -:  256:    const unbounded_value_sequence<CORBA::Octet> &rhs)
    #####:  257:    : maximum_ (0)
        -:  258:    , length_ (0)
        -:  259:    , buffer_(0)
        -:  260:    , release_(false)
    #####:  261:    , mb_ (0)
        -:  262:  {
    #####:  263:    if (rhs.maximum_ == 0 || rhs.buffer_ == 0)
        -:  264:    {
    #####:  265:      maximum_ = rhs.maximum_;
    #####:  266:      length_ = rhs.length_;
    #####:  267:      return;
        -:  268:    }
    #####:  269:    unbounded_value_sequence<CORBA::Octet> tmp(rhs.maximum_);
    #####:  270:    tmp.length_ = rhs.length_;
    #####:  271:    if (rhs.mb_ == 0)
        -:  272:      {
    #####:  273:        ACE_OS::memcpy (tmp.buffer_,
    #####:  274:                        rhs.buffer_,
    #####:  275:                        rhs.length_);
        -:  276:      }
        -:  277:    else
        -:  278:      {
    #####:  279:        size_t offset = 0;
    #####:  280:        for (const ACE_Message_Block *i = rhs.mb_; i != 0; i = i->cont ())
        -:  281:          {
    #####:  282:            ACE_OS::memcpy (tmp.buffer_ + offset,
    #####:  283:                            i->rd_ptr (),
        -:  284:                            i->length ());
        -:  285:
    #####:  286:            offset += i->length ();
        -:  287:          }
        -:  288:      }
    #####:  289:    swap(tmp);
        -:  290:  }
------------------
        -:  291:
        -:  292:  unbounded_value_sequence<CORBA::Octet> &
    #####:  293:  operator= (const unbounded_value_sequence<CORBA::Octet> & rhs)
        -:  294:  {
    #####:  295:    unbounded_value_sequence<CORBA::Octet> tmp(rhs);
    #####:  296:    swap(tmp);
    #####:  297:    return * this;
        -:  298:  }
        -:  299:
        -:  300:private:
        -:  301:  /// The maximum number of elements the buffer can contain.
        -:  302:  CORBA::ULong maximum_;
        -:  303:
        -:  304:  /// The current number of elements in the buffer.
        -:  305:  CORBA::ULong length_;
        -:  306:
        -:  307:  /// The buffer with all the elements, casting must be done in derived
        -:  308:  /// classes.
        -:  309:  mutable value_type * buffer_;
        -:  310:
        -:  311:  /// If true then the sequence should release the buffer when it is
        -:  312:  /// destroyed.
        -:  313:  mutable CORBA::Boolean release_;
        -:  314:  ACE_Message_Block* mb_;
        -:  315:};
        -:  316:
        -:  317:} // namespace TAO
        -:  318:
        -:  319:TAO_END_VERSIONED_NAMESPACE_DECL
        -:  320:
        -:  321:#endif /* TAO_NO_COPY_OCTET_SEQUENCES == 1 */
        -:  322:
        -:  323:#if (TAO_NO_COPY_OCTET_SEQUENCES == 0)
        -:  324:
        -:  325:// This doesn't work always for unexplained reason. At least
        -:  326:// PortableServer::Active_Object_Map.cpp fails to compile with some compilers.
        -:  327:// But I'm keeping this in for the moment so that it may be
        -:  328:// resurrected if need be
        -:  329:inline
        -:  330:bool
        -:  331:operator== (const TAO_VERSIONED_NAMESPACE_NAME::TAO::unbounded_value_sequence<CORBA::Octet> & lhs,
        -:  332:            const TAO_VERSIONED_NAMESPACE_NAME::TAO::unbounded_value_sequence<CORBA::Octet> & rhs)
        -:  333:{
        -:  334:  ::CORBA::ULong const rlen = rhs.length ();
        -:  335:
        -:  336:  if (rlen != lhs.length ())
        -:  337:    {
        -:  338:      return false;
        -:  339:    }
        -:  340:
        -:  341:  const CORBA::Octet * rhs_buff = rhs.get_buffer ();
        -:  342:  const CORBA::Octet * lhs_buff = lhs.get_buffer ();
        -:  343:  const bool result = (ACE_OS::memcmp (lhs_buff, rhs_buff, rlen) == 0);
        -:  344:
        -:  345:  return result;
        -:  346:}
        -:  347:
        -:  348:inline
        -:  349:bool
        -:  350:operator!= (const TAO_VERSIONED_NAMESPACE_NAME::TAO::unbounded_value_sequence<CORBA::Octet> & lhs,
        -:  351:            const TAO_VERSIONED_NAMESPACE_NAME::TAO::unbounded_value_sequence<CORBA::Octet> & rhs)
        -:  352:{
        -:  353:  return !(lhs == rhs);
        -:  354:}
        -:  355:#endif /* TAO_NO_COPY_OCTET_SEQUENCES==0 */
        -:  356:
        -:  357:#endif // guard_unbounded_octet_sequence_hpp
