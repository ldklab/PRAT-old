        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Value_Sequence_T.h
        -:    0:Programs:72
        -:    1:#ifndef guard_unbounded_value_sequence_hpp
        -:    2:#define guard_unbounded_value_sequence_hpp
        -:    3:/**
        -:    4: * @file
        -:    5: *
        -:    6: * @brief Implement unbounded sequences for types with value-like
        -:    7: * semantics.
        -:    8: *
        -:    9: * $Id: Unbounded_Value_Sequence_T.h 1861 2011-08-31 16:18:08Z mesnierp $
        -:   10: *
        -:   11: * @author Carlos O'Ryan
        -:   12: */
        -:   13:
        -:   14:#include "tao/Unbounded_Value_Allocation_Traits_T.h"
        -:   15:#include "tao/Value_Traits_T.h"
        -:   16:#include "tao/Generic_Sequence_T.h"
        -:   17:
        -:   18:TAO_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   19:
        -:   20:namespace TAO
        -:   21:{
        -:   22:
        -:   23:template<class T>
     1833:   24:class unbounded_value_sequence
        -:   25:{
        -:   26:public:
        -:   27:  typedef T value_type;
        -:   28:  typedef T element_type;
        -:   29:  typedef T const const_value_type;
        -:   30:  typedef value_type & subscript_type;
        -:   31:  typedef value_type const & const_subscript_type;
        -:   32:  typedef ::CORBA::ULong size_type;
        -:   33:
        -:   34:  typedef details::unbounded_value_allocation_traits<value_type,true> allocation_traits;
        -:   35:  typedef details::value_traits<value_type,true> element_traits;
        -:   36:  typedef details::generic_sequence<value_type, allocation_traits, element_traits> implementation_type;
        -:   37:
      789:   38:  inline unbounded_value_sequence()
      789:   39:    : impl_()
      789:   40:  {}
      138:   41:  inline explicit unbounded_value_sequence(CORBA::ULong maximum)
      138:   42:    : impl_(maximum)
      138:   43:  {}
    #####:   44:  inline unbounded_value_sequence(
        -:   45:      CORBA::ULong maximum,
        -:   46:      CORBA::ULong length,
        -:   47:      value_type * data,
        -:   48:      CORBA::Boolean release = false)
    #####:   49:    : impl_(maximum, length, data, release)
    #####:   50:  {}
        -:   51:  /* Use default ctor, operator= and dtor */
        -:   52:  inline CORBA::ULong maximum() const {
        -:   53:    return impl_.maximum();
        -:   54:  }
        -:   55:  inline CORBA::Boolean release() const {
        -:   56:    return impl_.release();
        -:   57:  }
      435:   58:  inline CORBA::ULong length() const {
      435:   59:    return impl_.length();
        -:   60:  }
      354:   61:  inline void length(CORBA::ULong length) {
      354:   62:    impl_.length(length);
      354:   63:  }
      228:   64:  inline value_type const & operator[](CORBA::ULong i) const {
      228:   65:    return impl_[i];
        -:   66:  }
      129:   67:  inline value_type & operator[](CORBA::ULong i) {
      129:   68:    return impl_[i];
        -:   69:  }
        -:   70:  inline void replace(
        -:   71:      CORBA::ULong maximum,
        -:   72:      CORBA::ULong length,
        -:   73:      value_type * data,
        -:   74:      CORBA::Boolean release = false) {
        -:   75:    impl_.replace(maximum, length, data, release);
        -:   76:  }
    #####:   77:  inline value_type const * get_buffer() const {
    #####:   78:    return impl_.get_buffer();
        -:   79:  }
      108:   80:  inline value_type * get_buffer(CORBA::Boolean orphan = false) {
      108:   81:    return impl_.get_buffer(orphan);
        -:   82:  }
      108:   83:  inline void swap(unbounded_value_sequence & rhs) throw() {
      108:   84:    impl_.swap(rhs.impl_);
      108:   85:  }
        -:   86:  static value_type * allocbuf(CORBA::ULong maximum) {
        -:   87:    return implementation_type::allocbuf(maximum);
        -:   88:  }
        -:   89:  static void freebuf(value_type * buffer) {
        -:   90:    implementation_type::freebuf(buffer);
        -:   91:  }
        -:   92:
        -:   93:#if defined TAO_HAS_SEQUENCE_ITERATORS && TAO_HAS_SEQUENCE_ITERATORS == 1
        -:   94:
        -:   95:  ///
        -:   96:  /// Additions to support iterator semantics for TAO unbounded value
        -:   97:  /// sequences.
        -:   98:  ///
        -:   99:
        -:  100:  // = Traits and factory methods that create iterators.
        -:  101:  typedef details::Generic_Sequence_Iterator<details::generic_sequence<value_type, allocation_traits, element_traits> > iterator;
        -:  102:  typedef details::Const_Generic_Sequence_Iterator<details::generic_sequence<value_type, allocation_traits, element_traits> > const_iterator;
        -:  103:  typedef details::Generic_Sequence_Reverse_Iterator<details::generic_sequence<value_type, allocation_traits, element_traits> > reverse_iterator;
        -:  104:  typedef details::Const_Generic_Sequence_Reverse_Iterator<details::generic_sequence<value_type, allocation_traits, element_traits> > const_reverse_iterator;
        -:  105:
        -:  106:  // Get an iterator that points to the beginning of the sequence.
        -:  107:  iterator begin (void)
        -:  108:  {
        -:  109:    return impl_.begin ();
        -:  110:  }
        -:  111:
        -:  112:  // Get a const iterator that points to the beginning of the sequence.
        -:  113:  const_iterator begin (void) const
        -:  114:  {
        -:  115:    return impl_.begin ();
        -:  116:  }
        -:  117:
        -:  118:  // Get an iterator that points to the end of the sequence.
        -:  119:  iterator end (void)
        -:  120:  {
        -:  121:    return impl_.end ();
        -:  122:  }
        -:  123:
        -:  124:  // Get a const iterator that points to the end of the sequence.
        -:  125:  const_iterator end (void) const
        -:  126:  {
        -:  127:    return impl_.end ();
        -:  128:  }
        -:  129:
        -:  130:  // Get a reverse iterator that points to the end of the sequence.
        -:  131:  reverse_iterator rbegin (void)
        -:  132:  {
        -:  133:    return impl_.rbegin ();
        -:  134:  }
        -:  135:
        -:  136:  // Get a const reverse iterator that points to the end of the sequence.
        -:  137:  const_reverse_iterator rbegin (void) const
        -:  138:  {
        -:  139:    return impl_.rbegin ();
        -:  140:  }
        -:  141:
        -:  142:  // Get a reverse iterator that points to one before the beginning
        -:  143:  // of the sequence.
        -:  144:  reverse_iterator rend (void)
        -:  145:  {
        -:  146:    return impl_.rend ();
        -:  147:  }
        -:  148:
        -:  149:  // Get a const reverse iterator that points to one before the
        -:  150:  // beginning of the sequence.
        -:  151:  const_reverse_iterator rend (void) const
        -:  152:  {
        -:  153:    return impl_.rend ();
        -:  154:  }
        -:  155:
        -:  156:#endif /* TAO_HAS_SEQUENCE_ITERATORS==1 */
        -:  157:
        -:  158:private:
        -:  159:  implementation_type impl_;
        -:  160:};
        -:  161:
        -:  162:} // namespace TAO
        -:  163:
        -:  164:TAO_END_VERSIONED_NAMESPACE_DECL
        -:  165:
        -:  166:#endif // guard_unbounded_string_sequence_hpp
        -:  167:
