        -:    0:Source:../dds/DCPS/DataSampleHeader.inl
        -:    0:Programs:72
        -:    1:/*
        -:    2: *
        -:    3: *
        -:    4: * Distributed under the OpenDDS License.
        -:    5: * See: http://www.opendds.org/license.html
        -:    6: */
        -:    7:
        -:    8:ACE_INLINE
       84:    9:OpenDDS::DCPS::DataSampleHeader::DataSampleHeader()
        -:   10:  : message_id_(0)
        -:   11:  , submessage_id_(0)
        -:   12:  , byte_order_(ACE_CDR_BYTE_ORDER)
        -:   13:  , coherent_change_(0)
        -:   14:  , historic_sample_(0)
        -:   15:  , lifespan_duration_(0)
        -:   16:  , group_coherent_(0)
        -:   17:  , content_filter_(0)
        -:   18:  , sequence_repair_(0)
        -:   19:  , more_fragments_(0)
        -:   20:  , cdr_encapsulation_(0)
        -:   21:  , key_fields_only_(0)
        -:   22:  , reserved_1(0)
        -:   23:  , reserved_2(0)
        -:   24:  , reserved_3(0)
        -:   25:  , reserved_4(0)
        -:   26:  , reserved_5(0)
        -:   27:  , reserved_6(0)
        -:   28:  , message_length_(0)
        -:   29:  , sequence_()
        -:   30:  , source_timestamp_sec_(0)
        -:   31:  , source_timestamp_nanosec_(0)
        -:   32:  , lifespan_duration_sec_(0)
        -:   33:  , lifespan_duration_nanosec_(0)
        -:   34:  , publication_id_(GUID_UNKNOWN)
        -:   35:  , publisher_id_(GUID_UNKNOWN)
       84:   36:  , marshaled_size_(0)
        -:   37:{
       84:   38:}
        -:   39:
        -:   40:ACE_INLINE
        -:   41:OpenDDS::DCPS::DataSampleHeader::DataSampleHeader(ACE_Message_Block& buffer)
        -:   42:  : message_id_(0)
        -:   43:  , submessage_id_(0)
        -:   44:  , byte_order_(ACE_CDR_BYTE_ORDER)
        -:   45:  , coherent_change_(0)
        -:   46:  , historic_sample_(0)
        -:   47:  , lifespan_duration_(0)
        -:   48:  , group_coherent_(0)
        -:   49:  , content_filter_(0)
        -:   50:  , sequence_repair_(0)
        -:   51:  , more_fragments_(0)
        -:   52:  , cdr_encapsulation_(0)
        -:   53:  , key_fields_only_(0)
        -:   54:  , reserved_1(0)
        -:   55:  , reserved_2(0)
        -:   56:  , reserved_3(0)
        -:   57:  , reserved_4(0)
        -:   58:  , reserved_5(0)
        -:   59:  , reserved_6(0)
        -:   60:  , message_length_(0)
        -:   61:  , sequence_()
        -:   62:  , source_timestamp_sec_(0)
        -:   63:  , source_timestamp_nanosec_(0)
        -:   64:  , lifespan_duration_sec_(0)
        -:   65:  , lifespan_duration_nanosec_(0)
        -:   66:  , publication_id_(GUID_UNKNOWN)
        -:   67:  , publisher_id_(GUID_UNKNOWN)
        -:   68:{
        -:   69:  this->init(&buffer);
        -:   70:}
        -:   71:
        -:   72:ACE_INLINE
        -:   73:OpenDDS::DCPS::DataSampleHeader&
        -:   74:OpenDDS::DCPS::DataSampleHeader::operator=(ACE_Message_Block& buffer)
        -:   75:{
        -:   76:  this->init(&buffer);
        -:   77:  return *this;
        -:   78:}
        -:   79:
        -:   80:ACE_INLINE
        -:   81:size_t
        -:   82:OpenDDS::DCPS::DataSampleHeader::marshaled_size() const
        -:   83:{
        -:   84:  return marshaled_size_;
        -:   85:}
        -:   86:
        -:   87:ACE_INLINE
        -:   88:size_t
        -:   89:OpenDDS::DCPS::DataSampleHeader::max_marshaled_size()
        -:   90:{
        -:   91:  return 1 + // message_id_;
        -:   92:         1 + // submessage_id_;
        -:   93:         2 + // flags
        -:   94:         4 + // message_length_;
        -:   95:         8 + // sequence_;
        -:   96:         4 + // source_timestamp_sec_;
        -:   97:         4 + // source_timestamp_nanosec_;
        -:   98:         4 + // lifespan_duration_sec_;
        -:   99:         4 + // lifespan_duration_nanosec_;
        -:  100:        16 + // publication_id_;
        -:  101:        16 ; // publisher_id_;
        -:  102:  // content_filter_entries_ is not marsahled into the same Data Block
        -:  103:  // so it is not part of the max_marshaled_size() which is used to allocate
        -:  104:}
        -:  105:
        -:  106:/// The clear_flag and set_flag methods are a hack to update the
        -:  107:/// header flags after a sample has been serialized without
        -:  108:/// deserializing the entire message. This method will break if
        -:  109:/// the current Serializer behavior changes.
        -:  110:
        -:  111:ACE_INLINE
        -:  112:void
        -:  113:OpenDDS::DCPS::DataSampleHeader::clear_flag(DataSampleHeaderFlag flag,
        -:  114:                                            ACE_Message_Block* buffer)
        -:  115:{
        -:  116:  char* base = buffer->base();
        -:  117:
        -:  118:  // verify sufficient length exists:
        -:  119:  if (static_cast<size_t>(buffer->end() - base) < FLAGS_OFFSET + 1) {
        -:  120:    ACE_ERROR((LM_ERROR,
        -:  121:               ACE_TEXT("(%P|%t) ERROR: DataSampleHeader::clear_flag: ")
        -:  122:               ACE_TEXT("ACE_Message_Block too short (missing flags octet).\n")));
        -:  123:    return;
        -:  124:  }
        -:  125:
        -:  126:  base[FLAGS_OFFSET] &= ~mask_flag(flag);
        -:  127:}
        -:  128:
        -:  129:ACE_INLINE
        -:  130:void
        -:  131:OpenDDS::DCPS::DataSampleHeader::set_flag(DataSampleHeaderFlag flag,
        -:  132:                                          ACE_Message_Block* buffer)
        -:  133:{
        -:  134:  char* base = buffer->base();
        -:  135:
        -:  136:  // verify sufficient length exists:
        -:  137:  if (static_cast<size_t>(buffer->end() - base) < FLAGS_OFFSET + 1) {
        -:  138:    ACE_ERROR((LM_ERROR,
        -:  139:               ACE_TEXT("(%P|%t) ERROR: DataSampleHeader::set_flag: ")
        -:  140:               ACE_TEXT("ACE_Message_Block too short (missing flags octet).\n")));
        -:  141:    return;
        -:  142:  }
        -:  143:
        -:  144:  base[FLAGS_OFFSET] |= mask_flag(flag);
        -:  145:}
        -:  146:
        -:  147:ACE_INLINE
        -:  148:bool
        -:  149:OpenDDS::DCPS::DataSampleHeader::test_flag(DataSampleHeaderFlag flag,
        -:  150:                                           const ACE_Message_Block* buffer)
        -:  151:{
        -:  152:  char* base = buffer->base();
        -:  153:
        -:  154:  // verify sufficient length exists:
        -:  155:  if (static_cast<size_t>(buffer->end() - base) < FLAGS_OFFSET + 1) {
        -:  156:    ACE_ERROR_RETURN((LM_ERROR,
        -:  157:                      ACE_TEXT("(%P|%t) ERROR: DataSampleHeader::set_flag: ")
        -:  158:                      ACE_TEXT("ACE_Message_Block too short (missing flags octet).\n")), false);
        -:  159:  }
        -:  160:
        -:  161:  // Test flag bit.
        -:  162:  return base[FLAGS_OFFSET] & mask_flag(flag);
        -:  163:}
        -:  164:
    #####:  165:ACE_INLINE bool OpenDDS::DCPS::DataSampleHeader::valid_data() const {
    #####:  166:  return !(message_id_ == DISPOSE_INSTANCE
    #####:  167:    || message_id_ == DISPOSE_UNREGISTER_INSTANCE
    #####:  168:    || message_id_ == UNREGISTER_INSTANCE
    #####:  169:  );
        -:  170:}
