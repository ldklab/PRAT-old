        -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Singleton.h
        -:    0:Programs:51
        -:    1:// -*- C++ -*-
        -:    2:
        -:    3://=============================================================================
        -:    4:/**
        -:    5: *  @file    Singleton.h
        -:    6: *
        -:    7: *  $Id: Singleton.h 2622 2015-08-13 18:30:00Z mitza $
        -:    8: *
        -:    9: *  @brief
        -:   10: *
        -:   11: *  @author Tim Harrison <harrison@cs.wustl.edu>
        -:   12: *  @author Douglas C. Schmidt <schmidt@cs.wustl.edu>
        -:   13: *  @author Chris Lahey
        -:   14: *  @author Rich Christy
        -:   15: *  @author David Levine <levine@cs.wustl.edu>
        -:   16: */
        -:   17://=============================================================================
        -:   18:
        -:   19:#ifndef ACE_SINGLETON_H
        -:   20:#define ACE_SINGLETON_H
        -:   21:#include /**/ "ace/pre.h"
        -:   22:
        -:   23:#include /**/ "ace/config-all.h"
        -:   24:#include "ace/TSS_T.h"
        -:   25:#include "ace/Cleanup.h"
        -:   26:
        -:   27:#if !defined (ACE_LACKS_PRAGMA_ONCE)
        -:   28:# pragma once
        -:   29:#endif /* ACE_LACKS_PRAGMA_ONCE */
        -:   30:
        -:   31:ACE_BEGIN_VERSIONED_NAMESPACE_DECL
        -:   32:
        -:   33:/**
        -:   34: * @class ACE_Singleton
        -:   35: *
        -:   36: * @brief A Singleton Adapter uses the Adapter pattern to turn ordinary
        -:   37: * classes into Singletons optimized with the Double-Checked
        -:   38: * Locking optimization pattern.
        -:   39: *
        -:   40: * This implementation is a slight variation on the GoF
        -:   41: * Singleton pattern.  In particular, a single
        -:   42: * <ACE_Singleton<TYPE, ACE_LOCK> > instance is allocated here,
        -:   43: * not a <TYPE> instance.  The reason for this is to allow
        -:   44: * registration with the ACE_Object_Manager, so that the
        -:   45: * Singleton can be cleaned up when the process exits.  For this
        -:   46: * scheme to work, a (static) cleanup() function must be
        -:   47: * provided.  ACE_Singleton provides one so that TYPE doesn't
        -:   48: * need to.
        -:   49: * If you want to make sure that only the singleton instance of
        -:   50: * <T> is created, and that users cannot create their own
        -:   51: * instances of <T>, do the following to class <T>:
        -:   52: * (a) Make the constructor of <T> private (or protected)
        -:   53: * (b) Make Singleton a friend of <T>
        -:   54: * Here is an example:
        -:   55: * @verbatim
        -:   56: * class foo
        -:   57: * {
        -:   58: * friend class ACE_Singleton<foo, ACE_Null_Mutex>;
        -:   59: * private:
        -:   60: * foo () { cout << "foo constructed" << endl; }
        -:   61: * ~foo () { cout << "foo destroyed" << endl; }
        -:   62: * };
        -:   63: * typedef ACE_Singleton<foo, ACE_Null_Mutex> FOO;
        -:   64: * @endverbatim
        -:   65: *
        -:   66: * @note The best types to use for ACE_LOCK are
        -:   67: * ACE_Recursive_Thread_Mutex and ACE_Null_Mutex.
        -:   68: * ACE_Recursive_Thread_Mutex should be used in multi-threaded
        -:   69: * programs in which it is possible for more than one thread to
        -:   70: * access the <ACE_Singleton<TYPE, ACE_LOCK>> instance.
        -:   71: * ACE_Null_Mutex can be used otherwise.  The reason that these
        -:   72: * types of locks are best has to do with their allocation by
        -:   73: * the ACE_Object_Manager.  Single ACE_Recursive_Thread_Mutex
        -:   74: * and ACE_Null_Mutex instances are used for all ACE_Singleton
        -:   75: * instantiations.  However, other types of locks are allocated
        -:   76: * per ACE_Singleton instantiation.
        -:   77: */
        -:   78:template <class TYPE, class ACE_LOCK>
        7:   79:class ACE_Singleton : public ACE_Cleanup
        -:   80:{
        -:   81:public:
        -:   82:  /// Global access point to the Singleton.
        -:   83:  static TYPE *instance (void);
        -:   84:
        -:   85:  /// Cleanup method, used by @c ace_cleanup_destroyer to destroy the
        -:   86:  /// ACE_Singleton.
        -:   87:  virtual void cleanup (void *param = 0);
        -:   88:
        -:   89:  /// Explicitly delete the Singleton instance.
        -:   90:  static void close (void);
        -:   91:
        -:   92:  /// Dump the state of the object.
        -:   93:  static void dump (void);
        -:   94:
        -:   95:  /// Declare the dynamic allocation hooks.
        -:   96:  ACE_ALLOC_HOOK_DECLARE;
        -:   97:
        -:   98:protected:
        -:   99:  /// Default constructor.
        -:  100:  ACE_Singleton (void);
        -:  101:
        -:  102:  /// Contained instance.
        -:  103:  TYPE instance_;
        -:  104:
        -:  105:#if !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES)
        -:  106:  /// Pointer to the Singleton (ACE_Cleanup) instance.
        -:  107:  static ACE_Singleton<TYPE, ACE_LOCK> *singleton_;
        -:  108:#endif /* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
        -:  109:
        -:  110:  /// Get pointer to the Singleton instance.
        -:  111:  static ACE_Singleton<TYPE, ACE_LOCK> *&instance_i (void);
        -:  112:};
        -:  113:
        -:  114:/**
        -:  115: * @class ACE_Unmanaged_Singleton
        -:  116: *
        -:  117: * @brief Same as ACE_Singleton, except does _not_ register with
        -:  118: * ACE_Object_Manager for destruction.
        -:  119: *
        -:  120: * This version of ACE_Singleton can be used if, for example,
        -:  121: * its DLL will be unloaded before the ACE_Object_Manager
        -:  122: * destroys the instance.  Unlike with ACE_Singleton, the
        -:  123: * application is responsible for explicitly destroying the
        -:  124: * instance after it is no longer needed (if it wants to avoid
        -:  125: * memory leaks, at least).  The close() static member function
        -:  126: * must be used to explicitly destroy the Singleton.
        -:  127: * Usage is the same as for ACE_Singleton, but note that if you
        -:  128: * you declare a friend, the friend class must still be an
        -:  129: * *ACE_Singleton*<T, [ACE_LOCK]>, not an ACE_Unmanaged_Singleton.
        -:  130: */
        -:  131:template <class TYPE, class ACE_LOCK>
       14:  132:class ACE_Unmanaged_Singleton : public ACE_Singleton <TYPE, ACE_LOCK>
        -:  133:{
        -:  134:public:
        -:  135:  /// Global access point to the Singleton.
        -:  136:  static TYPE *instance (void);
        -:  137:
        -:  138:  /// Explicitly delete the Singleton instance.
        -:  139:  static void close (void);
        -:  140:
        -:  141:  /// Dump the state of the object.
        -:  142:  static void dump (void);
        -:  143:
        -:  144:  /// Declare the dynamic allocation hooks.
        -:  145:  ACE_ALLOC_HOOK_DECLARE;
        -:  146:
        -:  147:protected:
        -:  148:  /// Default constructor.
        -:  149:  ACE_Unmanaged_Singleton (void);
        -:  150:
        -:  151:#if !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES)
        -:  152:  /// Pointer to the Singleton (ACE_Cleanup) instance.
        -:  153:  static ACE_Unmanaged_Singleton<TYPE, ACE_LOCK> *singleton_;
        -:  154:#endif /* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
        -:  155:
        -:  156:  /// Get pointer to the Singleton instance.
        -:  157:  static ACE_Unmanaged_Singleton<TYPE, ACE_LOCK> *&instance_i (void);
        -:  158:};
        -:  159:
        -:  160:/**
        -:  161: * @class ACE_TSS_Singleton
        -:  162: *
        -:  163: * @brief This class uses the Adapter pattern to turn ordinary classes
        -:  164: * into Thread-specific Singletons optimized with the
        -:  165: * Double-Checked Locking optimization pattern.
        -:  166: *
        -:  167: * This implementation is another variation on the GoF Singleton
        -:  168: * pattern.  In this case, a single <ACE_TSS_Singleton<TYPE,
        -:  169: * LOCK> > instance is allocated here, not a <TYPE> instance.
        -:  170: * Each call to the <instance> static method returns a Singleton
        -:  171: * whose pointer resides in thread-specific storage.  As with
        -:  172: * ACE_Singleton, we use the ACE_Object_Manager so that the
        -:  173: * Singleton can be cleaned up when the process exits.  For this
        -:  174: * scheme to work, a (static) cleanup() function must be
        -:  175: * provided.  ACE_Singleton provides one so that TYPE doesn't
        -:  176: * need to.
        -:  177: */
        -:  178:template <class TYPE, class ACE_LOCK>
        -:  179:class ACE_TSS_Singleton : public ACE_Cleanup
        -:  180:{
        -:  181:public:
        -:  182:  /// Global access point to the singleton.
        -:  183:  static TYPE *instance (void);
        -:  184:
        -:  185:  /// Cleanup method, used by <ace_cleanup_destroyer> to destroy the
        -:  186:  /// singleton.
        -:  187:  virtual void cleanup (void *param = 0);
        -:  188:
        -:  189:  /// Dump the state of the object.
        -:  190:  static void dump (void);
        -:  191:
        -:  192:  /// Declare the dynamic allocation hooks.
        -:  193:  ACE_ALLOC_HOOK_DECLARE;
        -:  194:
        -:  195:protected:
        -:  196:  /// Default constructor.
        -:  197:  ACE_TSS_Singleton (void);
        -:  198:
        -:  199:  /// Contained instance.
        -:  200:  ACE_TSS_TYPE (TYPE) instance_;
        -:  201:
        -:  202:  ACE_UNIMPLEMENTED_FUNC (void operator= (const ACE_TSS_Singleton<TYPE,ACE_LOCK> &))
        -:  203:  ACE_UNIMPLEMENTED_FUNC (ACE_TSS_Singleton (const ACE_TSS_Singleton<TYPE,ACE_LOCK> &))
        -:  204:
        -:  205:#if !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES)
        -:  206:  /// Pointer to the Singleton (ACE_Cleanup) instance.
        -:  207:  static ACE_TSS_Singleton<TYPE, ACE_LOCK> *singleton_;
        -:  208:#endif /* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
        -:  209:
        -:  210:  /// Get pointer to the TSS Singleton instance.
        -:  211:  static ACE_TSS_Singleton<TYPE, ACE_LOCK> *&instance_i (void);
        -:  212:};
        -:  213:
        -:  214:/**
        -:  215: * @class ACE_Unmanaged_TSS_Singleton
        -:  216: *
        -:  217: * @brief Same as ACE_TSS_Singleton, except does _not_ register with
        -:  218: * ACE_Object_Manager for destruction.
        -:  219: *
        -:  220: * This version of ACE_TSS_Singleton can be used if, for example, its DLL will
        -:  221: * be unloaded before the ACE_Object_Manager destroys the instance.  Unlike with
        -:  222: * ACE_Singleton, the application is responsible for explicitly destroying the
        -:  223: * instance after it is no longer needed (if it wants to avoid memory leaks,
        -:  224: * at least).  The close() static member function must be used to explicitly
        -:  225: * destroy the Singleton.
        -:  226: */
        -:  227:template <class TYPE, class ACE_LOCK>
        -:  228:class ACE_Unmanaged_TSS_Singleton : public ACE_TSS_Singleton <TYPE, ACE_LOCK>
        -:  229:{
        -:  230:public:
        -:  231:  /// Global access point to the singleton.
        -:  232:  static TYPE *instance (void);
        -:  233:
        -:  234:  /// Explicitly delete the singleton instance.
        -:  235:  static void close (void);
        -:  236:
        -:  237:  /// Dump the state of the object.
        -:  238:  static void dump (void);
        -:  239:
        -:  240:  /// Declare the dynamic allocation hooks.
        -:  241:  ACE_ALLOC_HOOK_DECLARE;
        -:  242:
        -:  243:protected:
        -:  244:  /// Default constructor.
        -:  245:  ACE_Unmanaged_TSS_Singleton (void);
        -:  246:
        -:  247:#if !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES)
        -:  248:  /// Pointer to the Singleton (ACE_Cleanup) instance.
        -:  249:  static ACE_Unmanaged_TSS_Singleton<TYPE, ACE_LOCK> *singleton_;
        -:  250:#endif /* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
        -:  251:
        -:  252:  /// Get pointer to the Singleton instance.
        -:  253:  static ACE_Unmanaged_TSS_Singleton<TYPE, ACE_LOCK> *&instance_i (void);
        -:  254:};
        -:  255:
        -:  256:/**
        -:  257: * @class ACE_DLL_Singleton_T
        -:  258: *
        -:  259: * @brief Same as ACE_Singleton, except that it registers for
        -:  260: * destruction with the ACE_Framework_Repository instead of
        -:  261: * with the ACE_Object_Manager directly.
        -:  262: *
        -:  263: * This version of ACE_Singleton should be used for singletons
        -:  264: * that live in a dll loaded either directly by ACE_DLL or indirectly
        -:  265: * by the ACE Service Configuration framework.  Whenever ACE_DLL is ready
        -:  266: * to actually unload the dll, ACE_DLL_Singleton based dlls associated
        -:  267: * with that dll will be destroyed first.  In fact, any singleton can
        -:  268: * safely use ACE_DLL_Singleton, even those that don't live in dlls.  In
        -:  269: * that case, the singleton will be destroyed at normal program shutdown.
        -:  270: *
        -:  271: * The only additional requirement is that the contained class
        -:  272: * export name() and dll_name() methods.  See ACE_DLL_Singleton_Adapter_T
        -:  273: * below for a convenient example of how to satisfy this
        -:  274: * requirement for the dll_name().
        -:  275: *
        -:  276: * Usage is the same as for ACE_Singleton, but note that if you
        -:  277: * you declare a friend, the friend class must still be an
        -:  278: * *ACE_Singleton*<T, [ACE_LOCK]>, not an ACE_Unmanaged_Singleton.
        -:  279: */
        -:  280:template <class TYPE, class ACE_LOCK>
        -:  281:class ACE_DLL_Singleton_T
        -:  282:{
        -:  283:public:
        -:  284:  //void cleanup (void *param = 0);
        -:  285:
        -:  286:  /// Global access point to the Singleton.
        -:  287:  static TYPE *instance (void);
        -:  288:
        -:  289:  /// Explicitly delete the Singleton instance.
        -:  290:  static void close (void);
        -:  291:
        -:  292:  static void close_singleton (void);
        -:  293:
        -:  294:  /// Dump the state of the object.
        -:  295:  static void dump (void);
        -:  296:
        -:  297:  const ACE_TCHAR *dll_name (void);
        -:  298:
        -:  299:  const ACE_TCHAR *name (void);
        -:  300:
        -:  301:  /// Declare the dynamic allocation hooks.
        -:  302:  ACE_ALLOC_HOOK_DECLARE;
        -:  303:
        -:  304:protected:
        -:  305:  /// Default constructor.
        -:  306:  ACE_DLL_Singleton_T (void);
        -:  307:
        -:  308:  /// Destructor.
        -:  309:  ~ACE_DLL_Singleton_T (void);
        -:  310:
        -:  311:  /// Contained instance.
        -:  312:  TYPE instance_;
        -:  313:
        -:  314:#if !defined (ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES)
        -:  315:  /// Pointer to the Singleton instance.
        -:  316:  static ACE_DLL_Singleton_T<TYPE, ACE_LOCK> *singleton_;
        -:  317:#endif /* ACE_LACKS_STATIC_DATA_MEMBER_TEMPLATES */
        -:  318:
        -:  319:  /// Get pointer to the singleton instance.
        -:  320:  static ACE_DLL_Singleton_T<TYPE, ACE_LOCK> *&instance_i (void);
        -:  321:};
        -:  322:
        -:  323:template <class TYPE>
        -:  324:class ACE_DLL_Singleton_Adapter_T : public TYPE
        -:  325:{
        -:  326:public:
        -:  327:  const ACE_TCHAR *dll_name (void);
        -:  328:
        -:  329:  /// Declare the dynamic allocation hooks.
        -:  330:  ACE_ALLOC_HOOK_DECLARE;
        -:  331:};
        -:  332:
        -:  333:ACE_END_VERSIONED_NAMESPACE_DECL
        -:  334:
        -:  335:#if defined (__ACE_INLINE__)
        -:  336:#include "ace/Singleton.inl"
        -:  337:#endif /* __ACE_INLINE__ */
        -:  338:
        -:  339:#if defined (ACE_TEMPLATES_REQUIRE_SOURCE)
        -:  340:#include "ace/Singleton.cpp"
        -:  341:#endif /* ACE_TEMPLATES_REQUIRE_SOURCE */
        -:  342:
        -:  343:#if defined (ACE_TEMPLATES_REQUIRE_PRAGMA)
        -:  344:#pragma implementation ("Singleton.cpp")
        -:  345:#endif /* ACE_TEMPLATES_REQUIRE_PRAGMA */
        -:  346:
        -:  347:#include /**/ "ace/post.h"
        -:  348:#endif /* ACE_SINGLETON_H */
