1,2c1,2
<         -:    0:Source:/usr/include/c++/8/bits/basic_string.tcc
<         -:    0:Programs:51
---
>         -:    0:Source:/usr/include/c++/7/bits/basic_string.tcc
>         -:    0:Programs:69
5c5
<         -:    3:// Copyright (C) 1997-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 1997-2017 Free Software Foundation, Inc.
208c208
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
---
>       833:  206:      basic_string<_CharT, _Traits, _Alloc>::
213c213
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
---
>       833:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
217c217
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
---
>       833:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
219c219
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
---
>       833:  217:	if (__dnew > size_type(_S_local_capacity))
221,222c221,222
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
---
>       289:  219:	    _M_data(_M_create(__dnew, size_type(0)));
>       289:  220:	    _M_capacity(__dnew);
227c227
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
---
>       833:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
234,476c234,235
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPcEEvT_S7_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPcEEvT_S7_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPcEEvT_S7_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPcEEvT_S7_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
< _ZNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEE12_M_constructIPKcEEvT_S8_St20forward_iterator_tag:
<     #####:  206:      basic_string<_CharT, _Traits, _Alloc>::
<         -:  207:      _M_construct(_InIterator __beg, _InIterator __end,
<         -:  208:		   std::forward_iterator_tag)
<         -:  209:      {
<         -:  210:	// NB: Not required, but considered best practice.
<     #####:  211:	if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
<     #####:  212:	  std::__throw_logic_error(__N("basic_string::"
<         -:  213:				       "_M_construct null not valid"));
<         -:  214:
<     #####:  215:	size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));
<         -:  216:
<     #####:  217:	if (__dnew > size_type(_S_local_capacity))
<         -:  218:	  {
<     #####:  219:	    _M_data(_M_create(__dnew, size_type(0)));
<     #####:  220:	    _M_capacity(__dnew);
<         -:  221:	  }
<         -:  222:
<         -:  223:	// Check for out_of_range and length_error exceptions.
<         -:  224:	__try
<     #####:  225:	  { this->_S_copy_chars(_M_data(), __beg, __end); }
<     =====:  226:	__catch(...)
<         -:  227:	  {
<     =====:  228:	    _M_dispose();
<     =====:  229:	    __throw_exception_again;
<         -:  230:	  }
<         -:  231:
<     #####:  232:	_M_set_length(__dnew);
<     #####:  233:      }
< ------------------
---
>       833:  232:	_M_set_length(__dnew);
>       833:  233:      }
1400c1159
<         -: 1157:    operator+(const _CharT* __lhs,
---
>     #####: 1157:    operator+(const _CharT* __lhs,
1406,1411c1165,1170
<         -: 1163:      const __size_type __len = _Traits::length(__lhs);
<         -: 1164:      __string_type __str;
<         -: 1165:      __str.reserve(__len + __rhs.size());
<         -: 1166:      __str.append(__lhs, __len);
<         -: 1167:      __str.append(__rhs);
<         -: 1168:      return __str;
---
>     #####: 1163:      const __size_type __len = _Traits::length(__lhs);
>     #####: 1164:      __string_type __str;
>     #####: 1165:      __str.reserve(__len + __rhs.size());
>     #####: 1166:      __str.append(__lhs, __len);
>     #####: 1167:      __str.append(__rhs);
>     #####: 1168:      return __str;
