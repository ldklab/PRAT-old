105c105
<        57:  103:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Octet> & target) {
---
>     #####:  103:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Octet> & target) {
107,108c107,108
<        57:  105:    ::CORBA::ULong new_length = 0;
<        57:  106:    if (!(strm >> new_length)) {
---
>     #####:  105:    ::CORBA::ULong new_length = 0;
>     #####:  106:    if (!(strm >> new_length)) {
111c111
<        57:  109:    if (new_length > strm.length()) {
---
>     #####:  109:    if (new_length > strm.length()) {
114,116c114,116
<       114:  112:    sequence tmp(new_length);
<        57:  113:    tmp.length(new_length);
<        57:  114:    if (ACE_BIT_DISABLED (strm.start ()->flags (), ACE_Message_Block::DONT_DELETE))
---
>     #####:  112:    sequence tmp(new_length);
>     #####:  113:    tmp.length(new_length);
>     #####:  114:    if (ACE_BIT_DISABLED (strm.start ()->flags (), ACE_Message_Block::DONT_DELETE))
118,120c118,120
<        12:  116:      TAO_ORB_Core* orb_core = strm.orb_core ();
<       24*:  117:      if (orb_core != 0 && strm.orb_core ()->resource_factory ()->
<        12:  118:        input_cdr_allocator_type_locked () == 1)
---
>     #####:  116:      TAO_ORB_Core* orb_core = strm.orb_core ();
>     #####:  117:      if (orb_core != 0 && strm.orb_core ()->resource_factory ()->
>     #####:  118:        input_cdr_allocator_type_locked () == 1)
122,126c122,126
<        12:  120:        tmp.replace (new_length, strm.start ());
<        12:  121:        tmp.mb ()->wr_ptr (tmp.mb()->rd_ptr () + new_length);
<        12:  122:        strm.skip_bytes (new_length);
<        12:  123:        tmp.swap(target);
<        12:  124:        return true;
---
>     #####:  120:        tmp.replace (new_length, strm.start ());
>     #####:  121:        tmp.mb ()->wr_ptr (tmp.mb()->rd_ptr () + new_length);
>     #####:  122:        strm.skip_bytes (new_length);
>     #####:  123:        tmp.swap(target);
>     #####:  124:        return true;
129,130c129,130
<        45:  127:    typename sequence::value_type * buffer = tmp.get_buffer();
<        45:  128:    if (!strm.read_octet_array (buffer, new_length)) {
---
>     #####:  127:    typename sequence::value_type * buffer = tmp.get_buffer();
>     #####:  128:    if (!strm.read_octet_array (buffer, new_length)) {
133,134c133,134
<        45:  131:    tmp.swap(target);
<        45:  132:    return true;
---
>     #####:  131:    tmp.swap(target);
>     #####:  132:    return true;
321c321
<       19*:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
---
>     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
323,324c323,324
<       19*:  321:    ::CORBA::ULong new_length = 0;
<       19*:  322:    if (!(strm >> new_length)) {
---
>     #####:  321:    ::CORBA::ULong new_length = 0;
>     #####:  322:    if (!(strm >> new_length)) {
327c327
<       19*:  325:    if (new_length > strm.length()) {
---
>     #####:  325:    if (new_length > strm.length()) {
330,334c330,334
<       38*:  328:    sequence tmp(new_length);
<       19*:  329:    tmp.length(new_length);
<       19*:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<       34*:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<       15*:  332:      if (!(strm >> buffer[i])) {
---
>     #####:  328:    sequence tmp(new_length);
>     #####:  329:    tmp.length(new_length);
>     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
>     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
>     #####:  332:      if (!(strm >> buffer[i])) {
338,339c338,339
<       19*:  336:    tmp.swap(target);
<       19*:  337:    return true;
---
>     #####:  336:    tmp.swap(target);
>     #####:  337:    return true;
365c365
<         2:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
---
>     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
367,368c367,368
<         2:  321:    ::CORBA::ULong new_length = 0;
<         2:  322:    if (!(strm >> new_length)) {
---
>     #####:  321:    ::CORBA::ULong new_length = 0;
>     #####:  322:    if (!(strm >> new_length)) {
371c371
<         2:  325:    if (new_length > strm.length()) {
---
>     #####:  325:    if (new_length > strm.length()) {
374,377c374,377
<         4:  328:    sequence tmp(new_length);
<         2:  329:    tmp.length(new_length);
<         2:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<        2*:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
---
>     #####:  328:    sequence tmp(new_length);
>     #####:  329:    tmp.length(new_length);
>     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
>     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
382,383c382,383
<         2:  336:    tmp.swap(target);
<         2:  337:    return true;
---
>     #####:  336:    tmp.swap(target);
>     #####:  337:    return true;
387c387
<         2:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
---
>     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
389,390c389,390
<         2:  321:    ::CORBA::ULong new_length = 0;
<         2:  322:    if (!(strm >> new_length)) {
---
>     #####:  321:    ::CORBA::ULong new_length = 0;
>     #####:  322:    if (!(strm >> new_length)) {
393c393
<         2:  325:    if (new_length > strm.length()) {
---
>     #####:  325:    if (new_length > strm.length()) {
396,399c396,399
<         4:  328:    sequence tmp(new_length);
<         2:  329:    tmp.length(new_length);
<         2:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<        2*:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
---
>     #####:  328:    sequence tmp(new_length);
>     #####:  329:    tmp.length(new_length);
>     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
>     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
404,405c404,405
<         2:  336:    tmp.swap(target);
<         2:  337:    return true;
---
>     #####:  336:    tmp.swap(target);
>     #####:  337:    return true;
497c497
<        15:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
---
>     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
499,500c499,500
<        15:  321:    ::CORBA::ULong new_length = 0;
<        15:  322:    if (!(strm >> new_length)) {
---
>     #####:  321:    ::CORBA::ULong new_length = 0;
>     #####:  322:    if (!(strm >> new_length)) {
503c503
<        15:  325:    if (new_length > strm.length()) {
---
>     #####:  325:    if (new_length > strm.length()) {
506,510c506,510
<        30:  328:    sequence tmp(new_length);
<        15:  329:    tmp.length(new_length);
<        15:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<        30:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<        15:  332:      if (!(strm >> buffer[i])) {
---
>     #####:  328:    sequence tmp(new_length);
>     #####:  329:    tmp.length(new_length);
>     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
>     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
>     #####:  332:      if (!(strm >> buffer[i])) {
514,515c514,515
<        15:  336:    tmp.swap(target);
<        15:  337:    return true;
---
>     #####:  336:    tmp.swap(target);
>     #####:  337:    return true;
542c542
<        25:  341:  bool demarshal_sequence(stream & strm, TAO::unbounded_basic_string_sequence <charT> & target) {
---
>     #####:  341:  bool demarshal_sequence(stream & strm, TAO::unbounded_basic_string_sequence <charT> & target) {
546,547c546,547
<        25:  345:    ::CORBA::ULong new_length = 0;
<        25:  346:    if (!(strm >> new_length)) {
---
>     #####:  345:    ::CORBA::ULong new_length = 0;
>     #####:  346:    if (!(strm >> new_length)) {
550c550
<        25:  349:    if (new_length > strm.length()) {
---
>     #####:  349:    if (new_length > strm.length()) {
553c553
<        50:  352:    sequence tmp(new_length, new_length,
---
>     #####:  352:    sequence tmp(new_length, new_length,
556c556
<       25*:  355:    for(CORBA::ULong i = 0; i < new_length; ++i) {
---
>     #####:  355:    for(CORBA::ULong i = 0; i < new_length; ++i) {
565,566c565,566
<        25:  364:    tmp.swap(target);
<        25:  365:    return true;
---
>     #####:  364:    tmp.swap(target);
>     #####:  365:    return true;
665,667c665,667
<        51:  464:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Octet> & source) {
<        51:  465:    ::CORBA::ULong const length = source.length ();
<        51:  466:    if (!(strm << length)) {
---
>     #####:  464:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Octet> & source) {
>     #####:  465:    ::CORBA::ULong const length = source.length ();
>     #####:  466:    if (!(strm << length)) {
670c670
<        51:  469:    if (source.mb ()) {
---
>     #####:  469:    if (source.mb ()) {
673c673
<        51:  472:    return strm.write_octet_array (source.get_buffer (), length);
---
>     #####:  472:    return strm.write_octet_array (source.get_buffer (), length);
761,763c761,763
<       18*:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<       18*:  561:    ::CORBA::ULong const length = source.length ();
<       18*:  562:    if (!(strm << length)) {
---
>     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
>     #####:  561:    ::CORBA::ULong const length = source.length ();
>     #####:  562:    if (!(strm << length)) {
766,767c766,767
<       34*:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<       16*:  566:      if (!(strm << source[i])) {
---
>     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
>     #####:  566:      if (!(strm << source[i])) {
771c771
<       18*:  570:    return true;
---
>     #####:  570:    return true;
789,791c789,791
<         1:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<         1:  561:    ::CORBA::ULong const length = source.length ();
<         1:  562:    if (!(strm << length)) {
---
>     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
>     #####:  561:    ::CORBA::ULong const length = source.length ();
>     #####:  562:    if (!(strm << length)) {
794c794
<        1*:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
---
>     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
799c799
<         1:  570:    return true;
---
>     #####:  570:    return true;
803,805c803,805
<         1:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<         1:  561:    ::CORBA::ULong const length = source.length ();
<         1:  562:    if (!(strm << length)) {
---
>     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
>     #####:  561:    ::CORBA::ULong const length = source.length ();
>     #####:  562:    if (!(strm << length)) {
808c808
<        1*:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
---
>     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
813c813
<         1:  570:    return true;
---
>     #####:  570:    return true;
831,833c831,833
<         1:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<         1:  561:    ::CORBA::ULong const length = source.length ();
<         1:  562:    if (!(strm << length)) {
---
>     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
>     #####:  561:    ::CORBA::ULong const length = source.length ();
>     #####:  562:    if (!(strm << length)) {
836,837c836,837
<         2:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<         1:  566:      if (!(strm << source[i])) {
---
>     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
>     #####:  566:      if (!(strm << source[i])) {
841c841
<         1:  570:    return true;
---
>     #####:  570:    return true;
873,875c873,875
<        15:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<        15:  561:    ::CORBA::ULong const length = source.length ();
<        15:  562:    if (!(strm << length)) {
---
>     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
>     #####:  561:    ::CORBA::ULong const length = source.length ();
>     #####:  562:    if (!(strm << length)) {
878,879c878,879
<        30:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<        15:  566:      if (!(strm << source[i])) {
---
>     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
>     #####:  566:      if (!(strm << source[i])) {
883c883
<        15:  570:    return true;
---
>     #####:  570:    return true;
902,904c902,904
<        20:  574:  bool marshal_sequence(stream & strm, const TAO::unbounded_basic_string_sequence <charT> & source) {
<        20:  575:    ::CORBA::ULong const length = source.length ();
<        20:  576:    if (!(strm << length)) {
---
>     #####:  574:  bool marshal_sequence(stream & strm, const TAO::unbounded_basic_string_sequence <charT> & source) {
>     #####:  575:    ::CORBA::ULong const length = source.length ();
>     #####:  576:    if (!(strm << length)) {
907c907
<       20*:  579:    for(CORBA::ULong i = 0; i < length; ++i) {
---
>     #####:  579:    for(CORBA::ULong i = 0; i < length; ++i) {
912c912
<        20:  584:    return true;
---
>     #####:  584:    return true;
