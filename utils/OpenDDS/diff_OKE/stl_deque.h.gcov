1c1
<         -:    0:Source:/usr/include/c++/8/bits/stl_deque.h
---
>         -:    0:Source:/usr/include/c++/7/bits/stl_deque.h
5c5
<         -:    3:// Copyright (C) 2001-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 2001-2017 Free Software Foundation, Inc.
72,127c72,96
<         -:   70:_GLIBCXX_BEGIN_NAMESPACE_VERSION
<         -:   71:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
<         -:   72:
<         -:   73:  /**
<         -:   74:   *  @brief This function controls the size of memory nodes.
<         -:   75:   *  @param  __size  The size of an element.
<         -:   76:   *  @return   The number (not byte size) of elements per node.
<         -:   77:   *
<         -:   78:   *  This function started off as a compiler kludge from SGI, but
<         -:   79:   *  seems to be a useful wrapper around a repeated constant
<         -:   80:   *  expression.  The @b 512 is tunable (and no other code needs to
<         -:   81:   *  change), but no investigation has been done since inheriting the
<         -:   82:   *  SGI code.  Touch _GLIBCXX_DEQUE_BUF_SIZE only if you know what
<         -:   83:   *  you are doing, however: changing it breaks the binary
<         -:   84:   *  compatibility!!
<         -:   85:  */
<         -:   86:
<         -:   87:#ifndef _GLIBCXX_DEQUE_BUF_SIZE
<         -:   88:#define _GLIBCXX_DEQUE_BUF_SIZE 512
<         -:   89:#endif
<         -:   90:
<         -:   91:  _GLIBCXX_CONSTEXPR inline size_t
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
< _ZSt16__deque_buf_sizem:
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
< _ZSt16__deque_buf_sizem:
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
< _ZSt16__deque_buf_sizem:
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
< _ZSt16__deque_buf_sizem:
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
< _ZSt16__deque_buf_sizem:
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
< _ZSt16__deque_buf_sizem:
<     #####:   92:  __deque_buf_size(size_t __size)
<         -:   93:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
<     #####:   94:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
< ------------------
---
>         -:   70:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
>         -:   71:
>         -:   72:  /**
>         -:   73:   *  @brief This function controls the size of memory nodes.
>         -:   74:   *  @param  __size  The size of an element.
>         -:   75:   *  @return   The number (not byte size) of elements per node.
>         -:   76:   *
>         -:   77:   *  This function started off as a compiler kludge from SGI, but
>         -:   78:   *  seems to be a useful wrapper around a repeated constant
>         -:   79:   *  expression.  The @b 512 is tunable (and no other code needs to
>         -:   80:   *  change), but no investigation has been done since inheriting the
>         -:   81:   *  SGI code.  Touch _GLIBCXX_DEQUE_BUF_SIZE only if you know what
>         -:   82:   *  you are doing, however: changing it breaks the binary
>         -:   83:   *  compatibility!!
>         -:   84:  */
>         -:   85:
>         -:   86:#ifndef _GLIBCXX_DEQUE_BUF_SIZE
>         -:   87:#define _GLIBCXX_DEQUE_BUF_SIZE 512
>         -:   88:#endif
>         -:   89:
>         -:   90:  _GLIBCXX_CONSTEXPR inline size_t
>     #####:   91:  __deque_buf_size(size_t __size)
>         -:   92:  { return (__size < _GLIBCXX_DEQUE_BUF_SIZE
>     #####:   93:	    ? size_t(_GLIBCXX_DEQUE_BUF_SIZE / __size) : size_t(1)); }
>         -:   94:
129,1781c98,875
<         -:   96:
<         -:   97:  /**
<         -:   98:   *  @brief A deque::iterator.
<         -:   99:   *
<         -:  100:   *  Quite a bit of intelligence here.  Much of the functionality of
<         -:  101:   *  deque is actually passed off to this class.  A deque holds two
<         -:  102:   *  of these internally, marking its valid range.  Access to
<         -:  103:   *  elements is done as offsets of either of those two, relying on
<         -:  104:   *  operator overloading in this class.
<         -:  105:   *
<         -:  106:   *  All the functions are op overloads except for _M_set_node.
<         -:  107:  */
<         -:  108:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  109:    struct _Deque_iterator
<         -:  110:    {
<         -:  111:#if __cplusplus < 201103L
<         -:  112:      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>	     iterator;
<         -:  113:      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
<         -:  114:      typedef _Tp*					 _Elt_pointer;
<         -:  115:      typedef _Tp**					_Map_pointer;
<         -:  116:#else
<         -:  117:    private:
<         -:  118:      template<typename _Up>
<         -:  119:	using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
<         -:  120:      template<typename _CvTp>
<         -:  121:	using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
<         -:  122:    public:
<         -:  123:      typedef __iter<_Tp>		iterator;
<         -:  124:      typedef __iter<const _Tp>		const_iterator;
<         -:  125:      typedef __ptr_to<_Tp>		_Elt_pointer;
<         -:  126:      typedef __ptr_to<_Elt_pointer>	_Map_pointer;
<         -:  127:#endif
<         -:  128:
<      344*:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<      344*:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERS3_PS3_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EERS7_PS7_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E14_S_buffer_sizeEv:
<       344:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<       344:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E14_S_buffer_sizeEv:
<     #####:  129:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<     #####:  130:      { return __deque_buf_size(sizeof(_Tp)); }
< ------------------
<         -:  131:
<         -:  132:      typedef std::random_access_iterator_tag	iterator_category;
<         -:  133:      typedef _Tp				value_type;
<         -:  134:      typedef _Ptr				pointer;
<         -:  135:      typedef _Ref				reference;
<         -:  136:      typedef size_t				size_type;
<         -:  137:      typedef ptrdiff_t				difference_type;
<         -:  138:      typedef _Deque_iterator			_Self;
<         -:  139:
<         -:  140:      _Elt_pointer _M_cur;
<         -:  141:      _Elt_pointer _M_first;
<         -:  142:      _Elt_pointer _M_last;
<         -:  143:      _Map_pointer _M_node;
<         -:  144:
<         -:  145:      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
<         -:  146:      : _M_cur(__x), _M_first(*__y),
<         -:  147:	_M_last(*__y + _S_buffer_size()), _M_node(__y) { }
<         -:  148:
<       72*:  149:      _Deque_iterator() _GLIBCXX_NOEXCEPT
<       72*:  150:      : _M_cur(), _M_first(), _M_last(), _M_node() { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERS3_PS3_EC2Ev:
<     #####:  149:      _Deque_iterator() _GLIBCXX_NOEXCEPT
<     #####:  150:      : _M_cur(), _M_first(), _M_last(), _M_node() { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EC2Ev:
<        72:  149:      _Deque_iterator() _GLIBCXX_NOEXCEPT
<        72:  150:      : _M_cur(), _M_first(), _M_last(), _M_node() { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EC2Ev:
<     #####:  149:      _Deque_iterator() _GLIBCXX_NOEXCEPT
<     #####:  150:      : _M_cur(), _M_first(), _M_last(), _M_node() { }
< ------------------
<         -:  151:
<      416*:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<      832*:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<      832*:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_EC2ERKS_IS3_RS3_PS3_E:
<     #####:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<     #####:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<     #####:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERS3_PS3_EC2ERKS6_:
<     #####:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<     #####:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<     #####:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EC2ERKS_IS3_RS3_PS3_E:
<       134:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<       268:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<       268:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EC2ERKS6_:
<       282:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<       564:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<       564:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EC2ERKS_IS3_RS3_PS3_E:
<     #####:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<     #####:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<     #####:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EC2ERKS6_:
<     #####:  152:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
<     #####:  153:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
<     #####:  154:	_M_last(__x._M_last), _M_node(__x._M_node) { }
< ------------------
<         -:  155:
<         -:  156:      iterator
<         -:  157:      _M_const_cast() const _GLIBCXX_NOEXCEPT
<         -:  158:      { return iterator(_M_cur, _M_node); }
<         -:  159:
<         -:  160:      reference
<      138*:  161:      operator*() const _GLIBCXX_NOEXCEPT
<      138*:  162:      { return *_M_cur; }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERS3_PS3_EdeEv:
<     #####:  161:      operator*() const _GLIBCXX_NOEXCEPT
<     #####:  162:      { return *_M_cur; }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_EdeEv:
<     #####:  161:      operator*() const _GLIBCXX_NOEXCEPT
<     #####:  162:      { return *_M_cur; }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EdeEv:
<        46:  161:      operator*() const _GLIBCXX_NOEXCEPT
<        46:  162:      { return *_M_cur; }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EdeEv:
<        92:  161:      operator*() const _GLIBCXX_NOEXCEPT
<        92:  162:      { return *_M_cur; }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EdeEv:
<     #####:  161:      operator*() const _GLIBCXX_NOEXCEPT
<     #####:  162:      { return *_M_cur; }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EdeEv:
<     #####:  161:      operator*() const _GLIBCXX_NOEXCEPT
<     #####:  162:      { return *_M_cur; }
< ------------------
<         -:  163:
<         -:  164:      pointer
<         -:  165:      operator->() const _GLIBCXX_NOEXCEPT
<         -:  166:      { return _M_cur; }
<         -:  167:
<         -:  168:      _Self&
<       46*:  169:      operator++() _GLIBCXX_NOEXCEPT
<         -:  170:      {
<       46*:  171:	++_M_cur;
<       46*:  172:	if (_M_cur == _M_last)
<         -:  173:	  {
<     #####:  174:	    _M_set_node(_M_node + 1);
<     #####:  175:	    _M_cur = _M_first;
<         -:  176:	  }
<       46*:  177:	return *this;
<         -:  178:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_EppEv:
<     #####:  169:      operator++() _GLIBCXX_NOEXCEPT
<         -:  170:      {
<     #####:  171:	++_M_cur;
<     #####:  172:	if (_M_cur == _M_last)
<         -:  173:	  {
<     #####:  174:	    _M_set_node(_M_node + 1);
<     #####:  175:	    _M_cur = _M_first;
<         -:  176:	  }
<     #####:  177:	return *this;
<         -:  178:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EppEv:
<        46:  169:      operator++() _GLIBCXX_NOEXCEPT
<         -:  170:      {
<        46:  171:	++_M_cur;
<        46:  172:	if (_M_cur == _M_last)
<         -:  173:	  {
<     #####:  174:	    _M_set_node(_M_node + 1);
<     #####:  175:	    _M_cur = _M_first;
<         -:  176:	  }
<        46:  177:	return *this;
<         -:  178:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EppEv:
<     #####:  169:      operator++() _GLIBCXX_NOEXCEPT
<         -:  170:      {
<     #####:  171:	++_M_cur;
<     #####:  172:	if (_M_cur == _M_last)
<         -:  173:	  {
<     #####:  174:	    _M_set_node(_M_node + 1);
<     #####:  175:	    _M_cur = _M_first;
<         -:  176:	  }
<     #####:  177:	return *this;
<         -:  178:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EppEv:
<     #####:  169:      operator++() _GLIBCXX_NOEXCEPT
<         -:  170:      {
<     #####:  171:	++_M_cur;
<     #####:  172:	if (_M_cur == _M_last)
<         -:  173:	  {
<     #####:  174:	    _M_set_node(_M_node + 1);
<     #####:  175:	    _M_cur = _M_first;
<         -:  176:	  }
<     #####:  177:	return *this;
<         -:  178:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EppEv:
<     #####:  169:      operator++() _GLIBCXX_NOEXCEPT
<         -:  170:      {
<     #####:  171:	++_M_cur;
<     #####:  172:	if (_M_cur == _M_last)
<         -:  173:	  {
<     #####:  174:	    _M_set_node(_M_node + 1);
<     #####:  175:	    _M_cur = _M_first;
<         -:  176:	  }
<     #####:  177:	return *this;
<         -:  178:      }
< ------------------
<         -:  179:
<         -:  180:      _Self
<         -:  181:      operator++(int) _GLIBCXX_NOEXCEPT
<         -:  182:      {
<         -:  183:	_Self __tmp = *this;
<         -:  184:	++*this;
<         -:  185:	return __tmp;
<         -:  186:      }
<         -:  187:
<         -:  188:      _Self&
<         -:  189:      operator--() _GLIBCXX_NOEXCEPT
<         -:  190:      {
<         -:  191:	if (_M_cur == _M_first)
<         -:  192:	  {
<         -:  193:	    _M_set_node(_M_node - 1);
<         -:  194:	    _M_cur = _M_last;
<         -:  195:	  }
<         -:  196:	--_M_cur;
<         -:  197:	return *this;
<         -:  198:      }
<         -:  199:
<         -:  200:      _Self
<         -:  201:      operator--(int) _GLIBCXX_NOEXCEPT
<         -:  202:      {
<         -:  203:	_Self __tmp = *this;
<         -:  204:	--*this;
<         -:  205:	return __tmp;
<         -:  206:      }
<         -:  207:
<         -:  208:      _Self&
<       46*:  209:      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
<         -:  210:      {
<       46*:  211:	const difference_type __offset = __n + (_M_cur - _M_first);
<       46*:  212:	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
<       46*:  213:	  _M_cur += __n;
<         -:  214:	else
<         -:  215:	  {
<     #####:  216:	    const difference_type __node_offset =
<     #####:  217:	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
<     #####:  218:			   : -difference_type((-__offset - 1)
<     #####:  219:					      / _S_buffer_size()) - 1;
<     #####:  220:	    _M_set_node(_M_node + __node_offset);
<     #####:  221:	    _M_cur = _M_first + (__offset - __node_offset
<     #####:  222:				 * difference_type(_S_buffer_size()));
<         -:  223:	  }
<       46*:  224:	return *this;
<         -:  225:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EpLEl:
<        46:  209:      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
<         -:  210:      {
<        46:  211:	const difference_type __offset = __n + (_M_cur - _M_first);
<       46*:  212:	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
<        46:  213:	  _M_cur += __n;
<         -:  214:	else
<         -:  215:	  {
<     #####:  216:	    const difference_type __node_offset =
<     #####:  217:	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
<     #####:  218:			   : -difference_type((-__offset - 1)
<     #####:  219:					      / _S_buffer_size()) - 1;
<     #####:  220:	    _M_set_node(_M_node + __node_offset);
<     #####:  221:	    _M_cur = _M_first + (__offset - __node_offset
<     #####:  222:				 * difference_type(_S_buffer_size()));
<         -:  223:	  }
<        46:  224:	return *this;
<         -:  225:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EpLEl:
<     #####:  209:      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
<         -:  210:      {
<     #####:  211:	const difference_type __offset = __n + (_M_cur - _M_first);
<     #####:  212:	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
<     #####:  213:	  _M_cur += __n;
<         -:  214:	else
<         -:  215:	  {
<     #####:  216:	    const difference_type __node_offset =
<     #####:  217:	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
<     #####:  218:			   : -difference_type((-__offset - 1)
<     #####:  219:					      / _S_buffer_size()) - 1;
<     #####:  220:	    _M_set_node(_M_node + __node_offset);
<     #####:  221:	    _M_cur = _M_first + (__offset - __node_offset
<     #####:  222:				 * difference_type(_S_buffer_size()));
<         -:  223:	  }
<     #####:  224:	return *this;
<         -:  225:      }
< ------------------
<         -:  226:
<         -:  227:      _Self
<       46*:  228:      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
<         -:  229:      {
<       46*:  230:	_Self __tmp = *this;
<       46*:  231:	return __tmp += __n;
<         -:  232:      }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EplEl:
<        46:  228:      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
<         -:  229:      {
<        46:  230:	_Self __tmp = *this;
<        46:  231:	return __tmp += __n;
<         -:  232:      }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EplEl:
<     #####:  228:      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
<         -:  229:      {
<     #####:  230:	_Self __tmp = *this;
<     #####:  231:	return __tmp += __n;
<         -:  232:      }
< ------------------
<         -:  233:
<         -:  234:      _Self&
<         -:  235:      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
<         -:  236:      { return *this += -__n; }
<         -:  237:
<         -:  238:      _Self
<         -:  239:      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
<         -:  240:      {
<         -:  241:	_Self __tmp = *this;
<         -:  242:	return __tmp -= __n;
<         -:  243:      }
<         -:  244:
<         -:  245:      reference
<       46*:  246:      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
<       46*:  247:      { return *(*this + __n); }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EixEl:
<        46:  246:      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
<        46:  247:      { return *(*this + __n); }
< ------------------
< _ZNKSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EixEl:
<     #####:  246:      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
<     #####:  247:      { return *(*this + __n); }
< ------------------
<         -:  248:
<         -:  249:      /**
<         -:  250:       *  Prepares to traverse new_node.  Sets everything except
<         -:  251:       *  _M_cur, which should therefore be set by the caller
<         -:  252:       *  immediately afterwards, based on _M_first and _M_last.
<         -:  253:       */
<         -:  254:      void
<       72*:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<       72*:  257:	_M_node = __new_node;
<       72*:  258:	_M_first = *__new_node;
<       72*:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<       72*:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E11_M_set_nodeEPS5_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERS3_PS3_E11_M_set_nodeEPS5_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_E11_M_set_nodeEPPS3_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EERS7_PS7_E11_M_set_nodeEPS9_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_E11_M_set_nodeEPPS3_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E11_M_set_nodeEPS5_:
<        72:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<        72:  257:	_M_node = __new_node;
<        72:  258:	_M_first = *__new_node;
<        72:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<        72:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_E11_M_set_nodeEPPS3_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
< _ZNSt15_Deque_iteratorIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_E11_M_set_nodeEPS5_:
<     #####:  255:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
<         -:  256:      {
<     #####:  257:	_M_node = __new_node;
<     #####:  258:	_M_first = *__new_node;
<     #####:  259:	_M_last = _M_first + difference_type(_S_buffer_size());
<     #####:  260:      }
< ------------------
<         -:  261:    };
<         -:  262:
<         -:  263:  // Note: we also provide overloads whose operands are of the same type in
<         -:  264:  // order to avoid ambiguous overload resolution when std::rel_ops operators
<         -:  265:  // are in scope (for additional details, see libstdc++/3628)
<         -:  266:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  267:    inline bool
<      102*:  268:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  269:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<      102*:  270:    { return __x._M_cur == __y._M_cur; }
< ------------------
< _ZSteqIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_EbRKSt15_Deque_iteratorIT_T0_T1_ESD_:
<     #####:  268:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  269:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<     #####:  270:    { return __x._M_cur == __y._M_cur; }
< ------------------
< _ZSteqIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EbRKSt15_Deque_iteratorIT_T0_T1_ESD_:
<        90:  268:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  269:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<        90:  270:    { return __x._M_cur == __y._M_cur; }
< ------------------
< _ZSteqIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EbRKSt15_Deque_iteratorIT_T0_T1_ESC_:
<        12:  268:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  269:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<        12:  270:    { return __x._M_cur == __y._M_cur; }
< ------------------
< _ZSteqIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EbRKSt15_Deque_iteratorIT_T0_T1_ESD_:
<     #####:  268:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  269:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<     #####:  270:    { return __x._M_cur == __y._M_cur; }
< ------------------
< _ZSteqIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EbRKSt15_Deque_iteratorIT_T0_T1_ESC_:
<     #####:  268:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  269:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<     #####:  270:    { return __x._M_cur == __y._M_cur; }
< ------------------
<         -:  271:
<         -:  272:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  273:	   typename _RefR, typename _PtrR>
<         -:  274:    inline bool
<         -:  275:    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  276:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  277:    { return __x._M_cur == __y._M_cur; }
<         -:  278:
<         -:  279:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  280:    inline bool
<      102*:  281:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  282:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<      102*:  283:    { return !(__x == __y); }
< ------------------
< _ZStneIPN7OpenDDS4DCPS11SendRequestERKS3_PS4_EbRKSt15_Deque_iteratorIT_T0_T1_ESD_:
<     #####:  281:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  282:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<     #####:  283:    { return !(__x == __y); }
< ------------------
< _ZStneIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EbRKSt15_Deque_iteratorIT_T0_T1_ESD_:
<        90:  281:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  282:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<        90:  283:    { return !(__x == __y); }
< ------------------
< _ZStneIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EbRKSt15_Deque_iteratorIT_T0_T1_ESC_:
<        12:  281:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  282:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<        12:  283:    { return !(__x == __y); }
< ------------------
< _ZStneIPN7OpenDDS4DCPS21TransportQueueElementERKS3_PS4_EbRKSt15_Deque_iteratorIT_T0_T1_ESD_:
<     #####:  281:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  282:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<     #####:  283:    { return !(__x == __y); }
< ------------------
< _ZStneIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_EbRKSt15_Deque_iteratorIT_T0_T1_ESC_:
<     #####:  281:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  282:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<     #####:  283:    { return !(__x == __y); }
< ------------------
<         -:  284:
<         -:  285:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  286:	   typename _RefR, typename _PtrR>
<         -:  287:    inline bool
<         -:  288:    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  289:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  290:    { return !(__x == __y); }
<         -:  291:
<         -:  292:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  293:    inline bool
<         -:  294:    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  295:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  296:    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
<         -:  297:					  : (__x._M_node < __y._M_node); }
<         -:  298:
<         -:  299:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  300:	   typename _RefR, typename _PtrR>
<         -:  301:    inline bool
<         -:  302:    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  303:	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  304:    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
<         -:  305:					  : (__x._M_node < __y._M_node); }
<         -:  306:
<         -:  307:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  308:    inline bool
<         -:  309:    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  310:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  311:    { return __y < __x; }
<         -:  312:
<         -:  313:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  314:	   typename _RefR, typename _PtrR>
<         -:  315:    inline bool
<         -:  316:    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  317:	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  318:    { return __y < __x; }
<         -:  319:
<         -:  320:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  321:    inline bool
<         -:  322:    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  323:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  324:    { return !(__y < __x); }
<         -:  325:
<         -:  326:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  327:	   typename _RefR, typename _PtrR>
<         -:  328:    inline bool
<         -:  329:    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  330:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  331:    { return !(__y < __x); }
<         -:  332:
<         -:  333:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  334:    inline bool
<         -:  335:    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  336:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  337:    { return !(__x < __y); }
<         -:  338:
<         -:  339:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  340:	   typename _RefR, typename _PtrR>
<         -:  341:    inline bool
<         -:  342:    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  343:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  344:    { return !(__x < __y); }
<         -:  345:
<         -:  346:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -:  347:  // According to the resolution of DR179 not only the various comparison
<         -:  348:  // operators but also operator- must accept mixed iterator/const_iterator
<         -:  349:  // parameters.
<         -:  350:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  351:    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
<      226*:  352:    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  353:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  354:    {
<         -:  355:      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
<      226*:  356:	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
<      226*:  357:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
<      226*:  358:	+ (__y._M_last - __y._M_cur);
<         -:  359:    }
< ------------------
< _ZStmiIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_ENSt15_Deque_iteratorIT_T0_T1_E15difference_typeERKSA_SD_:
<     #####:  352:    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  353:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  354:    {
<         -:  355:      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
<     #####:  356:	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
<     #####:  357:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
<     #####:  358:	+ (__y._M_last - __y._M_cur);
<         -:  359:    }
< ------------------
< _ZStmiIPN7OpenDDS4DCPS11SendRequestERS3_PS3_ENSt15_Deque_iteratorIT_T0_T1_E15difference_typeERKSA_SD_:
<     #####:  352:    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  353:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  354:    {
<         -:  355:      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
<     #####:  356:	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
<     #####:  357:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
<     #####:  358:	+ (__y._M_last - __y._M_cur);
<         -:  359:    }
< ------------------
< _ZStmiIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_ENSt15_Deque_iteratorIT_T0_T1_E15difference_typeERKSA_SD_:
<       226:  352:    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  353:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  354:    {
<         -:  355:      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
<       226:  356:	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
<       226:  357:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
<       226:  358:	+ (__y._M_last - __y._M_cur);
<         -:  359:    }
< ------------------
< _ZStmiIPN7OpenDDS4DCPS21TransportQueueElementERS3_PS3_ENSt15_Deque_iteratorIT_T0_T1_E15difference_typeERKSA_SD_:
<     #####:  352:    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
<         -:  353:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
<         -:  354:    {
<         -:  355:      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
<     #####:  356:	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
<     #####:  357:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
<     #####:  358:	+ (__y._M_last - __y._M_cur);
<         -:  359:    }
< ------------------
<         -:  360:
<         -:  361:  template<typename _Tp, typename _RefL, typename _PtrL,
<         -:  362:	   typename _RefR, typename _PtrR>
<         -:  363:    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
<         -:  364:    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
<         -:  365:	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
<         -:  366:    {
<         -:  367:      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
<         -:  368:	(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
<         -:  369:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
<         -:  370:	+ (__y._M_last - __y._M_cur);
<         -:  371:    }
<         -:  372:
<         -:  373:  template<typename _Tp, typename _Ref, typename _Ptr>
<         -:  374:    inline _Deque_iterator<_Tp, _Ref, _Ptr>
<         -:  375:    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
<         -:  376:    _GLIBCXX_NOEXCEPT
<         -:  377:    { return __x + __n; }
<         -:  378:
<         -:  379:  template<typename _Tp>
<         -:  380:    void
<         -:  381:    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
<         -:  382:	 const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);
<         -:  383:
<         -:  384:  template<typename _Tp>
<         -:  385:    _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  386:    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  387:	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  388:	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
<         -:  389:
<         -:  390:  template<typename _Tp>
<         -:  391:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  392:    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
<         -:  393:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
<         -:  394:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
<         -:  395:    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
<         -:  396:		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
<         -:  397:		       __result); }
<         -:  398:
<         -:  399:  template<typename _Tp>
<         -:  400:    _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  401:    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  402:		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  403:		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
<         -:  404:
<         -:  405:  template<typename _Tp>
<         -:  406:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  407:    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
<         -:  408:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
<         -:  409:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
<         -:  410:    { return std::copy_backward(_Deque_iterator<_Tp,
<         -:  411:				const _Tp&, const _Tp*>(__first),
<         -:  412:				_Deque_iterator<_Tp,
<         -:  413:				const _Tp&, const _Tp*>(__last),
<         -:  414:				__result); }
<         -:  415:
<         -:  416:#if __cplusplus >= 201103L
<         -:  417:  template<typename _Tp>
<         -:  418:    _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  419:    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  420:	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  421:	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
<         -:  422:
<         -:  423:  template<typename _Tp>
<         -:  424:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  425:    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
<         -:  426:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
<         -:  427:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
<         -:  428:    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
<         -:  429:		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
<         -:  430:		       __result); }
<         -:  431:
<         -:  432:  template<typename _Tp>
<         -:  433:    _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  434:    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  435:		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
<         -:  436:		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
<         -:  437:
<         -:  438:  template<typename _Tp>
<         -:  439:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
<         -:  440:    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
<         -:  441:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
<         -:  442:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
<         -:  443:    { return std::move_backward(_Deque_iterator<_Tp,
<         -:  444:				const _Tp&, const _Tp*>(__first),
<         -:  445:				_Deque_iterator<_Tp,
<         -:  446:				const _Tp&, const _Tp*>(__last),
<         -:  447:				__result); }
<         -:  448:#endif
<         -:  449:
<         -:  450:  /**
<         -:  451:   *  Deque base class.  This class provides the unified face for %deque's
<         -:  452:   *  allocation.  This class's constructor and destructor allocate and
<         -:  453:   *  deallocate (but do not initialize) storage.  This makes %exception
<         -:  454:   *  safety easier.
<         -:  455:   *
<         -:  456:   *  Nothing in this class ever constructs or destroys an actual Tp element.
<         -:  457:   *  (Deque handles that itself.)  Only/All memory management is performed
<         -:  458:   *  here.
<         -:  459:  */
<         -:  460:  template<typename _Tp, typename _Alloc>
<         -:  461:    class _Deque_base
<         -:  462:    {
<         -:  463:    protected:
<         -:  464:      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
<         -:  465:	rebind<_Tp>::other _Tp_alloc_type;
<         -:  466:      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	 _Alloc_traits;
<         -:  467:
<         -:  468:#if __cplusplus < 201103L
<         -:  469:      typedef _Tp*					_Ptr;
<         -:  470:      typedef const _Tp*				_Ptr_const;
<         -:  471:#else
<         -:  472:      typedef typename _Alloc_traits::pointer		_Ptr;
<         -:  473:      typedef typename _Alloc_traits::const_pointer	_Ptr_const;
<         -:  474:#endif
<         -:  475:
<         -:  476:      typedef typename _Alloc_traits::template rebind<_Ptr>::other
<         -:  477:	_Map_alloc_type;
<         -:  478:      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;
<         -:  479:
<         -:  480:    public:
<         -:  481:      typedef _Alloc		  allocator_type;
<         -:  482:      typedef typename _Alloc_traits::size_type size_type;
<         -:  483:
<         -:  484:      allocator_type
<         -:  485:      get_allocator() const _GLIBCXX_NOEXCEPT
<         -:  486:      { return allocator_type(_M_get_Tp_allocator()); }
<         -:  487:
<         -:  488:      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>	  iterator;
<         -:  489:      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;
<         -:  490:
<       36*:  491:      _Deque_base()
<       36*:  492:      : _M_impl()
<       36*:  493:      { _M_initialize_map(0); }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EEC2Ev:
<     #####:  491:      _Deque_base()
<     #####:  492:      : _M_impl()
<     #####:  493:      { _M_initialize_map(0); }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EEC2Ev:
<        36:  491:      _Deque_base()
<        36:  492:      : _M_impl()
<        36:  493:      { _M_initialize_map(0); }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EEC2Ev:
<     #####:  491:      _Deque_base()
<     #####:  492:      : _M_impl()
<     #####:  493:      { _M_initialize_map(0); }
< ------------------
<         -:  494:
<         -:  495:      _Deque_base(size_t __num_elements)
<         -:  496:      : _M_impl()
<         -:  497:      { _M_initialize_map(__num_elements); }
<         -:  498:
<         -:  499:      _Deque_base(const allocator_type& __a, size_t __num_elements)
<         -:  500:      : _M_impl(__a)
<         -:  501:      { _M_initialize_map(__num_elements); }
<         -:  502:
<         -:  503:      _Deque_base(const allocator_type& __a)
<         -:  504:      : _M_impl(__a)
<         -:  505:      { /* Caller must initialize map. */ }
<         -:  506:
<         -:  507:#if __cplusplus >= 201103L
<         -:  508:      _Deque_base(_Deque_base&& __x, false_type)
<         -:  509:      : _M_impl(__x._M_move_impl())
<         -:  510:      { }
<         -:  511:
<         -:  512:      _Deque_base(_Deque_base&& __x, true_type)
<         -:  513:      : _M_impl(std::move(__x._M_get_Tp_allocator()))
<         -:  514:      {
<         -:  515:	_M_initialize_map(0);
<         -:  516:	if (__x._M_impl._M_map)
<         -:  517:	  this->_M_impl._M_swap_data(__x._M_impl);
<         -:  518:      }
<         -:  519:
<         -:  520:      _Deque_base(_Deque_base&& __x)
<         -:  521:      : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})
<         -:  522:      { }
<         -:  523:
<         -:  524:      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
<         -:  525:      : _M_impl(__a)
<         -:  526:      {
<         -:  527:	if (__x.get_allocator() == __a)
<         -:  528:	  {
<         -:  529:	    if (__x._M_impl._M_map)
<         -:  530:	      {
<         -:  531:		_M_initialize_map(0);
<         -:  532:		this->_M_impl._M_swap_data(__x._M_impl);
<         -:  533:	      }
<         -:  534:	  }
<         -:  535:	else
<         -:  536:	  {
<         -:  537:	    _M_initialize_map(__n);
<         -:  538:	  }
<         -:  539:      }
<         -:  540:#endif
<         -:  541:
<         -:  542:      ~_Deque_base() _GLIBCXX_NOEXCEPT;
<         -:  543:
<         -:  544:    protected:
<         -:  545:      typedef typename iterator::_Map_pointer _Map_pointer;
<         -:  546:
<         -:  547:      //This struct encapsulates the implementation of the std::deque
<         -:  548:      //standard container and at the same time makes use of the EBO
<         -:  549:      //for empty allocators.
<         -:  550:      struct _Deque_impl
<         -:  551:      : public _Tp_alloc_type
<         -:  552:      {
<         -:  553:	_Map_pointer _M_map;
<         -:  554:	size_t _M_map_size;
<         -:  555:	iterator _M_start;
<         -:  556:	iterator _M_finish;
<         -:  557:
<       36*:  558:	_Deque_impl()
<         -:  559:	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
<       36*:  560:	  _M_start(), _M_finish()
<       36*:  561:	{ }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE11_Deque_implC2Ev:
<     #####:  558:	_Deque_impl()
<         -:  559:	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
<     #####:  560:	  _M_start(), _M_finish()
<     #####:  561:	{ }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE11_Deque_implC2Ev:
<        36:  558:	_Deque_impl()
<         -:  559:	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
<        36:  560:	  _M_start(), _M_finish()
<        36:  561:	{ }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE11_Deque_implC2Ev:
<     #####:  558:	_Deque_impl()
<         -:  559:	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
<     #####:  560:	  _M_start(), _M_finish()
<     #####:  561:	{ }
< ------------------
<         -:  562:
<         -:  563:	_Deque_impl(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
<         -:  564:	: _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
<         -:  565:	  _M_start(), _M_finish()
<         -:  566:	{ }
<         -:  567:
<         -:  568:#if __cplusplus >= 201103L
<         -:  569:	_Deque_impl(_Deque_impl&&) = default;
<         -:  570:
<         -:  571:	_Deque_impl(_Tp_alloc_type&& __a) noexcept
<         -:  572:	: _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
<         -:  573:	  _M_start(), _M_finish()
<         -:  574:	{ }
<         -:  575:#endif
<         -:  576:
<       24*:  577:	void _M_swap_data(_Deque_impl& __x) _GLIBCXX_NOEXCEPT
<         -:  578:	{
<         -:  579:	  using std::swap;
<       24*:  580:	  swap(this->_M_start, __x._M_start);
<       24*:  581:	  swap(this->_M_finish, __x._M_finish);
<       24*:  582:	  swap(this->_M_map, __x._M_map);
<       24*:  583:	  swap(this->_M_map_size, __x._M_map_size);
<       24*:  584:	}
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE11_Deque_impl12_M_swap_dataERS6_:
<        24:  577:	void _M_swap_data(_Deque_impl& __x) _GLIBCXX_NOEXCEPT
<         -:  578:	{
<         -:  579:	  using std::swap;
<        24:  580:	  swap(this->_M_start, __x._M_start);
<        24:  581:	  swap(this->_M_finish, __x._M_finish);
<        24:  582:	  swap(this->_M_map, __x._M_map);
<        24:  583:	  swap(this->_M_map_size, __x._M_map_size);
<        24:  584:	}
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE11_Deque_impl12_M_swap_dataERS6_:
<     #####:  577:	void _M_swap_data(_Deque_impl& __x) _GLIBCXX_NOEXCEPT
<         -:  578:	{
<         -:  579:	  using std::swap;
<     #####:  580:	  swap(this->_M_start, __x._M_start);
<     #####:  581:	  swap(this->_M_finish, __x._M_finish);
<     #####:  582:	  swap(this->_M_map, __x._M_map);
<     #####:  583:	  swap(this->_M_map_size, __x._M_map_size);
<     #####:  584:	}
< ------------------
<         -:  585:      };
<         -:  586:
<         -:  587:      _Tp_alloc_type&
<       84*:  588:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<       84*:  589:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE19_M_get_Tp_allocatorEv:
<     #####:  588:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  589:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE19_M_get_Tp_allocatorEv:
<        84:  588:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<        84:  589:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE19_M_get_Tp_allocatorEv:
<     #####:  588:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  589:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
<         -:  590:
<         -:  591:      const _Tp_alloc_type&
<       72*:  592:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<       72*:  593:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE19_M_get_Tp_allocatorEv:
<     #####:  592:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  593:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE19_M_get_Tp_allocatorEv:
<     #####:  592:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  593:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt11_Deque_baseISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE19_M_get_Tp_allocatorEv:
<     #####:  592:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  593:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE19_M_get_Tp_allocatorEv:
<        72:  592:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<        72:  593:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE19_M_get_Tp_allocatorEv:
<     #####:  592:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  593:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
<         -:  594:
<         -:  595:      _Map_alloc_type
<       72*:  596:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
<       72*:  597:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE20_M_get_map_allocatorEv:
<     #####:  596:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  597:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE20_M_get_map_allocatorEv:
<     #####:  596:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  597:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt11_Deque_baseISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE20_M_get_map_allocatorEv:
<     #####:  596:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  597:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE20_M_get_map_allocatorEv:
<        72:  596:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
<        72:  597:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE20_M_get_map_allocatorEv:
<     #####:  596:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  597:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
< ------------------
<         -:  598:
<         -:  599:      _Ptr
<       36*:  600:      _M_allocate_node()
<         -:  601:      {
<         -:  602:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<       36*:  603:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
<         -:  604:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE16_M_allocate_nodeEv:
<     #####:  600:      _M_allocate_node()
<         -:  601:      {
<         -:  602:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  603:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
<         -:  604:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE16_M_allocate_nodeEv:
<     #####:  600:      _M_allocate_node()
<         -:  601:      {
<         -:  602:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  603:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
<         -:  604:      }
< ------------------
< _ZNSt11_Deque_baseISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE16_M_allocate_nodeEv:
<     #####:  600:      _M_allocate_node()
<         -:  601:      {
<         -:  602:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  603:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
<         -:  604:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE16_M_allocate_nodeEv:
<        36:  600:      _M_allocate_node()
<         -:  601:      {
<         -:  602:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<        36:  603:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
<         -:  604:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE16_M_allocate_nodeEv:
<     #####:  600:      _M_allocate_node()
<         -:  601:      {
<         -:  602:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  603:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
<         -:  604:      }
< ------------------
<         -:  605:
<         -:  606:      void
<       36*:  607:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
<         -:  608:      {
<         -:  609:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<       36*:  610:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
<       36*:  611:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE18_M_deallocate_nodeEPS3_:
<     #####:  607:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
<         -:  608:      {
<         -:  609:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  610:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
<     #####:  611:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE18_M_deallocate_nodeEPS3_:
<     #####:  607:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
<         -:  608:      {
<         -:  609:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  610:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
<     #####:  611:      }
< ------------------
< _ZNSt11_Deque_baseISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE18_M_deallocate_nodeEPS7_:
<     #####:  607:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
<         -:  608:      {
<         -:  609:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  610:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
<     #####:  611:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE18_M_deallocate_nodeEPS3_:
<        36:  607:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
<         -:  608:      {
<         -:  609:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<        36:  610:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
<        36:  611:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE18_M_deallocate_nodeEPS3_:
<     #####:  607:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
<         -:  608:      {
<         -:  609:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
<     #####:  610:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
<     #####:  611:      }
< ------------------
<         -:  612:
<         -:  613:      _Map_pointer
<       36*:  614:      _M_allocate_map(size_t __n)
<         -:  615:      {
<       72*:  616:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<       72*:  617:	return _Map_alloc_traits::allocate(__map_alloc, __n);
<         -:  618:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_allocate_mapEm:
<     #####:  614:      _M_allocate_map(size_t __n)
<         -:  615:      {
<     #####:  616:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  617:	return _Map_alloc_traits::allocate(__map_alloc, __n);
<         -:  618:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE15_M_allocate_mapEm:
<     #####:  614:      _M_allocate_map(size_t __n)
<         -:  615:      {
<     #####:  616:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  617:	return _Map_alloc_traits::allocate(__map_alloc, __n);
<         -:  618:      }
< ------------------
< _ZNSt11_Deque_baseISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE15_M_allocate_mapEm:
<     #####:  614:      _M_allocate_map(size_t __n)
<         -:  615:      {
<     #####:  616:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  617:	return _Map_alloc_traits::allocate(__map_alloc, __n);
<         -:  618:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_allocate_mapEm:
<        36:  614:      _M_allocate_map(size_t __n)
<         -:  615:      {
<        72:  616:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<        72:  617:	return _Map_alloc_traits::allocate(__map_alloc, __n);
<         -:  618:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_allocate_mapEm:
<     #####:  614:      _M_allocate_map(size_t __n)
<         -:  615:      {
<     #####:  616:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  617:	return _Map_alloc_traits::allocate(__map_alloc, __n);
<         -:  618:      }
< ------------------
<         -:  619:
<         -:  620:      void
<       36*:  621:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
<         -:  622:      {
<       72*:  623:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<       36*:  624:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
<       36*:  625:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE17_M_deallocate_mapEPPS3_m:
<     #####:  621:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
<         -:  622:      {
<     #####:  623:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  624:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
<     #####:  625:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE17_M_deallocate_mapEPPS3_m:
<     #####:  621:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
<         -:  622:      {
<     #####:  623:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  624:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
<     #####:  625:      }
< ------------------
< _ZNSt11_Deque_baseISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE17_M_deallocate_mapEPPS7_m:
<     #####:  621:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
<         -:  622:      {
<     #####:  623:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  624:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
<     #####:  625:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE17_M_deallocate_mapEPPS3_m:
<        36:  621:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
<         -:  622:      {
<        72:  623:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<        36:  624:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
<        36:  625:      }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE17_M_deallocate_mapEPPS3_m:
<     #####:  621:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
<         -:  622:      {
<     #####:  623:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
<     #####:  624:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
<     #####:  625:      }
< ------------------
<         -:  626:
<         -:  627:    protected:
<         -:  628:      void _M_initialize_map(size_t);
<         -:  629:      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
<         -:  630:      void _M_destroy_nodes(_Map_pointer __nstart,
<         -:  631:			    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;
<         -:  632:      enum { _S_initial_map_size = 8 };
<         -:  633:
<         -:  634:      _Deque_impl _M_impl;
<         -:  635:
<         -:  636:#if __cplusplus >= 201103L
<         -:  637:    private:
<         -:  638:      _Deque_impl
<         -:  639:      _M_move_impl()
<         -:  640:      {
<         -:  641:	if (!_M_impl._M_map)
<         -:  642:	  return std::move(_M_impl);
<         -:  643:
<         -:  644:	// Create a copy of the current allocator.
<         -:  645:	_Tp_alloc_type __alloc{_M_get_Tp_allocator()};
<         -:  646:	// Put that copy in a moved-from state.
<         -:  647:	_Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};
<         -:  648:	// Create an empty map that allocates using the moved-from allocator.
<         -:  649:	_Deque_base __empty{__alloc};
<         -:  650:	__empty._M_initialize_map(0);
<         -:  651:	// Now safe to modify current allocator and perform non-throwing swaps.
<         -:  652:	_Deque_impl __ret{std::move(_M_get_Tp_allocator())};
<         -:  653:	_M_impl._M_swap_data(__ret);
<         -:  654:	_M_impl._M_swap_data(__empty._M_impl);
<         -:  655:	return __ret;
<         -:  656:      }
<         -:  657:#endif
<         -:  658:    };
<         -:  659:
<         -:  660:  template<typename _Tp, typename _Alloc>
<       36*:  661:    _Deque_base<_Tp, _Alloc>::
<         -:  662:    ~_Deque_base() _GLIBCXX_NOEXCEPT
<         -:  663:    {
<       36*:  664:      if (this->_M_impl._M_map)
<         -:  665:	{
<       36*:  666:	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
<       36*:  667:			   this->_M_impl._M_finish._M_node + 1);
<       36*:  668:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<         -:  669:	}
<       36*:  670:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EED2Ev:
<     #####:  661:    _Deque_base<_Tp, _Alloc>::
<         -:  662:    ~_Deque_base() _GLIBCXX_NOEXCEPT
<         -:  663:    {
<     #####:  664:      if (this->_M_impl._M_map)
<         -:  665:	{
<     #####:  666:	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
<     #####:  667:			   this->_M_impl._M_finish._M_node + 1);
<     #####:  668:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<         -:  669:	}
<     #####:  670:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EED2Ev:
<        36:  661:    _Deque_base<_Tp, _Alloc>::
<         -:  662:    ~_Deque_base() _GLIBCXX_NOEXCEPT
<         -:  663:    {
<        36:  664:      if (this->_M_impl._M_map)
<         -:  665:	{
<        36:  666:	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
<        36:  667:			   this->_M_impl._M_finish._M_node + 1);
<        36:  668:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<         -:  669:	}
<        36:  670:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EED2Ev:
<     #####:  661:    _Deque_base<_Tp, _Alloc>::
<         -:  662:    ~_Deque_base() _GLIBCXX_NOEXCEPT
<         -:  663:    {
<     #####:  664:      if (this->_M_impl._M_map)
<         -:  665:	{
<     #####:  666:	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
<     #####:  667:			   this->_M_impl._M_finish._M_node + 1);
<     #####:  668:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<         -:  669:	}
<     #####:  670:    }
< ------------------
<         -:  671:
<         -:  672:  /**
<         -:  673:   *  @brief Layout storage.
<         -:  674:   *  @param  __num_elements  The count of T's for which to allocate space
<         -:  675:   *                          at first.
<         -:  676:   *  @return   Nothing.
<         -:  677:   *
<         -:  678:   *  The initial underlying memory layout is a bit complicated...
<         -:  679:  */
<         -:  680:  template<typename _Tp, typename _Alloc>
<         -:  681:    void
<       36*:  682:    _Deque_base<_Tp, _Alloc>::
<         -:  683:    _M_initialize_map(size_t __num_elements)
<         -:  684:    {
<       36*:  685:      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
<         -:  686:				  + 1);
<         -:  687:
<       36*:  688:      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
<       36*:  689:					   size_t(__num_nodes + 2));
<       36*:  690:      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
<         -:  691:
<         -:  692:      // For "small" maps (needing less than _M_map_size nodes), allocation
<         -:  693:      // starts in the middle elements and grows outwards.  So nstart may be
<         -:  694:      // the beginning of _M_map, but for small maps it may be as far in as
<         -:  695:      // _M_map+3.
<         -:  696:
<       72*:  697:      _Map_pointer __nstart = (this->_M_impl._M_map
<       36*:  698:			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
<       36*:  699:      _Map_pointer __nfinish = __nstart + __num_nodes;
<         -:  700:
<         -:  701:      __try
<       36*:  702:	{ _M_create_nodes(__nstart, __nfinish); }
<     =====:  703:      __catch(...)
<         -:  704:	{
<     =====:  705:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<     =====:  706:	  this->_M_impl._M_map = _Map_pointer();
<     =====:  707:	  this->_M_impl._M_map_size = 0;
<     =====:  708:	  __throw_exception_again;
<         -:  709:	}
<         -:  710:
<       36*:  711:      this->_M_impl._M_start._M_set_node(__nstart);
<       36*:  712:      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
<       36*:  713:      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
<       72*:  714:      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
<       36*:  715:					+ __num_elements
<       36*:  716:					% __deque_buf_size(sizeof(_Tp)));
<       36*:  717:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE17_M_initialize_mapEm:
<     #####:  682:    _Deque_base<_Tp, _Alloc>::
<         -:  683:    _M_initialize_map(size_t __num_elements)
<         -:  684:    {
<     #####:  685:      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
<         -:  686:				  + 1);
<         -:  687:
<     #####:  688:      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
<     #####:  689:					   size_t(__num_nodes + 2));
<     #####:  690:      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
<         -:  691:
<         -:  692:      // For "small" maps (needing less than _M_map_size nodes), allocation
<         -:  693:      // starts in the middle elements and grows outwards.  So nstart may be
<         -:  694:      // the beginning of _M_map, but for small maps it may be as far in as
<         -:  695:      // _M_map+3.
<         -:  696:
<     #####:  697:      _Map_pointer __nstart = (this->_M_impl._M_map
<     #####:  698:			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
<     #####:  699:      _Map_pointer __nfinish = __nstart + __num_nodes;
<         -:  700:
<         -:  701:      __try
<     #####:  702:	{ _M_create_nodes(__nstart, __nfinish); }
<     =====:  703:      __catch(...)
<         -:  704:	{
<     =====:  705:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<     =====:  706:	  this->_M_impl._M_map = _Map_pointer();
<     =====:  707:	  this->_M_impl._M_map_size = 0;
<     =====:  708:	  __throw_exception_again;
<         -:  709:	}
<         -:  710:
<     #####:  711:      this->_M_impl._M_start._M_set_node(__nstart);
<     #####:  712:      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
<     #####:  713:      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
<     #####:  714:      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
<     #####:  715:					+ __num_elements
<     #####:  716:					% __deque_buf_size(sizeof(_Tp)));
<     #####:  717:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE17_M_initialize_mapEm:
<        36:  682:    _Deque_base<_Tp, _Alloc>::
<         -:  683:    _M_initialize_map(size_t __num_elements)
<         -:  684:    {
<        36:  685:      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
<         -:  686:				  + 1);
<         -:  687:
<        36:  688:      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
<        36:  689:					   size_t(__num_nodes + 2));
<        36:  690:      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
<         -:  691:
<         -:  692:      // For "small" maps (needing less than _M_map_size nodes), allocation
<         -:  693:      // starts in the middle elements and grows outwards.  So nstart may be
<         -:  694:      // the beginning of _M_map, but for small maps it may be as far in as
<         -:  695:      // _M_map+3.
<         -:  696:
<        72:  697:      _Map_pointer __nstart = (this->_M_impl._M_map
<        36:  698:			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
<        36:  699:      _Map_pointer __nfinish = __nstart + __num_nodes;
<         -:  700:
<         -:  701:      __try
<        36:  702:	{ _M_create_nodes(__nstart, __nfinish); }
<     =====:  703:      __catch(...)
<         -:  704:	{
<     =====:  705:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<     =====:  706:	  this->_M_impl._M_map = _Map_pointer();
<     =====:  707:	  this->_M_impl._M_map_size = 0;
<     =====:  708:	  __throw_exception_again;
<         -:  709:	}
<         -:  710:
<        36:  711:      this->_M_impl._M_start._M_set_node(__nstart);
<        36:  712:      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
<        36:  713:      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
<        72:  714:      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
<        36:  715:					+ __num_elements
<        36:  716:					% __deque_buf_size(sizeof(_Tp)));
<        36:  717:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE17_M_initialize_mapEm:
<     #####:  682:    _Deque_base<_Tp, _Alloc>::
<         -:  683:    _M_initialize_map(size_t __num_elements)
<         -:  684:    {
<     #####:  685:      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
<         -:  686:				  + 1);
<         -:  687:
<     #####:  688:      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
<     #####:  689:					   size_t(__num_nodes + 2));
<     #####:  690:      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
<         -:  691:
<         -:  692:      // For "small" maps (needing less than _M_map_size nodes), allocation
<         -:  693:      // starts in the middle elements and grows outwards.  So nstart may be
<         -:  694:      // the beginning of _M_map, but for small maps it may be as far in as
<         -:  695:      // _M_map+3.
<         -:  696:
<     #####:  697:      _Map_pointer __nstart = (this->_M_impl._M_map
<     #####:  698:			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
<     #####:  699:      _Map_pointer __nfinish = __nstart + __num_nodes;
<         -:  700:
<         -:  701:      __try
<     #####:  702:	{ _M_create_nodes(__nstart, __nfinish); }
<     =====:  703:      __catch(...)
<         -:  704:	{
<     =====:  705:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<     =====:  706:	  this->_M_impl._M_map = _Map_pointer();
<     =====:  707:	  this->_M_impl._M_map_size = 0;
<     =====:  708:	  __throw_exception_again;
<         -:  709:	}
<         -:  710:
<     #####:  711:      this->_M_impl._M_start._M_set_node(__nstart);
<     #####:  712:      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
<     #####:  713:      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
<     #####:  714:      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
<     #####:  715:					+ __num_elements
<     #####:  716:					% __deque_buf_size(sizeof(_Tp)));
<     #####:  717:    }
< ------------------
<         -:  718:
<         -:  719:  template<typename _Tp, typename _Alloc>
<         -:  720:    void
<       36*:  721:    _Deque_base<_Tp, _Alloc>::
<         -:  722:    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
<         -:  723:    {
<         -:  724:      _Map_pointer __cur;
<         -:  725:      __try
<         -:  726:	{
<       72*:  727:	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
<       36*:  728:	    *__cur = this->_M_allocate_node();
<         -:  729:	}
<     =====:  730:      __catch(...)
<         -:  731:	{
<     =====:  732:	  _M_destroy_nodes(__nstart, __cur);
<     =====:  733:	  __throw_exception_again;
<         -:  734:	}
<       36*:  735:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE15_M_create_nodesEPPS3_S7_:
<     #####:  721:    _Deque_base<_Tp, _Alloc>::
<         -:  722:    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
<         -:  723:    {
<         -:  724:      _Map_pointer __cur;
<         -:  725:      __try
<         -:  726:	{
<     #####:  727:	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
<     #####:  728:	    *__cur = this->_M_allocate_node();
<         -:  729:	}
<     =====:  730:      __catch(...)
<         -:  731:	{
<     =====:  732:	  _M_destroy_nodes(__nstart, __cur);
<     =====:  733:	  __throw_exception_again;
<         -:  734:	}
<     #####:  735:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_create_nodesEPPS3_S7_:
<        36:  721:    _Deque_base<_Tp, _Alloc>::
<         -:  722:    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
<         -:  723:    {
<         -:  724:      _Map_pointer __cur;
<         -:  725:      __try
<         -:  726:	{
<        72:  727:	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
<        36:  728:	    *__cur = this->_M_allocate_node();
<         -:  729:	}
<     =====:  730:      __catch(...)
<         -:  731:	{
<     =====:  732:	  _M_destroy_nodes(__nstart, __cur);
<     =====:  733:	  __throw_exception_again;
<         -:  734:	}
<        36:  735:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_create_nodesEPPS3_S7_:
<     #####:  721:    _Deque_base<_Tp, _Alloc>::
<         -:  722:    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
<         -:  723:    {
<         -:  724:      _Map_pointer __cur;
<         -:  725:      __try
<         -:  726:	{
<     #####:  727:	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
<     #####:  728:	    *__cur = this->_M_allocate_node();
<         -:  729:	}
<     =====:  730:      __catch(...)
<         -:  731:	{
<     =====:  732:	  _M_destroy_nodes(__nstart, __cur);
<     =====:  733:	  __throw_exception_again;
<         -:  734:	}
<     #####:  735:    }
< ------------------
<         -:  736:
<         -:  737:  template<typename _Tp, typename _Alloc>
<         -:  738:    void
<       36*:  739:    _Deque_base<_Tp, _Alloc>::
<         -:  740:    _M_destroy_nodes(_Map_pointer __nstart,
<         -:  741:		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
<         -:  742:    {
<       72*:  743:      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
<       36*:  744:	_M_deallocate_node(*__n);
<       36*:  745:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS11SendRequestESaIS3_EE16_M_destroy_nodesEPPS3_S7_:
<     #####:  739:    _Deque_base<_Tp, _Alloc>::
<         -:  740:    _M_destroy_nodes(_Map_pointer __nstart,
<         -:  741:		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
<         -:  742:    {
<     #####:  743:      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
<     #####:  744:	_M_deallocate_node(*__n);
<     #####:  745:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE16_M_destroy_nodesEPPS3_S7_:
<        36:  739:    _Deque_base<_Tp, _Alloc>::
<         -:  740:    _M_destroy_nodes(_Map_pointer __nstart,
<         -:  741:		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
<         -:  742:    {
<        72:  743:      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
<        36:  744:	_M_deallocate_node(*__n);
<        36:  745:    }
< ------------------
< _ZNSt11_Deque_baseIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE16_M_destroy_nodesEPPS3_S7_:
<     #####:  739:    _Deque_base<_Tp, _Alloc>::
<         -:  740:    _M_destroy_nodes(_Map_pointer __nstart,
<         -:  741:		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
<         -:  742:    {
<     #####:  743:      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
<     #####:  744:	_M_deallocate_node(*__n);
<     #####:  745:    }
< ------------------
<         -:  746:
<         -:  747:  /**
<         -:  748:   *  @brief  A standard container using fixed-size memory allocation and
<         -:  749:   *  constant-time manipulation of elements at either end.
<         -:  750:   *
<         -:  751:   *  @ingroup sequences
<         -:  752:   *
<         -:  753:   *  @tparam _Tp  Type of element.
<         -:  754:   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
<         -:  755:   *
<         -:  756:   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
<         -:  757:   *  <a href="tables.html#66">reversible container</a>, and a
<         -:  758:   *  <a href="tables.html#67">sequence</a>, including the
<         -:  759:   *  <a href="tables.html#68">optional sequence requirements</a>.
<         -:  760:   *
<         -:  761:   *  In previous HP/SGI versions of deque, there was an extra template
<         -:  762:   *  parameter so users could control the node size.  This extension turned
<         -:  763:   *  out to violate the C++ standard (it can be detected using template
<         -:  764:   *  template parameters), and it was removed.
<         -:  765:   *
<         -:  766:   *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
<         -:  767:   *
<         -:  768:   *  - Tp**        _M_map
<         -:  769:   *  - size_t      _M_map_size
<         -:  770:   *  - iterator    _M_start, _M_finish
<         -:  771:   *
<         -:  772:   *  map_size is at least 8.  %map is an array of map_size
<         -:  773:   *  pointers-to-@a nodes.  (The name %map has nothing to do with the
<         -:  774:   *  std::map class, and @b nodes should not be confused with
<         -:  775:   *  std::list's usage of @a node.)
<         -:  776:   *
<         -:  777:   *  A @a node has no specific type name as such, but it is referred
<         -:  778:   *  to as @a node in this file.  It is a simple array-of-Tp.  If Tp
<         -:  779:   *  is very large, there will be one Tp element per node (i.e., an
<         -:  780:   *  @a array of one).  For non-huge Tp's, node size is inversely
<         -:  781:   *  related to Tp size: the larger the Tp, the fewer Tp's will fit
<         -:  782:   *  in a node.  The goal here is to keep the total size of a node
<         -:  783:   *  relatively small and constant over different Tp's, to improve
<         -:  784:   *  allocator efficiency.
<         -:  785:   *
<         -:  786:   *  Not every pointer in the %map array will point to a node.  If
<         -:  787:   *  the initial number of elements in the deque is small, the
<         -:  788:   *  /middle/ %map pointers will be valid, and the ones at the edges
<         -:  789:   *  will be unused.  This same situation will arise as the %map
<         -:  790:   *  grows: available %map pointers, if any, will be on the ends.  As
<         -:  791:   *  new nodes are created, only a subset of the %map's pointers need
<         -:  792:   *  to be copied @a outward.
<         -:  793:   *
<         -:  794:   *  Class invariants:
<         -:  795:   * - For any nonsingular iterator i:
<         -:  796:   *    - i.node points to a member of the %map array.  (Yes, you read that
<         -:  797:   *      correctly:  i.node does not actually point to a node.)  The member of
<         -:  798:   *      the %map array is what actually points to the node.
<         -:  799:   *    - i.first == *(i.node)    (This points to the node (first Tp element).)
<         -:  800:   *    - i.last  == i.first + node_size
<         -:  801:   *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:
<         -:  802:   *      the implication of this is that i.cur is always a dereferenceable
<         -:  803:   *      pointer, even if i is a past-the-end iterator.
<         -:  804:   * - Start and Finish are always nonsingular iterators.  NOTE: this
<         -:  805:   * means that an empty deque must have one node, a deque with <N
<         -:  806:   * elements (where N is the node buffer size) must have one node, a
<         -:  807:   * deque with N through (2N-1) elements must have two nodes, etc.
<         -:  808:   * - For every node other than start.node and finish.node, every
<         -:  809:   * element in the node is an initialized object.  If start.node ==
<         -:  810:   * finish.node, then [start.cur, finish.cur) are initialized
<         -:  811:   * objects, and the elements outside that range are uninitialized
<         -:  812:   * storage.  Otherwise, [start.cur, start.last) and [finish.first,
<         -:  813:   * finish.cur) are initialized objects, and [start.first, start.cur)
<         -:  814:   * and [finish.cur, finish.last) are uninitialized storage.
<         -:  815:   * - [%map, %map + map_size) is a valid, non-empty range.
<         -:  816:   * - [start.node, finish.node] is a valid range contained within
<         -:  817:   *   [%map, %map + map_size).
<         -:  818:   * - A pointer in the range [%map, %map + map_size) points to an allocated
<         -:  819:   *   node if and only if the pointer is in the range
<         -:  820:   *   [start.node, finish.node].
<         -:  821:   *
<         -:  822:   *  Here's the magic:  nothing in deque is @b aware of the discontiguous
<         -:  823:   *  storage!
<         -:  824:   *
<         -:  825:   *  The memory setup and layout occurs in the parent, _Base, and the iterator
<         -:  826:   *  class is entirely responsible for @a leaping from one node to the next.
<         -:  827:   *  All the implementation routines for deque itself work only through the
<         -:  828:   *  start and finish iterators.  This keeps the routines simple and sane,
<         -:  829:   *  and we can use other standard algorithms as well.
<         -:  830:  */
<         -:  831:  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
<         -:  832:    class deque : protected _Deque_base<_Tp, _Alloc>
<         -:  833:    {
<         -:  834:#ifdef _GLIBCXX_CONCEPT_CHECKS
<         -:  835:      // concept requirements
<         -:  836:      typedef typename _Alloc::value_type	_Alloc_value_type;
<         -:  837:# if __cplusplus < 201103L
<         -:  838:      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
<         -:  839:# endif
<         -:  840:      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
<         -:  841:#endif
<         -:  842:
<         -:  843:#if __cplusplus >= 201103L
<         -:  844:      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
<         -:  845:	  "std::deque must have a non-const, non-volatile value_type");
<         -:  846:# ifdef __STRICT_ANSI__
<         -:  847:      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
<         -:  848:	  "std::deque must have the same value_type as its allocator");
<         -:  849:# endif
<         -:  850:#endif
<         -:  851:
<         -:  852:      typedef _Deque_base<_Tp, _Alloc>			_Base;
<         -:  853:      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
<         -:  854:      typedef typename _Base::_Alloc_traits		_Alloc_traits;
<         -:  855:      typedef typename _Base::_Map_pointer		_Map_pointer;
<         -:  856:
<         -:  857:    public:
<         -:  858:      typedef _Tp					value_type;
<         -:  859:      typedef typename _Alloc_traits::pointer		pointer;
<         -:  860:      typedef typename _Alloc_traits::const_pointer	const_pointer;
<         -:  861:      typedef typename _Alloc_traits::reference		reference;
<         -:  862:      typedef typename _Alloc_traits::const_reference	const_reference;
<         -:  863:      typedef typename _Base::iterator			iterator;
<         -:  864:      typedef typename _Base::const_iterator		const_iterator;
<         -:  865:      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
<         -:  866:      typedef std::reverse_iterator<iterator>		reverse_iterator;
<         -:  867:      typedef size_t					size_type;
<         -:  868:      typedef ptrdiff_t					difference_type;
<         -:  869:      typedef _Alloc					allocator_type;
<         -:  870:
<         -:  871:    protected:
<         -:  872:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
<         -:  873:      { return __deque_buf_size(sizeof(_Tp)); }
---
>         -:   96:  /**
>         -:   97:   *  @brief A deque::iterator.
>         -:   98:   *
>         -:   99:   *  Quite a bit of intelligence here.  Much of the functionality of
>         -:  100:   *  deque is actually passed off to this class.  A deque holds two
>         -:  101:   *  of these internally, marking its valid range.  Access to
>         -:  102:   *  elements is done as offsets of either of those two, relying on
>         -:  103:   *  operator overloading in this class.
>         -:  104:   *
>         -:  105:   *  All the functions are op overloads except for _M_set_node.
>         -:  106:  */
>         -:  107:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  108:    struct _Deque_iterator
>         -:  109:    {
>         -:  110:#if __cplusplus < 201103L
>         -:  111:      typedef _Deque_iterator<_Tp, _Tp&, _Tp*>	     iterator;
>         -:  112:      typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;
>         -:  113:      typedef _Tp*					 _Elt_pointer;
>         -:  114:      typedef _Tp**					_Map_pointer;
>         -:  115:#else
>         -:  116:    private:
>         -:  117:      template<typename _Up>
>         -:  118:	using __ptr_to = typename pointer_traits<_Ptr>::template rebind<_Up>;
>         -:  119:      template<typename _CvTp>
>         -:  120:	using __iter = _Deque_iterator<_Tp, _CvTp&, __ptr_to<_CvTp>>;
>         -:  121:    public:
>         -:  122:      typedef __iter<_Tp>		iterator;
>         -:  123:      typedef __iter<const _Tp>		const_iterator;
>         -:  124:      typedef __ptr_to<_Tp>		_Elt_pointer;
>         -:  125:      typedef __ptr_to<_Elt_pointer>	_Map_pointer;
>         -:  126:#endif
>         -:  127:
>       260:  128:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
>       260:  129:      { return __deque_buf_size(sizeof(_Tp)); }
>         -:  130:
>         -:  131:      typedef std::random_access_iterator_tag	iterator_category;
>         -:  132:      typedef _Tp				value_type;
>         -:  133:      typedef _Ptr				pointer;
>         -:  134:      typedef _Ref				reference;
>         -:  135:      typedef size_t				size_type;
>         -:  136:      typedef ptrdiff_t				difference_type;
>         -:  137:      typedef _Deque_iterator			_Self;
>         -:  138:
>         -:  139:      _Elt_pointer _M_cur;
>         -:  140:      _Elt_pointer _M_first;
>         -:  141:      _Elt_pointer _M_last;
>         -:  142:      _Map_pointer _M_node;
>         -:  143:
>         -:  144:      _Deque_iterator(_Elt_pointer __x, _Map_pointer __y) _GLIBCXX_NOEXCEPT
>         -:  145:      : _M_cur(__x), _M_first(*__y),
>         -:  146:	_M_last(*__y + _S_buffer_size()), _M_node(__y) { }
>         -:  147:
>       200:  148:      _Deque_iterator() _GLIBCXX_NOEXCEPT
>       200:  149:      : _M_cur(), _M_first(), _M_last(), _M_node() { }
>         -:  150:
>       488:  151:      _Deque_iterator(const iterator& __x) _GLIBCXX_NOEXCEPT
>       976:  152:      : _M_cur(__x._M_cur), _M_first(__x._M_first),
>       976:  153:	_M_last(__x._M_last), _M_node(__x._M_node) { }
>         -:  154:
>         -:  155:      iterator
>         -:  156:      _M_const_cast() const _GLIBCXX_NOEXCEPT
>         -:  157:      { return iterator(_M_cur, _M_node); }
>         -:  158:
>         -:  159:      reference
>        30:  160:      operator*() const _GLIBCXX_NOEXCEPT
>        30:  161:      { return *_M_cur; }
>         -:  162:
>         -:  163:      pointer
>         -:  164:      operator->() const _GLIBCXX_NOEXCEPT
>         -:  165:      { return _M_cur; }
>         -:  166:
>         -:  167:      _Self&
>        10:  168:      operator++() _GLIBCXX_NOEXCEPT
>         -:  169:      {
>        10:  170:	++_M_cur;
>        10:  171:	if (_M_cur == _M_last)
>         -:  172:	  {
>     #####:  173:	    _M_set_node(_M_node + 1);
>     #####:  174:	    _M_cur = _M_first;
>         -:  175:	  }
>        10:  176:	return *this;
>         -:  177:      }
>         -:  178:
>         -:  179:      _Self
>         -:  180:      operator++(int) _GLIBCXX_NOEXCEPT
>         -:  181:      {
>         -:  182:	_Self __tmp = *this;
>         -:  183:	++*this;
>         -:  184:	return __tmp;
>         -:  185:      }
>         -:  186:
>         -:  187:      _Self&
>         -:  188:      operator--() _GLIBCXX_NOEXCEPT
>         -:  189:      {
>         -:  190:	if (_M_cur == _M_first)
>         -:  191:	  {
>         -:  192:	    _M_set_node(_M_node - 1);
>         -:  193:	    _M_cur = _M_last;
>         -:  194:	  }
>         -:  195:	--_M_cur;
>         -:  196:	return *this;
>         -:  197:      }
>         -:  198:
>         -:  199:      _Self
>         -:  200:      operator--(int) _GLIBCXX_NOEXCEPT
>         -:  201:      {
>         -:  202:	_Self __tmp = *this;
>         -:  203:	--*this;
>         -:  204:	return __tmp;
>         -:  205:      }
>         -:  206:
>         -:  207:      _Self&
>        10:  208:      operator+=(difference_type __n) _GLIBCXX_NOEXCEPT
>         -:  209:      {
>        10:  210:	const difference_type __offset = __n + (_M_cur - _M_first);
>        10:  211:	if (__offset >= 0 && __offset < difference_type(_S_buffer_size()))
>        10:  212:	  _M_cur += __n;
>         -:  213:	else
>         -:  214:	  {
>     #####:  215:	    const difference_type __node_offset =
>     #####:  216:	      __offset > 0 ? __offset / difference_type(_S_buffer_size())
>     #####:  217:			   : -difference_type((-__offset - 1)
>     #####:  218:					      / _S_buffer_size()) - 1;
>     #####:  219:	    _M_set_node(_M_node + __node_offset);
>     #####:  220:	    _M_cur = _M_first + (__offset - __node_offset
>     #####:  221:				 * difference_type(_S_buffer_size()));
>         -:  222:	  }
>        10:  223:	return *this;
>         -:  224:      }
>         -:  225:
>         -:  226:      _Self
>        10:  227:      operator+(difference_type __n) const _GLIBCXX_NOEXCEPT
>         -:  228:      {
>        10:  229:	_Self __tmp = *this;
>        10:  230:	return __tmp += __n;
>         -:  231:      }
>         -:  232:
>         -:  233:      _Self&
>         -:  234:      operator-=(difference_type __n) _GLIBCXX_NOEXCEPT
>         -:  235:      { return *this += -__n; }
>         -:  236:
>         -:  237:      _Self
>         -:  238:      operator-(difference_type __n) const _GLIBCXX_NOEXCEPT
>         -:  239:      {
>         -:  240:	_Self __tmp = *this;
>         -:  241:	return __tmp -= __n;
>         -:  242:      }
>         -:  243:
>         -:  244:      reference
>        10:  245:      operator[](difference_type __n) const _GLIBCXX_NOEXCEPT
>        10:  246:      { return *(*this + __n); }
>         -:  247:
>         -:  248:      /**
>         -:  249:       *  Prepares to traverse new_node.  Sets everything except
>         -:  250:       *  _M_cur, which should therefore be set by the caller
>         -:  251:       *  immediately afterwards, based on _M_first and _M_last.
>         -:  252:       */
>         -:  253:      void
>       200:  254:      _M_set_node(_Map_pointer __new_node) _GLIBCXX_NOEXCEPT
>         -:  255:      {
>       200:  256:	_M_node = __new_node;
>       200:  257:	_M_first = *__new_node;
>       200:  258:	_M_last = _M_first + difference_type(_S_buffer_size());
>       200:  259:      }
>         -:  260:    };
>         -:  261:
>         -:  262:  // Note: we also provide overloads whose operands are of the same type in
>         -:  263:  // order to avoid ambiguous overload resolution when std::rel_ops operators
>         -:  264:  // are in scope (for additional details, see libstdc++/3628)
>         -:  265:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  266:    inline bool
>        58:  267:    operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  268:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>        58:  269:    { return __x._M_cur == __y._M_cur; }
>         -:  270:
>         -:  271:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  272:	   typename _RefR, typename _PtrR>
>         -:  273:    inline bool
>         -:  274:    operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  275:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  276:    { return __x._M_cur == __y._M_cur; }
>         -:  277:
>         -:  278:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  279:    inline bool
>        58:  280:    operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  281:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>        58:  282:    { return !(__x == __y); }
>         -:  283:
>         -:  284:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  285:	   typename _RefR, typename _PtrR>
>         -:  286:    inline bool
>         -:  287:    operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  288:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  289:    { return !(__x == __y); }
>         -:  290:
>         -:  291:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  292:    inline bool
>         -:  293:    operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  294:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>         -:  295:    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
>         -:  296:					  : (__x._M_node < __y._M_node); }
>         -:  297:
>         -:  298:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  299:	   typename _RefR, typename _PtrR>
>         -:  300:    inline bool
>         -:  301:    operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  302:	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  303:    { return (__x._M_node == __y._M_node) ? (__x._M_cur < __y._M_cur)
>         -:  304:					  : (__x._M_node < __y._M_node); }
>         -:  305:
>         -:  306:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  307:    inline bool
>         -:  308:    operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  309:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>         -:  310:    { return __y < __x; }
>         -:  311:
>         -:  312:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  313:	   typename _RefR, typename _PtrR>
>         -:  314:    inline bool
>         -:  315:    operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  316:	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  317:    { return __y < __x; }
>         -:  318:
>         -:  319:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  320:    inline bool
>         -:  321:    operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  322:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>         -:  323:    { return !(__y < __x); }
>         -:  324:
>         -:  325:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  326:	   typename _RefR, typename _PtrR>
>         -:  327:    inline bool
>         -:  328:    operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  329:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  330:    { return !(__y < __x); }
>         -:  331:
>         -:  332:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  333:    inline bool
>         -:  334:    operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  335:	       const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>         -:  336:    { return !(__x < __y); }
>         -:  337:
>         -:  338:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  339:	   typename _RefR, typename _PtrR>
>         -:  340:    inline bool
>         -:  341:    operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  342:	       const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  343:    { return !(__x < __y); }
>         -:  344:
>         -:  345:  // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  346:  // According to the resolution of DR179 not only the various comparison
>         -:  347:  // operators but also operator- must accept mixed iterator/const_iterator
>         -:  348:  // parameters.
>         -:  349:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  350:    inline typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
>        50:  351:    operator-(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,
>         -:  352:	      const _Deque_iterator<_Tp, _Ref, _Ptr>& __y) _GLIBCXX_NOEXCEPT
>         -:  353:    {
>         -:  354:      return typename _Deque_iterator<_Tp, _Ref, _Ptr>::difference_type
>        50:  355:	(_Deque_iterator<_Tp, _Ref, _Ptr>::_S_buffer_size())
>        50:  356:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
>        50:  357:	+ (__y._M_last - __y._M_cur);
>         -:  358:    }
>         -:  359:
>         -:  360:  template<typename _Tp, typename _RefL, typename _PtrL,
>         -:  361:	   typename _RefR, typename _PtrR>
>         -:  362:    inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
>         -:  363:    operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,
>         -:  364:	      const _Deque_iterator<_Tp, _RefR, _PtrR>& __y) _GLIBCXX_NOEXCEPT
>         -:  365:    {
>         -:  366:      return typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type
>         -:  367:	(_Deque_iterator<_Tp, _RefL, _PtrL>::_S_buffer_size())
>         -:  368:	* (__x._M_node - __y._M_node - 1) + (__x._M_cur - __x._M_first)
>         -:  369:	+ (__y._M_last - __y._M_cur);
>         -:  370:    }
>         -:  371:
>         -:  372:  template<typename _Tp, typename _Ref, typename _Ptr>
>         -:  373:    inline _Deque_iterator<_Tp, _Ref, _Ptr>
>         -:  374:    operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)
>         -:  375:    _GLIBCXX_NOEXCEPT
>         -:  376:    { return __x + __n; }
>         -:  377:
>         -:  378:  template<typename _Tp>
>         -:  379:    void
>         -:  380:    fill(const _Deque_iterator<_Tp, _Tp&, _Tp*>&,
>         -:  381:	 const _Deque_iterator<_Tp, _Tp&, _Tp*>&, const _Tp&);
>         -:  382:
>         -:  383:  template<typename _Tp>
>         -:  384:    _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  385:    copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  386:	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  387:	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
>         -:  388:
>         -:  389:  template<typename _Tp>
>         -:  390:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  391:    copy(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
>         -:  392:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
>         -:  393:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
>         -:  394:    { return std::copy(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
>         -:  395:		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
>         -:  396:		       __result); }
>         -:  397:
>         -:  398:  template<typename _Tp>
>         -:  399:    _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  400:    copy_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  401:		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  402:		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
>         -:  403:
>         -:  404:  template<typename _Tp>
>         -:  405:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  406:    copy_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
>         -:  407:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
>         -:  408:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
>         -:  409:    { return std::copy_backward(_Deque_iterator<_Tp,
>         -:  410:				const _Tp&, const _Tp*>(__first),
>         -:  411:				_Deque_iterator<_Tp,
>         -:  412:				const _Tp&, const _Tp*>(__last),
>         -:  413:				__result); }
>         -:  414:
>         -:  415:#if __cplusplus >= 201103L
>         -:  416:  template<typename _Tp>
>         -:  417:    _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  418:    move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  419:	 _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  420:	 _Deque_iterator<_Tp, _Tp&, _Tp*>);
>         -:  421:
>         -:  422:  template<typename _Tp>
>         -:  423:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  424:    move(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
>         -:  425:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
>         -:  426:	 _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
>         -:  427:    { return std::move(_Deque_iterator<_Tp, const _Tp&, const _Tp*>(__first),
>         -:  428:		       _Deque_iterator<_Tp, const _Tp&, const _Tp*>(__last),
>         -:  429:		       __result); }
>         -:  430:
>         -:  431:  template<typename _Tp>
>         -:  432:    _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  433:    move_backward(_Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  434:		  _Deque_iterator<_Tp, const _Tp&, const _Tp*>,
>         -:  435:		  _Deque_iterator<_Tp, _Tp&, _Tp*>);
>         -:  436:
>         -:  437:  template<typename _Tp>
>         -:  438:    inline _Deque_iterator<_Tp, _Tp&, _Tp*>
>         -:  439:    move_backward(_Deque_iterator<_Tp, _Tp&, _Tp*> __first,
>         -:  440:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __last,
>         -:  441:		  _Deque_iterator<_Tp, _Tp&, _Tp*> __result)
>         -:  442:    { return std::move_backward(_Deque_iterator<_Tp,
>         -:  443:				const _Tp&, const _Tp*>(__first),
>         -:  444:				_Deque_iterator<_Tp,
>         -:  445:				const _Tp&, const _Tp*>(__last),
>         -:  446:				__result); }
>         -:  447:#endif
>         -:  448:
>         -:  449:  /**
>         -:  450:   *  Deque base class.  This class provides the unified face for %deque's
>         -:  451:   *  allocation.  This class's constructor and destructor allocate and
>         -:  452:   *  deallocate (but do not initialize) storage.  This makes %exception
>         -:  453:   *  safety easier.
>         -:  454:   *
>         -:  455:   *  Nothing in this class ever constructs or destroys an actual Tp element.
>         -:  456:   *  (Deque handles that itself.)  Only/All memory management is performed
>         -:  457:   *  here.
>         -:  458:  */
>         -:  459:  template<typename _Tp, typename _Alloc>
>         -:  460:    class _Deque_base
>         -:  461:    {
>         -:  462:    protected:
>         -:  463:      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
>         -:  464:	rebind<_Tp>::other _Tp_alloc_type;
>         -:  465:      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	 _Alloc_traits;
>         -:  466:
>         -:  467:#if __cplusplus < 201103L
>         -:  468:      typedef _Tp*					_Ptr;
>         -:  469:      typedef const _Tp*				_Ptr_const;
>         -:  470:#else
>         -:  471:      typedef typename _Alloc_traits::pointer		_Ptr;
>         -:  472:      typedef typename _Alloc_traits::const_pointer	_Ptr_const;
>         -:  473:#endif
>         -:  474:
>         -:  475:      typedef typename _Alloc_traits::template rebind<_Ptr>::other
>         -:  476:	_Map_alloc_type;
>         -:  477:      typedef __gnu_cxx::__alloc_traits<_Map_alloc_type> _Map_alloc_traits;
>         -:  478:
>         -:  479:    public:
>         -:  480:      typedef _Alloc		  allocator_type;
>         -:  481:      typedef typename _Alloc_traits::size_type size_type;
>         -:  482:
>         -:  483:      allocator_type
>         -:  484:      get_allocator() const _GLIBCXX_NOEXCEPT
>         -:  485:      { return allocator_type(_M_get_Tp_allocator()); }
>         -:  486:
>         -:  487:      typedef _Deque_iterator<_Tp, _Tp&, _Ptr>	  iterator;
>         -:  488:      typedef _Deque_iterator<_Tp, const _Tp&, _Ptr_const>   const_iterator;
>         -:  489:
>       100:  490:      _Deque_base()
>       100:  491:      : _M_impl()
>       100:  492:      { _M_initialize_map(0); }
>         -:  493:
>         -:  494:      _Deque_base(size_t __num_elements)
>         -:  495:      : _M_impl()
>         -:  496:      { _M_initialize_map(__num_elements); }
>         -:  497:
>         -:  498:      _Deque_base(const allocator_type& __a, size_t __num_elements)
>         -:  499:      : _M_impl(__a)
>         -:  500:      { _M_initialize_map(__num_elements); }
>         -:  501:
>         -:  502:      _Deque_base(const allocator_type& __a)
>         -:  503:      : _M_impl(__a)
>         -:  504:      { /* Caller must initialize map. */ }
>         -:  505:
>         -:  506:#if __cplusplus >= 201103L
>         -:  507:      _Deque_base(_Deque_base&& __x, false_type)
>         -:  508:      : _M_impl(__x._M_move_impl())
>         -:  509:      { }
>         -:  510:
>         -:  511:      _Deque_base(_Deque_base&& __x, true_type)
>         -:  512:      : _M_impl(std::move(__x._M_get_Tp_allocator()))
>         -:  513:      {
>         -:  514:	_M_initialize_map(0);
>         -:  515:	if (__x._M_impl._M_map)
>         -:  516:	  this->_M_impl._M_swap_data(__x._M_impl);
>         -:  517:      }
>         -:  518:
>         -:  519:      _Deque_base(_Deque_base&& __x)
>         -:  520:      : _Deque_base(std::move(__x), typename _Alloc_traits::is_always_equal{})
>         -:  521:      { }
>         -:  522:
>         -:  523:      _Deque_base(_Deque_base&& __x, const allocator_type& __a, size_type __n)
>         -:  524:      : _M_impl(__a)
>         -:  525:      {
>         -:  526:	if (__x.get_allocator() == __a)
>         -:  527:	  {
>         -:  528:	    if (__x._M_impl._M_map)
>         -:  529:	      {
>         -:  530:		_M_initialize_map(0);
>         -:  531:		this->_M_impl._M_swap_data(__x._M_impl);
>         -:  532:	      }
>         -:  533:	  }
>         -:  534:	else
>         -:  535:	  {
>         -:  536:	    _M_initialize_map(__n);
>         -:  537:	  }
>         -:  538:      }
>         -:  539:#endif
>         -:  540:
>         -:  541:      ~_Deque_base() _GLIBCXX_NOEXCEPT;
>         -:  542:
>         -:  543:    protected:
>         -:  544:      typedef typename iterator::_Map_pointer _Map_pointer;
>         -:  545:
>         -:  546:      //This struct encapsulates the implementation of the std::deque
>         -:  547:      //standard container and at the same time makes use of the EBO
>         -:  548:      //for empty allocators.
>       100:  549:      struct _Deque_impl
>         -:  550:      : public _Tp_alloc_type
>         -:  551:      {
>         -:  552:	_Map_pointer _M_map;
>         -:  553:	size_t _M_map_size;
>         -:  554:	iterator _M_start;
>         -:  555:	iterator _M_finish;
>         -:  556:
>       100:  557:	_Deque_impl()
>         -:  558:	: _Tp_alloc_type(), _M_map(), _M_map_size(0),
>       100:  559:	  _M_start(), _M_finish()
>       100:  560:	{ }
>         -:  561:
>         -:  562:	_Deque_impl(const _Tp_alloc_type& __a) _GLIBCXX_NOEXCEPT
>         -:  563:	: _Tp_alloc_type(__a), _M_map(), _M_map_size(0),
>         -:  564:	  _M_start(), _M_finish()
>         -:  565:	{ }
>         -:  566:
>         -:  567:#if __cplusplus >= 201103L
>         -:  568:	_Deque_impl(_Deque_impl&&) = default;
>         -:  569:
>         -:  570:	_Deque_impl(_Tp_alloc_type&& __a) noexcept
>         -:  571:	: _Tp_alloc_type(std::move(__a)), _M_map(), _M_map_size(0),
>         -:  572:	  _M_start(), _M_finish()
>         -:  573:	{ }
>         -:  574:#endif
>         -:  575:
>        76:  576:	void _M_swap_data(_Deque_impl& __x) _GLIBCXX_NOEXCEPT
>         -:  577:	{
>         -:  578:	  using std::swap;
>        76:  579:	  swap(this->_M_start, __x._M_start);
>        76:  580:	  swap(this->_M_finish, __x._M_finish);
>        76:  581:	  swap(this->_M_map, __x._M_map);
>        76:  582:	  swap(this->_M_map_size, __x._M_map_size);
>        76:  583:	}
>         -:  584:      };
>         -:  585:
>         -:  586:      _Tp_alloc_type&
>       252:  587:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
>       252:  588:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
>         -:  589:
>         -:  590:      const _Tp_alloc_type&
>       200:  591:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
>       200:  592:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
>         -:  593:
>         -:  594:      _Map_alloc_type
>       200:  595:      _M_get_map_allocator() const _GLIBCXX_NOEXCEPT
>       200:  596:      { return _Map_alloc_type(_M_get_Tp_allocator()); }
>         -:  597:
>         -:  598:      _Ptr
>       100:  599:      _M_allocate_node()
>         -:  600:      {
>         -:  601:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
>       100:  602:	return _Traits::allocate(_M_impl, __deque_buf_size(sizeof(_Tp)));
>         -:  603:      }
>         -:  604:
>         -:  605:      void
>       100:  606:      _M_deallocate_node(_Ptr __p) _GLIBCXX_NOEXCEPT
>         -:  607:      {
>         -:  608:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Traits;
>       100:  609:	_Traits::deallocate(_M_impl, __p, __deque_buf_size(sizeof(_Tp)));
>       100:  610:      }
>         -:  611:
>         -:  612:      _Map_pointer
>       100:  613:      _M_allocate_map(size_t __n)
>         -:  614:      {
>       200:  615:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
>       200:  616:	return _Map_alloc_traits::allocate(__map_alloc, __n);
>         -:  617:      }
>         -:  618:
>         -:  619:      void
>       100:  620:      _M_deallocate_map(_Map_pointer __p, size_t __n) _GLIBCXX_NOEXCEPT
>         -:  621:      {
>       200:  622:	_Map_alloc_type __map_alloc = _M_get_map_allocator();
>       100:  623:	_Map_alloc_traits::deallocate(__map_alloc, __p, __n);
>       100:  624:      }
>         -:  625:
>         -:  626:    protected:
>         -:  627:      void _M_initialize_map(size_t);
>         -:  628:      void _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish);
>         -:  629:      void _M_destroy_nodes(_Map_pointer __nstart,
>         -:  630:			    _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT;
>         -:  631:      enum { _S_initial_map_size = 8 };
>         -:  632:
>         -:  633:      _Deque_impl _M_impl;
>         -:  634:
>         -:  635:#if __cplusplus >= 201103L
>         -:  636:    private:
>         -:  637:      _Deque_impl
>         -:  638:      _M_move_impl()
>         -:  639:      {
>         -:  640:	if (!_M_impl._M_map)
>         -:  641:	  return std::move(_M_impl);
>         -:  642:
>         -:  643:	// Create a copy of the current allocator.
>         -:  644:	_Tp_alloc_type __alloc{_M_get_Tp_allocator()};
>         -:  645:	// Put that copy in a moved-from state.
>         -:  646:	_Tp_alloc_type __sink __attribute((__unused__)) {std::move(__alloc)};
>         -:  647:	// Create an empty map that allocates using the moved-from allocator.
>         -:  648:	_Deque_base __empty{__alloc};
>         -:  649:	__empty._M_initialize_map(0);
>         -:  650:	// Now safe to modify current allocator and perform non-throwing swaps.
>         -:  651:	_Deque_impl __ret{std::move(_M_get_Tp_allocator())};
>         -:  652:	_M_impl._M_swap_data(__ret);
>         -:  653:	_M_impl._M_swap_data(__empty._M_impl);
>         -:  654:	return __ret;
>         -:  655:      }
>         -:  656:#endif
>         -:  657:    };
>         -:  658:
>         -:  659:  template<typename _Tp, typename _Alloc>
>       100:  660:    _Deque_base<_Tp, _Alloc>::
>         -:  661:    ~_Deque_base() _GLIBCXX_NOEXCEPT
>         -:  662:    {
>       100:  663:      if (this->_M_impl._M_map)
>         -:  664:	{
>       100:  665:	  _M_destroy_nodes(this->_M_impl._M_start._M_node,
>       100:  666:			   this->_M_impl._M_finish._M_node + 1);
>       100:  667:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
>         -:  668:	}
>       100:  669:    }
>         -:  670:
>         -:  671:  /**
>         -:  672:   *  @brief Layout storage.
>         -:  673:   *  @param  __num_elements  The count of T's for which to allocate space
>         -:  674:   *                          at first.
>         -:  675:   *  @return   Nothing.
>         -:  676:   *
>         -:  677:   *  The initial underlying memory layout is a bit complicated...
>         -:  678:  */
>         -:  679:  template<typename _Tp, typename _Alloc>
>         -:  680:    void
>       100:  681:    _Deque_base<_Tp, _Alloc>::
>         -:  682:    _M_initialize_map(size_t __num_elements)
>         -:  683:    {
>       100:  684:      const size_t __num_nodes = (__num_elements/ __deque_buf_size(sizeof(_Tp))
>         -:  685:				  + 1);
>         -:  686:
>       100:  687:      this->_M_impl._M_map_size = std::max((size_t) _S_initial_map_size,
>       200:  688:					   size_t(__num_nodes + 2));
>       100:  689:      this->_M_impl._M_map = _M_allocate_map(this->_M_impl._M_map_size);
>         -:  690:
>         -:  691:      // For "small" maps (needing less than _M_map_size nodes), allocation
>         -:  692:      // starts in the middle elements and grows outwards.  So nstart may be
>         -:  693:      // the beginning of _M_map, but for small maps it may be as far in as
>         -:  694:      // _M_map+3.
>         -:  695:
>       200:  696:      _Map_pointer __nstart = (this->_M_impl._M_map
>       100:  697:			       + (this->_M_impl._M_map_size - __num_nodes) / 2);
>       100:  698:      _Map_pointer __nfinish = __nstart + __num_nodes;
>         -:  699:
>         -:  700:      __try
>       100:  701:	{ _M_create_nodes(__nstart, __nfinish); }
>     =====:  702:      __catch(...)
>         -:  703:	{
>     =====:  704:	  _M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
>     =====:  705:	  this->_M_impl._M_map = _Map_pointer();
>     =====:  706:	  this->_M_impl._M_map_size = 0;
>     =====:  707:	  __throw_exception_again;
>         -:  708:	}
>         -:  709:
>       100:  710:      this->_M_impl._M_start._M_set_node(__nstart);
>       100:  711:      this->_M_impl._M_finish._M_set_node(__nfinish - 1);
>       100:  712:      this->_M_impl._M_start._M_cur = _M_impl._M_start._M_first;
>       200:  713:      this->_M_impl._M_finish._M_cur = (this->_M_impl._M_finish._M_first
>       100:  714:					+ __num_elements
>       100:  715:					% __deque_buf_size(sizeof(_Tp)));
>       100:  716:    }
>         -:  717:
>         -:  718:  template<typename _Tp, typename _Alloc>
>         -:  719:    void
>       100:  720:    _Deque_base<_Tp, _Alloc>::
>         -:  721:    _M_create_nodes(_Map_pointer __nstart, _Map_pointer __nfinish)
>         -:  722:    {
>         -:  723:      _Map_pointer __cur;
>         -:  724:      __try
>         -:  725:	{
>       200:  726:	  for (__cur = __nstart; __cur < __nfinish; ++__cur)
>       100:  727:	    *__cur = this->_M_allocate_node();
>         -:  728:	}
>     =====:  729:      __catch(...)
>         -:  730:	{
>     =====:  731:	  _M_destroy_nodes(__nstart, __cur);
>     =====:  732:	  __throw_exception_again;
>         -:  733:	}
>       100:  734:    }
>         -:  735:
>         -:  736:  template<typename _Tp, typename _Alloc>
>         -:  737:    void
>       100:  738:    _Deque_base<_Tp, _Alloc>::
>         -:  739:    _M_destroy_nodes(_Map_pointer __nstart,
>         -:  740:		     _Map_pointer __nfinish) _GLIBCXX_NOEXCEPT
>         -:  741:    {
>       200:  742:      for (_Map_pointer __n = __nstart; __n < __nfinish; ++__n)
>       100:  743:	_M_deallocate_node(*__n);
>       100:  744:    }
>         -:  745:
>         -:  746:  /**
>         -:  747:   *  @brief  A standard container using fixed-size memory allocation and
>         -:  748:   *  constant-time manipulation of elements at either end.
>         -:  749:   *
>         -:  750:   *  @ingroup sequences
>         -:  751:   *
>         -:  752:   *  @tparam _Tp  Type of element.
>         -:  753:   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
>         -:  754:   *
>         -:  755:   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
>         -:  756:   *  <a href="tables.html#66">reversible container</a>, and a
>         -:  757:   *  <a href="tables.html#67">sequence</a>, including the
>         -:  758:   *  <a href="tables.html#68">optional sequence requirements</a>.
>         -:  759:   *
>         -:  760:   *  In previous HP/SGI versions of deque, there was an extra template
>         -:  761:   *  parameter so users could control the node size.  This extension turned
>         -:  762:   *  out to violate the C++ standard (it can be detected using template
>         -:  763:   *  template parameters), and it was removed.
>         -:  764:   *
>         -:  765:   *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:
>         -:  766:   *
>         -:  767:   *  - Tp**        _M_map
>         -:  768:   *  - size_t      _M_map_size
>         -:  769:   *  - iterator    _M_start, _M_finish
>         -:  770:   *
>         -:  771:   *  map_size is at least 8.  %map is an array of map_size
>         -:  772:   *  pointers-to-@a nodes.  (The name %map has nothing to do with the
>         -:  773:   *  std::map class, and @b nodes should not be confused with
>         -:  774:   *  std::list's usage of @a node.)
>         -:  775:   *
>         -:  776:   *  A @a node has no specific type name as such, but it is referred
>         -:  777:   *  to as @a node in this file.  It is a simple array-of-Tp.  If Tp
>         -:  778:   *  is very large, there will be one Tp element per node (i.e., an
>         -:  779:   *  @a array of one).  For non-huge Tp's, node size is inversely
>         -:  780:   *  related to Tp size: the larger the Tp, the fewer Tp's will fit
>         -:  781:   *  in a node.  The goal here is to keep the total size of a node
>         -:  782:   *  relatively small and constant over different Tp's, to improve
>         -:  783:   *  allocator efficiency.
>         -:  784:   *
>         -:  785:   *  Not every pointer in the %map array will point to a node.  If
>         -:  786:   *  the initial number of elements in the deque is small, the
>         -:  787:   *  /middle/ %map pointers will be valid, and the ones at the edges
>         -:  788:   *  will be unused.  This same situation will arise as the %map
>         -:  789:   *  grows: available %map pointers, if any, will be on the ends.  As
>         -:  790:   *  new nodes are created, only a subset of the %map's pointers need
>         -:  791:   *  to be copied @a outward.
>         -:  792:   *
>         -:  793:   *  Class invariants:
>         -:  794:   * - For any nonsingular iterator i:
>         -:  795:   *    - i.node points to a member of the %map array.  (Yes, you read that
>         -:  796:   *      correctly:  i.node does not actually point to a node.)  The member of
>         -:  797:   *      the %map array is what actually points to the node.
>         -:  798:   *    - i.first == *(i.node)    (This points to the node (first Tp element).)
>         -:  799:   *    - i.last  == i.first + node_size
>         -:  800:   *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:
>         -:  801:   *      the implication of this is that i.cur is always a dereferenceable
>         -:  802:   *      pointer, even if i is a past-the-end iterator.
>         -:  803:   * - Start and Finish are always nonsingular iterators.  NOTE: this
>         -:  804:   * means that an empty deque must have one node, a deque with <N
>         -:  805:   * elements (where N is the node buffer size) must have one node, a
>         -:  806:   * deque with N through (2N-1) elements must have two nodes, etc.
>         -:  807:   * - For every node other than start.node and finish.node, every
>         -:  808:   * element in the node is an initialized object.  If start.node ==
>         -:  809:   * finish.node, then [start.cur, finish.cur) are initialized
>         -:  810:   * objects, and the elements outside that range are uninitialized
>         -:  811:   * storage.  Otherwise, [start.cur, start.last) and [finish.first,
>         -:  812:   * finish.cur) are initialized objects, and [start.first, start.cur)
>         -:  813:   * and [finish.cur, finish.last) are uninitialized storage.
>         -:  814:   * - [%map, %map + map_size) is a valid, non-empty range.
>         -:  815:   * - [start.node, finish.node] is a valid range contained within
>         -:  816:   *   [%map, %map + map_size).
>         -:  817:   * - A pointer in the range [%map, %map + map_size) points to an allocated
>         -:  818:   *   node if and only if the pointer is in the range
>         -:  819:   *   [start.node, finish.node].
>         -:  820:   *
>         -:  821:   *  Here's the magic:  nothing in deque is @b aware of the discontiguous
>         -:  822:   *  storage!
>         -:  823:   *
>         -:  824:   *  The memory setup and layout occurs in the parent, _Base, and the iterator
>         -:  825:   *  class is entirely responsible for @a leaping from one node to the next.
>         -:  826:   *  All the implementation routines for deque itself work only through the
>         -:  827:   *  start and finish iterators.  This keeps the routines simple and sane,
>         -:  828:   *  and we can use other standard algorithms as well.
>         -:  829:  */
>         -:  830:  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
>         -:  831:    class deque : protected _Deque_base<_Tp, _Alloc>
>         -:  832:    {
>         -:  833:#ifdef _GLIBCXX_CONCEPT_CHECKS
>         -:  834:      // concept requirements
>         -:  835:      typedef typename _Alloc::value_type	_Alloc_value_type;
>         -:  836:# if __cplusplus < 201103L
>         -:  837:      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
>         -:  838:# endif
>         -:  839:      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
>         -:  840:#endif
>         -:  841:
>         -:  842:      typedef _Deque_base<_Tp, _Alloc>			_Base;
>         -:  843:      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
>         -:  844:      typedef typename _Base::_Alloc_traits		_Alloc_traits;
>         -:  845:      typedef typename _Base::_Map_pointer		_Map_pointer;
>         -:  846:
>         -:  847:    public:
>         -:  848:      typedef _Tp					value_type;
>         -:  849:      typedef typename _Alloc_traits::pointer		pointer;
>         -:  850:      typedef typename _Alloc_traits::const_pointer	const_pointer;
>         -:  851:      typedef typename _Alloc_traits::reference		reference;
>         -:  852:      typedef typename _Alloc_traits::const_reference	const_reference;
>         -:  853:      typedef typename _Base::iterator			iterator;
>         -:  854:      typedef typename _Base::const_iterator		const_iterator;
>         -:  855:      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
>         -:  856:      typedef std::reverse_iterator<iterator>		reverse_iterator;
>         -:  857:      typedef size_t					size_type;
>         -:  858:      typedef ptrdiff_t					difference_type;
>         -:  859:      typedef _Alloc					allocator_type;
>         -:  860:
>         -:  861:    protected:
>         -:  862:      static size_t _S_buffer_size() _GLIBCXX_NOEXCEPT
>         -:  863:      { return __deque_buf_size(sizeof(_Tp)); }
>         -:  864:
>         -:  865:      // Functions controlling memory layout, and nothing else.
>         -:  866:      using _Base::_M_initialize_map;
>         -:  867:      using _Base::_M_create_nodes;
>         -:  868:      using _Base::_M_destroy_nodes;
>         -:  869:      using _Base::_M_allocate_node;
>         -:  870:      using _Base::_M_deallocate_node;
>         -:  871:      using _Base::_M_allocate_map;
>         -:  872:      using _Base::_M_deallocate_map;
>         -:  873:      using _Base::_M_get_Tp_allocator;
1783,1791c877,885
<         -:  875:      // Functions controlling memory layout, and nothing else.
<         -:  876:      using _Base::_M_initialize_map;
<         -:  877:      using _Base::_M_create_nodes;
<         -:  878:      using _Base::_M_destroy_nodes;
<         -:  879:      using _Base::_M_allocate_node;
<         -:  880:      using _Base::_M_deallocate_node;
<         -:  881:      using _Base::_M_allocate_map;
<         -:  882:      using _Base::_M_deallocate_map;
<         -:  883:      using _Base::_M_get_Tp_allocator;
---
>         -:  875:      /**
>         -:  876:       *  A total of four data members accumulated down the hierarchy.
>         -:  877:       *  May be accessed via _M_impl.*
>         -:  878:       */
>         -:  879:      using _Base::_M_impl;
>         -:  880:
>         -:  881:    public:
>         -:  882:      // [23.2.1.1] construct/copy/destroy
>         -:  883:      // (assign() and get_allocator() are also listed in this section)
1794,2214c888,1233
<         -:  886:       *  A total of four data members accumulated down the hierarchy.
<         -:  887:       *  May be accessed via _M_impl.*
<         -:  888:       */
<         -:  889:      using _Base::_M_impl;
<         -:  890:
<         -:  891:    public:
<         -:  892:      // [23.2.1.1] construct/copy/destroy
<         -:  893:      // (assign() and get_allocator() are also listed in this section)
<         -:  894:
<         -:  895:      /**
<         -:  896:       *  @brief  Creates a %deque with no elements.
<         -:  897:       */
<       36*:  898:      deque() : _Base() { }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EEC2Ev:
<     #####:  898:      deque() : _Base() { }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EEC2Ev:
<        36:  898:      deque() : _Base() { }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EEC2Ev:
<     #####:  898:      deque() : _Base() { }
< ------------------
<         -:  899:
<         -:  900:      /**
<         -:  901:       *  @brief  Creates a %deque with no elements.
<         -:  902:       *  @param  __a  An allocator object.
<         -:  903:       */
<         -:  904:      explicit
<         -:  905:      deque(const allocator_type& __a)
<         -:  906:      : _Base(__a, 0) { }
<         -:  907:
<         -:  908:#if __cplusplus >= 201103L
<         -:  909:      /**
<         -:  910:       *  @brief  Creates a %deque with default constructed elements.
<         -:  911:       *  @param  __n  The number of elements to initially create.
<         -:  912:       *  @param  __a  An allocator.
<         -:  913:       *
<         -:  914:       *  This constructor fills the %deque with @a n default
<         -:  915:       *  constructed elements.
<         -:  916:       */
<         -:  917:      explicit
<         -:  918:      deque(size_type __n, const allocator_type& __a = allocator_type())
<         -:  919:      : _Base(__a, __n)
<         -:  920:      { _M_default_initialize(); }
<         -:  921:
<         -:  922:      /**
<         -:  923:       *  @brief  Creates a %deque with copies of an exemplar element.
<         -:  924:       *  @param  __n  The number of elements to initially create.
<         -:  925:       *  @param  __value  An element to copy.
<         -:  926:       *  @param  __a  An allocator.
<         -:  927:       *
<         -:  928:       *  This constructor fills the %deque with @a __n copies of @a __value.
<         -:  929:       */
<         -:  930:      deque(size_type __n, const value_type& __value,
<         -:  931:	    const allocator_type& __a = allocator_type())
<         -:  932:      : _Base(__a, __n)
<         -:  933:      { _M_fill_initialize(__value); }
<         -:  934:#else
<         -:  935:      /**
<         -:  936:       *  @brief  Creates a %deque with copies of an exemplar element.
<         -:  937:       *  @param  __n  The number of elements to initially create.
<         -:  938:       *  @param  __value  An element to copy.
<         -:  939:       *  @param  __a  An allocator.
<         -:  940:       *
<         -:  941:       *  This constructor fills the %deque with @a __n copies of @a __value.
<         -:  942:       */
<         -:  943:      explicit
<         -:  944:      deque(size_type __n, const value_type& __value = value_type(),
<         -:  945:	    const allocator_type& __a = allocator_type())
<         -:  946:      : _Base(__a, __n)
<         -:  947:      { _M_fill_initialize(__value); }
<         -:  948:#endif
<         -:  949:
<         -:  950:      /**
<         -:  951:       *  @brief  %Deque copy constructor.
<         -:  952:       *  @param  __x  A %deque of identical element and allocator types.
<         -:  953:       *
<         -:  954:       *  The newly-created %deque uses a copy of the allocator object used
<         -:  955:       *  by @a __x (unless the allocator traits dictate a different object).
<         -:  956:       */
<         -:  957:      deque(const deque& __x)
<         -:  958:      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
<         -:  959:	      __x.size())
<         -:  960:      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
<         -:  961:				    this->_M_impl._M_start,
<         -:  962:				    _M_get_Tp_allocator()); }
<         -:  963:
<         -:  964:#if __cplusplus >= 201103L
<         -:  965:      /**
<         -:  966:       *  @brief  %Deque move constructor.
<         -:  967:       *  @param  __x  A %deque of identical element and allocator types.
<         -:  968:       *
<         -:  969:       *  The newly-created %deque contains the exact contents of @a __x.
<         -:  970:       *  The contents of @a __x are a valid, but unspecified %deque.
<         -:  971:       */
<         -:  972:      deque(deque&& __x)
<         -:  973:      : _Base(std::move(__x)) { }
<         -:  974:
<         -:  975:      /// Copy constructor with alternative allocator
<         -:  976:      deque(const deque& __x, const allocator_type& __a)
<         -:  977:      : _Base(__a, __x.size())
<         -:  978:      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
<         -:  979:				    this->_M_impl._M_start,
<         -:  980:				    _M_get_Tp_allocator()); }
<         -:  981:
<         -:  982:      /// Move constructor with alternative allocator
<         -:  983:      deque(deque&& __x, const allocator_type& __a)
<         -:  984:      : _Base(std::move(__x), __a, __x.size())
<         -:  985:      {
<         -:  986:	if (__x.get_allocator() != __a)
<         -:  987:	  {
<         -:  988:	    std::__uninitialized_move_a(__x.begin(), __x.end(),
<         -:  989:					this->_M_impl._M_start,
<         -:  990:					_M_get_Tp_allocator());
<         -:  991:	    __x.clear();
<         -:  992:	  }
<         -:  993:      }
<         -:  994:
<         -:  995:      /**
<         -:  996:       *  @brief  Builds a %deque from an initializer list.
<         -:  997:       *  @param  __l  An initializer_list.
<         -:  998:       *  @param  __a  An allocator object.
<         -:  999:       *
<         -: 1000:       *  Create a %deque consisting of copies of the elements in the
<         -: 1001:       *  initializer_list @a __l.
<         -: 1002:       *
<         -: 1003:       *  This will call the element type's copy constructor N times
<         -: 1004:       *  (where N is __l.size()) and do no memory reallocation.
<         -: 1005:       */
<         -: 1006:      deque(initializer_list<value_type> __l,
<         -: 1007:	    const allocator_type& __a = allocator_type())
<         -: 1008:      : _Base(__a)
<         -: 1009:      {
<         -: 1010:	_M_range_initialize(__l.begin(), __l.end(),
<         -: 1011:			    random_access_iterator_tag());
<         -: 1012:      }
<         -: 1013:#endif
<         -: 1014:
<         -: 1015:      /**
<         -: 1016:       *  @brief  Builds a %deque from a range.
<         -: 1017:       *  @param  __first  An input iterator.
<         -: 1018:       *  @param  __last  An input iterator.
<         -: 1019:       *  @param  __a  An allocator object.
<         -: 1020:       *
<         -: 1021:       *  Create a %deque consisting of copies of the elements from [__first,
<         -: 1022:       *  __last).
<         -: 1023:       *
<         -: 1024:       *  If the iterators are forward, bidirectional, or random-access, then
<         -: 1025:       *  this will call the elements' copy constructor N times (where N is
<         -: 1026:       *  distance(__first,__last)) and do no memory reallocation.  But if only
<         -: 1027:       *  input iterators are used, then this will do at most 2N calls to the
<         -: 1028:       *  copy constructor, and logN memory reallocations.
<         -: 1029:       */
<         -: 1030:#if __cplusplus >= 201103L
<         -: 1031:      template<typename _InputIterator,
<         -: 1032:	       typename = std::_RequireInputIter<_InputIterator>>
<         -: 1033:	deque(_InputIterator __first, _InputIterator __last,
<         -: 1034:	      const allocator_type& __a = allocator_type())
<         -: 1035:	: _Base(__a)
<         -: 1036:	{ _M_initialize_dispatch(__first, __last, __false_type()); }
<         -: 1037:#else
<         -: 1038:      template<typename _InputIterator>
<         -: 1039:	deque(_InputIterator __first, _InputIterator __last,
<         -: 1040:	      const allocator_type& __a = allocator_type())
<         -: 1041:	: _Base(__a)
<         -: 1042:	{
<         -: 1043:	  // Check whether it's an integral type.  If so, it's not an iterator.
<         -: 1044:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
<         -: 1045:	  _M_initialize_dispatch(__first, __last, _Integral());
<         -: 1046:	}
<         -: 1047:#endif
<         -: 1048:
<         -: 1049:      /**
<         -: 1050:       *  The dtor only erases the elements, and note that if the elements
<         -: 1051:       *  themselves are pointers, the pointed-to memory is not touched in any
<         -: 1052:       *  way.  Managing the pointer is the user's responsibility.
<         -: 1053:       */
<       36*: 1054:      ~deque()
<       36*: 1055:      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EED2Ev:
<     #####: 1054:      ~deque()
<     #####: 1055:      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EED2Ev:
<        36: 1054:      ~deque()
<        36: 1055:      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EED2Ev:
<     #####: 1054:      ~deque()
<     #####: 1055:      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
< ------------------
<         -: 1056:
<         -: 1057:      /**
<         -: 1058:       *  @brief  %Deque assignment operator.
<         -: 1059:       *  @param  __x  A %deque of identical element and allocator types.
<         -: 1060:       *
<         -: 1061:       *  All the elements of @a x are copied.
<         -: 1062:       *
<         -: 1063:       *  The newly-created %deque uses a copy of the allocator object used
<         -: 1064:       *  by @a __x (unless the allocator traits dictate a different object).
<         -: 1065:       */
<         -: 1066:      deque&
<         -: 1067:      operator=(const deque& __x);
<         -: 1068:
<         -: 1069:#if __cplusplus >= 201103L
<         -: 1070:      /**
<         -: 1071:       *  @brief  %Deque move assignment operator.
<         -: 1072:       *  @param  __x  A %deque of identical element and allocator types.
<         -: 1073:       *
<         -: 1074:       *  The contents of @a __x are moved into this deque (without copying,
<         -: 1075:       *  if the allocators permit it).
<         -: 1076:       *  @a __x is a valid, but unspecified %deque.
<         -: 1077:       */
<         -: 1078:      deque&
<         -: 1079:      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
<         -: 1080:      {
<         -: 1081:	using __always_equal = typename _Alloc_traits::is_always_equal;
<         -: 1082:	_M_move_assign1(std::move(__x), __always_equal{});
<         -: 1083:	return *this;
<         -: 1084:      }
<         -: 1085:
<         -: 1086:      /**
<         -: 1087:       *  @brief  Assigns an initializer list to a %deque.
<         -: 1088:       *  @param  __l  An initializer_list.
<         -: 1089:       *
<         -: 1090:       *  This function fills a %deque with copies of the elements in the
<         -: 1091:       *  initializer_list @a __l.
<         -: 1092:       *
<         -: 1093:       *  Note that the assignment completely changes the %deque and that the
<         -: 1094:       *  resulting %deque's size is the same as the number of elements
<         -: 1095:       *  assigned.
<         -: 1096:       */
<         -: 1097:      deque&
<         -: 1098:      operator=(initializer_list<value_type> __l)
<         -: 1099:      {
<         -: 1100:	_M_assign_aux(__l.begin(), __l.end(),
<         -: 1101:		      random_access_iterator_tag());
<         -: 1102:	return *this;
<         -: 1103:      }
<         -: 1104:#endif
<         -: 1105:
<         -: 1106:      /**
<         -: 1107:       *  @brief  Assigns a given value to a %deque.
<         -: 1108:       *  @param  __n  Number of elements to be assigned.
<         -: 1109:       *  @param  __val  Value to be assigned.
<         -: 1110:       *
<         -: 1111:       *  This function fills a %deque with @a n copies of the given
<         -: 1112:       *  value.  Note that the assignment completely changes the
<         -: 1113:       *  %deque and that the resulting %deque's size is the same as
<         -: 1114:       *  the number of elements assigned.
<         -: 1115:       */
<         -: 1116:      void
<         -: 1117:      assign(size_type __n, const value_type& __val)
<         -: 1118:      { _M_fill_assign(__n, __val); }
<         -: 1119:
<         -: 1120:      /**
<         -: 1121:       *  @brief  Assigns a range to a %deque.
<         -: 1122:       *  @param  __first  An input iterator.
<         -: 1123:       *  @param  __last   An input iterator.
<         -: 1124:       *
<         -: 1125:       *  This function fills a %deque with copies of the elements in the
<         -: 1126:       *  range [__first,__last).
<         -: 1127:       *
<         -: 1128:       *  Note that the assignment completely changes the %deque and that the
<         -: 1129:       *  resulting %deque's size is the same as the number of elements
<         -: 1130:       *  assigned.
<         -: 1131:       */
<         -: 1132:#if __cplusplus >= 201103L
<         -: 1133:      template<typename _InputIterator,
<         -: 1134:	       typename = std::_RequireInputIter<_InputIterator>>
<         -: 1135:	void
<         -: 1136:	assign(_InputIterator __first, _InputIterator __last)
<         -: 1137:	{ _M_assign_dispatch(__first, __last, __false_type()); }
<         -: 1138:#else
<         -: 1139:      template<typename _InputIterator>
<         -: 1140:	void
<         -: 1141:	assign(_InputIterator __first, _InputIterator __last)
<         -: 1142:	{
<         -: 1143:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
<         -: 1144:	  _M_assign_dispatch(__first, __last, _Integral());
<         -: 1145:	}
<         -: 1146:#endif
<         -: 1147:
<         -: 1148:#if __cplusplus >= 201103L
<         -: 1149:      /**
<         -: 1150:       *  @brief  Assigns an initializer list to a %deque.
<         -: 1151:       *  @param  __l  An initializer_list.
<         -: 1152:       *
<         -: 1153:       *  This function fills a %deque with copies of the elements in the
<         -: 1154:       *  initializer_list @a __l.
<         -: 1155:       *
<         -: 1156:       *  Note that the assignment completely changes the %deque and that the
<         -: 1157:       *  resulting %deque's size is the same as the number of elements
<         -: 1158:       *  assigned.
<         -: 1159:       */
<         -: 1160:      void
<         -: 1161:      assign(initializer_list<value_type> __l)
<         -: 1162:      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }
<         -: 1163:#endif
<         -: 1164:
<         -: 1165:      /// Get a copy of the memory allocation object.
<         -: 1166:      allocator_type
<         -: 1167:      get_allocator() const _GLIBCXX_NOEXCEPT
<         -: 1168:      { return _Base::get_allocator(); }
<         -: 1169:
<         -: 1170:      // iterators
<         -: 1171:      /**
<         -: 1172:       *  Returns a read/write iterator that points to the first element in the
<         -: 1173:       *  %deque.  Iteration is done in ordinary element order.
<         -: 1174:       */
<         -: 1175:      iterator
<       94*: 1176:      begin() _GLIBCXX_NOEXCEPT
<       94*: 1177:      { return this->_M_impl._M_start; }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE5beginEv:
<     #####: 1176:      begin() _GLIBCXX_NOEXCEPT
<     #####: 1177:      { return this->_M_impl._M_start; }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE5beginEv:
<        94: 1176:      begin() _GLIBCXX_NOEXCEPT
<        94: 1177:      { return this->_M_impl._M_start; }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE5beginEv:
<     #####: 1176:      begin() _GLIBCXX_NOEXCEPT
<     #####: 1177:      { return this->_M_impl._M_start; }
< ------------------
<         -: 1178:
<         -: 1179:      /**
<         -: 1180:       *  Returns a read-only (constant) iterator that points to the first
<         -: 1181:       *  element in the %deque.  Iteration is done in ordinary element order.
<         -: 1182:       */
<         -: 1183:      const_iterator
<       44*: 1184:      begin() const _GLIBCXX_NOEXCEPT
<       44*: 1185:      { return this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE5beginEv:
<     #####: 1184:      begin() const _GLIBCXX_NOEXCEPT
<     #####: 1185:      { return this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE5beginEv:
<        44: 1184:      begin() const _GLIBCXX_NOEXCEPT
<        44: 1185:      { return this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE5beginEv:
<     #####: 1184:      begin() const _GLIBCXX_NOEXCEPT
<     #####: 1185:      { return this->_M_impl._M_start; }
< ------------------
<         -: 1186:
<         -: 1187:      /**
<         -: 1188:       *  Returns a read/write iterator that points one past the last
<         -: 1189:       *  element in the %deque.  Iteration is done in ordinary
<         -: 1190:       *  element order.
<         -: 1191:       */
<         -: 1192:      iterator
<       48*: 1193:      end() _GLIBCXX_NOEXCEPT
<       48*: 1194:      { return this->_M_impl._M_finish; }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE3endEv:
<     #####: 1193:      end() _GLIBCXX_NOEXCEPT
<     #####: 1194:      { return this->_M_impl._M_finish; }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE3endEv:
<        48: 1193:      end() _GLIBCXX_NOEXCEPT
<        48: 1194:      { return this->_M_impl._M_finish; }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE3endEv:
<     #####: 1193:      end() _GLIBCXX_NOEXCEPT
<     #####: 1194:      { return this->_M_impl._M_finish; }
< ------------------
<         -: 1195:
<         -: 1196:      /**
<         -: 1197:       *  Returns a read-only (constant) iterator that points one past
<         -: 1198:       *  the last element in the %deque.  Iteration is done in
<         -: 1199:       *  ordinary element order.
<         -: 1200:       */
<         -: 1201:      const_iterator
<       90*: 1202:      end() const _GLIBCXX_NOEXCEPT
<       90*: 1203:      { return this->_M_impl._M_finish; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE3endEv:
<     #####: 1202:      end() const _GLIBCXX_NOEXCEPT
<     #####: 1203:      { return this->_M_impl._M_finish; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE3endEv:
<        90: 1202:      end() const _GLIBCXX_NOEXCEPT
<        90: 1203:      { return this->_M_impl._M_finish; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE3endEv:
<     #####: 1202:      end() const _GLIBCXX_NOEXCEPT
<     #####: 1203:      { return this->_M_impl._M_finish; }
< ------------------
<         -: 1204:
<         -: 1205:      /**
<         -: 1206:       *  Returns a read/write reverse iterator that points to the
<         -: 1207:       *  last element in the %deque.  Iteration is done in reverse
<         -: 1208:       *  element order.
<         -: 1209:       */
<         -: 1210:      reverse_iterator
<         -: 1211:      rbegin() _GLIBCXX_NOEXCEPT
<         -: 1212:      { return reverse_iterator(this->_M_impl._M_finish); }
<         -: 1213:
<         -: 1214:      /**
<         -: 1215:       *  Returns a read-only (constant) reverse iterator that points
<         -: 1216:       *  to the last element in the %deque.  Iteration is done in
<         -: 1217:       *  reverse element order.
<         -: 1218:       */
<         -: 1219:      const_reverse_iterator
<         -: 1220:      rbegin() const _GLIBCXX_NOEXCEPT
<         -: 1221:      { return const_reverse_iterator(this->_M_impl._M_finish); }
<         -: 1222:
<         -: 1223:      /**
<         -: 1224:       *  Returns a read/write reverse iterator that points to one
<         -: 1225:       *  before the first element in the %deque.  Iteration is done
<         -: 1226:       *  in reverse element order.
<         -: 1227:       */
<         -: 1228:      reverse_iterator
<         -: 1229:      rend() _GLIBCXX_NOEXCEPT
<         -: 1230:      { return reverse_iterator(this->_M_impl._M_start); }
<         -: 1231:
---
>         -:  886:       *  @brief  Creates a %deque with no elements.
>         -:  887:       */
>       100:  888:      deque() : _Base() { }
>         -:  889:
>         -:  890:      /**
>         -:  891:       *  @brief  Creates a %deque with no elements.
>         -:  892:       *  @param  __a  An allocator object.
>         -:  893:       */
>         -:  894:      explicit
>         -:  895:      deque(const allocator_type& __a)
>         -:  896:      : _Base(__a, 0) { }
>         -:  897:
>         -:  898:#if __cplusplus >= 201103L
>         -:  899:      /**
>         -:  900:       *  @brief  Creates a %deque with default constructed elements.
>         -:  901:       *  @param  __n  The number of elements to initially create.
>         -:  902:       *  @param  __a  An allocator.
>         -:  903:       *
>         -:  904:       *  This constructor fills the %deque with @a n default
>         -:  905:       *  constructed elements.
>         -:  906:       */
>         -:  907:      explicit
>         -:  908:      deque(size_type __n, const allocator_type& __a = allocator_type())
>         -:  909:      : _Base(__a, __n)
>         -:  910:      { _M_default_initialize(); }
>         -:  911:
>         -:  912:      /**
>         -:  913:       *  @brief  Creates a %deque with copies of an exemplar element.
>         -:  914:       *  @param  __n  The number of elements to initially create.
>         -:  915:       *  @param  __value  An element to copy.
>         -:  916:       *  @param  __a  An allocator.
>         -:  917:       *
>         -:  918:       *  This constructor fills the %deque with @a __n copies of @a __value.
>         -:  919:       */
>         -:  920:      deque(size_type __n, const value_type& __value,
>         -:  921:	    const allocator_type& __a = allocator_type())
>         -:  922:      : _Base(__a, __n)
>         -:  923:      { _M_fill_initialize(__value); }
>         -:  924:#else
>         -:  925:      /**
>         -:  926:       *  @brief  Creates a %deque with copies of an exemplar element.
>         -:  927:       *  @param  __n  The number of elements to initially create.
>         -:  928:       *  @param  __value  An element to copy.
>         -:  929:       *  @param  __a  An allocator.
>         -:  930:       *
>         -:  931:       *  This constructor fills the %deque with @a __n copies of @a __value.
>         -:  932:       */
>         -:  933:      explicit
>         -:  934:      deque(size_type __n, const value_type& __value = value_type(),
>         -:  935:	    const allocator_type& __a = allocator_type())
>         -:  936:      : _Base(__a, __n)
>         -:  937:      { _M_fill_initialize(__value); }
>         -:  938:#endif
>         -:  939:
>         -:  940:      /**
>         -:  941:       *  @brief  %Deque copy constructor.
>         -:  942:       *  @param  __x  A %deque of identical element and allocator types.
>         -:  943:       *
>         -:  944:       *  The newly-created %deque uses a copy of the allocator object used
>         -:  945:       *  by @a __x (unless the allocator traits dictate a different object).
>         -:  946:       */
>         -:  947:      deque(const deque& __x)
>         -:  948:      : _Base(_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()),
>         -:  949:	      __x.size())
>         -:  950:      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
>         -:  951:				    this->_M_impl._M_start,
>         -:  952:				    _M_get_Tp_allocator()); }
>         -:  953:
>         -:  954:#if __cplusplus >= 201103L
>         -:  955:      /**
>         -:  956:       *  @brief  %Deque move constructor.
>         -:  957:       *  @param  __x  A %deque of identical element and allocator types.
>         -:  958:       *
>         -:  959:       *  The newly-created %deque contains the exact contents of @a __x.
>         -:  960:       *  The contents of @a __x are a valid, but unspecified %deque.
>         -:  961:       */
>         -:  962:      deque(deque&& __x)
>         -:  963:      : _Base(std::move(__x)) { }
>         -:  964:
>         -:  965:      /// Copy constructor with alternative allocator
>         -:  966:      deque(const deque& __x, const allocator_type& __a)
>         -:  967:      : _Base(__a, __x.size())
>         -:  968:      { std::__uninitialized_copy_a(__x.begin(), __x.end(),
>         -:  969:				    this->_M_impl._M_start,
>         -:  970:				    _M_get_Tp_allocator()); }
>         -:  971:
>         -:  972:      /// Move constructor with alternative allocator
>         -:  973:      deque(deque&& __x, const allocator_type& __a)
>         -:  974:      : _Base(std::move(__x), __a, __x.size())
>         -:  975:      {
>         -:  976:	if (__x.get_allocator() != __a)
>         -:  977:	  {
>         -:  978:	    std::__uninitialized_move_a(__x.begin(), __x.end(),
>         -:  979:					this->_M_impl._M_start,
>         -:  980:					_M_get_Tp_allocator());
>         -:  981:	    __x.clear();
>         -:  982:	  }
>         -:  983:      }
>         -:  984:
>         -:  985:      /**
>         -:  986:       *  @brief  Builds a %deque from an initializer list.
>         -:  987:       *  @param  __l  An initializer_list.
>         -:  988:       *  @param  __a  An allocator object.
>         -:  989:       *
>         -:  990:       *  Create a %deque consisting of copies of the elements in the
>         -:  991:       *  initializer_list @a __l.
>         -:  992:       *
>         -:  993:       *  This will call the element type's copy constructor N times
>         -:  994:       *  (where N is __l.size()) and do no memory reallocation.
>         -:  995:       */
>         -:  996:      deque(initializer_list<value_type> __l,
>         -:  997:	    const allocator_type& __a = allocator_type())
>         -:  998:      : _Base(__a)
>         -:  999:      {
>         -: 1000:	_M_range_initialize(__l.begin(), __l.end(),
>         -: 1001:			    random_access_iterator_tag());
>         -: 1002:      }
>         -: 1003:#endif
>         -: 1004:
>         -: 1005:      /**
>         -: 1006:       *  @brief  Builds a %deque from a range.
>         -: 1007:       *  @param  __first  An input iterator.
>         -: 1008:       *  @param  __last  An input iterator.
>         -: 1009:       *  @param  __a  An allocator object.
>         -: 1010:       *
>         -: 1011:       *  Create a %deque consisting of copies of the elements from [__first,
>         -: 1012:       *  __last).
>         -: 1013:       *
>         -: 1014:       *  If the iterators are forward, bidirectional, or random-access, then
>         -: 1015:       *  this will call the elements' copy constructor N times (where N is
>         -: 1016:       *  distance(__first,__last)) and do no memory reallocation.  But if only
>         -: 1017:       *  input iterators are used, then this will do at most 2N calls to the
>         -: 1018:       *  copy constructor, and logN memory reallocations.
>         -: 1019:       */
>         -: 1020:#if __cplusplus >= 201103L
>         -: 1021:      template<typename _InputIterator,
>         -: 1022:	       typename = std::_RequireInputIter<_InputIterator>>
>         -: 1023:	deque(_InputIterator __first, _InputIterator __last,
>         -: 1024:	      const allocator_type& __a = allocator_type())
>         -: 1025:	: _Base(__a)
>         -: 1026:	{ _M_initialize_dispatch(__first, __last, __false_type()); }
>         -: 1027:#else
>         -: 1028:      template<typename _InputIterator>
>         -: 1029:	deque(_InputIterator __first, _InputIterator __last,
>         -: 1030:	      const allocator_type& __a = allocator_type())
>         -: 1031:	: _Base(__a)
>         -: 1032:	{
>         -: 1033:	  // Check whether it's an integral type.  If so, it's not an iterator.
>         -: 1034:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
>         -: 1035:	  _M_initialize_dispatch(__first, __last, _Integral());
>         -: 1036:	}
>         -: 1037:#endif
>         -: 1038:
>         -: 1039:      /**
>         -: 1040:       *  The dtor only erases the elements, and note that if the elements
>         -: 1041:       *  themselves are pointers, the pointed-to memory is not touched in any
>         -: 1042:       *  way.  Managing the pointer is the user's responsibility.
>         -: 1043:       */
>       100: 1044:      ~deque()
>       100: 1045:      { _M_destroy_data(begin(), end(), _M_get_Tp_allocator()); }
>         -: 1046:
>         -: 1047:      /**
>         -: 1048:       *  @brief  %Deque assignment operator.
>         -: 1049:       *  @param  __x  A %deque of identical element and allocator types.
>         -: 1050:       *
>         -: 1051:       *  All the elements of @a x are copied.
>         -: 1052:       *
>         -: 1053:       *  The newly-created %deque uses a copy of the allocator object used
>         -: 1054:       *  by @a __x (unless the allocator traits dictate a different object).
>         -: 1055:       */
>         -: 1056:      deque&
>         -: 1057:      operator=(const deque& __x);
>         -: 1058:
>         -: 1059:#if __cplusplus >= 201103L
>         -: 1060:      /**
>         -: 1061:       *  @brief  %Deque move assignment operator.
>         -: 1062:       *  @param  __x  A %deque of identical element and allocator types.
>         -: 1063:       *
>         -: 1064:       *  The contents of @a __x are moved into this deque (without copying,
>         -: 1065:       *  if the allocators permit it).
>         -: 1066:       *  @a __x is a valid, but unspecified %deque.
>         -: 1067:       */
>         -: 1068:      deque&
>         -: 1069:      operator=(deque&& __x) noexcept(_Alloc_traits::_S_always_equal())
>         -: 1070:      {
>         -: 1071:	using __always_equal = typename _Alloc_traits::is_always_equal;
>         -: 1072:	_M_move_assign1(std::move(__x), __always_equal{});
>         -: 1073:	return *this;
>         -: 1074:      }
>         -: 1075:
>         -: 1076:      /**
>         -: 1077:       *  @brief  Assigns an initializer list to a %deque.
>         -: 1078:       *  @param  __l  An initializer_list.
>         -: 1079:       *
>         -: 1080:       *  This function fills a %deque with copies of the elements in the
>         -: 1081:       *  initializer_list @a __l.
>         -: 1082:       *
>         -: 1083:       *  Note that the assignment completely changes the %deque and that the
>         -: 1084:       *  resulting %deque's size is the same as the number of elements
>         -: 1085:       *  assigned.
>         -: 1086:       */
>         -: 1087:      deque&
>         -: 1088:      operator=(initializer_list<value_type> __l)
>         -: 1089:      {
>         -: 1090:	_M_assign_aux(__l.begin(), __l.end(),
>         -: 1091:		      random_access_iterator_tag());
>         -: 1092:	return *this;
>         -: 1093:      }
>         -: 1094:#endif
>         -: 1095:
>         -: 1096:      /**
>         -: 1097:       *  @brief  Assigns a given value to a %deque.
>         -: 1098:       *  @param  __n  Number of elements to be assigned.
>         -: 1099:       *  @param  __val  Value to be assigned.
>         -: 1100:       *
>         -: 1101:       *  This function fills a %deque with @a n copies of the given
>         -: 1102:       *  value.  Note that the assignment completely changes the
>         -: 1103:       *  %deque and that the resulting %deque's size is the same as
>         -: 1104:       *  the number of elements assigned.
>         -: 1105:       */
>         -: 1106:      void
>         -: 1107:      assign(size_type __n, const value_type& __val)
>         -: 1108:      { _M_fill_assign(__n, __val); }
>         -: 1109:
>         -: 1110:      /**
>         -: 1111:       *  @brief  Assigns a range to a %deque.
>         -: 1112:       *  @param  __first  An input iterator.
>         -: 1113:       *  @param  __last   An input iterator.
>         -: 1114:       *
>         -: 1115:       *  This function fills a %deque with copies of the elements in the
>         -: 1116:       *  range [__first,__last).
>         -: 1117:       *
>         -: 1118:       *  Note that the assignment completely changes the %deque and that the
>         -: 1119:       *  resulting %deque's size is the same as the number of elements
>         -: 1120:       *  assigned.
>         -: 1121:       */
>         -: 1122:#if __cplusplus >= 201103L
>         -: 1123:      template<typename _InputIterator,
>         -: 1124:	       typename = std::_RequireInputIter<_InputIterator>>
>         -: 1125:	void
>         -: 1126:	assign(_InputIterator __first, _InputIterator __last)
>         -: 1127:	{ _M_assign_dispatch(__first, __last, __false_type()); }
>         -: 1128:#else
>         -: 1129:      template<typename _InputIterator>
>         -: 1130:	void
>         -: 1131:	assign(_InputIterator __first, _InputIterator __last)
>         -: 1132:	{
>         -: 1133:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
>         -: 1134:	  _M_assign_dispatch(__first, __last, _Integral());
>         -: 1135:	}
>         -: 1136:#endif
>         -: 1137:
>         -: 1138:#if __cplusplus >= 201103L
>         -: 1139:      /**
>         -: 1140:       *  @brief  Assigns an initializer list to a %deque.
>         -: 1141:       *  @param  __l  An initializer_list.
>         -: 1142:       *
>         -: 1143:       *  This function fills a %deque with copies of the elements in the
>         -: 1144:       *  initializer_list @a __l.
>         -: 1145:       *
>         -: 1146:       *  Note that the assignment completely changes the %deque and that the
>         -: 1147:       *  resulting %deque's size is the same as the number of elements
>         -: 1148:       *  assigned.
>         -: 1149:       */
>         -: 1150:      void
>         -: 1151:      assign(initializer_list<value_type> __l)
>         -: 1152:      { _M_assign_aux(__l.begin(), __l.end(), random_access_iterator_tag()); }
>         -: 1153:#endif
>         -: 1154:
>         -: 1155:      /// Get a copy of the memory allocation object.
>         -: 1156:      allocator_type
>         -: 1157:      get_allocator() const _GLIBCXX_NOEXCEPT
>         -: 1158:      { return _Base::get_allocator(); }
>         -: 1159:
>         -: 1160:      // iterators
>         -: 1161:      /**
>         -: 1162:       *  Returns a read/write iterator that points to the first element in the
>         -: 1163:       *  %deque.  Iteration is done in ordinary element order.
>         -: 1164:       */
>         -: 1165:      iterator
>       148: 1166:      begin() _GLIBCXX_NOEXCEPT
>       148: 1167:      { return this->_M_impl._M_start; }
>         -: 1168:
>         -: 1169:      /**
>         -: 1170:       *  Returns a read-only (constant) iterator that points to the first
>         -: 1171:       *  element in the %deque.  Iteration is done in ordinary element order.
>         -: 1172:       */
>         -: 1173:      const_iterator
>        10: 1174:      begin() const _GLIBCXX_NOEXCEPT
>        10: 1175:      { return this->_M_impl._M_start; }
>         -: 1176:
>         -: 1177:      /**
>         -: 1178:       *  Returns a read/write iterator that points one past the last
>         -: 1179:       *  element in the %deque.  Iteration is done in ordinary
>         -: 1180:       *  element order.
>         -: 1181:       */
>         -: 1182:      iterator
>       138: 1183:      end() _GLIBCXX_NOEXCEPT
>       138: 1184:      { return this->_M_impl._M_finish; }
>         -: 1185:
>         -: 1186:      /**
>         -: 1187:       *  Returns a read-only (constant) iterator that points one past
>         -: 1188:       *  the last element in the %deque.  Iteration is done in
>         -: 1189:       *  ordinary element order.
>         -: 1190:       */
>         -: 1191:      const_iterator
>        20: 1192:      end() const _GLIBCXX_NOEXCEPT
>        20: 1193:      { return this->_M_impl._M_finish; }
>         -: 1194:
>         -: 1195:      /**
>         -: 1196:       *  Returns a read/write reverse iterator that points to the
>         -: 1197:       *  last element in the %deque.  Iteration is done in reverse
>         -: 1198:       *  element order.
>         -: 1199:       */
>         -: 1200:      reverse_iterator
>         -: 1201:      rbegin() _GLIBCXX_NOEXCEPT
>         -: 1202:      { return reverse_iterator(this->_M_impl._M_finish); }
>         -: 1203:
>         -: 1204:      /**
>         -: 1205:       *  Returns a read-only (constant) reverse iterator that points
>         -: 1206:       *  to the last element in the %deque.  Iteration is done in
>         -: 1207:       *  reverse element order.
>         -: 1208:       */
>         -: 1209:      const_reverse_iterator
>         -: 1210:      rbegin() const _GLIBCXX_NOEXCEPT
>         -: 1211:      { return const_reverse_iterator(this->_M_impl._M_finish); }
>         -: 1212:
>         -: 1213:      /**
>         -: 1214:       *  Returns a read/write reverse iterator that points to one
>         -: 1215:       *  before the first element in the %deque.  Iteration is done
>         -: 1216:       *  in reverse element order.
>         -: 1217:       */
>         -: 1218:      reverse_iterator
>         -: 1219:      rend() _GLIBCXX_NOEXCEPT
>         -: 1220:      { return reverse_iterator(this->_M_impl._M_start); }
>         -: 1221:
>         -: 1222:      /**
>         -: 1223:       *  Returns a read-only (constant) reverse iterator that points
>         -: 1224:       *  to one before the first element in the %deque.  Iteration is
>         -: 1225:       *  done in reverse element order.
>         -: 1226:       */
>         -: 1227:      const_reverse_iterator
>         -: 1228:      rend() const _GLIBCXX_NOEXCEPT
>         -: 1229:      { return const_reverse_iterator(this->_M_impl._M_start); }
>         -: 1230:
>         -: 1231:#if __cplusplus >= 201103L
2216,2249c1235,1268
<         -: 1233:       *  Returns a read-only (constant) reverse iterator that points
<         -: 1234:       *  to one before the first element in the %deque.  Iteration is
<         -: 1235:       *  done in reverse element order.
<         -: 1236:       */
<         -: 1237:      const_reverse_iterator
<         -: 1238:      rend() const _GLIBCXX_NOEXCEPT
<         -: 1239:      { return const_reverse_iterator(this->_M_impl._M_start); }
<         -: 1240:
<         -: 1241:#if __cplusplus >= 201103L
<         -: 1242:      /**
<         -: 1243:       *  Returns a read-only (constant) iterator that points to the first
<         -: 1244:       *  element in the %deque.  Iteration is done in ordinary element order.
<         -: 1245:       */
<         -: 1246:      const_iterator
<         -: 1247:      cbegin() const noexcept
<         -: 1248:      { return this->_M_impl._M_start; }
<         -: 1249:
<         -: 1250:      /**
<         -: 1251:       *  Returns a read-only (constant) iterator that points one past
<         -: 1252:       *  the last element in the %deque.  Iteration is done in
<         -: 1253:       *  ordinary element order.
<         -: 1254:       */
<         -: 1255:      const_iterator
<         -: 1256:      cend() const noexcept
<         -: 1257:      { return this->_M_impl._M_finish; }
<         -: 1258:
<         -: 1259:      /**
<         -: 1260:       *  Returns a read-only (constant) reverse iterator that points
<         -: 1261:       *  to the last element in the %deque.  Iteration is done in
<         -: 1262:       *  reverse element order.
<         -: 1263:       */
<         -: 1264:      const_reverse_iterator
<         -: 1265:      crbegin() const noexcept
<         -: 1266:      { return const_reverse_iterator(this->_M_impl._M_finish); }
---
>         -: 1233:       *  Returns a read-only (constant) iterator that points to the first
>         -: 1234:       *  element in the %deque.  Iteration is done in ordinary element order.
>         -: 1235:       */
>         -: 1236:      const_iterator
>         -: 1237:      cbegin() const noexcept
>         -: 1238:      { return this->_M_impl._M_start; }
>         -: 1239:
>         -: 1240:      /**
>         -: 1241:       *  Returns a read-only (constant) iterator that points one past
>         -: 1242:       *  the last element in the %deque.  Iteration is done in
>         -: 1243:       *  ordinary element order.
>         -: 1244:       */
>         -: 1245:      const_iterator
>         -: 1246:      cend() const noexcept
>         -: 1247:      { return this->_M_impl._M_finish; }
>         -: 1248:
>         -: 1249:      /**
>         -: 1250:       *  Returns a read-only (constant) reverse iterator that points
>         -: 1251:       *  to the last element in the %deque.  Iteration is done in
>         -: 1252:       *  reverse element order.
>         -: 1253:       */
>         -: 1254:      const_reverse_iterator
>         -: 1255:      crbegin() const noexcept
>         -: 1256:      { return const_reverse_iterator(this->_M_impl._M_finish); }
>         -: 1257:
>         -: 1258:      /**
>         -: 1259:       *  Returns a read-only (constant) reverse iterator that points
>         -: 1260:       *  to one before the first element in the %deque.  Iteration is
>         -: 1261:       *  done in reverse element order.
>         -: 1262:       */
>         -: 1263:      const_reverse_iterator
>         -: 1264:      crend() const noexcept
>         -: 1265:      { return const_reverse_iterator(this->_M_impl._M_start); }
>         -: 1266:#endif
2251,2984c1270,1843
<         -: 1268:      /**
<         -: 1269:       *  Returns a read-only (constant) reverse iterator that points
<         -: 1270:       *  to one before the first element in the %deque.  Iteration is
<         -: 1271:       *  done in reverse element order.
<         -: 1272:       */
<         -: 1273:      const_reverse_iterator
<         -: 1274:      crend() const noexcept
<         -: 1275:      { return const_reverse_iterator(this->_M_impl._M_start); }
<         -: 1276:#endif
<         -: 1277:
<         -: 1278:      // [23.2.1.2] capacity
<         -: 1279:      /**  Returns the number of elements in the %deque.  */
<         -: 1280:      size_type
<      226*: 1281:      size() const _GLIBCXX_NOEXCEPT
<      226*: 1282:      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE4sizeEv:
<     #####: 1281:      size() const _GLIBCXX_NOEXCEPT
<     #####: 1282:      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE4sizeEv:
<     #####: 1281:      size() const _GLIBCXX_NOEXCEPT
<     #####: 1282:      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE4sizeEv:
<       226: 1281:      size() const _GLIBCXX_NOEXCEPT
<       226: 1282:      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE4sizeEv:
<     #####: 1281:      size() const _GLIBCXX_NOEXCEPT
<     #####: 1282:      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
< ------------------
<         -: 1283:
<         -: 1284:      /**  Returns the size() of the largest possible %deque.  */
<         -: 1285:      size_type
<         -: 1286:      max_size() const _GLIBCXX_NOEXCEPT
<         -: 1287:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
<         -: 1288:
<         -: 1289:#if __cplusplus >= 201103L
<         -: 1290:      /**
<         -: 1291:       *  @brief  Resizes the %deque to the specified number of elements.
<         -: 1292:       *  @param  __new_size  Number of elements the %deque should contain.
<         -: 1293:       *
<         -: 1294:       *  This function will %resize the %deque to the specified
<         -: 1295:       *  number of elements.  If the number is smaller than the
<         -: 1296:       *  %deque's current size the %deque is truncated, otherwise
<         -: 1297:       *  default constructed elements are appended.
<         -: 1298:       */
<         -: 1299:      void
<         -: 1300:      resize(size_type __new_size)
<         -: 1301:      {
<         -: 1302:	const size_type __len = size();
<         -: 1303:	if (__new_size > __len)
<         -: 1304:	  _M_default_append(__new_size - __len);
<         -: 1305:	else if (__new_size < __len)
<         -: 1306:	  _M_erase_at_end(this->_M_impl._M_start
<         -: 1307:			  + difference_type(__new_size));
<         -: 1308:      }
<         -: 1309:
<         -: 1310:      /**
<         -: 1311:       *  @brief  Resizes the %deque to the specified number of elements.
<         -: 1312:       *  @param  __new_size  Number of elements the %deque should contain.
<         -: 1313:       *  @param  __x  Data with which new elements should be populated.
<         -: 1314:       *
<         -: 1315:       *  This function will %resize the %deque to the specified
<         -: 1316:       *  number of elements.  If the number is smaller than the
<         -: 1317:       *  %deque's current size the %deque is truncated, otherwise the
<         -: 1318:       *  %deque is extended and new elements are populated with given
<         -: 1319:       *  data.
<         -: 1320:       */
<         -: 1321:      void
<         -: 1322:      resize(size_type __new_size, const value_type& __x)
<         -: 1323:      {
<         -: 1324:	const size_type __len = size();
<         -: 1325:	if (__new_size > __len)
<         -: 1326:	  _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
<         -: 1327:	else if (__new_size < __len)
<         -: 1328:	  _M_erase_at_end(this->_M_impl._M_start
<         -: 1329:			  + difference_type(__new_size));
<         -: 1330:      }
<         -: 1331:#else
<         -: 1332:      /**
<         -: 1333:       *  @brief  Resizes the %deque to the specified number of elements.
<         -: 1334:       *  @param  __new_size  Number of elements the %deque should contain.
<         -: 1335:       *  @param  __x  Data with which new elements should be populated.
<         -: 1336:       *
<         -: 1337:       *  This function will %resize the %deque to the specified
<         -: 1338:       *  number of elements.  If the number is smaller than the
<         -: 1339:       *  %deque's current size the %deque is truncated, otherwise the
<         -: 1340:       *  %deque is extended and new elements are populated with given
<         -: 1341:       *  data.
<         -: 1342:       */
<         -: 1343:      void
<         -: 1344:      resize(size_type __new_size, value_type __x = value_type())
<         -: 1345:      {
<         -: 1346:	const size_type __len = size();
<         -: 1347:	if (__new_size > __len)
<         -: 1348:	  _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
<         -: 1349:	else if (__new_size < __len)
<         -: 1350:	  _M_erase_at_end(this->_M_impl._M_start
<         -: 1351:			  + difference_type(__new_size));
<         -: 1352:      }
<         -: 1353:#endif
<         -: 1354:
<         -: 1355:#if __cplusplus >= 201103L
<         -: 1356:      /**  A non-binding request to reduce memory use.  */
<         -: 1357:      void
<         -: 1358:      shrink_to_fit() noexcept
<         -: 1359:      { _M_shrink_to_fit(); }
<         -: 1360:#endif
<         -: 1361:
<         -: 1362:      /**
<         -: 1363:       *  Returns true if the %deque is empty.  (Thus begin() would
<         -: 1364:       *  equal end().)
<         -: 1365:       */
<         -: 1366:      bool
<         -: 1367:      empty() const _GLIBCXX_NOEXCEPT
<         -: 1368:      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
<         -: 1369:
<         -: 1370:      // element access
<         -: 1371:      /**
<         -: 1372:       *  @brief Subscript access to the data contained in the %deque.
<         -: 1373:       *  @param __n The index of the element for which data should be
<         -: 1374:       *  accessed.
<         -: 1375:       *  @return  Read/write reference to data.
<         -: 1376:       *
<         -: 1377:       *  This operator allows for easy, array-style, data access.
<         -: 1378:       *  Note that data access with this operator is unchecked and
<         -: 1379:       *  out_of_range lookups are not defined. (For checked lookups
<         -: 1380:       *  see at().)
<         -: 1381:       */
<         -: 1382:      reference
<     #####: 1383:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -: 1384:      {
<         -: 1385:	__glibcxx_requires_subscript(__n);
<     #####: 1386:	return this->_M_impl._M_start[difference_type(__n)];
<         -: 1387:      }
<         -: 1388:
<         -: 1389:      /**
<         -: 1390:       *  @brief Subscript access to the data contained in the %deque.
<         -: 1391:       *  @param __n The index of the element for which data should be
<         -: 1392:       *  accessed.
<         -: 1393:       *  @return  Read-only (constant) reference to data.
<         -: 1394:       *
<         -: 1395:       *  This operator allows for easy, array-style, data access.
<         -: 1396:       *  Note that data access with this operator is unchecked and
<         -: 1397:       *  out_of_range lookups are not defined. (For checked lookups
<         -: 1398:       *  see at().)
<         -: 1399:       */
<         -: 1400:      const_reference
<       46*: 1401:      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
<         -: 1402:      {
<         -: 1403:	__glibcxx_requires_subscript(__n);
<       46*: 1404:	return this->_M_impl._M_start[difference_type(__n)];
<         -: 1405:      }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EEixEm:
<        46: 1401:      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
<         -: 1402:      {
<         -: 1403:	__glibcxx_requires_subscript(__n);
<        46: 1404:	return this->_M_impl._M_start[difference_type(__n)];
<         -: 1405:      }
< ------------------
< _ZNKSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EEixEm:
<     #####: 1401:      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
<         -: 1402:      {
<         -: 1403:	__glibcxx_requires_subscript(__n);
<     #####: 1404:	return this->_M_impl._M_start[difference_type(__n)];
<         -: 1405:      }
< ------------------
<         -: 1406:
<         -: 1407:    protected:
<         -: 1408:      /// Safety check used only from at().
<         -: 1409:      void
<         -: 1410:      _M_range_check(size_type __n) const
<         -: 1411:      {
<         -: 1412:	if (__n >= this->size())
<         -: 1413:	  __throw_out_of_range_fmt(__N("deque::_M_range_check: __n "
<         -: 1414:				       "(which is %zu)>= this->size() "
<         -: 1415:				       "(which is %zu)"),
<         -: 1416:				   __n, this->size());
<         -: 1417:      }
<         -: 1418:
<         -: 1419:    public:
<         -: 1420:      /**
<         -: 1421:       *  @brief  Provides access to the data contained in the %deque.
<         -: 1422:       *  @param __n The index of the element for which data should be
<         -: 1423:       *  accessed.
<         -: 1424:       *  @return  Read/write reference to data.
<         -: 1425:       *  @throw  std::out_of_range  If @a __n is an invalid index.
<         -: 1426:       *
<         -: 1427:       *  This function provides for safer data access.  The parameter
<         -: 1428:       *  is first checked that it is in the range of the deque.  The
<         -: 1429:       *  function throws out_of_range if the check fails.
<         -: 1430:       */
<         -: 1431:      reference
<         -: 1432:      at(size_type __n)
<         -: 1433:      {
<         -: 1434:	_M_range_check(__n);
<         -: 1435:	return (*this)[__n];
<         -: 1436:      }
<         -: 1437:
<         -: 1438:      /**
<         -: 1439:       *  @brief  Provides access to the data contained in the %deque.
<         -: 1440:       *  @param __n The index of the element for which data should be
<         -: 1441:       *  accessed.
<         -: 1442:       *  @return  Read-only (constant) reference to data.
<         -: 1443:       *  @throw  std::out_of_range  If @a __n is an invalid index.
<         -: 1444:       *
<         -: 1445:       *  This function provides for safer data access.  The parameter is first
<         -: 1446:       *  checked that it is in the range of the deque.  The function throws
<         -: 1447:       *  out_of_range if the check fails.
<         -: 1448:       */
<         -: 1449:      const_reference
<         -: 1450:      at(size_type __n) const
<         -: 1451:      {
<         -: 1452:	_M_range_check(__n);
<         -: 1453:	return (*this)[__n];
<         -: 1454:      }
<         -: 1455:
<         -: 1456:      /**
<         -: 1457:       *  Returns a read/write reference to the data at the first
<         -: 1458:       *  element of the %deque.
<         -: 1459:       */
<         -: 1460:      reference
<       46*: 1461:      front() _GLIBCXX_NOEXCEPT
<         -: 1462:      {
<         -: 1463:	__glibcxx_requires_nonempty();
<       46*: 1464:	return *begin();
<         -: 1465:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE5frontEv:
<     #####: 1461:      front() _GLIBCXX_NOEXCEPT
<         -: 1462:      {
<         -: 1463:	__glibcxx_requires_nonempty();
<     #####: 1464:	return *begin();
<         -: 1465:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE5frontEv:
<        46: 1461:      front() _GLIBCXX_NOEXCEPT
<         -: 1462:      {
<         -: 1463:	__glibcxx_requires_nonempty();
<        46: 1464:	return *begin();
<         -: 1465:      }
< ------------------
<         -: 1466:
<         -: 1467:      /**
<         -: 1468:       *  Returns a read-only (constant) reference to the data at the first
<         -: 1469:       *  element of the %deque.
<         -: 1470:       */
<         -: 1471:      const_reference
<         -: 1472:      front() const _GLIBCXX_NOEXCEPT
<         -: 1473:      {
<         -: 1474:	__glibcxx_requires_nonempty();
<         -: 1475:	return *begin();
<         -: 1476:      }
<         -: 1477:
<         -: 1478:      /**
<         -: 1479:       *  Returns a read/write reference to the data at the last element of the
<         -: 1480:       *  %deque.
<         -: 1481:       */
<         -: 1482:      reference
<         -: 1483:      back() _GLIBCXX_NOEXCEPT
<         -: 1484:      {
<         -: 1485:	__glibcxx_requires_nonempty();
<         -: 1486:	iterator __tmp = end();
<         -: 1487:	--__tmp;
<         -: 1488:	return *__tmp;
<         -: 1489:      }
<         -: 1490:
<         -: 1491:      /**
<         -: 1492:       *  Returns a read-only (constant) reference to the data at the last
<         -: 1493:       *  element of the %deque.
<         -: 1494:       */
<         -: 1495:      const_reference
<         -: 1496:      back() const _GLIBCXX_NOEXCEPT
<         -: 1497:      {
<         -: 1498:	__glibcxx_requires_nonempty();
<         -: 1499:	const_iterator __tmp = end();
<         -: 1500:	--__tmp;
<         -: 1501:	return *__tmp;
<         -: 1502:      }
<         -: 1503:
<         -: 1504:      // [23.2.1.2] modifiers
<         -: 1505:      /**
<         -: 1506:       *  @brief  Add data to the front of the %deque.
<         -: 1507:       *  @param  __x  Data to be added.
<         -: 1508:       *
<         -: 1509:       *  This is a typical stack operation.  The function creates an
<         -: 1510:       *  element at the front of the %deque and assigns the given
<         -: 1511:       *  data to it.  Due to the nature of a %deque this operation
<         -: 1512:       *  can be done in constant time.
<         -: 1513:       */
<         -: 1514:      void
<         -: 1515:      push_front(const value_type& __x)
<         -: 1516:      {
<         -: 1517:	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
<         -: 1518:	  {
<         -: 1519:	    _Alloc_traits::construct(this->_M_impl,
<         -: 1520:				     this->_M_impl._M_start._M_cur - 1,
<         -: 1521:				     __x);
<         -: 1522:	    --this->_M_impl._M_start._M_cur;
<         -: 1523:	  }
<         -: 1524:	else
<         -: 1525:	  _M_push_front_aux(__x);
<         -: 1526:      }
<         -: 1527:
<         -: 1528:#if __cplusplus >= 201103L
<         -: 1529:      void
<         -: 1530:      push_front(value_type&& __x)
<         -: 1531:      { emplace_front(std::move(__x)); }
<         -: 1532:
<         -: 1533:      template<typename... _Args>
<         -: 1534:#if __cplusplus > 201402L
<         -: 1535:	reference
<         -: 1536:#else
<         -: 1537:	void
<         -: 1538:#endif
<         -: 1539:	emplace_front(_Args&&... __args);
<         -: 1540:#endif
<         -: 1541:
<         -: 1542:      /**
<         -: 1543:       *  @brief  Add data to the end of the %deque.
<         -: 1544:       *  @param  __x  Data to be added.
<         -: 1545:       *
<         -: 1546:       *  This is a typical stack operation.  The function creates an
<         -: 1547:       *  element at the end of the %deque and assigns the given data
<         -: 1548:       *  to it.  Due to the nature of a %deque this operation can be
<         -: 1549:       *  done in constant time.
<         -: 1550:       */
<         -: 1551:      void
<       46*: 1552:      push_back(const value_type& __x)
<         -: 1553:      {
<       92*: 1554:	if (this->_M_impl._M_finish._M_cur
<       46*: 1555:	    != this->_M_impl._M_finish._M_last - 1)
<         -: 1556:	  {
<       46*: 1557:	    _Alloc_traits::construct(this->_M_impl,
<         -: 1558:				     this->_M_impl._M_finish._M_cur, __x);
<       46*: 1559:	    ++this->_M_impl._M_finish._M_cur;
<         -: 1560:	  }
<         -: 1561:	else
<     #####: 1562:	  _M_push_back_aux(__x);
<       46*: 1563:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE9push_backERKS3_:
<     #####: 1552:      push_back(const value_type& __x)
<         -: 1553:      {
<     #####: 1554:	if (this->_M_impl._M_finish._M_cur
<     #####: 1555:	    != this->_M_impl._M_finish._M_last - 1)
<         -: 1556:	  {
<     #####: 1557:	    _Alloc_traits::construct(this->_M_impl,
<         -: 1558:				     this->_M_impl._M_finish._M_cur, __x);
<     #####: 1559:	    ++this->_M_impl._M_finish._M_cur;
<         -: 1560:	  }
<         -: 1561:	else
<     #####: 1562:	  _M_push_back_aux(__x);
<     #####: 1563:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE9push_backERKS3_:
<     #####: 1552:      push_back(const value_type& __x)
<         -: 1553:      {
<     #####: 1554:	if (this->_M_impl._M_finish._M_cur
<     #####: 1555:	    != this->_M_impl._M_finish._M_last - 1)
<         -: 1556:	  {
<     #####: 1557:	    _Alloc_traits::construct(this->_M_impl,
<         -: 1558:				     this->_M_impl._M_finish._M_cur, __x);
<     #####: 1559:	    ++this->_M_impl._M_finish._M_cur;
<         -: 1560:	  }
<         -: 1561:	else
<     #####: 1562:	  _M_push_back_aux(__x);
<     #####: 1563:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE9push_backERKS3_:
<        46: 1552:      push_back(const value_type& __x)
<         -: 1553:      {
<        92: 1554:	if (this->_M_impl._M_finish._M_cur
<        46: 1555:	    != this->_M_impl._M_finish._M_last - 1)
<         -: 1556:	  {
<        46: 1557:	    _Alloc_traits::construct(this->_M_impl,
<         -: 1558:				     this->_M_impl._M_finish._M_cur, __x);
<        46: 1559:	    ++this->_M_impl._M_finish._M_cur;
<         -: 1560:	  }
<         -: 1561:	else
<     #####: 1562:	  _M_push_back_aux(__x);
<        46: 1563:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE9push_backERKS3_:
<     #####: 1552:      push_back(const value_type& __x)
<         -: 1553:      {
<     #####: 1554:	if (this->_M_impl._M_finish._M_cur
<     #####: 1555:	    != this->_M_impl._M_finish._M_last - 1)
<         -: 1556:	  {
<     #####: 1557:	    _Alloc_traits::construct(this->_M_impl,
<         -: 1558:				     this->_M_impl._M_finish._M_cur, __x);
<     #####: 1559:	    ++this->_M_impl._M_finish._M_cur;
<         -: 1560:	  }
<         -: 1561:	else
<     #####: 1562:	  _M_push_back_aux(__x);
<     #####: 1563:      }
< ------------------
<         -: 1564:
<         -: 1565:#if __cplusplus >= 201103L
<         -: 1566:      void
<     #####: 1567:      push_back(value_type&& __x)
<     #####: 1568:      { emplace_back(std::move(__x)); }
<         -: 1569:
<         -: 1570:      template<typename... _Args>
<         -: 1571:#if __cplusplus > 201402L
<         -: 1572:	reference
<         -: 1573:#else
<         -: 1574:	void
<         -: 1575:#endif
<         -: 1576:	emplace_back(_Args&&... __args);
<         -: 1577:#endif
<         -: 1578:
<         -: 1579:      /**
<         -: 1580:       *  @brief  Removes first element.
<         -: 1581:       *
<         -: 1582:       *  This is a typical stack operation.  It shrinks the %deque by one.
<         -: 1583:       *
<         -: 1584:       *  Note that no data is returned, and if the first element's data is
<         -: 1585:       *  needed, it should be retrieved before pop_front() is called.
<         -: 1586:       */
<         -: 1587:      void
<       46*: 1588:      pop_front() _GLIBCXX_NOEXCEPT
<         -: 1589:      {
<         -: 1590:	__glibcxx_requires_nonempty();
<       92*: 1591:	if (this->_M_impl._M_start._M_cur
<       46*: 1592:	    != this->_M_impl._M_start._M_last - 1)
<         -: 1593:	  {
<       46*: 1594:	    _Alloc_traits::destroy(this->_M_impl,
<         -: 1595:				   this->_M_impl._M_start._M_cur);
<       46*: 1596:	    ++this->_M_impl._M_start._M_cur;
<         -: 1597:	  }
<         -: 1598:	else
<     #####: 1599:	  _M_pop_front_aux();
<       46*: 1600:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE9pop_frontEv:
<     #####: 1588:      pop_front() _GLIBCXX_NOEXCEPT
<         -: 1589:      {
<         -: 1590:	__glibcxx_requires_nonempty();
<     #####: 1591:	if (this->_M_impl._M_start._M_cur
<     #####: 1592:	    != this->_M_impl._M_start._M_last - 1)
<         -: 1593:	  {
<     #####: 1594:	    _Alloc_traits::destroy(this->_M_impl,
<         -: 1595:				   this->_M_impl._M_start._M_cur);
<     #####: 1596:	    ++this->_M_impl._M_start._M_cur;
<         -: 1597:	  }
<         -: 1598:	else
<     #####: 1599:	  _M_pop_front_aux();
<     #####: 1600:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE9pop_frontEv:
<        46: 1588:      pop_front() _GLIBCXX_NOEXCEPT
<         -: 1589:      {
<         -: 1590:	__glibcxx_requires_nonempty();
<        92: 1591:	if (this->_M_impl._M_start._M_cur
<        46: 1592:	    != this->_M_impl._M_start._M_last - 1)
<         -: 1593:	  {
<        46: 1594:	    _Alloc_traits::destroy(this->_M_impl,
<         -: 1595:				   this->_M_impl._M_start._M_cur);
<        46: 1596:	    ++this->_M_impl._M_start._M_cur;
<         -: 1597:	  }
<         -: 1598:	else
<     #####: 1599:	  _M_pop_front_aux();
<        46: 1600:      }
< ------------------
<         -: 1601:
<         -: 1602:      /**
<         -: 1603:       *  @brief  Removes last element.
<         -: 1604:       *
<         -: 1605:       *  This is a typical stack operation.  It shrinks the %deque by one.
<         -: 1606:       *
<         -: 1607:       *  Note that no data is returned, and if the last element's data is
<         -: 1608:       *  needed, it should be retrieved before pop_back() is called.
<         -: 1609:       */
<         -: 1610:      void
<         -: 1611:      pop_back() _GLIBCXX_NOEXCEPT
<         -: 1612:      {
<         -: 1613:	__glibcxx_requires_nonempty();
<         -: 1614:	if (this->_M_impl._M_finish._M_cur
<         -: 1615:	    != this->_M_impl._M_finish._M_first)
<         -: 1616:	  {
<         -: 1617:	    --this->_M_impl._M_finish._M_cur;
<         -: 1618:	    _Alloc_traits::destroy(this->_M_impl,
<         -: 1619:				   this->_M_impl._M_finish._M_cur);
<         -: 1620:	  }
<         -: 1621:	else
<         -: 1622:	  _M_pop_back_aux();
<         -: 1623:      }
<         -: 1624:
<         -: 1625:#if __cplusplus >= 201103L
<         -: 1626:      /**
<         -: 1627:       *  @brief  Inserts an object in %deque before specified iterator.
<         -: 1628:       *  @param  __position  A const_iterator into the %deque.
<         -: 1629:       *  @param  __args  Arguments.
<         -: 1630:       *  @return  An iterator that points to the inserted data.
<         -: 1631:       *
<         -: 1632:       *  This function will insert an object of type T constructed
<         -: 1633:       *  with T(std::forward<Args>(args)...) before the specified location.
<         -: 1634:       */
<         -: 1635:      template<typename... _Args>
<         -: 1636:	iterator
<         -: 1637:	emplace(const_iterator __position, _Args&&... __args);
<         -: 1638:
<         -: 1639:      /**
<         -: 1640:       *  @brief  Inserts given value into %deque before specified iterator.
<         -: 1641:       *  @param  __position  A const_iterator into the %deque.
<         -: 1642:       *  @param  __x  Data to be inserted.
<         -: 1643:       *  @return  An iterator that points to the inserted data.
<         -: 1644:       *
<         -: 1645:       *  This function will insert a copy of the given value before the
<         -: 1646:       *  specified location.
<         -: 1647:       */
<         -: 1648:      iterator
<         -: 1649:      insert(const_iterator __position, const value_type& __x);
<         -: 1650:#else
<         -: 1651:      /**
<         -: 1652:       *  @brief  Inserts given value into %deque before specified iterator.
<         -: 1653:       *  @param  __position  An iterator into the %deque.
<         -: 1654:       *  @param  __x  Data to be inserted.
<         -: 1655:       *  @return  An iterator that points to the inserted data.
<         -: 1656:       *
<         -: 1657:       *  This function will insert a copy of the given value before the
<         -: 1658:       *  specified location.
<         -: 1659:       */
<         -: 1660:      iterator
<         -: 1661:      insert(iterator __position, const value_type& __x);
<         -: 1662:#endif
<         -: 1663:
<         -: 1664:#if __cplusplus >= 201103L
<         -: 1665:      /**
<         -: 1666:       *  @brief  Inserts given rvalue into %deque before specified iterator.
<         -: 1667:       *  @param  __position  A const_iterator into the %deque.
<         -: 1668:       *  @param  __x  Data to be inserted.
<         -: 1669:       *  @return  An iterator that points to the inserted data.
<         -: 1670:       *
<         -: 1671:       *  This function will insert a copy of the given rvalue before the
<         -: 1672:       *  specified location.
<         -: 1673:       */
<         -: 1674:      iterator
<         -: 1675:      insert(const_iterator __position, value_type&& __x)
<         -: 1676:      { return emplace(__position, std::move(__x)); }
<         -: 1677:
<         -: 1678:      /**
<         -: 1679:       *  @brief  Inserts an initializer list into the %deque.
<         -: 1680:       *  @param  __p  An iterator into the %deque.
<         -: 1681:       *  @param  __l  An initializer_list.
<         -: 1682:       *
<         -: 1683:       *  This function will insert copies of the data in the
<         -: 1684:       *  initializer_list @a __l into the %deque before the location
<         -: 1685:       *  specified by @a __p.  This is known as <em>list insert</em>.
<         -: 1686:       */
<         -: 1687:      iterator
<         -: 1688:      insert(const_iterator __p, initializer_list<value_type> __l)
<         -: 1689:      {
<         -: 1690:	auto __offset = __p - cbegin();
<         -: 1691:	_M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(),
<         -: 1692:			    std::random_access_iterator_tag());
<         -: 1693:	return begin() + __offset;
<         -: 1694:      }
<         -: 1695:#endif
<         -: 1696:
<         -: 1697:#if __cplusplus >= 201103L
<         -: 1698:      /**
<         -: 1699:       *  @brief  Inserts a number of copies of given data into the %deque.
<         -: 1700:       *  @param  __position  A const_iterator into the %deque.
<         -: 1701:       *  @param  __n  Number of elements to be inserted.
<         -: 1702:       *  @param  __x  Data to be inserted.
<         -: 1703:       *  @return  An iterator that points to the inserted data.
<         -: 1704:       *
<         -: 1705:       *  This function will insert a specified number of copies of the given
<         -: 1706:       *  data before the location specified by @a __position.
<         -: 1707:       */
<         -: 1708:      iterator
<         -: 1709:      insert(const_iterator __position, size_type __n, const value_type& __x)
<         -: 1710:      {
<         -: 1711:	difference_type __offset = __position - cbegin();
<         -: 1712:	_M_fill_insert(__position._M_const_cast(), __n, __x);
<         -: 1713:	return begin() + __offset;
<         -: 1714:      }
<         -: 1715:#else
<         -: 1716:      /**
<         -: 1717:       *  @brief  Inserts a number of copies of given data into the %deque.
<         -: 1718:       *  @param  __position  An iterator into the %deque.
<         -: 1719:       *  @param  __n  Number of elements to be inserted.
<         -: 1720:       *  @param  __x  Data to be inserted.
<         -: 1721:       *
<         -: 1722:       *  This function will insert a specified number of copies of the given
<         -: 1723:       *  data before the location specified by @a __position.
<         -: 1724:       */
<         -: 1725:      void
<         -: 1726:      insert(iterator __position, size_type __n, const value_type& __x)
<         -: 1727:      { _M_fill_insert(__position, __n, __x); }
<         -: 1728:#endif
<         -: 1729:
<         -: 1730:#if __cplusplus >= 201103L
<         -: 1731:      /**
<         -: 1732:       *  @brief  Inserts a range into the %deque.
<         -: 1733:       *  @param  __position  A const_iterator into the %deque.
<         -: 1734:       *  @param  __first  An input iterator.
<         -: 1735:       *  @param  __last   An input iterator.
<         -: 1736:       *  @return  An iterator that points to the inserted data.
<         -: 1737:       *
<         -: 1738:       *  This function will insert copies of the data in the range
<         -: 1739:       *  [__first,__last) into the %deque before the location specified
<         -: 1740:       *  by @a __position.  This is known as <em>range insert</em>.
<         -: 1741:       */
<         -: 1742:      template<typename _InputIterator,
<         -: 1743:	       typename = std::_RequireInputIter<_InputIterator>>
<         -: 1744:	iterator
<         -: 1745:	insert(const_iterator __position, _InputIterator __first,
<         -: 1746:	       _InputIterator __last)
<         -: 1747:	{
<         -: 1748:	  difference_type __offset = __position - cbegin();
<         -: 1749:	  _M_insert_dispatch(__position._M_const_cast(),
<         -: 1750:			     __first, __last, __false_type());
<         -: 1751:	  return begin() + __offset;
<         -: 1752:	}
<         -: 1753:#else
<         -: 1754:      /**
<         -: 1755:       *  @brief  Inserts a range into the %deque.
<         -: 1756:       *  @param  __position  An iterator into the %deque.
<         -: 1757:       *  @param  __first  An input iterator.
<         -: 1758:       *  @param  __last   An input iterator.
<         -: 1759:       *
<         -: 1760:       *  This function will insert copies of the data in the range
<         -: 1761:       *  [__first,__last) into the %deque before the location specified
<         -: 1762:       *  by @a __position.  This is known as <em>range insert</em>.
<         -: 1763:       */
<         -: 1764:      template<typename _InputIterator>
<         -: 1765:	void
<         -: 1766:	insert(iterator __position, _InputIterator __first,
<         -: 1767:	       _InputIterator __last)
<         -: 1768:	{
<         -: 1769:	  // Check whether it's an integral type.  If so, it's not an iterator.
<         -: 1770:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
<         -: 1771:	  _M_insert_dispatch(__position, __first, __last, _Integral());
<         -: 1772:	}
<         -: 1773:#endif
<         -: 1774:
<         -: 1775:      /**
<         -: 1776:       *  @brief  Remove element at given position.
<         -: 1777:       *  @param  __position  Iterator pointing to element to be erased.
<         -: 1778:       *  @return  An iterator pointing to the next element (or end()).
<         -: 1779:       *
<         -: 1780:       *  This function will erase the element at the given position and thus
<         -: 1781:       *  shorten the %deque by one.
<         -: 1782:       *
<         -: 1783:       *  The user is cautioned that
<         -: 1784:       *  this function only erases the element, and that if the element is
<         -: 1785:       *  itself a pointer, the pointed-to memory is not touched in any way.
<         -: 1786:       *  Managing the pointer is the user's responsibility.
<         -: 1787:       */
<         -: 1788:      iterator
<         -: 1789:#if __cplusplus >= 201103L
<         -: 1790:      erase(const_iterator __position)
<         -: 1791:#else
<         -: 1792:      erase(iterator __position)
<         -: 1793:#endif
<         -: 1794:      { return _M_erase(__position._M_const_cast()); }
<         -: 1795:
<         -: 1796:      /**
<         -: 1797:       *  @brief  Remove a range of elements.
<         -: 1798:       *  @param  __first  Iterator pointing to the first element to be erased.
<         -: 1799:       *  @param  __last  Iterator pointing to one past the last element to be
<         -: 1800:       *                erased.
<         -: 1801:       *  @return  An iterator pointing to the element pointed to by @a last
<         -: 1802:       *           prior to erasing (or end()).
<         -: 1803:       *
<         -: 1804:       *  This function will erase the elements in the range
<         -: 1805:       *  [__first,__last) and shorten the %deque accordingly.
<         -: 1806:       *
<         -: 1807:       *  The user is cautioned that
<         -: 1808:       *  this function only erases the elements, and that if the elements
<         -: 1809:       *  themselves are pointers, the pointed-to memory is not touched in any
<         -: 1810:       *  way.  Managing the pointer is the user's responsibility.
<         -: 1811:       */
<         -: 1812:      iterator
<         -: 1813:#if __cplusplus >= 201103L
<         -: 1814:      erase(const_iterator __first, const_iterator __last)
<         -: 1815:#else
<         -: 1816:      erase(iterator __first, iterator __last)
<         -: 1817:#endif
<         -: 1818:      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
<         -: 1819:
<         -: 1820:      /**
<         -: 1821:       *  @brief  Swaps data with another %deque.
<         -: 1822:       *  @param  __x  A %deque of the same element and allocator types.
<         -: 1823:       *
<         -: 1824:       *  This exchanges the elements between two deques in constant time.
<         -: 1825:       *  (Four pointers, so it should be quite fast.)
<         -: 1826:       *  Note that the global std::swap() function is specialized such that
<         -: 1827:       *  std::swap(d1,d2) will feed to this function.
<         -: 1828:       *
<         -: 1829:       *  Whether the allocators are swapped depends on the allocator traits.
<         -: 1830:       */
<         -: 1831:      void
<       24*: 1832:      swap(deque& __x) _GLIBCXX_NOEXCEPT
<         -: 1833:      {
<         -: 1834:#if __cplusplus >= 201103L
<         -: 1835:	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
<         -: 1836:			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
<         -: 1837:#endif
<       24*: 1838:	_M_impl._M_swap_data(__x._M_impl);
<       24*: 1839:	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
<         -: 1840:				  __x._M_get_Tp_allocator());
<       24*: 1841:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE4swapERS5_:
<        24: 1832:      swap(deque& __x) _GLIBCXX_NOEXCEPT
<         -: 1833:      {
<         -: 1834:#if __cplusplus >= 201103L
<         -: 1835:	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
<         -: 1836:			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
<         -: 1837:#endif
<        24: 1838:	_M_impl._M_swap_data(__x._M_impl);
<        24: 1839:	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
<         -: 1840:				  __x._M_get_Tp_allocator());
<        24: 1841:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE4swapERS5_:
<     #####: 1832:      swap(deque& __x) _GLIBCXX_NOEXCEPT
<         -: 1833:      {
<         -: 1834:#if __cplusplus >= 201103L
<         -: 1835:	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
<         -: 1836:			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
<         -: 1837:#endif
<     #####: 1838:	_M_impl._M_swap_data(__x._M_impl);
<     #####: 1839:	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
<         -: 1840:				  __x._M_get_Tp_allocator());
<     #####: 1841:      }
< ------------------
---
>         -: 1268:      // [23.2.1.2] capacity
>         -: 1269:      /**  Returns the number of elements in the %deque.  */
>         -: 1270:      size_type
>        50: 1271:      size() const _GLIBCXX_NOEXCEPT
>        50: 1272:      { return this->_M_impl._M_finish - this->_M_impl._M_start; }
>         -: 1273:
>         -: 1274:      /**  Returns the size() of the largest possible %deque.  */
>         -: 1275:      size_type
>         -: 1276:      max_size() const _GLIBCXX_NOEXCEPT
>         -: 1277:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
>         -: 1278:
>         -: 1279:#if __cplusplus >= 201103L
>         -: 1280:      /**
>         -: 1281:       *  @brief  Resizes the %deque to the specified number of elements.
>         -: 1282:       *  @param  __new_size  Number of elements the %deque should contain.
>         -: 1283:       *
>         -: 1284:       *  This function will %resize the %deque to the specified
>         -: 1285:       *  number of elements.  If the number is smaller than the
>         -: 1286:       *  %deque's current size the %deque is truncated, otherwise
>         -: 1287:       *  default constructed elements are appended.
>         -: 1288:       */
>         -: 1289:      void
>         -: 1290:      resize(size_type __new_size)
>         -: 1291:      {
>         -: 1292:	const size_type __len = size();
>         -: 1293:	if (__new_size > __len)
>         -: 1294:	  _M_default_append(__new_size - __len);
>         -: 1295:	else if (__new_size < __len)
>         -: 1296:	  _M_erase_at_end(this->_M_impl._M_start
>         -: 1297:			  + difference_type(__new_size));
>         -: 1298:      }
>         -: 1299:
>         -: 1300:      /**
>         -: 1301:       *  @brief  Resizes the %deque to the specified number of elements.
>         -: 1302:       *  @param  __new_size  Number of elements the %deque should contain.
>         -: 1303:       *  @param  __x  Data with which new elements should be populated.
>         -: 1304:       *
>         -: 1305:       *  This function will %resize the %deque to the specified
>         -: 1306:       *  number of elements.  If the number is smaller than the
>         -: 1307:       *  %deque's current size the %deque is truncated, otherwise the
>         -: 1308:       *  %deque is extended and new elements are populated with given
>         -: 1309:       *  data.
>         -: 1310:       */
>         -: 1311:      void
>         -: 1312:      resize(size_type __new_size, const value_type& __x)
>         -: 1313:      {
>         -: 1314:	const size_type __len = size();
>         -: 1315:	if (__new_size > __len)
>         -: 1316:	  _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
>         -: 1317:	else if (__new_size < __len)
>         -: 1318:	  _M_erase_at_end(this->_M_impl._M_start
>         -: 1319:			  + difference_type(__new_size));
>         -: 1320:      }
>         -: 1321:#else
>         -: 1322:      /**
>         -: 1323:       *  @brief  Resizes the %deque to the specified number of elements.
>         -: 1324:       *  @param  __new_size  Number of elements the %deque should contain.
>         -: 1325:       *  @param  __x  Data with which new elements should be populated.
>         -: 1326:       *
>         -: 1327:       *  This function will %resize the %deque to the specified
>         -: 1328:       *  number of elements.  If the number is smaller than the
>         -: 1329:       *  %deque's current size the %deque is truncated, otherwise the
>         -: 1330:       *  %deque is extended and new elements are populated with given
>         -: 1331:       *  data.
>         -: 1332:       */
>         -: 1333:      void
>         -: 1334:      resize(size_type __new_size, value_type __x = value_type())
>         -: 1335:      {
>         -: 1336:	const size_type __len = size();
>         -: 1337:	if (__new_size > __len)
>         -: 1338:	  _M_fill_insert(this->_M_impl._M_finish, __new_size - __len, __x);
>         -: 1339:	else if (__new_size < __len)
>         -: 1340:	  _M_erase_at_end(this->_M_impl._M_start
>         -: 1341:			  + difference_type(__new_size));
>         -: 1342:      }
>         -: 1343:#endif
>         -: 1344:
>         -: 1345:#if __cplusplus >= 201103L
>         -: 1346:      /**  A non-binding request to reduce memory use.  */
>         -: 1347:      void
>         -: 1348:      shrink_to_fit() noexcept
>         -: 1349:      { _M_shrink_to_fit(); }
>         -: 1350:#endif
>         -: 1351:
>         -: 1352:      /**
>         -: 1353:       *  Returns true if the %deque is empty.  (Thus begin() would
>         -: 1354:       *  equal end().)
>         -: 1355:       */
>         -: 1356:      bool
>         -: 1357:      empty() const _GLIBCXX_NOEXCEPT
>         -: 1358:      { return this->_M_impl._M_finish == this->_M_impl._M_start; }
>         -: 1359:
>         -: 1360:      // element access
>         -: 1361:      /**
>         -: 1362:       *  @brief Subscript access to the data contained in the %deque.
>         -: 1363:       *  @param __n The index of the element for which data should be
>         -: 1364:       *  accessed.
>         -: 1365:       *  @return  Read/write reference to data.
>         -: 1366:       *
>         -: 1367:       *  This operator allows for easy, array-style, data access.
>         -: 1368:       *  Note that data access with this operator is unchecked and
>         -: 1369:       *  out_of_range lookups are not defined. (For checked lookups
>         -: 1370:       *  see at().)
>         -: 1371:       */
>         -: 1372:      reference
>     #####: 1373:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
>         -: 1374:      {
>         -: 1375:	__glibcxx_requires_subscript(__n);
>     #####: 1376:	return this->_M_impl._M_start[difference_type(__n)];
>         -: 1377:      }
>         -: 1378:
>         -: 1379:      /**
>         -: 1380:       *  @brief Subscript access to the data contained in the %deque.
>         -: 1381:       *  @param __n The index of the element for which data should be
>         -: 1382:       *  accessed.
>         -: 1383:       *  @return  Read-only (constant) reference to data.
>         -: 1384:       *
>         -: 1385:       *  This operator allows for easy, array-style, data access.
>         -: 1386:       *  Note that data access with this operator is unchecked and
>         -: 1387:       *  out_of_range lookups are not defined. (For checked lookups
>         -: 1388:       *  see at().)
>         -: 1389:       */
>         -: 1390:      const_reference
>        10: 1391:      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
>         -: 1392:      {
>         -: 1393:	__glibcxx_requires_subscript(__n);
>        10: 1394:	return this->_M_impl._M_start[difference_type(__n)];
>         -: 1395:      }
>         -: 1396:
>         -: 1397:    protected:
>         -: 1398:      /// Safety check used only from at().
>         -: 1399:      void
>         -: 1400:      _M_range_check(size_type __n) const
>         -: 1401:      {
>         -: 1402:	if (__n >= this->size())
>         -: 1403:	  __throw_out_of_range_fmt(__N("deque::_M_range_check: __n "
>         -: 1404:				       "(which is %zu)>= this->size() "
>         -: 1405:				       "(which is %zu)"),
>         -: 1406:				   __n, this->size());
>         -: 1407:      }
>         -: 1408:
>         -: 1409:    public:
>         -: 1410:      /**
>         -: 1411:       *  @brief  Provides access to the data contained in the %deque.
>         -: 1412:       *  @param __n The index of the element for which data should be
>         -: 1413:       *  accessed.
>         -: 1414:       *  @return  Read/write reference to data.
>         -: 1415:       *  @throw  std::out_of_range  If @a __n is an invalid index.
>         -: 1416:       *
>         -: 1417:       *  This function provides for safer data access.  The parameter
>         -: 1418:       *  is first checked that it is in the range of the deque.  The
>         -: 1419:       *  function throws out_of_range if the check fails.
>         -: 1420:       */
>         -: 1421:      reference
>         -: 1422:      at(size_type __n)
>         -: 1423:      {
>         -: 1424:	_M_range_check(__n);
>         -: 1425:	return (*this)[__n];
>         -: 1426:      }
>         -: 1427:
>         -: 1428:      /**
>         -: 1429:       *  @brief  Provides access to the data contained in the %deque.
>         -: 1430:       *  @param __n The index of the element for which data should be
>         -: 1431:       *  accessed.
>         -: 1432:       *  @return  Read-only (constant) reference to data.
>         -: 1433:       *  @throw  std::out_of_range  If @a __n is an invalid index.
>         -: 1434:       *
>         -: 1435:       *  This function provides for safer data access.  The parameter is first
>         -: 1436:       *  checked that it is in the range of the deque.  The function throws
>         -: 1437:       *  out_of_range if the check fails.
>         -: 1438:       */
>         -: 1439:      const_reference
>         -: 1440:      at(size_type __n) const
>         -: 1441:      {
>         -: 1442:	_M_range_check(__n);
>         -: 1443:	return (*this)[__n];
>         -: 1444:      }
>         -: 1445:
>         -: 1446:      /**
>         -: 1447:       *  Returns a read/write reference to the data at the first
>         -: 1448:       *  element of the %deque.
>         -: 1449:       */
>         -: 1450:      reference
>        10: 1451:      front() _GLIBCXX_NOEXCEPT
>         -: 1452:      {
>         -: 1453:	__glibcxx_requires_nonempty();
>        10: 1454:	return *begin();
>         -: 1455:      }
>         -: 1456:
>         -: 1457:      /**
>         -: 1458:       *  Returns a read-only (constant) reference to the data at the first
>         -: 1459:       *  element of the %deque.
>         -: 1460:       */
>         -: 1461:      const_reference
>         -: 1462:      front() const _GLIBCXX_NOEXCEPT
>         -: 1463:      {
>         -: 1464:	__glibcxx_requires_nonempty();
>         -: 1465:	return *begin();
>         -: 1466:      }
>         -: 1467:
>         -: 1468:      /**
>         -: 1469:       *  Returns a read/write reference to the data at the last element of the
>         -: 1470:       *  %deque.
>         -: 1471:       */
>         -: 1472:      reference
>         -: 1473:      back() _GLIBCXX_NOEXCEPT
>         -: 1474:      {
>         -: 1475:	__glibcxx_requires_nonempty();
>         -: 1476:	iterator __tmp = end();
>         -: 1477:	--__tmp;
>         -: 1478:	return *__tmp;
>         -: 1479:      }
>         -: 1480:
>         -: 1481:      /**
>         -: 1482:       *  Returns a read-only (constant) reference to the data at the last
>         -: 1483:       *  element of the %deque.
>         -: 1484:       */
>         -: 1485:      const_reference
>         -: 1486:      back() const _GLIBCXX_NOEXCEPT
>         -: 1487:      {
>         -: 1488:	__glibcxx_requires_nonempty();
>         -: 1489:	const_iterator __tmp = end();
>         -: 1490:	--__tmp;
>         -: 1491:	return *__tmp;
>         -: 1492:      }
>         -: 1493:
>         -: 1494:      // [23.2.1.2] modifiers
>         -: 1495:      /**
>         -: 1496:       *  @brief  Add data to the front of the %deque.
>         -: 1497:       *  @param  __x  Data to be added.
>         -: 1498:       *
>         -: 1499:       *  This is a typical stack operation.  The function creates an
>         -: 1500:       *  element at the front of the %deque and assigns the given
>         -: 1501:       *  data to it.  Due to the nature of a %deque this operation
>         -: 1502:       *  can be done in constant time.
>         -: 1503:       */
>         -: 1504:      void
>         -: 1505:      push_front(const value_type& __x)
>         -: 1506:      {
>         -: 1507:	if (this->_M_impl._M_start._M_cur != this->_M_impl._M_start._M_first)
>         -: 1508:	  {
>         -: 1509:	    _Alloc_traits::construct(this->_M_impl,
>         -: 1510:				     this->_M_impl._M_start._M_cur - 1,
>         -: 1511:				     __x);
>         -: 1512:	    --this->_M_impl._M_start._M_cur;
>         -: 1513:	  }
>         -: 1514:	else
>         -: 1515:	  _M_push_front_aux(__x);
>         -: 1516:      }
>         -: 1517:
>         -: 1518:#if __cplusplus >= 201103L
>         -: 1519:      void
>         -: 1520:      push_front(value_type&& __x)
>         -: 1521:      { emplace_front(std::move(__x)); }
>         -: 1522:
>         -: 1523:      template<typename... _Args>
>         -: 1524:#if __cplusplus > 201402L
>         -: 1525:	reference
>         -: 1526:#else
>         -: 1527:	void
>         -: 1528:#endif
>         -: 1529:	emplace_front(_Args&&... __args);
>         -: 1530:#endif
>         -: 1531:
>         -: 1532:      /**
>         -: 1533:       *  @brief  Add data to the end of the %deque.
>         -: 1534:       *  @param  __x  Data to be added.
>         -: 1535:       *
>         -: 1536:       *  This is a typical stack operation.  The function creates an
>         -: 1537:       *  element at the end of the %deque and assigns the given data
>         -: 1538:       *  to it.  Due to the nature of a %deque this operation can be
>         -: 1539:       *  done in constant time.
>         -: 1540:       */
>         -: 1541:      void
>        10: 1542:      push_back(const value_type& __x)
>         -: 1543:      {
>        20: 1544:	if (this->_M_impl._M_finish._M_cur
>        10: 1545:	    != this->_M_impl._M_finish._M_last - 1)
>         -: 1546:	  {
>        10: 1547:	    _Alloc_traits::construct(this->_M_impl,
>         -: 1548:				     this->_M_impl._M_finish._M_cur, __x);
>        10: 1549:	    ++this->_M_impl._M_finish._M_cur;
>         -: 1550:	  }
>         -: 1551:	else
>     #####: 1552:	  _M_push_back_aux(__x);
>        10: 1553:      }
>         -: 1554:
>         -: 1555:#if __cplusplus >= 201103L
>         -: 1556:      void
>     #####: 1557:      push_back(value_type&& __x)
>     #####: 1558:      { emplace_back(std::move(__x)); }
>         -: 1559:
>         -: 1560:      template<typename... _Args>
>         -: 1561:#if __cplusplus > 201402L
>         -: 1562:	reference
>         -: 1563:#else
>         -: 1564:	void
>         -: 1565:#endif
>         -: 1566:	emplace_back(_Args&&... __args);
>         -: 1567:#endif
>         -: 1568:
>         -: 1569:      /**
>         -: 1570:       *  @brief  Removes first element.
>         -: 1571:       *
>         -: 1572:       *  This is a typical stack operation.  It shrinks the %deque by one.
>         -: 1573:       *
>         -: 1574:       *  Note that no data is returned, and if the first element's data is
>         -: 1575:       *  needed, it should be retrieved before pop_front() is called.
>         -: 1576:       */
>         -: 1577:      void
>        10: 1578:      pop_front() _GLIBCXX_NOEXCEPT
>         -: 1579:      {
>         -: 1580:	__glibcxx_requires_nonempty();
>        20: 1581:	if (this->_M_impl._M_start._M_cur
>        10: 1582:	    != this->_M_impl._M_start._M_last - 1)
>         -: 1583:	  {
>        10: 1584:	    _Alloc_traits::destroy(this->_M_impl,
>         -: 1585:				   this->_M_impl._M_start._M_cur);
>        10: 1586:	    ++this->_M_impl._M_start._M_cur;
>         -: 1587:	  }
>         -: 1588:	else
>     #####: 1589:	  _M_pop_front_aux();
>        10: 1590:      }
>         -: 1591:
>         -: 1592:      /**
>         -: 1593:       *  @brief  Removes last element.
>         -: 1594:       *
>         -: 1595:       *  This is a typical stack operation.  It shrinks the %deque by one.
>         -: 1596:       *
>         -: 1597:       *  Note that no data is returned, and if the last element's data is
>         -: 1598:       *  needed, it should be retrieved before pop_back() is called.
>         -: 1599:       */
>         -: 1600:      void
>         -: 1601:      pop_back() _GLIBCXX_NOEXCEPT
>         -: 1602:      {
>         -: 1603:	__glibcxx_requires_nonempty();
>         -: 1604:	if (this->_M_impl._M_finish._M_cur
>         -: 1605:	    != this->_M_impl._M_finish._M_first)
>         -: 1606:	  {
>         -: 1607:	    --this->_M_impl._M_finish._M_cur;
>         -: 1608:	    _Alloc_traits::destroy(this->_M_impl,
>         -: 1609:				   this->_M_impl._M_finish._M_cur);
>         -: 1610:	  }
>         -: 1611:	else
>         -: 1612:	  _M_pop_back_aux();
>         -: 1613:      }
>         -: 1614:
>         -: 1615:#if __cplusplus >= 201103L
>         -: 1616:      /**
>         -: 1617:       *  @brief  Inserts an object in %deque before specified iterator.
>         -: 1618:       *  @param  __position  A const_iterator into the %deque.
>         -: 1619:       *  @param  __args  Arguments.
>         -: 1620:       *  @return  An iterator that points to the inserted data.
>         -: 1621:       *
>         -: 1622:       *  This function will insert an object of type T constructed
>         -: 1623:       *  with T(std::forward<Args>(args)...) before the specified location.
>         -: 1624:       */
>         -: 1625:      template<typename... _Args>
>         -: 1626:	iterator
>         -: 1627:	emplace(const_iterator __position, _Args&&... __args);
>         -: 1628:
>         -: 1629:      /**
>         -: 1630:       *  @brief  Inserts given value into %deque before specified iterator.
>         -: 1631:       *  @param  __position  A const_iterator into the %deque.
>         -: 1632:       *  @param  __x  Data to be inserted.
>         -: 1633:       *  @return  An iterator that points to the inserted data.
>         -: 1634:       *
>         -: 1635:       *  This function will insert a copy of the given value before the
>         -: 1636:       *  specified location.
>         -: 1637:       */
>         -: 1638:      iterator
>         -: 1639:      insert(const_iterator __position, const value_type& __x);
>         -: 1640:#else
>         -: 1641:      /**
>         -: 1642:       *  @brief  Inserts given value into %deque before specified iterator.
>         -: 1643:       *  @param  __position  An iterator into the %deque.
>         -: 1644:       *  @param  __x  Data to be inserted.
>         -: 1645:       *  @return  An iterator that points to the inserted data.
>         -: 1646:       *
>         -: 1647:       *  This function will insert a copy of the given value before the
>         -: 1648:       *  specified location.
>         -: 1649:       */
>         -: 1650:      iterator
>         -: 1651:      insert(iterator __position, const value_type& __x);
>         -: 1652:#endif
>         -: 1653:
>         -: 1654:#if __cplusplus >= 201103L
>         -: 1655:      /**
>         -: 1656:       *  @brief  Inserts given rvalue into %deque before specified iterator.
>         -: 1657:       *  @param  __position  A const_iterator into the %deque.
>         -: 1658:       *  @param  __x  Data to be inserted.
>         -: 1659:       *  @return  An iterator that points to the inserted data.
>         -: 1660:       *
>         -: 1661:       *  This function will insert a copy of the given rvalue before the
>         -: 1662:       *  specified location.
>         -: 1663:       */
>         -: 1664:      iterator
>         -: 1665:      insert(const_iterator __position, value_type&& __x)
>         -: 1666:      { return emplace(__position, std::move(__x)); }
>         -: 1667:
>         -: 1668:      /**
>         -: 1669:       *  @brief  Inserts an initializer list into the %deque.
>         -: 1670:       *  @param  __p  An iterator into the %deque.
>         -: 1671:       *  @param  __l  An initializer_list.
>         -: 1672:       *
>         -: 1673:       *  This function will insert copies of the data in the
>         -: 1674:       *  initializer_list @a __l into the %deque before the location
>         -: 1675:       *  specified by @a __p.  This is known as <em>list insert</em>.
>         -: 1676:       */
>         -: 1677:      iterator
>         -: 1678:      insert(const_iterator __p, initializer_list<value_type> __l)
>         -: 1679:      {
>         -: 1680:	auto __offset = __p - cbegin();
>         -: 1681:	_M_range_insert_aux(__p._M_const_cast(), __l.begin(), __l.end(),
>         -: 1682:			    std::random_access_iterator_tag());
>         -: 1683:	return begin() + __offset;
>         -: 1684:      }
>         -: 1685:#endif
>         -: 1686:
>         -: 1687:#if __cplusplus >= 201103L
>         -: 1688:      /**
>         -: 1689:       *  @brief  Inserts a number of copies of given data into the %deque.
>         -: 1690:       *  @param  __position  A const_iterator into the %deque.
>         -: 1691:       *  @param  __n  Number of elements to be inserted.
>         -: 1692:       *  @param  __x  Data to be inserted.
>         -: 1693:       *  @return  An iterator that points to the inserted data.
>         -: 1694:       *
>         -: 1695:       *  This function will insert a specified number of copies of the given
>         -: 1696:       *  data before the location specified by @a __position.
>         -: 1697:       */
>         -: 1698:      iterator
>         -: 1699:      insert(const_iterator __position, size_type __n, const value_type& __x)
>         -: 1700:      {
>         -: 1701:	difference_type __offset = __position - cbegin();
>         -: 1702:	_M_fill_insert(__position._M_const_cast(), __n, __x);
>         -: 1703:	return begin() + __offset;
>         -: 1704:      }
>         -: 1705:#else
>         -: 1706:      /**
>         -: 1707:       *  @brief  Inserts a number of copies of given data into the %deque.
>         -: 1708:       *  @param  __position  An iterator into the %deque.
>         -: 1709:       *  @param  __n  Number of elements to be inserted.
>         -: 1710:       *  @param  __x  Data to be inserted.
>         -: 1711:       *
>         -: 1712:       *  This function will insert a specified number of copies of the given
>         -: 1713:       *  data before the location specified by @a __position.
>         -: 1714:       */
>         -: 1715:      void
>         -: 1716:      insert(iterator __position, size_type __n, const value_type& __x)
>         -: 1717:      { _M_fill_insert(__position, __n, __x); }
>         -: 1718:#endif
>         -: 1719:
>         -: 1720:#if __cplusplus >= 201103L
>         -: 1721:      /**
>         -: 1722:       *  @brief  Inserts a range into the %deque.
>         -: 1723:       *  @param  __position  A const_iterator into the %deque.
>         -: 1724:       *  @param  __first  An input iterator.
>         -: 1725:       *  @param  __last   An input iterator.
>         -: 1726:       *  @return  An iterator that points to the inserted data.
>         -: 1727:       *
>         -: 1728:       *  This function will insert copies of the data in the range
>         -: 1729:       *  [__first,__last) into the %deque before the location specified
>         -: 1730:       *  by @a __position.  This is known as <em>range insert</em>.
>         -: 1731:       */
>         -: 1732:      template<typename _InputIterator,
>         -: 1733:	       typename = std::_RequireInputIter<_InputIterator>>
>         -: 1734:	iterator
>         -: 1735:	insert(const_iterator __position, _InputIterator __first,
>         -: 1736:	       _InputIterator __last)
>         -: 1737:	{
>         -: 1738:	  difference_type __offset = __position - cbegin();
>         -: 1739:	  _M_insert_dispatch(__position._M_const_cast(),
>         -: 1740:			     __first, __last, __false_type());
>         -: 1741:	  return begin() + __offset;
>         -: 1742:	}
>         -: 1743:#else
>         -: 1744:      /**
>         -: 1745:       *  @brief  Inserts a range into the %deque.
>         -: 1746:       *  @param  __position  An iterator into the %deque.
>         -: 1747:       *  @param  __first  An input iterator.
>         -: 1748:       *  @param  __last   An input iterator.
>         -: 1749:       *
>         -: 1750:       *  This function will insert copies of the data in the range
>         -: 1751:       *  [__first,__last) into the %deque before the location specified
>         -: 1752:       *  by @a __position.  This is known as <em>range insert</em>.
>         -: 1753:       */
>         -: 1754:      template<typename _InputIterator>
>         -: 1755:	void
>         -: 1756:	insert(iterator __position, _InputIterator __first,
>         -: 1757:	       _InputIterator __last)
>         -: 1758:	{
>         -: 1759:	  // Check whether it's an integral type.  If so, it's not an iterator.
>         -: 1760:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
>         -: 1761:	  _M_insert_dispatch(__position, __first, __last, _Integral());
>         -: 1762:	}
>         -: 1763:#endif
>         -: 1764:
>         -: 1765:      /**
>         -: 1766:       *  @brief  Remove element at given position.
>         -: 1767:       *  @param  __position  Iterator pointing to element to be erased.
>         -: 1768:       *  @return  An iterator pointing to the next element (or end()).
>         -: 1769:       *
>         -: 1770:       *  This function will erase the element at the given position and thus
>         -: 1771:       *  shorten the %deque by one.
>         -: 1772:       *
>         -: 1773:       *  The user is cautioned that
>         -: 1774:       *  this function only erases the element, and that if the element is
>         -: 1775:       *  itself a pointer, the pointed-to memory is not touched in any way.
>         -: 1776:       *  Managing the pointer is the user's responsibility.
>         -: 1777:       */
>         -: 1778:      iterator
>         -: 1779:#if __cplusplus >= 201103L
>         -: 1780:      erase(const_iterator __position)
>         -: 1781:#else
>         -: 1782:      erase(iterator __position)
>         -: 1783:#endif
>         -: 1784:      { return _M_erase(__position._M_const_cast()); }
>         -: 1785:
>         -: 1786:      /**
>         -: 1787:       *  @brief  Remove a range of elements.
>         -: 1788:       *  @param  __first  Iterator pointing to the first element to be erased.
>         -: 1789:       *  @param  __last  Iterator pointing to one past the last element to be
>         -: 1790:       *                erased.
>         -: 1791:       *  @return  An iterator pointing to the element pointed to by @a last
>         -: 1792:       *           prior to erasing (or end()).
>         -: 1793:       *
>         -: 1794:       *  This function will erase the elements in the range
>         -: 1795:       *  [__first,__last) and shorten the %deque accordingly.
>         -: 1796:       *
>         -: 1797:       *  The user is cautioned that
>         -: 1798:       *  this function only erases the elements, and that if the elements
>         -: 1799:       *  themselves are pointers, the pointed-to memory is not touched in any
>         -: 1800:       *  way.  Managing the pointer is the user's responsibility.
>         -: 1801:       */
>         -: 1802:      iterator
>         -: 1803:#if __cplusplus >= 201103L
>         -: 1804:      erase(const_iterator __first, const_iterator __last)
>         -: 1805:#else
>         -: 1806:      erase(iterator __first, iterator __last)
>         -: 1807:#endif
>         -: 1808:      { return _M_erase(__first._M_const_cast(), __last._M_const_cast()); }
>         -: 1809:
>         -: 1810:      /**
>         -: 1811:       *  @brief  Swaps data with another %deque.
>         -: 1812:       *  @param  __x  A %deque of the same element and allocator types.
>         -: 1813:       *
>         -: 1814:       *  This exchanges the elements between two deques in constant time.
>         -: 1815:       *  (Four pointers, so it should be quite fast.)
>         -: 1816:       *  Note that the global std::swap() function is specialized such that
>         -: 1817:       *  std::swap(d1,d2) will feed to this function.
>         -: 1818:       *
>         -: 1819:       *  Whether the allocators are swapped depends on the allocator traits.
>         -: 1820:       */
>         -: 1821:      void
>        76: 1822:      swap(deque& __x) _GLIBCXX_NOEXCEPT
>         -: 1823:      {
>         -: 1824:#if __cplusplus >= 201103L
>         -: 1825:	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
>         -: 1826:			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
>         -: 1827:#endif
>        76: 1828:	_M_impl._M_swap_data(__x._M_impl);
>        76: 1829:	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
>         -: 1830:				  __x._M_get_Tp_allocator());
>        76: 1831:      }
>         -: 1832:
>         -: 1833:      /**
>         -: 1834:       *  Erases all the elements.  Note that this function only erases the
>         -: 1835:       *  elements, and that if the elements themselves are pointers, the
>         -: 1836:       *  pointed-to memory is not touched in any way.  Managing the pointer is
>         -: 1837:       *  the user's responsibility.
>         -: 1838:       */
>         -: 1839:      void
>         -: 1840:      clear() _GLIBCXX_NOEXCEPT
>         -: 1841:      { _M_erase_at_end(begin()); }
2986,2999c1845,1858
<         -: 1843:      /**
<         -: 1844:       *  Erases all the elements.  Note that this function only erases the
<         -: 1845:       *  elements, and that if the elements themselves are pointers, the
<         -: 1846:       *  pointed-to memory is not touched in any way.  Managing the pointer is
<         -: 1847:       *  the user's responsibility.
<         -: 1848:       */
<         -: 1849:      void
<         -: 1850:      clear() _GLIBCXX_NOEXCEPT
<         -: 1851:      { _M_erase_at_end(begin()); }
<         -: 1852:
<         -: 1853:    protected:
<         -: 1854:      // Internal constructor functions follow.
<         -: 1855:
<         -: 1856:      // called by the range constructor to implement [23.1.1]/9
---
>         -: 1843:    protected:
>         -: 1844:      // Internal constructor functions follow.
>         -: 1845:
>         -: 1846:      // called by the range constructor to implement [23.1.1]/9
>         -: 1847:
>         -: 1848:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 1849:      // 438. Ambiguity in the "do the right thing" clause
>         -: 1850:      template<typename _Integer>
>         -: 1851:	void
>         -: 1852:	_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
>         -: 1853:	{
>         -: 1854:	  _M_initialize_map(static_cast<size_type>(__n));
>         -: 1855:	  _M_fill_initialize(__x);
>         -: 1856:	}
3001,3005c1860,1864
<         -: 1858:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 1859:      // 438. Ambiguity in the "do the right thing" clause
<         -: 1860:      template<typename _Integer>
<         -: 1861:	void
<         -: 1862:	_M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
---
>         -: 1858:      // called by the range constructor to implement [23.1.1]/9
>         -: 1859:      template<typename _InputIterator>
>         -: 1860:	void
>         -: 1861:	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
>         -: 1862:			       __false_type)
3007,3008c1866,1867
<         -: 1864:	  _M_initialize_map(static_cast<size_type>(__n));
<         -: 1865:	  _M_fill_initialize(__x);
---
>         -: 1864:	  _M_range_initialize(__first, __last,
>         -: 1865:			      std::__iterator_category(__first));
3011,3123c1870,1982
<         -: 1868:      // called by the range constructor to implement [23.1.1]/9
<         -: 1869:      template<typename _InputIterator>
<         -: 1870:	void
<         -: 1871:	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
<         -: 1872:			       __false_type)
<         -: 1873:	{
<         -: 1874:	  _M_range_initialize(__first, __last,
<         -: 1875:			      std::__iterator_category(__first));
<         -: 1876:	}
<         -: 1877:
<         -: 1878:      // called by the second initialize_dispatch above
<         -: 1879:      //@{
<         -: 1880:      /**
<         -: 1881:       *  @brief Fills the deque with whatever is in [first,last).
<         -: 1882:       *  @param  __first  An input iterator.
<         -: 1883:       *  @param  __last  An input iterator.
<         -: 1884:       *  @return   Nothing.
<         -: 1885:       *
<         -: 1886:       *  If the iterators are actually forward iterators (or better), then the
<         -: 1887:       *  memory layout can be done all at once.  Else we move forward using
<         -: 1888:       *  push_back on each value from the iterator.
<         -: 1889:       */
<         -: 1890:      template<typename _InputIterator>
<         -: 1891:	void
<         -: 1892:	_M_range_initialize(_InputIterator __first, _InputIterator __last,
<         -: 1893:			    std::input_iterator_tag);
<         -: 1894:
<         -: 1895:      // called by the second initialize_dispatch above
<         -: 1896:      template<typename _ForwardIterator>
<         -: 1897:	void
<         -: 1898:	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
<         -: 1899:			    std::forward_iterator_tag);
<         -: 1900:      //@}
<         -: 1901:
<         -: 1902:      /**
<         -: 1903:       *  @brief Fills the %deque with copies of value.
<         -: 1904:       *  @param  __value  Initial value.
<         -: 1905:       *  @return   Nothing.
<         -: 1906:       *  @pre _M_start and _M_finish have already been initialized,
<         -: 1907:       *  but none of the %deque's elements have yet been constructed.
<         -: 1908:       *
<         -: 1909:       *  This function is called only when the user provides an explicit size
<         -: 1910:       *  (with or without an explicit exemplar value).
<         -: 1911:       */
<         -: 1912:      void
<         -: 1913:      _M_fill_initialize(const value_type& __value);
<         -: 1914:
<         -: 1915:#if __cplusplus >= 201103L
<         -: 1916:      // called by deque(n).
<         -: 1917:      void
<         -: 1918:      _M_default_initialize();
<         -: 1919:#endif
<         -: 1920:
<         -: 1921:      // Internal assign functions follow.  The *_aux functions do the actual
<         -: 1922:      // assignment work for the range versions.
<         -: 1923:
<         -: 1924:      // called by the range assign to implement [23.1.1]/9
<         -: 1925:
<         -: 1926:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 1927:      // 438. Ambiguity in the "do the right thing" clause
<         -: 1928:      template<typename _Integer>
<         -: 1929:	void
<         -: 1930:	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
<         -: 1931:	{ _M_fill_assign(__n, __val); }
<         -: 1932:
<         -: 1933:      // called by the range assign to implement [23.1.1]/9
<         -: 1934:      template<typename _InputIterator>
<         -: 1935:	void
<         -: 1936:	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
<         -: 1937:			   __false_type)
<         -: 1938:	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
<         -: 1939:
<         -: 1940:      // called by the second assign_dispatch above
<         -: 1941:      template<typename _InputIterator>
<         -: 1942:	void
<         -: 1943:	_M_assign_aux(_InputIterator __first, _InputIterator __last,
<         -: 1944:		      std::input_iterator_tag);
<         -: 1945:
<         -: 1946:      // called by the second assign_dispatch above
<         -: 1947:      template<typename _ForwardIterator>
<         -: 1948:	void
<         -: 1949:	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
<         -: 1950:		      std::forward_iterator_tag)
<         -: 1951:	{
<         -: 1952:	  const size_type __len = std::distance(__first, __last);
<         -: 1953:	  if (__len > size())
<         -: 1954:	    {
<         -: 1955:	      _ForwardIterator __mid = __first;
<         -: 1956:	      std::advance(__mid, size());
<         -: 1957:	      std::copy(__first, __mid, begin());
<         -: 1958:	      _M_range_insert_aux(end(), __mid, __last,
<         -: 1959:				  std::__iterator_category(__first));
<         -: 1960:	    }
<         -: 1961:	  else
<         -: 1962:	    _M_erase_at_end(std::copy(__first, __last, begin()));
<         -: 1963:	}
<         -: 1964:
<         -: 1965:      // Called by assign(n,t), and the range assign when it turns out
<         -: 1966:      // to be the same thing.
<         -: 1967:      void
<         -: 1968:      _M_fill_assign(size_type __n, const value_type& __val)
<         -: 1969:      {
<         -: 1970:	if (__n > size())
<         -: 1971:	  {
<         -: 1972:	    std::fill(begin(), end(), __val);
<         -: 1973:	    _M_fill_insert(end(), __n - size(), __val);
<         -: 1974:	  }
<         -: 1975:	else
<         -: 1976:	  {
<         -: 1977:	    _M_erase_at_end(begin() + difference_type(__n));
<         -: 1978:	    std::fill(begin(), end(), __val);
<         -: 1979:	  }
<         -: 1980:      }
---
>         -: 1868:      // called by the second initialize_dispatch above
>         -: 1869:      //@{
>         -: 1870:      /**
>         -: 1871:       *  @brief Fills the deque with whatever is in [first,last).
>         -: 1872:       *  @param  __first  An input iterator.
>         -: 1873:       *  @param  __last  An input iterator.
>         -: 1874:       *  @return   Nothing.
>         -: 1875:       *
>         -: 1876:       *  If the iterators are actually forward iterators (or better), then the
>         -: 1877:       *  memory layout can be done all at once.  Else we move forward using
>         -: 1878:       *  push_back on each value from the iterator.
>         -: 1879:       */
>         -: 1880:      template<typename _InputIterator>
>         -: 1881:	void
>         -: 1882:	_M_range_initialize(_InputIterator __first, _InputIterator __last,
>         -: 1883:			    std::input_iterator_tag);
>         -: 1884:
>         -: 1885:      // called by the second initialize_dispatch above
>         -: 1886:      template<typename _ForwardIterator>
>         -: 1887:	void
>         -: 1888:	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
>         -: 1889:			    std::forward_iterator_tag);
>         -: 1890:      //@}
>         -: 1891:
>         -: 1892:      /**
>         -: 1893:       *  @brief Fills the %deque with copies of value.
>         -: 1894:       *  @param  __value  Initial value.
>         -: 1895:       *  @return   Nothing.
>         -: 1896:       *  @pre _M_start and _M_finish have already been initialized,
>         -: 1897:       *  but none of the %deque's elements have yet been constructed.
>         -: 1898:       *
>         -: 1899:       *  This function is called only when the user provides an explicit size
>         -: 1900:       *  (with or without an explicit exemplar value).
>         -: 1901:       */
>         -: 1902:      void
>         -: 1903:      _M_fill_initialize(const value_type& __value);
>         -: 1904:
>         -: 1905:#if __cplusplus >= 201103L
>         -: 1906:      // called by deque(n).
>         -: 1907:      void
>         -: 1908:      _M_default_initialize();
>         -: 1909:#endif
>         -: 1910:
>         -: 1911:      // Internal assign functions follow.  The *_aux functions do the actual
>         -: 1912:      // assignment work for the range versions.
>         -: 1913:
>         -: 1914:      // called by the range assign to implement [23.1.1]/9
>         -: 1915:
>         -: 1916:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 1917:      // 438. Ambiguity in the "do the right thing" clause
>         -: 1918:      template<typename _Integer>
>         -: 1919:	void
>         -: 1920:	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
>         -: 1921:	{ _M_fill_assign(__n, __val); }
>         -: 1922:
>         -: 1923:      // called by the range assign to implement [23.1.1]/9
>         -: 1924:      template<typename _InputIterator>
>         -: 1925:	void
>         -: 1926:	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
>         -: 1927:			   __false_type)
>         -: 1928:	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
>         -: 1929:
>         -: 1930:      // called by the second assign_dispatch above
>         -: 1931:      template<typename _InputIterator>
>         -: 1932:	void
>         -: 1933:	_M_assign_aux(_InputIterator __first, _InputIterator __last,
>         -: 1934:		      std::input_iterator_tag);
>         -: 1935:
>         -: 1936:      // called by the second assign_dispatch above
>         -: 1937:      template<typename _ForwardIterator>
>         -: 1938:	void
>         -: 1939:	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
>         -: 1940:		      std::forward_iterator_tag)
>         -: 1941:	{
>         -: 1942:	  const size_type __len = std::distance(__first, __last);
>         -: 1943:	  if (__len > size())
>         -: 1944:	    {
>         -: 1945:	      _ForwardIterator __mid = __first;
>         -: 1946:	      std::advance(__mid, size());
>         -: 1947:	      std::copy(__first, __mid, begin());
>         -: 1948:	      _M_range_insert_aux(end(), __mid, __last,
>         -: 1949:				  std::__iterator_category(__first));
>         -: 1950:	    }
>         -: 1951:	  else
>         -: 1952:	    _M_erase_at_end(std::copy(__first, __last, begin()));
>         -: 1953:	}
>         -: 1954:
>         -: 1955:      // Called by assign(n,t), and the range assign when it turns out
>         -: 1956:      // to be the same thing.
>         -: 1957:      void
>         -: 1958:      _M_fill_assign(size_type __n, const value_type& __val)
>         -: 1959:      {
>         -: 1960:	if (__n > size())
>         -: 1961:	  {
>         -: 1962:	    std::fill(begin(), end(), __val);
>         -: 1963:	    _M_fill_insert(end(), __n - size(), __val);
>         -: 1964:	  }
>         -: 1965:	else
>         -: 1966:	  {
>         -: 1967:	    _M_erase_at_end(begin() + difference_type(__n));
>         -: 1968:	    std::fill(begin(), end(), __val);
>         -: 1969:	  }
>         -: 1970:      }
>         -: 1971:
>         -: 1972:      //@{
>         -: 1973:      /// Helper functions for push_* and pop_*.
>         -: 1974:#if __cplusplus < 201103L
>         -: 1975:      void _M_push_back_aux(const value_type&);
>         -: 1976:
>         -: 1977:      void _M_push_front_aux(const value_type&);
>         -: 1978:#else
>         -: 1979:      template<typename... _Args>
>         -: 1980:	void _M_push_back_aux(_Args&&... __args);
3125,3137c1984,1996
<         -: 1982:      //@{
<         -: 1983:      /// Helper functions for push_* and pop_*.
<         -: 1984:#if __cplusplus < 201103L
<         -: 1985:      void _M_push_back_aux(const value_type&);
<         -: 1986:
<         -: 1987:      void _M_push_front_aux(const value_type&);
<         -: 1988:#else
<         -: 1989:      template<typename... _Args>
<         -: 1990:	void _M_push_back_aux(_Args&&... __args);
<         -: 1991:
<         -: 1992:      template<typename... _Args>
<         -: 1993:	void _M_push_front_aux(_Args&&... __args);
<         -: 1994:#endif
---
>         -: 1982:      template<typename... _Args>
>         -: 1983:	void _M_push_front_aux(_Args&&... __args);
>         -: 1984:#endif
>         -: 1985:
>         -: 1986:      void _M_pop_back_aux();
>         -: 1987:
>         -: 1988:      void _M_pop_front_aux();
>         -: 1989:      //@}
>         -: 1990:
>         -: 1991:      // Internal insert functions follow.  The *_aux functions do the actual
>         -: 1992:      // insertion work when all shortcuts fail.
>         -: 1993:
>         -: 1994:      // called by the range insert to implement [23.1.1]/9
3139,3145c1998,2004
<         -: 1996:      void _M_pop_back_aux();
<         -: 1997:
<         -: 1998:      void _M_pop_front_aux();
<         -: 1999:      //@}
<         -: 2000:
<         -: 2001:      // Internal insert functions follow.  The *_aux functions do the actual
<         -: 2002:      // insertion work when all shortcuts fail.
---
>         -: 1996:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 1997:      // 438. Ambiguity in the "do the right thing" clause
>         -: 1998:      template<typename _Integer>
>         -: 1999:	void
>         -: 2000:	_M_insert_dispatch(iterator __pos,
>         -: 2001:			   _Integer __n, _Integer __x, __true_type)
>         -: 2002:	{ _M_fill_insert(__pos, __n, __x); }
3148,3184c2007,2043
<         -: 2005:
<         -: 2006:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 2007:      // 438. Ambiguity in the "do the right thing" clause
<         -: 2008:      template<typename _Integer>
<         -: 2009:	void
<         -: 2010:	_M_insert_dispatch(iterator __pos,
<         -: 2011:			   _Integer __n, _Integer __x, __true_type)
<         -: 2012:	{ _M_fill_insert(__pos, __n, __x); }
<         -: 2013:
<         -: 2014:      // called by the range insert to implement [23.1.1]/9
<         -: 2015:      template<typename _InputIterator>
<         -: 2016:	void
<         -: 2017:	_M_insert_dispatch(iterator __pos,
<         -: 2018:			   _InputIterator __first, _InputIterator __last,
<         -: 2019:			   __false_type)
<         -: 2020:	{
<         -: 2021:	  _M_range_insert_aux(__pos, __first, __last,
<         -: 2022:			      std::__iterator_category(__first));
<         -: 2023:	}
<         -: 2024:
<         -: 2025:      // called by the second insert_dispatch above
<         -: 2026:      template<typename _InputIterator>
<         -: 2027:	void
<         -: 2028:	_M_range_insert_aux(iterator __pos, _InputIterator __first,
<         -: 2029:			    _InputIterator __last, std::input_iterator_tag);
<         -: 2030:
<         -: 2031:      // called by the second insert_dispatch above
<         -: 2032:      template<typename _ForwardIterator>
<         -: 2033:	void
<         -: 2034:	_M_range_insert_aux(iterator __pos, _ForwardIterator __first,
<         -: 2035:			    _ForwardIterator __last, std::forward_iterator_tag);
<         -: 2036:
<         -: 2037:      // Called by insert(p,n,x), and the range insert when it turns out to be
<         -: 2038:      // the same thing.  Can use fill functions in optimal situations,
<         -: 2039:      // otherwise passes off to insert_aux(p,n,x).
<         -: 2040:      void
<         -: 2041:      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
---
>         -: 2005:      template<typename _InputIterator>
>         -: 2006:	void
>         -: 2007:	_M_insert_dispatch(iterator __pos,
>         -: 2008:			   _InputIterator __first, _InputIterator __last,
>         -: 2009:			   __false_type)
>         -: 2010:	{
>         -: 2011:	  _M_range_insert_aux(__pos, __first, __last,
>         -: 2012:			      std::__iterator_category(__first));
>         -: 2013:	}
>         -: 2014:
>         -: 2015:      // called by the second insert_dispatch above
>         -: 2016:      template<typename _InputIterator>
>         -: 2017:	void
>         -: 2018:	_M_range_insert_aux(iterator __pos, _InputIterator __first,
>         -: 2019:			    _InputIterator __last, std::input_iterator_tag);
>         -: 2020:
>         -: 2021:      // called by the second insert_dispatch above
>         -: 2022:      template<typename _ForwardIterator>
>         -: 2023:	void
>         -: 2024:	_M_range_insert_aux(iterator __pos, _ForwardIterator __first,
>         -: 2025:			    _ForwardIterator __last, std::forward_iterator_tag);
>         -: 2026:
>         -: 2027:      // Called by insert(p,n,x), and the range insert when it turns out to be
>         -: 2028:      // the same thing.  Can use fill functions in optimal situations,
>         -: 2029:      // otherwise passes off to insert_aux(p,n,x).
>         -: 2030:      void
>         -: 2031:      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
>         -: 2032:
>         -: 2033:      // called by insert(p,x)
>         -: 2034:#if __cplusplus < 201103L
>         -: 2035:      iterator
>         -: 2036:      _M_insert_aux(iterator __pos, const value_type& __x);
>         -: 2037:#else
>         -: 2038:      template<typename... _Args>
>         -: 2039:	iterator
>         -: 2040:	_M_insert_aux(iterator __pos, _Args&&... __args);
>         -: 2041:#endif
3186,3198c2045,2057
<         -: 2043:      // called by insert(p,x)
<         -: 2044:#if __cplusplus < 201103L
<         -: 2045:      iterator
<         -: 2046:      _M_insert_aux(iterator __pos, const value_type& __x);
<         -: 2047:#else
<         -: 2048:      template<typename... _Args>
<         -: 2049:	iterator
<         -: 2050:	_M_insert_aux(iterator __pos, _Args&&... __args);
<         -: 2051:#endif
<         -: 2052:
<         -: 2053:      // called by insert(p,n,x) via fill_insert
<         -: 2054:      void
<         -: 2055:      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
---
>         -: 2043:      // called by insert(p,n,x) via fill_insert
>         -: 2044:      void
>         -: 2045:      _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);
>         -: 2046:
>         -: 2047:      // called by range_insert_aux for forward iterators
>         -: 2048:      template<typename _ForwardIterator>
>         -: 2049:	void
>         -: 2050:	_M_insert_aux(iterator __pos,
>         -: 2051:		      _ForwardIterator __first, _ForwardIterator __last,
>         -: 2052:		      size_type __n);
>         -: 2053:
>         -: 2054:
>         -: 2055:      // Internal erase functions follow.
3200,3208c2059,2067
<         -: 2057:      // called by range_insert_aux for forward iterators
<         -: 2058:      template<typename _ForwardIterator>
<         -: 2059:	void
<         -: 2060:	_M_insert_aux(iterator __pos,
<         -: 2061:		      _ForwardIterator __first, _ForwardIterator __last,
<         -: 2062:		      size_type __n);
<         -: 2063:
<         -: 2064:
<         -: 2065:      // Internal erase functions follow.
---
>         -: 2057:      void
>         -: 2058:      _M_destroy_data_aux(iterator __first, iterator __last);
>         -: 2059:
>         -: 2060:      // Called by ~deque().
>         -: 2061:      // NB: Doesn't deallocate the nodes.
>         -: 2062:      template<typename _Alloc1>
>         -: 2063:	void
>         -: 2064:	_M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
>         -: 2065:	{ _M_destroy_data_aux(__first, __last); }
3211,3253c2070,2087
<         -: 2068:      _M_destroy_data_aux(iterator __first, iterator __last);
<         -: 2069:
<         -: 2070:      // Called by ~deque().
<         -: 2071:      // NB: Doesn't deallocate the nodes.
<         -: 2072:      template<typename _Alloc1>
<         -: 2073:	void
<         -: 2074:	_M_destroy_data(iterator __first, iterator __last, const _Alloc1&)
<         -: 2075:	{ _M_destroy_data_aux(__first, __last); }
<         -: 2076:
<         -: 2077:      void
<       36*: 2078:      _M_destroy_data(iterator __first, iterator __last,
<         -: 2079:		      const std::allocator<_Tp>&)
<         -: 2080:      {
<         -: 2081:	if (!__has_trivial_destructor(value_type))
<         -: 2082:	  _M_destroy_data_aux(__first, __last);
<       36*: 2083:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE15_M_destroy_dataESt15_Deque_iteratorIS3_RS3_PS3_ES9_RKS4_:
<     #####: 2078:      _M_destroy_data(iterator __first, iterator __last,
<         -: 2079:		      const std::allocator<_Tp>&)
<         -: 2080:      {
<         -: 2081:	if (!__has_trivial_destructor(value_type))
<         -: 2082:	  _M_destroy_data_aux(__first, __last);
<     #####: 2083:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_destroy_dataESt15_Deque_iteratorIS3_RS3_PS3_ES9_RKS4_:
<        36: 2078:      _M_destroy_data(iterator __first, iterator __last,
<         -: 2079:		      const std::allocator<_Tp>&)
<         -: 2080:      {
<         -: 2081:	if (!__has_trivial_destructor(value_type))
<         -: 2082:	  _M_destroy_data_aux(__first, __last);
<        36: 2083:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE15_M_destroy_dataESt15_Deque_iteratorIS3_RS3_PS3_ES9_RKS4_:
<     #####: 2078:      _M_destroy_data(iterator __first, iterator __last,
<         -: 2079:		      const std::allocator<_Tp>&)
<         -: 2080:      {
<         -: 2081:	if (!__has_trivial_destructor(value_type))
<         -: 2082:	  _M_destroy_data_aux(__first, __last);
<     #####: 2083:      }
< ------------------
<         -: 2084:
<         -: 2085:      // Called by erase(q1, q2).
---
>       100: 2068:      _M_destroy_data(iterator __first, iterator __last,
>         -: 2069:		      const std::allocator<_Tp>&)
>         -: 2070:      {
>         -: 2071:	if (!__has_trivial_destructor(value_type))
>         -: 2072:	  _M_destroy_data_aux(__first, __last);
>       100: 2073:      }
>         -: 2074:
>         -: 2075:      // Called by erase(q1, q2).
>         -: 2076:      void
>         -: 2077:      _M_erase_at_begin(iterator __pos)
>         -: 2078:      {
>         -: 2079:	_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
>         -: 2080:	_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
>         -: 2081:	this->_M_impl._M_start = __pos;
>         -: 2082:      }
>         -: 2083:
>         -: 2084:      // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
>         -: 2085:      // _M_fill_assign, operator=.
3255c2089
<         -: 2087:      _M_erase_at_begin(iterator __pos)
---
>         -: 2087:      _M_erase_at_end(iterator __pos)
3257,3289c2091,2123
<         -: 2089:	_M_destroy_data(begin(), __pos, _M_get_Tp_allocator());
<         -: 2090:	_M_destroy_nodes(this->_M_impl._M_start._M_node, __pos._M_node);
<         -: 2091:	this->_M_impl._M_start = __pos;
<         -: 2092:      }
<         -: 2093:
<         -: 2094:      // Called by erase(q1, q2), resize(), clear(), _M_assign_aux,
<         -: 2095:      // _M_fill_assign, operator=.
<         -: 2096:      void
<         -: 2097:      _M_erase_at_end(iterator __pos)
<         -: 2098:      {
<         -: 2099:	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
<         -: 2100:	_M_destroy_nodes(__pos._M_node + 1,
<         -: 2101:			 this->_M_impl._M_finish._M_node + 1);
<         -: 2102:	this->_M_impl._M_finish = __pos;
<         -: 2103:      }
<         -: 2104:
<         -: 2105:      iterator
<         -: 2106:      _M_erase(iterator __pos);
<         -: 2107:
<         -: 2108:      iterator
<         -: 2109:      _M_erase(iterator __first, iterator __last);
<         -: 2110:
<         -: 2111:#if __cplusplus >= 201103L
<         -: 2112:      // Called by resize(sz).
<         -: 2113:      void
<         -: 2114:      _M_default_append(size_type __n);
<         -: 2115:
<         -: 2116:      bool
<         -: 2117:      _M_shrink_to_fit();
<         -: 2118:#endif
<         -: 2119:
<         -: 2120:      //@{
<         -: 2121:      /// Memory-handling helpers for the previous internal insert functions.
---
>         -: 2089:	_M_destroy_data(__pos, end(), _M_get_Tp_allocator());
>         -: 2090:	_M_destroy_nodes(__pos._M_node + 1,
>         -: 2091:			 this->_M_impl._M_finish._M_node + 1);
>         -: 2092:	this->_M_impl._M_finish = __pos;
>         -: 2093:      }
>         -: 2094:
>         -: 2095:      iterator
>         -: 2096:      _M_erase(iterator __pos);
>         -: 2097:
>         -: 2098:      iterator
>         -: 2099:      _M_erase(iterator __first, iterator __last);
>         -: 2100:
>         -: 2101:#if __cplusplus >= 201103L
>         -: 2102:      // Called by resize(sz).
>         -: 2103:      void
>         -: 2104:      _M_default_append(size_type __n);
>         -: 2105:
>         -: 2106:      bool
>         -: 2107:      _M_shrink_to_fit();
>         -: 2108:#endif
>         -: 2109:
>         -: 2110:      //@{
>         -: 2111:      /// Memory-handling helpers for the previous internal insert functions.
>         -: 2112:      iterator
>         -: 2113:      _M_reserve_elements_at_front(size_type __n)
>         -: 2114:      {
>         -: 2115:	const size_type __vacancies = this->_M_impl._M_start._M_cur
>         -: 2116:				      - this->_M_impl._M_start._M_first;
>         -: 2117:	if (__n > __vacancies)
>         -: 2118:	  _M_new_elements_at_front(__n - __vacancies);
>         -: 2119:	return this->_M_impl._M_start - difference_type(__n);
>         -: 2120:      }
>         -: 2121:
3291c2125
<         -: 2123:      _M_reserve_elements_at_front(size_type __n)
---
>         -: 2123:      _M_reserve_elements_at_back(size_type __n)
3293,3294c2127,2128
<         -: 2125:	const size_type __vacancies = this->_M_impl._M_start._M_cur
<         -: 2126:				      - this->_M_impl._M_start._M_first;
---
>         -: 2125:	const size_type __vacancies = (this->_M_impl._M_finish._M_last
>         -: 2126:				       - this->_M_impl._M_finish._M_cur) - 1;
3296,3297c2130,2131
<         -: 2128:	  _M_new_elements_at_front(__n - __vacancies);
<         -: 2129:	return this->_M_impl._M_start - difference_type(__n);
---
>         -: 2128:	  _M_new_elements_at_back(__n - __vacancies);
>         -: 2129:	return this->_M_impl._M_finish + difference_type(__n);
3300,3528c2134,2321
<         -: 2132:      iterator
<         -: 2133:      _M_reserve_elements_at_back(size_type __n)
<         -: 2134:      {
<         -: 2135:	const size_type __vacancies = (this->_M_impl._M_finish._M_last
<         -: 2136:				       - this->_M_impl._M_finish._M_cur) - 1;
<         -: 2137:	if (__n > __vacancies)
<         -: 2138:	  _M_new_elements_at_back(__n - __vacancies);
<         -: 2139:	return this->_M_impl._M_finish + difference_type(__n);
<         -: 2140:      }
<         -: 2141:
<         -: 2142:      void
<         -: 2143:      _M_new_elements_at_front(size_type __new_elements);
<         -: 2144:
<         -: 2145:      void
<         -: 2146:      _M_new_elements_at_back(size_type __new_elements);
<         -: 2147:      //@}
<         -: 2148:
<         -: 2149:
<         -: 2150:      //@{
<         -: 2151:      /**
<         -: 2152:       *  @brief Memory-handling helpers for the major %map.
<         -: 2153:       *
<         -: 2154:       *  Makes sure the _M_map has space for new nodes.  Does not
<         -: 2155:       *  actually add the nodes.  Can invalidate _M_map pointers.
<         -: 2156:       *  (And consequently, %deque iterators.)
<         -: 2157:       */
<         -: 2158:      void
<     #####: 2159:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
<         -: 2160:      {
<     #####: 2161:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
<     #####: 2162:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
<     #####: 2163:	  _M_reallocate_map(__nodes_to_add, false);
<     #####: 2164:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE22_M_reserve_map_at_backEm:
<     #####: 2159:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
<         -: 2160:      {
<     #####: 2161:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
<     #####: 2162:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
<     #####: 2163:	  _M_reallocate_map(__nodes_to_add, false);
<     #####: 2164:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS11SendRequestESaIS3_EE22_M_reserve_map_at_backEm:
<     #####: 2159:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
<         -: 2160:      {
<     #####: 2161:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
<     #####: 2162:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
<     #####: 2163:	  _M_reallocate_map(__nodes_to_add, false);
<     #####: 2164:      }
< ------------------
< _ZNSt5dequeISt10unique_ptrIN7OpenDDS4DCPS18ReactorInterceptor7CommandESt14default_deleteIS4_EESaIS7_EE22_M_reserve_map_at_backEm:
<     #####: 2159:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
<         -: 2160:      {
<     #####: 2161:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
<     #####: 2162:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
<     #####: 2163:	  _M_reallocate_map(__nodes_to_add, false);
<     #####: 2164:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE22_M_reserve_map_at_backEm:
<     #####: 2159:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
<         -: 2160:      {
<     #####: 2161:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
<     #####: 2162:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
<     #####: 2163:	  _M_reallocate_map(__nodes_to_add, false);
<     #####: 2164:      }
< ------------------
< _ZNSt5dequeIPN7OpenDDS4DCPS21TransportQueueElementESaIS3_EE22_M_reserve_map_at_backEm:
<     #####: 2159:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
<         -: 2160:      {
<     #####: 2161:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
<     #####: 2162:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
<     #####: 2163:	  _M_reallocate_map(__nodes_to_add, false);
<     #####: 2164:      }
< ------------------
<         -: 2165:
<         -: 2166:      void
<         -: 2167:      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
<         -: 2168:      {
<         -: 2169:	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
<         -: 2170:				       - this->_M_impl._M_map))
<         -: 2171:	  _M_reallocate_map(__nodes_to_add, true);
<         -: 2172:      }
<         -: 2173:
<         -: 2174:      void
<         -: 2175:      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
<         -: 2176:      //@}
<         -: 2177:
<         -: 2178:#if __cplusplus >= 201103L
<         -: 2179:      // Constant-time, nothrow move assignment when source object's memory
<         -: 2180:      // can be moved because the allocators are equal.
<         -: 2181:      void
<         -: 2182:      _M_move_assign1(deque&& __x, /* always equal: */ true_type) noexcept
<         -: 2183:      {
<         -: 2184:	this->_M_impl._M_swap_data(__x._M_impl);
<         -: 2185:	__x.clear();
<         -: 2186:	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
<         -: 2187:      }
<         -: 2188:
<         -: 2189:      // When the allocators are not equal the operation could throw, because
<         -: 2190:      // we might need to allocate a new map for __x after moving from it
<         -: 2191:      // or we might need to allocate new elements for *this.
<         -: 2192:      void
<         -: 2193:      _M_move_assign1(deque&& __x, /* always equal: */ false_type)
<         -: 2194:      {
<         -: 2195:	constexpr bool __move_storage =
<         -: 2196:	  _Alloc_traits::_S_propagate_on_move_assign();
<         -: 2197:	_M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
<         -: 2198:      }
<         -: 2199:
<         -: 2200:      // Destroy all elements and deallocate all memory, then replace
<         -: 2201:      // with elements created from __args.
<         -: 2202:      template<typename... _Args>
<         -: 2203:      void
<         -: 2204:      _M_replace_map(_Args&&... __args)
<         -: 2205:      {
<         -: 2206:	// Create new data first, so if allocation fails there are no effects.
<         -: 2207:	deque __newobj(std::forward<_Args>(__args)...);
<         -: 2208:	// Free existing storage using existing allocator.
<         -: 2209:	clear();
<         -: 2210:	_M_deallocate_node(*begin()._M_node); // one node left after clear()
<         -: 2211:	_M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
<         -: 2212:	this->_M_impl._M_map = nullptr;
<         -: 2213:	this->_M_impl._M_map_size = 0;
<         -: 2214:	// Take ownership of replacement memory.
<         -: 2215:	this->_M_impl._M_swap_data(__newobj._M_impl);
<         -: 2216:      }
<         -: 2217:
<         -: 2218:      // Do move assignment when the allocator propagates.
<         -: 2219:      void
<         -: 2220:      _M_move_assign2(deque&& __x, /* propagate: */ true_type)
<         -: 2221:      {
<         -: 2222:	// Make a copy of the original allocator state.
<         -: 2223:	auto __alloc = __x._M_get_Tp_allocator();
<         -: 2224:	// The allocator propagates so storage can be moved from __x,
<         -: 2225:	// leaving __x in a valid empty state with a moved-from allocator.
<         -: 2226:	_M_replace_map(std::move(__x));
<         -: 2227:	// Move the corresponding allocator state too.
<         -: 2228:	_M_get_Tp_allocator() = std::move(__alloc);
<         -: 2229:      }
<         -: 2230:
<         -: 2231:      // Do move assignment when it may not be possible to move source
<         -: 2232:      // object's memory, resulting in a linear-time operation.
<         -: 2233:      void
<         -: 2234:      _M_move_assign2(deque&& __x, /* propagate: */ false_type)
<         -: 2235:      {
<         -: 2236:	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
<         -: 2237:	  {
<         -: 2238:	    // The allocators are equal so storage can be moved from __x,
<         -: 2239:	    // leaving __x in a valid empty state with its current allocator.
<         -: 2240:	    _M_replace_map(std::move(__x), __x.get_allocator());
<         -: 2241:	  }
<         -: 2242:	else
<         -: 2243:	  {
<         -: 2244:	    // The rvalue's allocator cannot be moved and is not equal,
<         -: 2245:	    // so we need to individually move each element.
<         -: 2246:	    _M_assign_aux(std::__make_move_if_noexcept_iterator(__x.begin()),
<         -: 2247:			  std::__make_move_if_noexcept_iterator(__x.end()),
<         -: 2248:			  std::random_access_iterator_tag());
<         -: 2249:	    __x.clear();
<         -: 2250:	  }
<         -: 2251:      }
<         -: 2252:#endif
<         -: 2253:    };
<         -: 2254:
<         -: 2255:#if __cpp_deduction_guides >= 201606
<         -: 2256:  template<typename _InputIterator, typename _ValT
<         -: 2257:	     = typename iterator_traits<_InputIterator>::value_type,
<         -: 2258:	   typename _Allocator = allocator<_ValT>,
<         -: 2259:	   typename = _RequireInputIter<_InputIterator>,
<         -: 2260:	   typename = _RequireAllocator<_Allocator>>
<         -: 2261:    deque(_InputIterator, _InputIterator, _Allocator = _Allocator())
<         -: 2262:      -> deque<_ValT, _Allocator>;
<         -: 2263:#endif
<         -: 2264:
<         -: 2265:  /**
<         -: 2266:   *  @brief  Deque equality comparison.
<         -: 2267:   *  @param  __x  A %deque.
<         -: 2268:   *  @param  __y  A %deque of the same type as @a __x.
<         -: 2269:   *  @return  True iff the size and elements of the deques are equal.
<         -: 2270:   *
<         -: 2271:   *  This is an equivalence relation.  It is linear in the size of the
<         -: 2272:   *  deques.  Deques are considered equivalent if their sizes are equal,
<         -: 2273:   *  and if corresponding elements compare equal.
<         -: 2274:  */
<         -: 2275:  template<typename _Tp, typename _Alloc>
<         -: 2276:    inline bool
<         -: 2277:    operator==(const deque<_Tp, _Alloc>& __x,
<         -: 2278:                         const deque<_Tp, _Alloc>& __y)
<         -: 2279:    { return __x.size() == __y.size()
<         -: 2280:	     && std::equal(__x.begin(), __x.end(), __y.begin()); }
<         -: 2281:
<         -: 2282:  /**
<         -: 2283:   *  @brief  Deque ordering relation.
<         -: 2284:   *  @param  __x  A %deque.
<         -: 2285:   *  @param  __y  A %deque of the same type as @a __x.
<         -: 2286:   *  @return  True iff @a x is lexicographically less than @a __y.
<         -: 2287:   *
<         -: 2288:   *  This is a total ordering relation.  It is linear in the size of the
<         -: 2289:   *  deques.  The elements must be comparable with @c <.
<         -: 2290:   *
<         -: 2291:   *  See std::lexicographical_compare() for how the determination is made.
<         -: 2292:  */
<         -: 2293:  template<typename _Tp, typename _Alloc>
<         -: 2294:    inline bool
<         -: 2295:    operator<(const deque<_Tp, _Alloc>& __x,
<         -: 2296:	      const deque<_Tp, _Alloc>& __y)
<         -: 2297:    { return std::lexicographical_compare(__x.begin(), __x.end(),
<         -: 2298:					  __y.begin(), __y.end()); }
<         -: 2299:
<         -: 2300:  /// Based on operator==
<         -: 2301:  template<typename _Tp, typename _Alloc>
<         -: 2302:    inline bool
<         -: 2303:    operator!=(const deque<_Tp, _Alloc>& __x,
<         -: 2304:	       const deque<_Tp, _Alloc>& __y)
<         -: 2305:    { return !(__x == __y); }
<         -: 2306:
<         -: 2307:  /// Based on operator<
<         -: 2308:  template<typename _Tp, typename _Alloc>
<         -: 2309:    inline bool
<         -: 2310:    operator>(const deque<_Tp, _Alloc>& __x,
<         -: 2311:	      const deque<_Tp, _Alloc>& __y)
<         -: 2312:    { return __y < __x; }
<         -: 2313:
<         -: 2314:  /// Based on operator<
<         -: 2315:  template<typename _Tp, typename _Alloc>
<         -: 2316:    inline bool
<         -: 2317:    operator<=(const deque<_Tp, _Alloc>& __x,
<         -: 2318:	       const deque<_Tp, _Alloc>& __y)
<         -: 2319:    { return !(__y < __x); }
---
>         -: 2132:      void
>         -: 2133:      _M_new_elements_at_front(size_type __new_elements);
>         -: 2134:
>         -: 2135:      void
>         -: 2136:      _M_new_elements_at_back(size_type __new_elements);
>         -: 2137:      //@}
>         -: 2138:
>         -: 2139:
>         -: 2140:      //@{
>         -: 2141:      /**
>         -: 2142:       *  @brief Memory-handling helpers for the major %map.
>         -: 2143:       *
>         -: 2144:       *  Makes sure the _M_map has space for new nodes.  Does not
>         -: 2145:       *  actually add the nodes.  Can invalidate _M_map pointers.
>         -: 2146:       *  (And consequently, %deque iterators.)
>         -: 2147:       */
>         -: 2148:      void
>     #####: 2149:      _M_reserve_map_at_back(size_type __nodes_to_add = 1)
>         -: 2150:      {
>     #####: 2151:	if (__nodes_to_add + 1 > this->_M_impl._M_map_size
>     #####: 2152:	    - (this->_M_impl._M_finish._M_node - this->_M_impl._M_map))
>     #####: 2153:	  _M_reallocate_map(__nodes_to_add, false);
>     #####: 2154:      }
>         -: 2155:
>         -: 2156:      void
>         -: 2157:      _M_reserve_map_at_front(size_type __nodes_to_add = 1)
>         -: 2158:      {
>         -: 2159:	if (__nodes_to_add > size_type(this->_M_impl._M_start._M_node
>         -: 2160:				       - this->_M_impl._M_map))
>         -: 2161:	  _M_reallocate_map(__nodes_to_add, true);
>         -: 2162:      }
>         -: 2163:
>         -: 2164:      void
>         -: 2165:      _M_reallocate_map(size_type __nodes_to_add, bool __add_at_front);
>         -: 2166:      //@}
>         -: 2167:
>         -: 2168:#if __cplusplus >= 201103L
>         -: 2169:      // Constant-time, nothrow move assignment when source object's memory
>         -: 2170:      // can be moved because the allocators are equal.
>         -: 2171:      void
>         -: 2172:      _M_move_assign1(deque&& __x, /* always equal: */ true_type) noexcept
>         -: 2173:      {
>         -: 2174:	this->_M_impl._M_swap_data(__x._M_impl);
>         -: 2175:	__x.clear();
>         -: 2176:	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
>         -: 2177:      }
>         -: 2178:
>         -: 2179:      // When the allocators are not equal the operation could throw, because
>         -: 2180:      // we might need to allocate a new map for __x after moving from it
>         -: 2181:      // or we might need to allocate new elements for *this.
>         -: 2182:      void
>         -: 2183:      _M_move_assign1(deque&& __x, /* always equal: */ false_type)
>         -: 2184:      {
>         -: 2185:	constexpr bool __move_storage =
>         -: 2186:	  _Alloc_traits::_S_propagate_on_move_assign();
>         -: 2187:	_M_move_assign2(std::move(__x), __bool_constant<__move_storage>());
>         -: 2188:      }
>         -: 2189:
>         -: 2190:      // Destroy all elements and deallocate all memory, then replace
>         -: 2191:      // with elements created from __args.
>         -: 2192:      template<typename... _Args>
>         -: 2193:      void
>         -: 2194:      _M_replace_map(_Args&&... __args)
>         -: 2195:      {
>         -: 2196:	// Create new data first, so if allocation fails there are no effects.
>         -: 2197:	deque __newobj(std::forward<_Args>(__args)...);
>         -: 2198:	// Free existing storage using existing allocator.
>         -: 2199:	clear();
>         -: 2200:	_M_deallocate_node(*begin()._M_node); // one node left after clear()
>         -: 2201:	_M_deallocate_map(this->_M_impl._M_map, this->_M_impl._M_map_size);
>         -: 2202:	this->_M_impl._M_map = nullptr;
>         -: 2203:	this->_M_impl._M_map_size = 0;
>         -: 2204:	// Take ownership of replacement memory.
>         -: 2205:	this->_M_impl._M_swap_data(__newobj._M_impl);
>         -: 2206:      }
>         -: 2207:
>         -: 2208:      // Do move assignment when the allocator propagates.
>         -: 2209:      void
>         -: 2210:      _M_move_assign2(deque&& __x, /* propagate: */ true_type)
>         -: 2211:      {
>         -: 2212:	// Make a copy of the original allocator state.
>         -: 2213:	auto __alloc = __x._M_get_Tp_allocator();
>         -: 2214:	// The allocator propagates so storage can be moved from __x,
>         -: 2215:	// leaving __x in a valid empty state with a moved-from allocator.
>         -: 2216:	_M_replace_map(std::move(__x));
>         -: 2217:	// Move the corresponding allocator state too.
>         -: 2218:	_M_get_Tp_allocator() = std::move(__alloc);
>         -: 2219:      }
>         -: 2220:
>         -: 2221:      // Do move assignment when it may not be possible to move source
>         -: 2222:      // object's memory, resulting in a linear-time operation.
>         -: 2223:      void
>         -: 2224:      _M_move_assign2(deque&& __x, /* propagate: */ false_type)
>         -: 2225:      {
>         -: 2226:	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
>         -: 2227:	  {
>         -: 2228:	    // The allocators are equal so storage can be moved from __x,
>         -: 2229:	    // leaving __x in a valid empty state with its current allocator.
>         -: 2230:	    _M_replace_map(std::move(__x), __x.get_allocator());
>         -: 2231:	  }
>         -: 2232:	else
>         -: 2233:	  {
>         -: 2234:	    // The rvalue's allocator cannot be moved and is not equal,
>         -: 2235:	    // so we need to individually move each element.
>         -: 2236:	    _M_assign_aux(std::__make_move_if_noexcept_iterator(__x.begin()),
>         -: 2237:			  std::__make_move_if_noexcept_iterator(__x.end()),
>         -: 2238:			  std::random_access_iterator_tag());
>         -: 2239:	    __x.clear();
>         -: 2240:	  }
>         -: 2241:      }
>         -: 2242:#endif
>         -: 2243:    };
>         -: 2244:
>         -: 2245:
>         -: 2246:  /**
>         -: 2247:   *  @brief  Deque equality comparison.
>         -: 2248:   *  @param  __x  A %deque.
>         -: 2249:   *  @param  __y  A %deque of the same type as @a __x.
>         -: 2250:   *  @return  True iff the size and elements of the deques are equal.
>         -: 2251:   *
>         -: 2252:   *  This is an equivalence relation.  It is linear in the size of the
>         -: 2253:   *  deques.  Deques are considered equivalent if their sizes are equal,
>         -: 2254:   *  and if corresponding elements compare equal.
>         -: 2255:  */
>         -: 2256:  template<typename _Tp, typename _Alloc>
>         -: 2257:    inline bool
>         -: 2258:    operator==(const deque<_Tp, _Alloc>& __x,
>         -: 2259:                         const deque<_Tp, _Alloc>& __y)
>         -: 2260:    { return __x.size() == __y.size()
>         -: 2261:	     && std::equal(__x.begin(), __x.end(), __y.begin()); }
>         -: 2262:
>         -: 2263:  /**
>         -: 2264:   *  @brief  Deque ordering relation.
>         -: 2265:   *  @param  __x  A %deque.
>         -: 2266:   *  @param  __y  A %deque of the same type as @a __x.
>         -: 2267:   *  @return  True iff @a x is lexicographically less than @a __y.
>         -: 2268:   *
>         -: 2269:   *  This is a total ordering relation.  It is linear in the size of the
>         -: 2270:   *  deques.  The elements must be comparable with @c <.
>         -: 2271:   *
>         -: 2272:   *  See std::lexicographical_compare() for how the determination is made.
>         -: 2273:  */
>         -: 2274:  template<typename _Tp, typename _Alloc>
>         -: 2275:    inline bool
>         -: 2276:    operator<(const deque<_Tp, _Alloc>& __x,
>         -: 2277:	      const deque<_Tp, _Alloc>& __y)
>         -: 2278:    { return std::lexicographical_compare(__x.begin(), __x.end(),
>         -: 2279:					  __y.begin(), __y.end()); }
>         -: 2280:
>         -: 2281:  /// Based on operator==
>         -: 2282:  template<typename _Tp, typename _Alloc>
>         -: 2283:    inline bool
>         -: 2284:    operator!=(const deque<_Tp, _Alloc>& __x,
>         -: 2285:	       const deque<_Tp, _Alloc>& __y)
>         -: 2286:    { return !(__x == __y); }
>         -: 2287:
>         -: 2288:  /// Based on operator<
>         -: 2289:  template<typename _Tp, typename _Alloc>
>         -: 2290:    inline bool
>         -: 2291:    operator>(const deque<_Tp, _Alloc>& __x,
>         -: 2292:	      const deque<_Tp, _Alloc>& __y)
>         -: 2293:    { return __y < __x; }
>         -: 2294:
>         -: 2295:  /// Based on operator<
>         -: 2296:  template<typename _Tp, typename _Alloc>
>         -: 2297:    inline bool
>         -: 2298:    operator<=(const deque<_Tp, _Alloc>& __x,
>         -: 2299:	       const deque<_Tp, _Alloc>& __y)
>         -: 2300:    { return !(__y < __x); }
>         -: 2301:
>         -: 2302:  /// Based on operator<
>         -: 2303:  template<typename _Tp, typename _Alloc>
>         -: 2304:    inline bool
>         -: 2305:    operator>=(const deque<_Tp, _Alloc>& __x,
>         -: 2306:	       const deque<_Tp, _Alloc>& __y)
>         -: 2307:    { return !(__x < __y); }
>         -: 2308:
>         -: 2309:  /// See std::deque::swap().
>         -: 2310:  template<typename _Tp, typename _Alloc>
>         -: 2311:    inline void
>         -: 2312:    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
>         -: 2313:    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
>         -: 2314:    { __x.swap(__y); }
>         -: 2315:
>         -: 2316:#undef _GLIBCXX_DEQUE_BUF_SIZE
>         -: 2317:
>         -: 2318:_GLIBCXX_END_NAMESPACE_CONTAINER
>         -: 2319:} // namespace std
3530,3550c2323
<         -: 2321:  /// Based on operator<
<         -: 2322:  template<typename _Tp, typename _Alloc>
<         -: 2323:    inline bool
<         -: 2324:    operator>=(const deque<_Tp, _Alloc>& __x,
<         -: 2325:	       const deque<_Tp, _Alloc>& __y)
<         -: 2326:    { return !(__x < __y); }
<         -: 2327:
<         -: 2328:  /// See std::deque::swap().
<         -: 2329:  template<typename _Tp, typename _Alloc>
<         -: 2330:    inline void
<         -: 2331:    swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)
<         -: 2332:    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
<         -: 2333:    { __x.swap(__y); }
<         -: 2334:
<         -: 2335:#undef _GLIBCXX_DEQUE_BUF_SIZE
<         -: 2336:
<         -: 2337:_GLIBCXX_END_NAMESPACE_CONTAINER
<         -: 2338:_GLIBCXX_END_NAMESPACE_VERSION
<         -: 2339:} // namespace std
<         -: 2340:
<         -: 2341:#endif /* _STL_DEQUE_H */
---
>         -: 2321:#endif /* _STL_DEQUE_H */
