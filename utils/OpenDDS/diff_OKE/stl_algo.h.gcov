1,2c1,2
<         -:    0:Source:/usr/include/c++/8/bits/stl_algo.h
<         -:    0:Programs:51
---
>         -:    0:Source:/usr/include/c++/7/bits/stl_algo.h
>         -:    0:Programs:15
5c5
<         -:    3:// Copyright (C) 2001-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 2001-2017 Free Software Foundation, Inc.
114c114
<         1:  112:    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
---
>         -:  112:    __find_if(_RandomAccessIterator __first, _RandomAccessIterator __last,
118c118
<         1:  116:	__trip_count = (__last - __first) >> 2;
---
>         -:  116:	__trip_count = (__last - __first) >> 2;
120c120
<        1*:  118:      for (; __trip_count > 0; --__trip_count)
---
>         -:  118:      for (; __trip_count > 0; --__trip_count)
122,124c122,124
<     #####:  120:	  if (__pred(__first))
<     #####:  121:	    return __first;
<     #####:  122:	  ++__first;
---
>         -:  120:	  if (__pred(__first))
>         -:  121:	    return __first;
>         -:  122:	  ++__first;
126,128c126,128
<     #####:  124:	  if (__pred(__first))
<     #####:  125:	    return __first;
<     #####:  126:	  ++__first;
---
>         -:  124:	  if (__pred(__first))
>         -:  125:	    return __first;
>         -:  126:	  ++__first;
130,132c130,132
<     #####:  128:	  if (__pred(__first))
<     #####:  129:	    return __first;
<     #####:  130:	  ++__first;
---
>         -:  128:	  if (__pred(__first))
>         -:  129:	    return __first;
>         -:  130:	  ++__first;
134,136c134,136
<     #####:  132:	  if (__pred(__first))
<     #####:  133:	    return __first;
<     #####:  134:	  ++__first;
---
>         -:  132:	  if (__pred(__first))
>         -:  133:	    return __first;
>         -:  134:	  ++__first;
139c139
<         1:  137:      switch (__last - __first)
---
>         -:  137:      switch (__last - __first)
141,153c141,153
<     #####:  139:	case 3:
<     #####:  140:	  if (__pred(__first))
<     #####:  141:	    return __first;
<     #####:  142:	  ++__first;
<     #####:  143:	case 2:
<     #####:  144:	  if (__pred(__first))
<     #####:  145:	    return __first;
<     #####:  146:	  ++__first;
<     #####:  147:	case 1:
<     #####:  148:	  if (__pred(__first))
<     #####:  149:	    return __first;
<     #####:  150:	  ++__first;
<         1:  151:	case 0:
---
>         -:  139:	case 3:
>         -:  140:	  if (__pred(__first))
>         -:  141:	    return __first;
>         -:  142:	  ++__first;
>         -:  143:	case 2:
>         -:  144:	  if (__pred(__first))
>         -:  145:	    return __first;
>         -:  146:	  ++__first;
>         -:  147:	case 1:
>         -:  148:	  if (__pred(__first))
>         -:  149:	    return __first;
>         -:  150:	  ++__first;
>         -:  151:	case 0:
155c155
<         1:  153:	  return __last;
---
>         -:  153:	  return __last;
161c161
<         1:  159:    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
---
>         -:  159:    __find_if(_Iterator __first, _Iterator __last, _Predicate __pred)
163,164c163,164
<         1:  161:      return __find_if(__first, __last, __pred,
<         2:  162:		       std::__iterator_category(__first));
---
>         -:  161:      return __find_if(__first, __last, __pred,
>         -:  162:		       std::__iterator_category(__first));
185c185
<         -:  183:      for (; __len; --__len,  (void) ++__first)
---
>         -:  183:      for (; __len; --__len, ++__first)
862c862
<         1:  860:    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
---
>         -:  860:    __remove_if(_ForwardIterator __first, _ForwardIterator __last,
865,871c865,871
<         1:  863:      __first = std::__find_if(__first, __last, __pred);
<         1:  864:      if (__first == __last)
<         1:  865:	return __first;
<     #####:  866:      _ForwardIterator __result = __first;
<     #####:  867:      ++__first;
<     #####:  868:      for (; __first != __last; ++__first)
<     #####:  869:	if (!__pred(__first))
---
>         -:  863:      __first = std::__find_if(__first, __last, __pred);
>         -:  864:      if (__first == __last)
>         -:  865:	return __first;
>         -:  866:      _ForwardIterator __result = __first;
>         -:  867:      ++__first;
>         -:  868:      for (; __first != __last; ++__first)
>         -:  869:	if (!__pred(__first))
873,874c873,874
<     #####:  871:	    *__result = _GLIBCXX_MOVE(*__first);
<     #####:  872:	    ++__result;
---
>         -:  871:	    *__result = _GLIBCXX_MOVE(*__first);
>         -:  872:	    ++__result;
876c876
<     #####:  874:      return __result;
---
>         -:  874:      return __result;
898c898
<         1:  896:    remove(_ForwardIterator __first, _ForwardIterator __last,
---
>         -:  896:    remove(_ForwardIterator __first, _ForwardIterator __last,
908,909c908,909
<         1:  906:      return std::__remove_if(__first, __last,
<         1:  907:		__gnu_cxx::__ops::__iter_equals_val(__value));
---
>         -:  906:      return std::__remove_if(__first, __last,
>         -:  907:		__gnu_cxx::__ops::__iter_equals_val(__value));
1209c1209
<        18: 1207:    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
---
>         -: 1207:    reverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last,
1219c1219
<        18: 1217:      while (__first != __last)
---
>         -: 1217:      while (__first != __last)
1221,1223c1221,1223
<         9: 1219:	  --__last;
<         9: 1220:	  *__result = *__last;
<         9: 1221:	  ++__result;
---
>         -: 1219:	  --__last;
>         -: 1220:	  *__result = *__last;
>         -: 1221:	  ++__result;
1225c1225
<         9: 1223:      return __result;
---
>         -: 1223:      return __result;
3192c3192
<         2: 3190:    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
---
>         -: 3190:    __count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
3194,3198c3194,3198
<         2: 3192:      typename iterator_traits<_InputIterator>::difference_type __n = 0;
<        2*: 3193:      for (; __first != __last; ++__first)
<     #####: 3194:	if (__pred(__first))
<     #####: 3195:	  ++__n;
<         2: 3196:      return __n;
---
>         -: 3192:      typename iterator_traits<_InputIterator>::difference_type __n = 0;
>         -: 3193:      for (; __first != __last; ++__first)
>         -: 3194:	if (__pred(__first))
>         -: 3195:	  ++__n;
>         -: 3196:      return __n;
3862c3862
<         -: 3860:_GLIBCXX_BEGIN_NAMESPACE_ALGO
---
>         -: 3860:_GLIBCXX_END_NAMESPACE_VERSION
3864,4404c3864,4404
<         -: 3862:  /**
<         -: 3863:   *  @brief Apply a function to every element of a sequence.
<         -: 3864:   *  @ingroup non_mutating_algorithms
<         -: 3865:   *  @param  __first  An input iterator.
<         -: 3866:   *  @param  __last   An input iterator.
<         -: 3867:   *  @param  __f      A unary function object.
<         -: 3868:   *  @return   @p __f
<         -: 3869:   *
<         -: 3870:   *  Applies the function object @p __f to each element in the range
<         -: 3871:   *  @p [first,last).  @p __f must not modify the order of the sequence.
<         -: 3872:   *  If @p __f has a return value it is ignored.
<         -: 3873:  */
<         -: 3874:  template<typename _InputIterator, typename _Function>
<         -: 3875:    _Function
<     #####: 3876:    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
<         -: 3877:    {
<         -: 3878:      // concept requirements
<         -: 3879:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 3880:      __glibcxx_requires_valid_range(__first, __last);
<     #####: 3881:      for (; __first != __last; ++__first)
<     #####: 3882:	__f(*__first);
<     #####: 3883:      return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.
<         -: 3884:    }
<         -: 3885:
<         -: 3886:  /**
<         -: 3887:   *  @brief Find the first occurrence of a value in a sequence.
<         -: 3888:   *  @ingroup non_mutating_algorithms
<         -: 3889:   *  @param  __first  An input iterator.
<         -: 3890:   *  @param  __last   An input iterator.
<         -: 3891:   *  @param  __val    The value to find.
<         -: 3892:   *  @return   The first iterator @c i in the range @p [__first,__last)
<         -: 3893:   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
<         -: 3894:  */
<         -: 3895:  template<typename _InputIterator, typename _Tp>
<         -: 3896:    inline _InputIterator
<         -: 3897:    find(_InputIterator __first, _InputIterator __last,
<         -: 3898:	 const _Tp& __val)
<         -: 3899:    {
<         -: 3900:      // concept requirements
<         -: 3901:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 3902:      __glibcxx_function_requires(_EqualOpConcept<
<         -: 3903:		typename iterator_traits<_InputIterator>::value_type, _Tp>)
<         -: 3904:      __glibcxx_requires_valid_range(__first, __last);
<         -: 3905:      return std::__find_if(__first, __last,
<         -: 3906:			    __gnu_cxx::__ops::__iter_equals_val(__val));
<         -: 3907:    }
<         -: 3908:
<         -: 3909:  /**
<         -: 3910:   *  @brief Find the first element in a sequence for which a
<         -: 3911:   *         predicate is true.
<         -: 3912:   *  @ingroup non_mutating_algorithms
<         -: 3913:   *  @param  __first  An input iterator.
<         -: 3914:   *  @param  __last   An input iterator.
<         -: 3915:   *  @param  __pred   A predicate.
<         -: 3916:   *  @return   The first iterator @c i in the range @p [__first,__last)
<         -: 3917:   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
<         -: 3918:  */
<         -: 3919:  template<typename _InputIterator, typename _Predicate>
<         -: 3920:    inline _InputIterator
<         -: 3921:    find_if(_InputIterator __first, _InputIterator __last,
<         -: 3922:	    _Predicate __pred)
<         -: 3923:    {
<         -: 3924:      // concept requirements
<         -: 3925:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 3926:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
<         -: 3927:	      typename iterator_traits<_InputIterator>::value_type>)
<         -: 3928:      __glibcxx_requires_valid_range(__first, __last);
<         -: 3929:
<         -: 3930:      return std::__find_if(__first, __last,
<         -: 3931:			    __gnu_cxx::__ops::__pred_iter(__pred));
<         -: 3932:    }
<         -: 3933:
<         -: 3934:  /**
<         -: 3935:   *  @brief  Find element from a set in a sequence.
<         -: 3936:   *  @ingroup non_mutating_algorithms
<         -: 3937:   *  @param  __first1  Start of range to search.
<         -: 3938:   *  @param  __last1   End of range to search.
<         -: 3939:   *  @param  __first2  Start of match candidates.
<         -: 3940:   *  @param  __last2   End of match candidates.
<         -: 3941:   *  @return   The first iterator @c i in the range
<         -: 3942:   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
<         -: 3943:   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
<         -: 3944:   *
<         -: 3945:   *  Searches the range @p [__first1,__last1) for an element that is
<         -: 3946:   *  equal to some element in the range [__first2,__last2).  If
<         -: 3947:   *  found, returns an iterator in the range [__first1,__last1),
<         -: 3948:   *  otherwise returns @p __last1.
<         -: 3949:  */
<         -: 3950:  template<typename _InputIterator, typename _ForwardIterator>
<         -: 3951:    _InputIterator
<         -: 3952:    find_first_of(_InputIterator __first1, _InputIterator __last1,
<         -: 3953:		  _ForwardIterator __first2, _ForwardIterator __last2)
<         -: 3954:    {
<         -: 3955:      // concept requirements
<         -: 3956:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 3957:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 3958:      __glibcxx_function_requires(_EqualOpConcept<
<         -: 3959:	    typename iterator_traits<_InputIterator>::value_type,
<         -: 3960:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 3961:      __glibcxx_requires_valid_range(__first1, __last1);
<         -: 3962:      __glibcxx_requires_valid_range(__first2, __last2);
<         -: 3963:
<         -: 3964:      for (; __first1 != __last1; ++__first1)
<         -: 3965:	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
<         -: 3966:	  if (*__first1 == *__iter)
<         -: 3967:	    return __first1;
<         -: 3968:      return __last1;
<         -: 3969:    }
<         -: 3970:
<         -: 3971:  /**
<         -: 3972:   *  @brief  Find element from a set in a sequence using a predicate.
<         -: 3973:   *  @ingroup non_mutating_algorithms
<         -: 3974:   *  @param  __first1  Start of range to search.
<         -: 3975:   *  @param  __last1   End of range to search.
<         -: 3976:   *  @param  __first2  Start of match candidates.
<         -: 3977:   *  @param  __last2   End of match candidates.
<         -: 3978:   *  @param  __comp    Predicate to use.
<         -: 3979:   *  @return   The first iterator @c i in the range
<         -: 3980:   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
<         -: 3981:   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
<         -: 3982:   *  such iterator exists.
<         -: 3983:   *
<         -: 3984:
<         -: 3985:   *  Searches the range @p [__first1,__last1) for an element that is
<         -: 3986:   *  equal to some element in the range [__first2,__last2).  If
<         -: 3987:   *  found, returns an iterator in the range [__first1,__last1),
<         -: 3988:   *  otherwise returns @p __last1.
<         -: 3989:  */
<         -: 3990:  template<typename _InputIterator, typename _ForwardIterator,
<         -: 3991:	   typename _BinaryPredicate>
<         -: 3992:    _InputIterator
<         -: 3993:    find_first_of(_InputIterator __first1, _InputIterator __last1,
<         -: 3994:		  _ForwardIterator __first2, _ForwardIterator __last2,
<         -: 3995:		  _BinaryPredicate __comp)
<         -: 3996:    {
<         -: 3997:      // concept requirements
<         -: 3998:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 3999:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 4000:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
<         -: 4001:	    typename iterator_traits<_InputIterator>::value_type,
<         -: 4002:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4003:      __glibcxx_requires_valid_range(__first1, __last1);
<         -: 4004:      __glibcxx_requires_valid_range(__first2, __last2);
<         -: 4005:
<         -: 4006:      for (; __first1 != __last1; ++__first1)
<         -: 4007:	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
<         -: 4008:	  if (__comp(*__first1, *__iter))
<         -: 4009:	    return __first1;
<         -: 4010:      return __last1;
<         -: 4011:    }
<         -: 4012:
<         -: 4013:  /**
<         -: 4014:   *  @brief Find two adjacent values in a sequence that are equal.
<         -: 4015:   *  @ingroup non_mutating_algorithms
<         -: 4016:   *  @param  __first  A forward iterator.
<         -: 4017:   *  @param  __last   A forward iterator.
<         -: 4018:   *  @return   The first iterator @c i such that @c i and @c i+1 are both
<         -: 4019:   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
<         -: 4020:   *  or @p __last if no such iterator exists.
<         -: 4021:  */
<         -: 4022:  template<typename _ForwardIterator>
<         -: 4023:    inline _ForwardIterator
<         -: 4024:    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
<         -: 4025:    {
<         -: 4026:      // concept requirements
<         -: 4027:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 4028:      __glibcxx_function_requires(_EqualityComparableConcept<
<         -: 4029:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4030:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4031:
<         -: 4032:      return std::__adjacent_find(__first, __last,
<         -: 4033:				  __gnu_cxx::__ops::__iter_equal_to_iter());
<         -: 4034:    }
<         -: 4035:
<         -: 4036:  /**
<         -: 4037:   *  @brief Find two adjacent values in a sequence using a predicate.
<         -: 4038:   *  @ingroup non_mutating_algorithms
<         -: 4039:   *  @param  __first         A forward iterator.
<         -: 4040:   *  @param  __last          A forward iterator.
<         -: 4041:   *  @param  __binary_pred   A binary predicate.
<         -: 4042:   *  @return   The first iterator @c i such that @c i and @c i+1 are both
<         -: 4043:   *  valid iterators in @p [__first,__last) and such that
<         -: 4044:   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
<         -: 4045:   *  exists.
<         -: 4046:  */
<         -: 4047:  template<typename _ForwardIterator, typename _BinaryPredicate>
<         -: 4048:    inline _ForwardIterator
<         -: 4049:    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4050:		  _BinaryPredicate __binary_pred)
<         -: 4051:    {
<         -: 4052:      // concept requirements
<         -: 4053:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 4054:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
<         -: 4055:	    typename iterator_traits<_ForwardIterator>::value_type,
<         -: 4056:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4057:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4058:
<         -: 4059:      return std::__adjacent_find(__first, __last,
<         -: 4060:			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
<         -: 4061:    }
<         -: 4062:
<         -: 4063:  /**
<         -: 4064:   *  @brief Count the number of copies of a value in a sequence.
<         -: 4065:   *  @ingroup non_mutating_algorithms
<         -: 4066:   *  @param  __first  An input iterator.
<         -: 4067:   *  @param  __last   An input iterator.
<         -: 4068:   *  @param  __value  The value to be counted.
<         -: 4069:   *  @return   The number of iterators @c i in the range @p [__first,__last)
<         -: 4070:   *  for which @c *i == @p __value
<         -: 4071:  */
<         -: 4072:  template<typename _InputIterator, typename _Tp>
<         -: 4073:    inline typename iterator_traits<_InputIterator>::difference_type
<         2: 4074:    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
<         -: 4075:    {
<         -: 4076:      // concept requirements
<         -: 4077:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 4078:      __glibcxx_function_requires(_EqualOpConcept<
<         -: 4079:	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
<         -: 4080:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4081:
<         2: 4082:      return std::__count_if(__first, __last,
<         2: 4083:			     __gnu_cxx::__ops::__iter_equals_val(__value));
<         -: 4084:    }
<         -: 4085:
<         -: 4086:  /**
<         -: 4087:   *  @brief Count the elements of a sequence for which a predicate is true.
<         -: 4088:   *  @ingroup non_mutating_algorithms
<         -: 4089:   *  @param  __first  An input iterator.
<         -: 4090:   *  @param  __last   An input iterator.
<         -: 4091:   *  @param  __pred   A predicate.
<         -: 4092:   *  @return   The number of iterators @c i in the range @p [__first,__last)
<         -: 4093:   *  for which @p __pred(*i) is true.
<         -: 4094:  */
<         -: 4095:  template<typename _InputIterator, typename _Predicate>
<         -: 4096:    inline typename iterator_traits<_InputIterator>::difference_type
<         -: 4097:    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
<         -: 4098:    {
<         -: 4099:      // concept requirements
<         -: 4100:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 4101:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
<         -: 4102:	    typename iterator_traits<_InputIterator>::value_type>)
<         -: 4103:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4104:
<         -: 4105:      return std::__count_if(__first, __last,
<         -: 4106:			     __gnu_cxx::__ops::__pred_iter(__pred));
<         -: 4107:    }
<         -: 4108:
<         -: 4109:  /**
<         -: 4110:   *  @brief Search a sequence for a matching sub-sequence.
<         -: 4111:   *  @ingroup non_mutating_algorithms
<         -: 4112:   *  @param  __first1  A forward iterator.
<         -: 4113:   *  @param  __last1   A forward iterator.
<         -: 4114:   *  @param  __first2  A forward iterator.
<         -: 4115:   *  @param  __last2   A forward iterator.
<         -: 4116:   *  @return The first iterator @c i in the range @p
<         -: 4117:   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
<         -: 4118:   *  *(__first2+N) for each @c N in the range @p
<         -: 4119:   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
<         -: 4120:   *
<         -: 4121:   *  Searches the range @p [__first1,__last1) for a sub-sequence that
<         -: 4122:   *  compares equal value-by-value with the sequence given by @p
<         -: 4123:   *  [__first2,__last2) and returns an iterator to the first element
<         -: 4124:   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
<         -: 4125:   *  found.
<         -: 4126:   *
<         -: 4127:   *  Because the sub-sequence must lie completely within the range @p
<         -: 4128:   *  [__first1,__last1) it must start at a position less than @p
<         -: 4129:   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
<         -: 4130:   *  length of the sub-sequence.
<         -: 4131:   *
<         -: 4132:   *  This means that the returned iterator @c i will be in the range
<         -: 4133:   *  @p [__first1,__last1-(__last2-__first2))
<         -: 4134:  */
<         -: 4135:  template<typename _ForwardIterator1, typename _ForwardIterator2>
<         -: 4136:    inline _ForwardIterator1
<         -: 4137:    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
<         -: 4138:	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
<         -: 4139:    {
<         -: 4140:      // concept requirements
<         -: 4141:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
<         -: 4142:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
<         -: 4143:      __glibcxx_function_requires(_EqualOpConcept<
<         -: 4144:	    typename iterator_traits<_ForwardIterator1>::value_type,
<         -: 4145:	    typename iterator_traits<_ForwardIterator2>::value_type>)
<         -: 4146:      __glibcxx_requires_valid_range(__first1, __last1);
<         -: 4147:      __glibcxx_requires_valid_range(__first2, __last2);
<         -: 4148:
<         -: 4149:      return std::__search(__first1, __last1, __first2, __last2,
<         -: 4150:			   __gnu_cxx::__ops::__iter_equal_to_iter());
<         -: 4151:    }
<         -: 4152:
<         -: 4153:  /**
<         -: 4154:   *  @brief Search a sequence for a matching sub-sequence using a predicate.
<         -: 4155:   *  @ingroup non_mutating_algorithms
<         -: 4156:   *  @param  __first1     A forward iterator.
<         -: 4157:   *  @param  __last1      A forward iterator.
<         -: 4158:   *  @param  __first2     A forward iterator.
<         -: 4159:   *  @param  __last2      A forward iterator.
<         -: 4160:   *  @param  __predicate  A binary predicate.
<         -: 4161:   *  @return   The first iterator @c i in the range
<         -: 4162:   *  @p [__first1,__last1-(__last2-__first2)) such that
<         -: 4163:   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
<         -: 4164:   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
<         -: 4165:   *
<         -: 4166:   *  Searches the range @p [__first1,__last1) for a sub-sequence that
<         -: 4167:   *  compares equal value-by-value with the sequence given by @p
<         -: 4168:   *  [__first2,__last2), using @p __predicate to determine equality,
<         -: 4169:   *  and returns an iterator to the first element of the
<         -: 4170:   *  sub-sequence, or @p __last1 if no such iterator exists.
<         -: 4171:   *
<         -: 4172:   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
<         -: 4173:  */
<         -: 4174:  template<typename _ForwardIterator1, typename _ForwardIterator2,
<         -: 4175:	   typename _BinaryPredicate>
<         -: 4176:    inline _ForwardIterator1
<         -: 4177:    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
<         -: 4178:	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
<         -: 4179:	   _BinaryPredicate  __predicate)
<         -: 4180:    {
<         -: 4181:      // concept requirements
<         -: 4182:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
<         -: 4183:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
<         -: 4184:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
<         -: 4185:	    typename iterator_traits<_ForwardIterator1>::value_type,
<         -: 4186:	    typename iterator_traits<_ForwardIterator2>::value_type>)
<         -: 4187:      __glibcxx_requires_valid_range(__first1, __last1);
<         -: 4188:      __glibcxx_requires_valid_range(__first2, __last2);
<         -: 4189:
<         -: 4190:      return std::__search(__first1, __last1, __first2, __last2,
<         -: 4191:			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
<         -: 4192:    }
<         -: 4193:
<         -: 4194:  /**
<         -: 4195:   *  @brief Search a sequence for a number of consecutive values.
<         -: 4196:   *  @ingroup non_mutating_algorithms
<         -: 4197:   *  @param  __first  A forward iterator.
<         -: 4198:   *  @param  __last   A forward iterator.
<         -: 4199:   *  @param  __count  The number of consecutive values.
<         -: 4200:   *  @param  __val    The value to find.
<         -: 4201:   *  @return The first iterator @c i in the range @p
<         -: 4202:   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
<         -: 4203:   *  each @c N in the range @p [0,__count), or @p __last if no such
<         -: 4204:   *  iterator exists.
<         -: 4205:   *
<         -: 4206:   *  Searches the range @p [__first,__last) for @p count consecutive elements
<         -: 4207:   *  equal to @p __val.
<         -: 4208:  */
<         -: 4209:  template<typename _ForwardIterator, typename _Integer, typename _Tp>
<         -: 4210:    inline _ForwardIterator
<         -: 4211:    search_n(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4212:	     _Integer __count, const _Tp& __val)
<         -: 4213:    {
<         -: 4214:      // concept requirements
<         -: 4215:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 4216:      __glibcxx_function_requires(_EqualOpConcept<
<         -: 4217:	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
<         -: 4218:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4219:
<         -: 4220:      return std::__search_n(__first, __last, __count,
<         -: 4221:			     __gnu_cxx::__ops::__iter_equals_val(__val));
<         -: 4222:    }
<         -: 4223:
<         -: 4224:
<         -: 4225:  /**
<         -: 4226:   *  @brief Search a sequence for a number of consecutive values using a
<         -: 4227:   *         predicate.
<         -: 4228:   *  @ingroup non_mutating_algorithms
<         -: 4229:   *  @param  __first        A forward iterator.
<         -: 4230:   *  @param  __last         A forward iterator.
<         -: 4231:   *  @param  __count        The number of consecutive values.
<         -: 4232:   *  @param  __val          The value to find.
<         -: 4233:   *  @param  __binary_pred  A binary predicate.
<         -: 4234:   *  @return The first iterator @c i in the range @p
<         -: 4235:   *  [__first,__last-__count) such that @p
<         -: 4236:   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
<         -: 4237:   *  @p [0,__count), or @p __last if no such iterator exists.
<         -: 4238:   *
<         -: 4239:   *  Searches the range @p [__first,__last) for @p __count
<         -: 4240:   *  consecutive elements for which the predicate returns true.
<         -: 4241:  */
<         -: 4242:  template<typename _ForwardIterator, typename _Integer, typename _Tp,
<         -: 4243:	   typename _BinaryPredicate>
<         -: 4244:    inline _ForwardIterator
<         -: 4245:    search_n(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4246:	     _Integer __count, const _Tp& __val,
<         -: 4247:	     _BinaryPredicate __binary_pred)
<         -: 4248:    {
<         -: 4249:      // concept requirements
<         -: 4250:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 4251:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
<         -: 4252:	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
<         -: 4253:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4254:
<         -: 4255:      return std::__search_n(__first, __last, __count,
<         -: 4256:		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
<         -: 4257:    }
<         -: 4258:
<         -: 4259:#if __cplusplus > 201402L
<         -: 4260:  /** @brief Search a sequence using a Searcher object.
<         -: 4261:   *
<         -: 4262:   *  @param  __first        A forward iterator.
<         -: 4263:   *  @param  __last         A forward iterator.
<         -: 4264:   *  @param  __searcher     A callable object.
<         -: 4265:   *  @return @p __searcher(__first,__last).first
<         -: 4266:  */
<         -: 4267:  template<typename _ForwardIterator, typename _Searcher>
<         -: 4268:    inline _ForwardIterator
<         -: 4269:    search(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4270:	   const _Searcher& __searcher)
<         -: 4271:    { return __searcher(__first, __last).first; }
<         -: 4272:#endif
<         -: 4273:
<         -: 4274:  /**
<         -: 4275:   *  @brief Perform an operation on a sequence.
<         -: 4276:   *  @ingroup mutating_algorithms
<         -: 4277:   *  @param  __first     An input iterator.
<         -: 4278:   *  @param  __last      An input iterator.
<         -: 4279:   *  @param  __result    An output iterator.
<         -: 4280:   *  @param  __unary_op  A unary operator.
<         -: 4281:   *  @return   An output iterator equal to @p __result+(__last-__first).
<         -: 4282:   *
<         -: 4283:   *  Applies the operator to each element in the input range and assigns
<         -: 4284:   *  the results to successive elements of the output sequence.
<         -: 4285:   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
<         -: 4286:   *  range @p [0,__last-__first).
<         -: 4287:   *
<         -: 4288:   *  @p unary_op must not alter its argument.
<         -: 4289:  */
<         -: 4290:  template<typename _InputIterator, typename _OutputIterator,
<         -: 4291:	   typename _UnaryOperation>
<         -: 4292:    _OutputIterator
<     #####: 4293:    transform(_InputIterator __first, _InputIterator __last,
<         -: 4294:	      _OutputIterator __result, _UnaryOperation __unary_op)
<         -: 4295:    {
<         -: 4296:      // concept requirements
<         -: 4297:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 4298:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4299:	    // "the type returned by a _UnaryOperation"
<         -: 4300:	    __typeof__(__unary_op(*__first))>)
<         -: 4301:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4302:
<     #####: 4303:      for (; __first != __last; ++__first, (void)++__result)
<     #####: 4304:	*__result = __unary_op(*__first);
<     #####: 4305:      return __result;
<         -: 4306:    }
<         -: 4307:
<         -: 4308:  /**
<         -: 4309:   *  @brief Perform an operation on corresponding elements of two sequences.
<         -: 4310:   *  @ingroup mutating_algorithms
<         -: 4311:   *  @param  __first1     An input iterator.
<         -: 4312:   *  @param  __last1      An input iterator.
<         -: 4313:   *  @param  __first2     An input iterator.
<         -: 4314:   *  @param  __result     An output iterator.
<         -: 4315:   *  @param  __binary_op  A binary operator.
<         -: 4316:   *  @return   An output iterator equal to @p result+(last-first).
<         -: 4317:   *
<         -: 4318:   *  Applies the operator to the corresponding elements in the two
<         -: 4319:   *  input ranges and assigns the results to successive elements of the
<         -: 4320:   *  output sequence.
<         -: 4321:   *  Evaluates @p
<         -: 4322:   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
<         -: 4323:   *  @c N in the range @p [0,__last1-__first1).
<         -: 4324:   *
<         -: 4325:   *  @p binary_op must not alter either of its arguments.
<         -: 4326:  */
<         -: 4327:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 4328:	   typename _OutputIterator, typename _BinaryOperation>
<         -: 4329:    _OutputIterator
<         -: 4330:    transform(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 4331:	      _InputIterator2 __first2, _OutputIterator __result,
<         -: 4332:	      _BinaryOperation __binary_op)
<         -: 4333:    {
<         -: 4334:      // concept requirements
<         -: 4335:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 4336:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 4337:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4338:	    // "the type returned by a _BinaryOperation"
<         -: 4339:	    __typeof__(__binary_op(*__first1,*__first2))>)
<         -: 4340:      __glibcxx_requires_valid_range(__first1, __last1);
<         -: 4341:
<         -: 4342:      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
<         -: 4343:	*__result = __binary_op(*__first1, *__first2);
<         -: 4344:      return __result;
<         -: 4345:    }
<         -: 4346:
<         -: 4347:  /**
<         -: 4348:   *  @brief Replace each occurrence of one value in a sequence with another
<         -: 4349:   *         value.
<         -: 4350:   *  @ingroup mutating_algorithms
<         -: 4351:   *  @param  __first      A forward iterator.
<         -: 4352:   *  @param  __last       A forward iterator.
<         -: 4353:   *  @param  __old_value  The value to be replaced.
<         -: 4354:   *  @param  __new_value  The replacement value.
<         -: 4355:   *  @return   replace() returns no value.
<         -: 4356:   *
<         -: 4357:   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
<         -: 4358:   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
<         -: 4359:  */
<         -: 4360:  template<typename _ForwardIterator, typename _Tp>
<         -: 4361:    void
<         -: 4362:    replace(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4363:	    const _Tp& __old_value, const _Tp& __new_value)
<         -: 4364:    {
<         -: 4365:      // concept requirements
<         -: 4366:      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
<         -: 4367:				  _ForwardIterator>)
<         -: 4368:      __glibcxx_function_requires(_EqualOpConcept<
<         -: 4369:	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
<         -: 4370:      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
<         -: 4371:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4372:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4373:
<         -: 4374:      for (; __first != __last; ++__first)
<         -: 4375:	if (*__first == __old_value)
<         -: 4376:	  *__first = __new_value;
<         -: 4377:    }
<         -: 4378:
<         -: 4379:  /**
<         -: 4380:   *  @brief Replace each value in a sequence for which a predicate returns
<         -: 4381:   *         true with another value.
<         -: 4382:   *  @ingroup mutating_algorithms
<         -: 4383:   *  @param  __first      A forward iterator.
<         -: 4384:   *  @param  __last       A forward iterator.
<         -: 4385:   *  @param  __pred       A predicate.
<         -: 4386:   *  @param  __new_value  The replacement value.
<         -: 4387:   *  @return   replace_if() returns no value.
<         -: 4388:   *
<         -: 4389:   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
<         -: 4390:   *  is true then the assignment @c *i = @p __new_value is performed.
<         -: 4391:  */
<         -: 4392:  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
<         -: 4393:    void
<         -: 4394:    replace_if(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4395:	       _Predicate __pred, const _Tp& __new_value)
<         -: 4396:    {
<         -: 4397:      // concept requirements
<         -: 4398:      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
<         -: 4399:				  _ForwardIterator>)
<         -: 4400:      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
<         -: 4401:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4402:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
---
>         -: 3862:_GLIBCXX_BEGIN_NAMESPACE_ALGO
>         -: 3863:
>         -: 3864:  /**
>         -: 3865:   *  @brief Apply a function to every element of a sequence.
>         -: 3866:   *  @ingroup non_mutating_algorithms
>         -: 3867:   *  @param  __first  An input iterator.
>         -: 3868:   *  @param  __last   An input iterator.
>         -: 3869:   *  @param  __f      A unary function object.
>         -: 3870:   *  @return   @p __f
>         -: 3871:   *
>         -: 3872:   *  Applies the function object @p __f to each element in the range
>         -: 3873:   *  @p [first,last).  @p __f must not modify the order of the sequence.
>         -: 3874:   *  If @p __f has a return value it is ignored.
>         -: 3875:  */
>         -: 3876:  template<typename _InputIterator, typename _Function>
>         -: 3877:    _Function
>     #####: 3878:    for_each(_InputIterator __first, _InputIterator __last, _Function __f)
>         -: 3879:    {
>         -: 3880:      // concept requirements
>         -: 3881:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 3882:      __glibcxx_requires_valid_range(__first, __last);
>     #####: 3883:      for (; __first != __last; ++__first)
>     #####: 3884:	__f(*__first);
>     #####: 3885:      return __f; // N.B. [alg.foreach] says std::move(f) but it's redundant.
>         -: 3886:    }
>         -: 3887:
>         -: 3888:  /**
>         -: 3889:   *  @brief Find the first occurrence of a value in a sequence.
>         -: 3890:   *  @ingroup non_mutating_algorithms
>         -: 3891:   *  @param  __first  An input iterator.
>         -: 3892:   *  @param  __last   An input iterator.
>         -: 3893:   *  @param  __val    The value to find.
>         -: 3894:   *  @return   The first iterator @c i in the range @p [__first,__last)
>         -: 3895:   *  such that @c *i == @p __val, or @p __last if no such iterator exists.
>         -: 3896:  */
>         -: 3897:  template<typename _InputIterator, typename _Tp>
>         -: 3898:    inline _InputIterator
>         -: 3899:    find(_InputIterator __first, _InputIterator __last,
>         -: 3900:	 const _Tp& __val)
>         -: 3901:    {
>         -: 3902:      // concept requirements
>         -: 3903:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 3904:      __glibcxx_function_requires(_EqualOpConcept<
>         -: 3905:		typename iterator_traits<_InputIterator>::value_type, _Tp>)
>         -: 3906:      __glibcxx_requires_valid_range(__first, __last);
>         -: 3907:      return std::__find_if(__first, __last,
>         -: 3908:			    __gnu_cxx::__ops::__iter_equals_val(__val));
>         -: 3909:    }
>         -: 3910:
>         -: 3911:  /**
>         -: 3912:   *  @brief Find the first element in a sequence for which a
>         -: 3913:   *         predicate is true.
>         -: 3914:   *  @ingroup non_mutating_algorithms
>         -: 3915:   *  @param  __first  An input iterator.
>         -: 3916:   *  @param  __last   An input iterator.
>         -: 3917:   *  @param  __pred   A predicate.
>         -: 3918:   *  @return   The first iterator @c i in the range @p [__first,__last)
>         -: 3919:   *  such that @p __pred(*i) is true, or @p __last if no such iterator exists.
>         -: 3920:  */
>         -: 3921:  template<typename _InputIterator, typename _Predicate>
>         -: 3922:    inline _InputIterator
>         -: 3923:    find_if(_InputIterator __first, _InputIterator __last,
>         -: 3924:	    _Predicate __pred)
>         -: 3925:    {
>         -: 3926:      // concept requirements
>         -: 3927:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 3928:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
>         -: 3929:	      typename iterator_traits<_InputIterator>::value_type>)
>         -: 3930:      __glibcxx_requires_valid_range(__first, __last);
>         -: 3931:
>         -: 3932:      return std::__find_if(__first, __last,
>         -: 3933:			    __gnu_cxx::__ops::__pred_iter(__pred));
>         -: 3934:    }
>         -: 3935:
>         -: 3936:  /**
>         -: 3937:   *  @brief  Find element from a set in a sequence.
>         -: 3938:   *  @ingroup non_mutating_algorithms
>         -: 3939:   *  @param  __first1  Start of range to search.
>         -: 3940:   *  @param  __last1   End of range to search.
>         -: 3941:   *  @param  __first2  Start of match candidates.
>         -: 3942:   *  @param  __last2   End of match candidates.
>         -: 3943:   *  @return   The first iterator @c i in the range
>         -: 3944:   *  @p [__first1,__last1) such that @c *i == @p *(i2) such that i2 is an
>         -: 3945:   *  iterator in [__first2,__last2), or @p __last1 if no such iterator exists.
>         -: 3946:   *
>         -: 3947:   *  Searches the range @p [__first1,__last1) for an element that is
>         -: 3948:   *  equal to some element in the range [__first2,__last2).  If
>         -: 3949:   *  found, returns an iterator in the range [__first1,__last1),
>         -: 3950:   *  otherwise returns @p __last1.
>         -: 3951:  */
>         -: 3952:  template<typename _InputIterator, typename _ForwardIterator>
>         -: 3953:    _InputIterator
>         -: 3954:    find_first_of(_InputIterator __first1, _InputIterator __last1,
>         -: 3955:		  _ForwardIterator __first2, _ForwardIterator __last2)
>         -: 3956:    {
>         -: 3957:      // concept requirements
>         -: 3958:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 3959:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 3960:      __glibcxx_function_requires(_EqualOpConcept<
>         -: 3961:	    typename iterator_traits<_InputIterator>::value_type,
>         -: 3962:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 3963:      __glibcxx_requires_valid_range(__first1, __last1);
>         -: 3964:      __glibcxx_requires_valid_range(__first2, __last2);
>         -: 3965:
>         -: 3966:      for (; __first1 != __last1; ++__first1)
>         -: 3967:	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
>         -: 3968:	  if (*__first1 == *__iter)
>         -: 3969:	    return __first1;
>         -: 3970:      return __last1;
>         -: 3971:    }
>         -: 3972:
>         -: 3973:  /**
>         -: 3974:   *  @brief  Find element from a set in a sequence using a predicate.
>         -: 3975:   *  @ingroup non_mutating_algorithms
>         -: 3976:   *  @param  __first1  Start of range to search.
>         -: 3977:   *  @param  __last1   End of range to search.
>         -: 3978:   *  @param  __first2  Start of match candidates.
>         -: 3979:   *  @param  __last2   End of match candidates.
>         -: 3980:   *  @param  __comp    Predicate to use.
>         -: 3981:   *  @return   The first iterator @c i in the range
>         -: 3982:   *  @p [__first1,__last1) such that @c comp(*i, @p *(i2)) is true
>         -: 3983:   *  and i2 is an iterator in [__first2,__last2), or @p __last1 if no
>         -: 3984:   *  such iterator exists.
>         -: 3985:   *
>         -: 3986:
>         -: 3987:   *  Searches the range @p [__first1,__last1) for an element that is
>         -: 3988:   *  equal to some element in the range [__first2,__last2).  If
>         -: 3989:   *  found, returns an iterator in the range [__first1,__last1),
>         -: 3990:   *  otherwise returns @p __last1.
>         -: 3991:  */
>         -: 3992:  template<typename _InputIterator, typename _ForwardIterator,
>         -: 3993:	   typename _BinaryPredicate>
>         -: 3994:    _InputIterator
>         -: 3995:    find_first_of(_InputIterator __first1, _InputIterator __last1,
>         -: 3996:		  _ForwardIterator __first2, _ForwardIterator __last2,
>         -: 3997:		  _BinaryPredicate __comp)
>         -: 3998:    {
>         -: 3999:      // concept requirements
>         -: 4000:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 4001:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 4002:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
>         -: 4003:	    typename iterator_traits<_InputIterator>::value_type,
>         -: 4004:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4005:      __glibcxx_requires_valid_range(__first1, __last1);
>         -: 4006:      __glibcxx_requires_valid_range(__first2, __last2);
>         -: 4007:
>         -: 4008:      for (; __first1 != __last1; ++__first1)
>         -: 4009:	for (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)
>         -: 4010:	  if (__comp(*__first1, *__iter))
>         -: 4011:	    return __first1;
>         -: 4012:      return __last1;
>         -: 4013:    }
>         -: 4014:
>         -: 4015:  /**
>         -: 4016:   *  @brief Find two adjacent values in a sequence that are equal.
>         -: 4017:   *  @ingroup non_mutating_algorithms
>         -: 4018:   *  @param  __first  A forward iterator.
>         -: 4019:   *  @param  __last   A forward iterator.
>         -: 4020:   *  @return   The first iterator @c i such that @c i and @c i+1 are both
>         -: 4021:   *  valid iterators in @p [__first,__last) and such that @c *i == @c *(i+1),
>         -: 4022:   *  or @p __last if no such iterator exists.
>         -: 4023:  */
>         -: 4024:  template<typename _ForwardIterator>
>         -: 4025:    inline _ForwardIterator
>         -: 4026:    adjacent_find(_ForwardIterator __first, _ForwardIterator __last)
>         -: 4027:    {
>         -: 4028:      // concept requirements
>         -: 4029:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 4030:      __glibcxx_function_requires(_EqualityComparableConcept<
>         -: 4031:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4032:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4033:
>         -: 4034:      return std::__adjacent_find(__first, __last,
>         -: 4035:				  __gnu_cxx::__ops::__iter_equal_to_iter());
>         -: 4036:    }
>         -: 4037:
>         -: 4038:  /**
>         -: 4039:   *  @brief Find two adjacent values in a sequence using a predicate.
>         -: 4040:   *  @ingroup non_mutating_algorithms
>         -: 4041:   *  @param  __first         A forward iterator.
>         -: 4042:   *  @param  __last          A forward iterator.
>         -: 4043:   *  @param  __binary_pred   A binary predicate.
>         -: 4044:   *  @return   The first iterator @c i such that @c i and @c i+1 are both
>         -: 4045:   *  valid iterators in @p [__first,__last) and such that
>         -: 4046:   *  @p __binary_pred(*i,*(i+1)) is true, or @p __last if no such iterator
>         -: 4047:   *  exists.
>         -: 4048:  */
>         -: 4049:  template<typename _ForwardIterator, typename _BinaryPredicate>
>         -: 4050:    inline _ForwardIterator
>         -: 4051:    adjacent_find(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4052:		  _BinaryPredicate __binary_pred)
>         -: 4053:    {
>         -: 4054:      // concept requirements
>         -: 4055:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 4056:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
>         -: 4057:	    typename iterator_traits<_ForwardIterator>::value_type,
>         -: 4058:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4059:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4060:
>         -: 4061:      return std::__adjacent_find(__first, __last,
>         -: 4062:			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
>         -: 4063:    }
>         -: 4064:
>         -: 4065:  /**
>         -: 4066:   *  @brief Count the number of copies of a value in a sequence.
>         -: 4067:   *  @ingroup non_mutating_algorithms
>         -: 4068:   *  @param  __first  An input iterator.
>         -: 4069:   *  @param  __last   An input iterator.
>         -: 4070:   *  @param  __value  The value to be counted.
>         -: 4071:   *  @return   The number of iterators @c i in the range @p [__first,__last)
>         -: 4072:   *  for which @c *i == @p __value
>         -: 4073:  */
>         -: 4074:  template<typename _InputIterator, typename _Tp>
>         -: 4075:    inline typename iterator_traits<_InputIterator>::difference_type
>         -: 4076:    count(_InputIterator __first, _InputIterator __last, const _Tp& __value)
>         -: 4077:    {
>         -: 4078:      // concept requirements
>         -: 4079:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 4080:      __glibcxx_function_requires(_EqualOpConcept<
>         -: 4081:	    typename iterator_traits<_InputIterator>::value_type, _Tp>)
>         -: 4082:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4083:
>         -: 4084:      return std::__count_if(__first, __last,
>         -: 4085:			     __gnu_cxx::__ops::__iter_equals_val(__value));
>         -: 4086:    }
>         -: 4087:
>         -: 4088:  /**
>         -: 4089:   *  @brief Count the elements of a sequence for which a predicate is true.
>         -: 4090:   *  @ingroup non_mutating_algorithms
>         -: 4091:   *  @param  __first  An input iterator.
>         -: 4092:   *  @param  __last   An input iterator.
>         -: 4093:   *  @param  __pred   A predicate.
>         -: 4094:   *  @return   The number of iterators @c i in the range @p [__first,__last)
>         -: 4095:   *  for which @p __pred(*i) is true.
>         -: 4096:  */
>         -: 4097:  template<typename _InputIterator, typename _Predicate>
>         -: 4098:    inline typename iterator_traits<_InputIterator>::difference_type
>         -: 4099:    count_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)
>         -: 4100:    {
>         -: 4101:      // concept requirements
>         -: 4102:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 4103:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
>         -: 4104:	    typename iterator_traits<_InputIterator>::value_type>)
>         -: 4105:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4106:
>         -: 4107:      return std::__count_if(__first, __last,
>         -: 4108:			     __gnu_cxx::__ops::__pred_iter(__pred));
>         -: 4109:    }
>         -: 4110:
>         -: 4111:  /**
>         -: 4112:   *  @brief Search a sequence for a matching sub-sequence.
>         -: 4113:   *  @ingroup non_mutating_algorithms
>         -: 4114:   *  @param  __first1  A forward iterator.
>         -: 4115:   *  @param  __last1   A forward iterator.
>         -: 4116:   *  @param  __first2  A forward iterator.
>         -: 4117:   *  @param  __last2   A forward iterator.
>         -: 4118:   *  @return The first iterator @c i in the range @p
>         -: 4119:   *  [__first1,__last1-(__last2-__first2)) such that @c *(i+N) == @p
>         -: 4120:   *  *(__first2+N) for each @c N in the range @p
>         -: 4121:   *  [0,__last2-__first2), or @p __last1 if no such iterator exists.
>         -: 4122:   *
>         -: 4123:   *  Searches the range @p [__first1,__last1) for a sub-sequence that
>         -: 4124:   *  compares equal value-by-value with the sequence given by @p
>         -: 4125:   *  [__first2,__last2) and returns an iterator to the first element
>         -: 4126:   *  of the sub-sequence, or @p __last1 if the sub-sequence is not
>         -: 4127:   *  found.
>         -: 4128:   *
>         -: 4129:   *  Because the sub-sequence must lie completely within the range @p
>         -: 4130:   *  [__first1,__last1) it must start at a position less than @p
>         -: 4131:   *  __last1-(__last2-__first2) where @p __last2-__first2 is the
>         -: 4132:   *  length of the sub-sequence.
>         -: 4133:   *
>         -: 4134:   *  This means that the returned iterator @c i will be in the range
>         -: 4135:   *  @p [__first1,__last1-(__last2-__first2))
>         -: 4136:  */
>         -: 4137:  template<typename _ForwardIterator1, typename _ForwardIterator2>
>         -: 4138:    inline _ForwardIterator1
>         -: 4139:    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
>         -: 4140:	   _ForwardIterator2 __first2, _ForwardIterator2 __last2)
>         -: 4141:    {
>         -: 4142:      // concept requirements
>         -: 4143:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
>         -: 4144:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
>         -: 4145:      __glibcxx_function_requires(_EqualOpConcept<
>         -: 4146:	    typename iterator_traits<_ForwardIterator1>::value_type,
>         -: 4147:	    typename iterator_traits<_ForwardIterator2>::value_type>)
>         -: 4148:      __glibcxx_requires_valid_range(__first1, __last1);
>         -: 4149:      __glibcxx_requires_valid_range(__first2, __last2);
>         -: 4150:
>         -: 4151:      return std::__search(__first1, __last1, __first2, __last2,
>         -: 4152:			   __gnu_cxx::__ops::__iter_equal_to_iter());
>         -: 4153:    }
>         -: 4154:
>         -: 4155:  /**
>         -: 4156:   *  @brief Search a sequence for a matching sub-sequence using a predicate.
>         -: 4157:   *  @ingroup non_mutating_algorithms
>         -: 4158:   *  @param  __first1     A forward iterator.
>         -: 4159:   *  @param  __last1      A forward iterator.
>         -: 4160:   *  @param  __first2     A forward iterator.
>         -: 4161:   *  @param  __last2      A forward iterator.
>         -: 4162:   *  @param  __predicate  A binary predicate.
>         -: 4163:   *  @return   The first iterator @c i in the range
>         -: 4164:   *  @p [__first1,__last1-(__last2-__first2)) such that
>         -: 4165:   *  @p __predicate(*(i+N),*(__first2+N)) is true for each @c N in the range
>         -: 4166:   *  @p [0,__last2-__first2), or @p __last1 if no such iterator exists.
>         -: 4167:   *
>         -: 4168:   *  Searches the range @p [__first1,__last1) for a sub-sequence that
>         -: 4169:   *  compares equal value-by-value with the sequence given by @p
>         -: 4170:   *  [__first2,__last2), using @p __predicate to determine equality,
>         -: 4171:   *  and returns an iterator to the first element of the
>         -: 4172:   *  sub-sequence, or @p __last1 if no such iterator exists.
>         -: 4173:   *
>         -: 4174:   *  @see search(_ForwardIter1, _ForwardIter1, _ForwardIter2, _ForwardIter2)
>         -: 4175:  */
>         -: 4176:  template<typename _ForwardIterator1, typename _ForwardIterator2,
>         -: 4177:	   typename _BinaryPredicate>
>         -: 4178:    inline _ForwardIterator1
>         -: 4179:    search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
>         -: 4180:	   _ForwardIterator2 __first2, _ForwardIterator2 __last2,
>         -: 4181:	   _BinaryPredicate  __predicate)
>         -: 4182:    {
>         -: 4183:      // concept requirements
>         -: 4184:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator1>)
>         -: 4185:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator2>)
>         -: 4186:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
>         -: 4187:	    typename iterator_traits<_ForwardIterator1>::value_type,
>         -: 4188:	    typename iterator_traits<_ForwardIterator2>::value_type>)
>         -: 4189:      __glibcxx_requires_valid_range(__first1, __last1);
>         -: 4190:      __glibcxx_requires_valid_range(__first2, __last2);
>         -: 4191:
>         -: 4192:      return std::__search(__first1, __last1, __first2, __last2,
>         -: 4193:			   __gnu_cxx::__ops::__iter_comp_iter(__predicate));
>         -: 4194:    }
>         -: 4195:
>         -: 4196:  /**
>         -: 4197:   *  @brief Search a sequence for a number of consecutive values.
>         -: 4198:   *  @ingroup non_mutating_algorithms
>         -: 4199:   *  @param  __first  A forward iterator.
>         -: 4200:   *  @param  __last   A forward iterator.
>         -: 4201:   *  @param  __count  The number of consecutive values.
>         -: 4202:   *  @param  __val    The value to find.
>         -: 4203:   *  @return The first iterator @c i in the range @p
>         -: 4204:   *  [__first,__last-__count) such that @c *(i+N) == @p __val for
>         -: 4205:   *  each @c N in the range @p [0,__count), or @p __last if no such
>         -: 4206:   *  iterator exists.
>         -: 4207:   *
>         -: 4208:   *  Searches the range @p [__first,__last) for @p count consecutive elements
>         -: 4209:   *  equal to @p __val.
>         -: 4210:  */
>         -: 4211:  template<typename _ForwardIterator, typename _Integer, typename _Tp>
>         -: 4212:    inline _ForwardIterator
>         -: 4213:    search_n(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4214:	     _Integer __count, const _Tp& __val)
>         -: 4215:    {
>         -: 4216:      // concept requirements
>         -: 4217:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 4218:      __glibcxx_function_requires(_EqualOpConcept<
>         -: 4219:	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
>         -: 4220:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4221:
>         -: 4222:      return std::__search_n(__first, __last, __count,
>         -: 4223:			     __gnu_cxx::__ops::__iter_equals_val(__val));
>         -: 4224:    }
>         -: 4225:
>         -: 4226:
>         -: 4227:  /**
>         -: 4228:   *  @brief Search a sequence for a number of consecutive values using a
>         -: 4229:   *         predicate.
>         -: 4230:   *  @ingroup non_mutating_algorithms
>         -: 4231:   *  @param  __first        A forward iterator.
>         -: 4232:   *  @param  __last         A forward iterator.
>         -: 4233:   *  @param  __count        The number of consecutive values.
>         -: 4234:   *  @param  __val          The value to find.
>         -: 4235:   *  @param  __binary_pred  A binary predicate.
>         -: 4236:   *  @return The first iterator @c i in the range @p
>         -: 4237:   *  [__first,__last-__count) such that @p
>         -: 4238:   *  __binary_pred(*(i+N),__val) is true for each @c N in the range
>         -: 4239:   *  @p [0,__count), or @p __last if no such iterator exists.
>         -: 4240:   *
>         -: 4241:   *  Searches the range @p [__first,__last) for @p __count
>         -: 4242:   *  consecutive elements for which the predicate returns true.
>         -: 4243:  */
>         -: 4244:  template<typename _ForwardIterator, typename _Integer, typename _Tp,
>         -: 4245:	   typename _BinaryPredicate>
>         -: 4246:    inline _ForwardIterator
>         -: 4247:    search_n(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4248:	     _Integer __count, const _Tp& __val,
>         -: 4249:	     _BinaryPredicate __binary_pred)
>         -: 4250:    {
>         -: 4251:      // concept requirements
>         -: 4252:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 4253:      __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,
>         -: 4254:	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
>         -: 4255:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4256:
>         -: 4257:      return std::__search_n(__first, __last, __count,
>         -: 4258:		__gnu_cxx::__ops::__iter_comp_val(__binary_pred, __val));
>         -: 4259:    }
>         -: 4260:
>         -: 4261:#if __cplusplus > 201402L
>         -: 4262:  /** @brief Search a sequence using a Searcher object.
>         -: 4263:   *
>         -: 4264:   *  @param  __first        A forward iterator.
>         -: 4265:   *  @param  __last         A forward iterator.
>         -: 4266:   *  @param  __searcher     A callable object.
>         -: 4267:   *  @return @p __searcher(__first,__last).first
>         -: 4268:  */
>         -: 4269:  template<typename _ForwardIterator, typename _Searcher>
>         -: 4270:    inline _ForwardIterator
>         -: 4271:    search(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4272:	   const _Searcher& __searcher)
>         -: 4273:    { return __searcher(__first, __last).first; }
>         -: 4274:#endif
>         -: 4275:
>         -: 4276:  /**
>         -: 4277:   *  @brief Perform an operation on a sequence.
>         -: 4278:   *  @ingroup mutating_algorithms
>         -: 4279:   *  @param  __first     An input iterator.
>         -: 4280:   *  @param  __last      An input iterator.
>         -: 4281:   *  @param  __result    An output iterator.
>         -: 4282:   *  @param  __unary_op  A unary operator.
>         -: 4283:   *  @return   An output iterator equal to @p __result+(__last-__first).
>         -: 4284:   *
>         -: 4285:   *  Applies the operator to each element in the input range and assigns
>         -: 4286:   *  the results to successive elements of the output sequence.
>         -: 4287:   *  Evaluates @p *(__result+N)=unary_op(*(__first+N)) for each @c N in the
>         -: 4288:   *  range @p [0,__last-__first).
>         -: 4289:   *
>         -: 4290:   *  @p unary_op must not alter its argument.
>         -: 4291:  */
>         -: 4292:  template<typename _InputIterator, typename _OutputIterator,
>         -: 4293:	   typename _UnaryOperation>
>         -: 4294:    _OutputIterator
>         -: 4295:    transform(_InputIterator __first, _InputIterator __last,
>         -: 4296:	      _OutputIterator __result, _UnaryOperation __unary_op)
>         -: 4297:    {
>         -: 4298:      // concept requirements
>         -: 4299:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 4300:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 4301:	    // "the type returned by a _UnaryOperation"
>         -: 4302:	    __typeof__(__unary_op(*__first))>)
>         -: 4303:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4304:
>         -: 4305:      for (; __first != __last; ++__first, (void)++__result)
>         -: 4306:	*__result = __unary_op(*__first);
>         -: 4307:      return __result;
>         -: 4308:    }
>         -: 4309:
>         -: 4310:  /**
>         -: 4311:   *  @brief Perform an operation on corresponding elements of two sequences.
>         -: 4312:   *  @ingroup mutating_algorithms
>         -: 4313:   *  @param  __first1     An input iterator.
>         -: 4314:   *  @param  __last1      An input iterator.
>         -: 4315:   *  @param  __first2     An input iterator.
>         -: 4316:   *  @param  __result     An output iterator.
>         -: 4317:   *  @param  __binary_op  A binary operator.
>         -: 4318:   *  @return   An output iterator equal to @p result+(last-first).
>         -: 4319:   *
>         -: 4320:   *  Applies the operator to the corresponding elements in the two
>         -: 4321:   *  input ranges and assigns the results to successive elements of the
>         -: 4322:   *  output sequence.
>         -: 4323:   *  Evaluates @p
>         -: 4324:   *  *(__result+N)=__binary_op(*(__first1+N),*(__first2+N)) for each
>         -: 4325:   *  @c N in the range @p [0,__last1-__first1).
>         -: 4326:   *
>         -: 4327:   *  @p binary_op must not alter either of its arguments.
>         -: 4328:  */
>         -: 4329:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 4330:	   typename _OutputIterator, typename _BinaryOperation>
>         -: 4331:    _OutputIterator
>         -: 4332:    transform(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 4333:	      _InputIterator2 __first2, _OutputIterator __result,
>         -: 4334:	      _BinaryOperation __binary_op)
>         -: 4335:    {
>         -: 4336:      // concept requirements
>         -: 4337:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 4338:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 4339:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 4340:	    // "the type returned by a _BinaryOperation"
>         -: 4341:	    __typeof__(__binary_op(*__first1,*__first2))>)
>         -: 4342:      __glibcxx_requires_valid_range(__first1, __last1);
>         -: 4343:
>         -: 4344:      for (; __first1 != __last1; ++__first1, (void)++__first2, ++__result)
>         -: 4345:	*__result = __binary_op(*__first1, *__first2);
>         -: 4346:      return __result;
>         -: 4347:    }
>         -: 4348:
>         -: 4349:  /**
>         -: 4350:   *  @brief Replace each occurrence of one value in a sequence with another
>         -: 4351:   *         value.
>         -: 4352:   *  @ingroup mutating_algorithms
>         -: 4353:   *  @param  __first      A forward iterator.
>         -: 4354:   *  @param  __last       A forward iterator.
>         -: 4355:   *  @param  __old_value  The value to be replaced.
>         -: 4356:   *  @param  __new_value  The replacement value.
>         -: 4357:   *  @return   replace() returns no value.
>         -: 4358:   *
>         -: 4359:   *  For each iterator @c i in the range @p [__first,__last) if @c *i ==
>         -: 4360:   *  @p __old_value then the assignment @c *i = @p __new_value is performed.
>         -: 4361:  */
>         -: 4362:  template<typename _ForwardIterator, typename _Tp>
>         -: 4363:    void
>         -: 4364:    replace(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4365:	    const _Tp& __old_value, const _Tp& __new_value)
>         -: 4366:    {
>         -: 4367:      // concept requirements
>         -: 4368:      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
>         -: 4369:				  _ForwardIterator>)
>         -: 4370:      __glibcxx_function_requires(_EqualOpConcept<
>         -: 4371:	    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)
>         -: 4372:      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
>         -: 4373:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4374:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4375:
>         -: 4376:      for (; __first != __last; ++__first)
>         -: 4377:	if (*__first == __old_value)
>         -: 4378:	  *__first = __new_value;
>         -: 4379:    }
>         -: 4380:
>         -: 4381:  /**
>         -: 4382:   *  @brief Replace each value in a sequence for which a predicate returns
>         -: 4383:   *         true with another value.
>         -: 4384:   *  @ingroup mutating_algorithms
>         -: 4385:   *  @param  __first      A forward iterator.
>         -: 4386:   *  @param  __last       A forward iterator.
>         -: 4387:   *  @param  __pred       A predicate.
>         -: 4388:   *  @param  __new_value  The replacement value.
>         -: 4389:   *  @return   replace_if() returns no value.
>         -: 4390:   *
>         -: 4391:   *  For each iterator @c i in the range @p [__first,__last) if @p __pred(*i)
>         -: 4392:   *  is true then the assignment @c *i = @p __new_value is performed.
>         -: 4393:  */
>         -: 4394:  template<typename _ForwardIterator, typename _Predicate, typename _Tp>
>         -: 4395:    void
>         -: 4396:    replace_if(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4397:	       _Predicate __pred, const _Tp& __new_value)
>         -: 4398:    {
>         -: 4399:      // concept requirements
>         -: 4400:      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
>         -: 4401:				  _ForwardIterator>)
>         -: 4402:      __glibcxx_function_requires(_ConvertibleConcept<_Tp,
4406,4502c4406,4502
<         -: 4404:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4405:
<         -: 4406:      for (; __first != __last; ++__first)
<         -: 4407:	if (__pred(*__first))
<         -: 4408:	  *__first = __new_value;
<         -: 4409:    }
<         -: 4410:
<         -: 4411:  /**
<         -: 4412:   *  @brief Assign the result of a function object to each value in a
<         -: 4413:   *         sequence.
<         -: 4414:   *  @ingroup mutating_algorithms
<         -: 4415:   *  @param  __first  A forward iterator.
<         -: 4416:   *  @param  __last   A forward iterator.
<         -: 4417:   *  @param  __gen    A function object taking no arguments and returning
<         -: 4418:   *                 std::iterator_traits<_ForwardIterator>::value_type
<         -: 4419:   *  @return   generate() returns no value.
<         -: 4420:   *
<         -: 4421:   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
<         -: 4422:   *  @p [__first,__last).
<         -: 4423:  */
<         -: 4424:  template<typename _ForwardIterator, typename _Generator>
<         -: 4425:    void
<     #####: 4426:    generate(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4427:	     _Generator __gen)
<         -: 4428:    {
<         -: 4429:      // concept requirements
<         -: 4430:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 4431:      __glibcxx_function_requires(_GeneratorConcept<_Generator,
<         -: 4432:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4433:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4434:
<     #####: 4435:      for (; __first != __last; ++__first)
<     #####: 4436:	*__first = __gen();
<     #####: 4437:    }
<         -: 4438:
<         -: 4439:  /**
<         -: 4440:   *  @brief Assign the result of a function object to each value in a
<         -: 4441:   *         sequence.
<         -: 4442:   *  @ingroup mutating_algorithms
<         -: 4443:   *  @param  __first  A forward iterator.
<         -: 4444:   *  @param  __n      The length of the sequence.
<         -: 4445:   *  @param  __gen    A function object taking no arguments and returning
<         -: 4446:   *                 std::iterator_traits<_ForwardIterator>::value_type
<         -: 4447:   *  @return   The end of the sequence, @p __first+__n
<         -: 4448:   *
<         -: 4449:   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
<         -: 4450:   *  @p [__first,__first+__n).
<         -: 4451:   *
<         -: 4452:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 4453:   *  DR 865. More algorithms that throw away information
<         -: 4454:  */
<         -: 4455:  template<typename _OutputIterator, typename _Size, typename _Generator>
<         -: 4456:    _OutputIterator
<         -: 4457:    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
<         -: 4458:    {
<         -: 4459:      // concept requirements
<         -: 4460:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4461:	    // "the type returned by a _Generator"
<         -: 4462:	    __typeof__(__gen())>)
<         -: 4463:
<         -: 4464:      for (__decltype(__n + 0) __niter = __n;
<         -: 4465:	   __niter > 0; --__niter, (void) ++__first)
<         -: 4466:	*__first = __gen();
<         -: 4467:      return __first;
<         -: 4468:    }
<         -: 4469:
<         -: 4470:  /**
<         -: 4471:   *  @brief Copy a sequence, removing consecutive duplicate values.
<         -: 4472:   *  @ingroup mutating_algorithms
<         -: 4473:   *  @param  __first   An input iterator.
<         -: 4474:   *  @param  __last    An input iterator.
<         -: 4475:   *  @param  __result  An output iterator.
<         -: 4476:   *  @return   An iterator designating the end of the resulting sequence.
<         -: 4477:   *
<         -: 4478:   *  Copies each element in the range @p [__first,__last) to the range
<         -: 4479:   *  beginning at @p __result, except that only the first element is copied
<         -: 4480:   *  from groups of consecutive elements that compare equal.
<         -: 4481:   *  unique_copy() is stable, so the relative order of elements that are
<         -: 4482:   *  copied is unchanged.
<         -: 4483:   *
<         -: 4484:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 4485:   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
<         -: 4486:   *  
<         -: 4487:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 4488:   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
<         -: 4489:   *  Assignable?
<         -: 4490:  */
<         -: 4491:  template<typename _InputIterator, typename _OutputIterator>
<         -: 4492:    inline _OutputIterator
<         -: 4493:    unique_copy(_InputIterator __first, _InputIterator __last,
<         -: 4494:		_OutputIterator __result)
<         -: 4495:    {
<         -: 4496:      // concept requirements
<         -: 4497:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 4498:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4499:	    typename iterator_traits<_InputIterator>::value_type>)
<         -: 4500:      __glibcxx_function_requires(_EqualityComparableConcept<
---
>         -: 4404:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
>         -: 4405:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4406:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4407:
>         -: 4408:      for (; __first != __last; ++__first)
>         -: 4409:	if (__pred(*__first))
>         -: 4410:	  *__first = __new_value;
>         -: 4411:    }
>         -: 4412:
>         -: 4413:  /**
>         -: 4414:   *  @brief Assign the result of a function object to each value in a
>         -: 4415:   *         sequence.
>         -: 4416:   *  @ingroup mutating_algorithms
>         -: 4417:   *  @param  __first  A forward iterator.
>         -: 4418:   *  @param  __last   A forward iterator.
>         -: 4419:   *  @param  __gen    A function object taking no arguments and returning
>         -: 4420:   *                 std::iterator_traits<_ForwardIterator>::value_type
>         -: 4421:   *  @return   generate() returns no value.
>         -: 4422:   *
>         -: 4423:   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
>         -: 4424:   *  @p [__first,__last).
>         -: 4425:  */
>         -: 4426:  template<typename _ForwardIterator, typename _Generator>
>         -: 4427:    void
>     #####: 4428:    generate(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4429:	     _Generator __gen)
>         -: 4430:    {
>         -: 4431:      // concept requirements
>         -: 4432:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 4433:      __glibcxx_function_requires(_GeneratorConcept<_Generator,
>         -: 4434:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4435:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4436:
>     #####: 4437:      for (; __first != __last; ++__first)
>     #####: 4438:	*__first = __gen();
>     #####: 4439:    }
>         -: 4440:
>         -: 4441:  /**
>         -: 4442:   *  @brief Assign the result of a function object to each value in a
>         -: 4443:   *         sequence.
>         -: 4444:   *  @ingroup mutating_algorithms
>         -: 4445:   *  @param  __first  A forward iterator.
>         -: 4446:   *  @param  __n      The length of the sequence.
>         -: 4447:   *  @param  __gen    A function object taking no arguments and returning
>         -: 4448:   *                 std::iterator_traits<_ForwardIterator>::value_type
>         -: 4449:   *  @return   The end of the sequence, @p __first+__n
>         -: 4450:   *
>         -: 4451:   *  Performs the assignment @c *i = @p __gen() for each @c i in the range
>         -: 4452:   *  @p [__first,__first+__n).
>         -: 4453:   *
>         -: 4454:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 4455:   *  DR 865. More algorithms that throw away information
>         -: 4456:  */
>         -: 4457:  template<typename _OutputIterator, typename _Size, typename _Generator>
>         -: 4458:    _OutputIterator
>         -: 4459:    generate_n(_OutputIterator __first, _Size __n, _Generator __gen)
>         -: 4460:    {
>         -: 4461:      // concept requirements
>         -: 4462:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 4463:	    // "the type returned by a _Generator"
>         -: 4464:	    __typeof__(__gen())>)
>         -: 4465:
>         -: 4466:      for (__decltype(__n + 0) __niter = __n;
>         -: 4467:	   __niter > 0; --__niter, ++__first)
>         -: 4468:	*__first = __gen();
>         -: 4469:      return __first;
>         -: 4470:    }
>         -: 4471:
>         -: 4472:  /**
>         -: 4473:   *  @brief Copy a sequence, removing consecutive duplicate values.
>         -: 4474:   *  @ingroup mutating_algorithms
>         -: 4475:   *  @param  __first   An input iterator.
>         -: 4476:   *  @param  __last    An input iterator.
>         -: 4477:   *  @param  __result  An output iterator.
>         -: 4478:   *  @return   An iterator designating the end of the resulting sequence.
>         -: 4479:   *
>         -: 4480:   *  Copies each element in the range @p [__first,__last) to the range
>         -: 4481:   *  beginning at @p __result, except that only the first element is copied
>         -: 4482:   *  from groups of consecutive elements that compare equal.
>         -: 4483:   *  unique_copy() is stable, so the relative order of elements that are
>         -: 4484:   *  copied is unchanged.
>         -: 4485:   *
>         -: 4486:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 4487:   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
>         -: 4488:   *  
>         -: 4489:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 4490:   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
>         -: 4491:   *  Assignable?
>         -: 4492:  */
>         -: 4493:  template<typename _InputIterator, typename _OutputIterator>
>         -: 4494:    inline _OutputIterator
>         -: 4495:    unique_copy(_InputIterator __first, _InputIterator __last,
>         -: 4496:		_OutputIterator __result)
>         -: 4497:    {
>         -: 4498:      // concept requirements
>         -: 4499:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 4500:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
4504,4926c4504,4926
<         -: 4502:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4503:
<         -: 4504:      if (__first == __last)
<         -: 4505:	return __result;
<         -: 4506:      return std::__unique_copy(__first, __last, __result,
<         -: 4507:				__gnu_cxx::__ops::__iter_equal_to_iter(),
<         -: 4508:				std::__iterator_category(__first),
<         -: 4509:				std::__iterator_category(__result));
<         -: 4510:    }
<         -: 4511:
<         -: 4512:  /**
<         -: 4513:   *  @brief Copy a sequence, removing consecutive values using a predicate.
<         -: 4514:   *  @ingroup mutating_algorithms
<         -: 4515:   *  @param  __first        An input iterator.
<         -: 4516:   *  @param  __last         An input iterator.
<         -: 4517:   *  @param  __result       An output iterator.
<         -: 4518:   *  @param  __binary_pred  A binary predicate.
<         -: 4519:   *  @return   An iterator designating the end of the resulting sequence.
<         -: 4520:   *
<         -: 4521:   *  Copies each element in the range @p [__first,__last) to the range
<         -: 4522:   *  beginning at @p __result, except that only the first element is copied
<         -: 4523:   *  from groups of consecutive elements for which @p __binary_pred returns
<         -: 4524:   *  true.
<         -: 4525:   *  unique_copy() is stable, so the relative order of elements that are
<         -: 4526:   *  copied is unchanged.
<         -: 4527:   *
<         -: 4528:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 4529:   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
<         -: 4530:  */
<         -: 4531:  template<typename _InputIterator, typename _OutputIterator,
<         -: 4532:	   typename _BinaryPredicate>
<         -: 4533:    inline _OutputIterator
<         -: 4534:    unique_copy(_InputIterator __first, _InputIterator __last,
<         -: 4535:		_OutputIterator __result,
<         -: 4536:		_BinaryPredicate __binary_pred)
<         -: 4537:    {
<         -: 4538:      // concept requirements -- predicates checked later
<         -: 4539:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
<         -: 4540:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4541:	    typename iterator_traits<_InputIterator>::value_type>)
<         -: 4542:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4543:
<         -: 4544:      if (__first == __last)
<         -: 4545:	return __result;
<         -: 4546:      return std::__unique_copy(__first, __last, __result,
<         -: 4547:			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
<         -: 4548:				std::__iterator_category(__first),
<         -: 4549:				std::__iterator_category(__result));
<         -: 4550:    }
<         -: 4551:
<         -: 4552:#if _GLIBCXX_HOSTED
<         -: 4553:  /**
<         -: 4554:   *  @brief Randomly shuffle the elements of a sequence.
<         -: 4555:   *  @ingroup mutating_algorithms
<         -: 4556:   *  @param  __first   A forward iterator.
<         -: 4557:   *  @param  __last    A forward iterator.
<         -: 4558:   *  @return  Nothing.
<         -: 4559:   *
<         -: 4560:   *  Reorder the elements in the range @p [__first,__last) using a random
<         -: 4561:   *  distribution, so that every possible ordering of the sequence is
<         -: 4562:   *  equally likely.
<         -: 4563:  */
<         -: 4564:  template<typename _RandomAccessIterator>
<         -: 4565:    inline void
<         -: 4566:    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
<         -: 4567:    {
<         -: 4568:      // concept requirements
<         -: 4569:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4570:	    _RandomAccessIterator>)
<         -: 4571:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4572:
<         -: 4573:      if (__first != __last)
<         -: 4574:	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
<         -: 4575:	  {
<         -: 4576:	    // XXX rand() % N is not uniformly distributed
<         -: 4577:	    _RandomAccessIterator __j = __first
<         -: 4578:					+ std::rand() % ((__i - __first) + 1);
<         -: 4579:	    if (__i != __j)
<         -: 4580:	      std::iter_swap(__i, __j);
<         -: 4581:	  }
<         -: 4582:    }
<         -: 4583:#endif
<         -: 4584:
<         -: 4585:  /**
<         -: 4586:   *  @brief Shuffle the elements of a sequence using a random number
<         -: 4587:   *         generator.
<         -: 4588:   *  @ingroup mutating_algorithms
<         -: 4589:   *  @param  __first   A forward iterator.
<         -: 4590:   *  @param  __last    A forward iterator.
<         -: 4591:   *  @param  __rand    The RNG functor or function.
<         -: 4592:   *  @return  Nothing.
<         -: 4593:   *
<         -: 4594:   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
<         -: 4595:   *  provide a random distribution. Calling @p __rand(N) for a positive
<         -: 4596:   *  integer @p N should return a randomly chosen integer from the
<         -: 4597:   *  range [0,N).
<         -: 4598:  */
<         -: 4599:  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
<         -: 4600:    void
<         -: 4601:    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
<         -: 4602:#if __cplusplus >= 201103L
<         -: 4603:		   _RandomNumberGenerator&& __rand)
<         -: 4604:#else
<         -: 4605:		   _RandomNumberGenerator& __rand)
<         -: 4606:#endif
<         -: 4607:    {
<         -: 4608:      // concept requirements
<         -: 4609:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4610:	    _RandomAccessIterator>)
<         -: 4611:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4612:
<         -: 4613:      if (__first == __last)
<         -: 4614:	return;
<         -: 4615:      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
<         -: 4616:	{
<         -: 4617:	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
<         -: 4618:	  if (__i != __j)
<         -: 4619:	    std::iter_swap(__i, __j);
<         -: 4620:	}
<         -: 4621:    }
<         -: 4622:
<         -: 4623:
<         -: 4624:  /**
<         -: 4625:   *  @brief Move elements for which a predicate is true to the beginning
<         -: 4626:   *         of a sequence.
<         -: 4627:   *  @ingroup mutating_algorithms
<         -: 4628:   *  @param  __first   A forward iterator.
<         -: 4629:   *  @param  __last    A forward iterator.
<         -: 4630:   *  @param  __pred    A predicate functor.
<         -: 4631:   *  @return  An iterator @p middle such that @p __pred(i) is true for each
<         -: 4632:   *  iterator @p i in the range @p [__first,middle) and false for each @p i
<         -: 4633:   *  in the range @p [middle,__last).
<         -: 4634:   *
<         -: 4635:   *  @p __pred must not modify its operand. @p partition() does not preserve
<         -: 4636:   *  the relative ordering of elements in each group, use
<         -: 4637:   *  @p stable_partition() if this is needed.
<         -: 4638:  */
<         -: 4639:  template<typename _ForwardIterator, typename _Predicate>
<         -: 4640:    inline _ForwardIterator
<         -: 4641:    partition(_ForwardIterator __first, _ForwardIterator __last,
<         -: 4642:	      _Predicate   __pred)
<         -: 4643:    {
<         -: 4644:      // concept requirements
<         -: 4645:      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
<         -: 4646:				  _ForwardIterator>)
<         -: 4647:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
<         -: 4648:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 4649:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4650:
<         -: 4651:      return std::__partition(__first, __last, __pred,
<         -: 4652:			      std::__iterator_category(__first));
<         -: 4653:    }
<         -: 4654:
<         -: 4655:
<         -: 4656:  /**
<         -: 4657:   *  @brief Sort the smallest elements of a sequence.
<         -: 4658:   *  @ingroup sorting_algorithms
<         -: 4659:   *  @param  __first   An iterator.
<         -: 4660:   *  @param  __middle  Another iterator.
<         -: 4661:   *  @param  __last    Another iterator.
<         -: 4662:   *  @return  Nothing.
<         -: 4663:   *
<         -: 4664:   *  Sorts the smallest @p (__middle-__first) elements in the range
<         -: 4665:   *  @p [first,last) and moves them to the range @p [__first,__middle). The
<         -: 4666:   *  order of the remaining elements in the range @p [__middle,__last) is
<         -: 4667:   *  undefined.
<         -: 4668:   *  After the sort if @e i and @e j are iterators in the range
<         -: 4669:   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
<         -: 4670:   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
<         -: 4671:  */
<         -: 4672:  template<typename _RandomAccessIterator>
<         -: 4673:    inline void
<         -: 4674:    partial_sort(_RandomAccessIterator __first,
<         -: 4675:		 _RandomAccessIterator __middle,
<         -: 4676:		 _RandomAccessIterator __last)
<         -: 4677:    {
<         -: 4678:      // concept requirements
<         -: 4679:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4680:	    _RandomAccessIterator>)
<         -: 4681:      __glibcxx_function_requires(_LessThanComparableConcept<
<         -: 4682:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 4683:      __glibcxx_requires_valid_range(__first, __middle);
<         -: 4684:      __glibcxx_requires_valid_range(__middle, __last);
<         -: 4685:      __glibcxx_requires_irreflexive(__first, __last);
<         -: 4686:
<         -: 4687:      std::__partial_sort(__first, __middle, __last,
<         -: 4688:			  __gnu_cxx::__ops::__iter_less_iter());
<         -: 4689:    }
<         -: 4690:
<         -: 4691:  /**
<         -: 4692:   *  @brief Sort the smallest elements of a sequence using a predicate
<         -: 4693:   *         for comparison.
<         -: 4694:   *  @ingroup sorting_algorithms
<         -: 4695:   *  @param  __first   An iterator.
<         -: 4696:   *  @param  __middle  Another iterator.
<         -: 4697:   *  @param  __last    Another iterator.
<         -: 4698:   *  @param  __comp    A comparison functor.
<         -: 4699:   *  @return  Nothing.
<         -: 4700:   *
<         -: 4701:   *  Sorts the smallest @p (__middle-__first) elements in the range
<         -: 4702:   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
<         -: 4703:   *  order of the remaining elements in the range @p [__middle,__last) is
<         -: 4704:   *  undefined.
<         -: 4705:   *  After the sort if @e i and @e j are iterators in the range
<         -: 4706:   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
<         -: 4707:   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
<         -: 4708:   *  are both false.
<         -: 4709:  */
<         -: 4710:  template<typename _RandomAccessIterator, typename _Compare>
<         -: 4711:    inline void
<         -: 4712:    partial_sort(_RandomAccessIterator __first,
<         -: 4713:		 _RandomAccessIterator __middle,
<         -: 4714:		 _RandomAccessIterator __last,
<         -: 4715:		 _Compare __comp)
<         -: 4716:    {
<         -: 4717:      // concept requirements
<         -: 4718:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4719:	    _RandomAccessIterator>)
<         -: 4720:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 4721:	    typename iterator_traits<_RandomAccessIterator>::value_type,
<         -: 4722:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 4723:      __glibcxx_requires_valid_range(__first, __middle);
<         -: 4724:      __glibcxx_requires_valid_range(__middle, __last);
<         -: 4725:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
<         -: 4726:
<         -: 4727:      std::__partial_sort(__first, __middle, __last,
<         -: 4728:			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 4729:    }
<         -: 4730:
<         -: 4731:  /**
<         -: 4732:   *  @brief Sort a sequence just enough to find a particular position.
<         -: 4733:   *  @ingroup sorting_algorithms
<         -: 4734:   *  @param  __first   An iterator.
<         -: 4735:   *  @param  __nth     Another iterator.
<         -: 4736:   *  @param  __last    Another iterator.
<         -: 4737:   *  @return  Nothing.
<         -: 4738:   *
<         -: 4739:   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
<         -: 4740:   *  is the same element that would have been in that position had the
<         -: 4741:   *  whole sequence been sorted. The elements either side of @p *__nth are
<         -: 4742:   *  not completely sorted, but for any iterator @e i in the range
<         -: 4743:   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
<         -: 4744:   *  holds that *j < *i is false.
<         -: 4745:  */
<         -: 4746:  template<typename _RandomAccessIterator>
<         -: 4747:    inline void
<         -: 4748:    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
<         -: 4749:		_RandomAccessIterator __last)
<         -: 4750:    {
<         -: 4751:      // concept requirements
<         -: 4752:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4753:				  _RandomAccessIterator>)
<         -: 4754:      __glibcxx_function_requires(_LessThanComparableConcept<
<         -: 4755:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 4756:      __glibcxx_requires_valid_range(__first, __nth);
<         -: 4757:      __glibcxx_requires_valid_range(__nth, __last);
<         -: 4758:      __glibcxx_requires_irreflexive(__first, __last);
<         -: 4759:
<         -: 4760:      if (__first == __last || __nth == __last)
<         -: 4761:	return;
<         -: 4762:
<         -: 4763:      std::__introselect(__first, __nth, __last,
<         -: 4764:			 std::__lg(__last - __first) * 2,
<         -: 4765:			 __gnu_cxx::__ops::__iter_less_iter());
<         -: 4766:    }
<         -: 4767:
<         -: 4768:  /**
<         -: 4769:   *  @brief Sort a sequence just enough to find a particular position
<         -: 4770:   *         using a predicate for comparison.
<         -: 4771:   *  @ingroup sorting_algorithms
<         -: 4772:   *  @param  __first   An iterator.
<         -: 4773:   *  @param  __nth     Another iterator.
<         -: 4774:   *  @param  __last    Another iterator.
<         -: 4775:   *  @param  __comp    A comparison functor.
<         -: 4776:   *  @return  Nothing.
<         -: 4777:   *
<         -: 4778:   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
<         -: 4779:   *  is the same element that would have been in that position had the
<         -: 4780:   *  whole sequence been sorted. The elements either side of @p *__nth are
<         -: 4781:   *  not completely sorted, but for any iterator @e i in the range
<         -: 4782:   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
<         -: 4783:   *  holds that @p __comp(*j,*i) is false.
<         -: 4784:  */
<         -: 4785:  template<typename _RandomAccessIterator, typename _Compare>
<         -: 4786:    inline void
<         -: 4787:    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
<         -: 4788:		_RandomAccessIterator __last, _Compare __comp)
<         -: 4789:    {
<         -: 4790:      // concept requirements
<         -: 4791:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4792:				  _RandomAccessIterator>)
<         -: 4793:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 4794:	    typename iterator_traits<_RandomAccessIterator>::value_type,
<         -: 4795:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 4796:      __glibcxx_requires_valid_range(__first, __nth);
<         -: 4797:      __glibcxx_requires_valid_range(__nth, __last);
<         -: 4798:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
<         -: 4799:
<         -: 4800:      if (__first == __last || __nth == __last)
<         -: 4801:	return;
<         -: 4802:
<         -: 4803:      std::__introselect(__first, __nth, __last,
<         -: 4804:			 std::__lg(__last - __first) * 2,
<         -: 4805:			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 4806:    }
<         -: 4807:
<         -: 4808:  /**
<         -: 4809:   *  @brief Sort the elements of a sequence.
<         -: 4810:   *  @ingroup sorting_algorithms
<         -: 4811:   *  @param  __first   An iterator.
<         -: 4812:   *  @param  __last    Another iterator.
<         -: 4813:   *  @return  Nothing.
<         -: 4814:   *
<         -: 4815:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
<         -: 4816:   *  such that for each iterator @e i in the range @p [__first,__last-1),  
<         -: 4817:   *  *(i+1)<*i is false.
<         -: 4818:   *
<         -: 4819:   *  The relative ordering of equivalent elements is not preserved, use
<         -: 4820:   *  @p stable_sort() if this is needed.
<         -: 4821:  */
<         -: 4822:  template<typename _RandomAccessIterator>
<         -: 4823:    inline void
<         -: 4824:    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
<         -: 4825:    {
<         -: 4826:      // concept requirements
<         -: 4827:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4828:	    _RandomAccessIterator>)
<         -: 4829:      __glibcxx_function_requires(_LessThanComparableConcept<
<         -: 4830:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 4831:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4832:      __glibcxx_requires_irreflexive(__first, __last);
<         -: 4833:
<         -: 4834:      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
<         -: 4835:    }
<         -: 4836:
<         -: 4837:  /**
<         -: 4838:   *  @brief Sort the elements of a sequence using a predicate for comparison.
<         -: 4839:   *  @ingroup sorting_algorithms
<         -: 4840:   *  @param  __first   An iterator.
<         -: 4841:   *  @param  __last    Another iterator.
<         -: 4842:   *  @param  __comp    A comparison functor.
<         -: 4843:   *  @return  Nothing.
<         -: 4844:   *
<         -: 4845:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
<         -: 4846:   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
<         -: 4847:   *  range @p [__first,__last-1).
<         -: 4848:   *
<         -: 4849:   *  The relative ordering of equivalent elements is not preserved, use
<         -: 4850:   *  @p stable_sort() if this is needed.
<         -: 4851:  */
<         -: 4852:  template<typename _RandomAccessIterator, typename _Compare>
<         -: 4853:    inline void
<         -: 4854:    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
<         -: 4855:	 _Compare __comp)
<         -: 4856:    {
<         -: 4857:      // concept requirements
<         -: 4858:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 4859:	    _RandomAccessIterator>)
<         -: 4860:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 4861:	    typename iterator_traits<_RandomAccessIterator>::value_type,
<         -: 4862:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 4863:      __glibcxx_requires_valid_range(__first, __last);
<         -: 4864:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
<         -: 4865:
<         -: 4866:      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 4867:    }
<         -: 4868:
<         -: 4869:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 4870:	   typename _OutputIterator, typename _Compare>
<         -: 4871:    _OutputIterator
<         -: 4872:    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 4873:	    _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 4874:	    _OutputIterator __result, _Compare __comp)
<         -: 4875:    {
<         -: 4876:      while (__first1 != __last1 && __first2 != __last2)
<         -: 4877:	{
<         -: 4878:	  if (__comp(__first2, __first1))
<         -: 4879:	    {
<         -: 4880:	      *__result = *__first2;
<         -: 4881:	      ++__first2;
<         -: 4882:	    }
<         -: 4883:	  else
<         -: 4884:	    {
<         -: 4885:	      *__result = *__first1;
<         -: 4886:	      ++__first1;
<         -: 4887:	    }
<         -: 4888:	  ++__result;
<         -: 4889:	}
<         -: 4890:      return std::copy(__first2, __last2,
<         -: 4891:		       std::copy(__first1, __last1, __result));
<         -: 4892:    }
<         -: 4893:
<         -: 4894:  /**
<         -: 4895:   *  @brief Merges two sorted ranges.
<         -: 4896:   *  @ingroup sorting_algorithms
<         -: 4897:   *  @param  __first1  An iterator.
<         -: 4898:   *  @param  __first2  Another iterator.
<         -: 4899:   *  @param  __last1   Another iterator.
<         -: 4900:   *  @param  __last2   Another iterator.
<         -: 4901:   *  @param  __result  An iterator pointing to the end of the merged range.
<         -: 4902:   *  @return         An iterator pointing to the first element <em>not less
<         -: 4903:   *                  than</em> @e val.
<         -: 4904:   *
<         -: 4905:   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
<         -: 4906:   *  the sorted range @p [__result, __result + (__last1-__first1) +
<         -: 4907:   *  (__last2-__first2)).  Both input ranges must be sorted, and the
<         -: 4908:   *  output range must not overlap with either of the input ranges.
<         -: 4909:   *  The sort is @e stable, that is, for equivalent elements in the
<         -: 4910:   *  two ranges, elements from the first range will always come
<         -: 4911:   *  before elements from the second.
<         -: 4912:  */
<         -: 4913:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 4914:	   typename _OutputIterator>
<         -: 4915:    inline _OutputIterator
<         -: 4916:    merge(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 4917:	  _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 4918:	  _OutputIterator __result)
<         -: 4919:    {
<         -: 4920:      // concept requirements
<         -: 4921:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 4922:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 4923:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4924:	    typename iterator_traits<_InputIterator1>::value_type>)
---
>         -: 4502:      __glibcxx_function_requires(_EqualityComparableConcept<
>         -: 4503:	    typename iterator_traits<_InputIterator>::value_type>)
>         -: 4504:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4505:
>         -: 4506:      if (__first == __last)
>         -: 4507:	return __result;
>         -: 4508:      return std::__unique_copy(__first, __last, __result,
>         -: 4509:				__gnu_cxx::__ops::__iter_equal_to_iter(),
>         -: 4510:				std::__iterator_category(__first),
>         -: 4511:				std::__iterator_category(__result));
>         -: 4512:    }
>         -: 4513:
>         -: 4514:  /**
>         -: 4515:   *  @brief Copy a sequence, removing consecutive values using a predicate.
>         -: 4516:   *  @ingroup mutating_algorithms
>         -: 4517:   *  @param  __first        An input iterator.
>         -: 4518:   *  @param  __last         An input iterator.
>         -: 4519:   *  @param  __result       An output iterator.
>         -: 4520:   *  @param  __binary_pred  A binary predicate.
>         -: 4521:   *  @return   An iterator designating the end of the resulting sequence.
>         -: 4522:   *
>         -: 4523:   *  Copies each element in the range @p [__first,__last) to the range
>         -: 4524:   *  beginning at @p __result, except that only the first element is copied
>         -: 4525:   *  from groups of consecutive elements for which @p __binary_pred returns
>         -: 4526:   *  true.
>         -: 4527:   *  unique_copy() is stable, so the relative order of elements that are
>         -: 4528:   *  copied is unchanged.
>         -: 4529:   *
>         -: 4530:   *  _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 4531:   *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
>         -: 4532:  */
>         -: 4533:  template<typename _InputIterator, typename _OutputIterator,
>         -: 4534:	   typename _BinaryPredicate>
>         -: 4535:    inline _OutputIterator
>         -: 4536:    unique_copy(_InputIterator __first, _InputIterator __last,
>         -: 4537:		_OutputIterator __result,
>         -: 4538:		_BinaryPredicate __binary_pred)
>         -: 4539:    {
>         -: 4540:      // concept requirements -- predicates checked later
>         -: 4541:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
>         -: 4542:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 4543:	    typename iterator_traits<_InputIterator>::value_type>)
>         -: 4544:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4545:
>         -: 4546:      if (__first == __last)
>         -: 4547:	return __result;
>         -: 4548:      return std::__unique_copy(__first, __last, __result,
>         -: 4549:			__gnu_cxx::__ops::__iter_comp_iter(__binary_pred),
>         -: 4550:				std::__iterator_category(__first),
>         -: 4551:				std::__iterator_category(__result));
>         -: 4552:    }
>         -: 4553:
>         -: 4554:#if _GLIBCXX_HOSTED
>         -: 4555:  /**
>         -: 4556:   *  @brief Randomly shuffle the elements of a sequence.
>         -: 4557:   *  @ingroup mutating_algorithms
>         -: 4558:   *  @param  __first   A forward iterator.
>         -: 4559:   *  @param  __last    A forward iterator.
>         -: 4560:   *  @return  Nothing.
>         -: 4561:   *
>         -: 4562:   *  Reorder the elements in the range @p [__first,__last) using a random
>         -: 4563:   *  distribution, so that every possible ordering of the sequence is
>         -: 4564:   *  equally likely.
>         -: 4565:  */
>         -: 4566:  template<typename _RandomAccessIterator>
>         -: 4567:    inline void
>         -: 4568:    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)
>         -: 4569:    {
>         -: 4570:      // concept requirements
>         -: 4571:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4572:	    _RandomAccessIterator>)
>         -: 4573:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4574:
>         -: 4575:      if (__first != __last)
>         -: 4576:	for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
>         -: 4577:	  {
>         -: 4578:	    // XXX rand() % N is not uniformly distributed
>         -: 4579:	    _RandomAccessIterator __j = __first
>         -: 4580:					+ std::rand() % ((__i - __first) + 1);
>         -: 4581:	    if (__i != __j)
>         -: 4582:	      std::iter_swap(__i, __j);
>         -: 4583:	  }
>         -: 4584:    }
>         -: 4585:#endif
>         -: 4586:
>         -: 4587:  /**
>         -: 4588:   *  @brief Shuffle the elements of a sequence using a random number
>         -: 4589:   *         generator.
>         -: 4590:   *  @ingroup mutating_algorithms
>         -: 4591:   *  @param  __first   A forward iterator.
>         -: 4592:   *  @param  __last    A forward iterator.
>         -: 4593:   *  @param  __rand    The RNG functor or function.
>         -: 4594:   *  @return  Nothing.
>         -: 4595:   *
>         -: 4596:   *  Reorders the elements in the range @p [__first,__last) using @p __rand to
>         -: 4597:   *  provide a random distribution. Calling @p __rand(N) for a positive
>         -: 4598:   *  integer @p N should return a randomly chosen integer from the
>         -: 4599:   *  range [0,N).
>         -: 4600:  */
>         -: 4601:  template<typename _RandomAccessIterator, typename _RandomNumberGenerator>
>         -: 4602:    void
>         -: 4603:    random_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,
>         -: 4604:#if __cplusplus >= 201103L
>         -: 4605:		   _RandomNumberGenerator&& __rand)
>         -: 4606:#else
>         -: 4607:		   _RandomNumberGenerator& __rand)
>         -: 4608:#endif
>         -: 4609:    {
>         -: 4610:      // concept requirements
>         -: 4611:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4612:	    _RandomAccessIterator>)
>         -: 4613:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4614:
>         -: 4615:      if (__first == __last)
>         -: 4616:	return;
>         -: 4617:      for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)
>         -: 4618:	{
>         -: 4619:	  _RandomAccessIterator __j = __first + __rand((__i - __first) + 1);
>         -: 4620:	  if (__i != __j)
>         -: 4621:	    std::iter_swap(__i, __j);
>         -: 4622:	}
>         -: 4623:    }
>         -: 4624:
>         -: 4625:
>         -: 4626:  /**
>         -: 4627:   *  @brief Move elements for which a predicate is true to the beginning
>         -: 4628:   *         of a sequence.
>         -: 4629:   *  @ingroup mutating_algorithms
>         -: 4630:   *  @param  __first   A forward iterator.
>         -: 4631:   *  @param  __last    A forward iterator.
>         -: 4632:   *  @param  __pred    A predicate functor.
>         -: 4633:   *  @return  An iterator @p middle such that @p __pred(i) is true for each
>         -: 4634:   *  iterator @p i in the range @p [__first,middle) and false for each @p i
>         -: 4635:   *  in the range @p [middle,__last).
>         -: 4636:   *
>         -: 4637:   *  @p __pred must not modify its operand. @p partition() does not preserve
>         -: 4638:   *  the relative ordering of elements in each group, use
>         -: 4639:   *  @p stable_partition() if this is needed.
>         -: 4640:  */
>         -: 4641:  template<typename _ForwardIterator, typename _Predicate>
>         -: 4642:    inline _ForwardIterator
>         -: 4643:    partition(_ForwardIterator __first, _ForwardIterator __last,
>         -: 4644:	      _Predicate   __pred)
>         -: 4645:    {
>         -: 4646:      // concept requirements
>         -: 4647:      __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<
>         -: 4648:				  _ForwardIterator>)
>         -: 4649:      __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
>         -: 4650:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 4651:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4652:
>         -: 4653:      return std::__partition(__first, __last, __pred,
>         -: 4654:			      std::__iterator_category(__first));
>         -: 4655:    }
>         -: 4656:
>         -: 4657:
>         -: 4658:  /**
>         -: 4659:   *  @brief Sort the smallest elements of a sequence.
>         -: 4660:   *  @ingroup sorting_algorithms
>         -: 4661:   *  @param  __first   An iterator.
>         -: 4662:   *  @param  __middle  Another iterator.
>         -: 4663:   *  @param  __last    Another iterator.
>         -: 4664:   *  @return  Nothing.
>         -: 4665:   *
>         -: 4666:   *  Sorts the smallest @p (__middle-__first) elements in the range
>         -: 4667:   *  @p [first,last) and moves them to the range @p [__first,__middle). The
>         -: 4668:   *  order of the remaining elements in the range @p [__middle,__last) is
>         -: 4669:   *  undefined.
>         -: 4670:   *  After the sort if @e i and @e j are iterators in the range
>         -: 4671:   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
>         -: 4672:   *  the range @p [__middle,__last) then *j<*i and *k<*i are both false.
>         -: 4673:  */
>         -: 4674:  template<typename _RandomAccessIterator>
>         -: 4675:    inline void
>         -: 4676:    partial_sort(_RandomAccessIterator __first,
>         -: 4677:		 _RandomAccessIterator __middle,
>         -: 4678:		 _RandomAccessIterator __last)
>         -: 4679:    {
>         -: 4680:      // concept requirements
>         -: 4681:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4682:	    _RandomAccessIterator>)
>         -: 4683:      __glibcxx_function_requires(_LessThanComparableConcept<
>         -: 4684:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 4685:      __glibcxx_requires_valid_range(__first, __middle);
>         -: 4686:      __glibcxx_requires_valid_range(__middle, __last);
>         -: 4687:      __glibcxx_requires_irreflexive(__first, __last);
>         -: 4688:
>         -: 4689:      std::__partial_sort(__first, __middle, __last,
>         -: 4690:			  __gnu_cxx::__ops::__iter_less_iter());
>         -: 4691:    }
>         -: 4692:
>         -: 4693:  /**
>         -: 4694:   *  @brief Sort the smallest elements of a sequence using a predicate
>         -: 4695:   *         for comparison.
>         -: 4696:   *  @ingroup sorting_algorithms
>         -: 4697:   *  @param  __first   An iterator.
>         -: 4698:   *  @param  __middle  Another iterator.
>         -: 4699:   *  @param  __last    Another iterator.
>         -: 4700:   *  @param  __comp    A comparison functor.
>         -: 4701:   *  @return  Nothing.
>         -: 4702:   *
>         -: 4703:   *  Sorts the smallest @p (__middle-__first) elements in the range
>         -: 4704:   *  @p [__first,__last) and moves them to the range @p [__first,__middle). The
>         -: 4705:   *  order of the remaining elements in the range @p [__middle,__last) is
>         -: 4706:   *  undefined.
>         -: 4707:   *  After the sort if @e i and @e j are iterators in the range
>         -: 4708:   *  @p [__first,__middle) such that i precedes j and @e k is an iterator in
>         -: 4709:   *  the range @p [__middle,__last) then @p *__comp(j,*i) and @p __comp(*k,*i)
>         -: 4710:   *  are both false.
>         -: 4711:  */
>         -: 4712:  template<typename _RandomAccessIterator, typename _Compare>
>         -: 4713:    inline void
>         -: 4714:    partial_sort(_RandomAccessIterator __first,
>         -: 4715:		 _RandomAccessIterator __middle,
>         -: 4716:		 _RandomAccessIterator __last,
>         -: 4717:		 _Compare __comp)
>         -: 4718:    {
>         -: 4719:      // concept requirements
>         -: 4720:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4721:	    _RandomAccessIterator>)
>         -: 4722:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 4723:	    typename iterator_traits<_RandomAccessIterator>::value_type,
>         -: 4724:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 4725:      __glibcxx_requires_valid_range(__first, __middle);
>         -: 4726:      __glibcxx_requires_valid_range(__middle, __last);
>         -: 4727:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
>         -: 4728:
>         -: 4729:      std::__partial_sort(__first, __middle, __last,
>         -: 4730:			  __gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 4731:    }
>         -: 4732:
>         -: 4733:  /**
>         -: 4734:   *  @brief Sort a sequence just enough to find a particular position.
>         -: 4735:   *  @ingroup sorting_algorithms
>         -: 4736:   *  @param  __first   An iterator.
>         -: 4737:   *  @param  __nth     Another iterator.
>         -: 4738:   *  @param  __last    Another iterator.
>         -: 4739:   *  @return  Nothing.
>         -: 4740:   *
>         -: 4741:   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
>         -: 4742:   *  is the same element that would have been in that position had the
>         -: 4743:   *  whole sequence been sorted. The elements either side of @p *__nth are
>         -: 4744:   *  not completely sorted, but for any iterator @e i in the range
>         -: 4745:   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
>         -: 4746:   *  holds that *j < *i is false.
>         -: 4747:  */
>         -: 4748:  template<typename _RandomAccessIterator>
>         -: 4749:    inline void
>         -: 4750:    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
>         -: 4751:		_RandomAccessIterator __last)
>         -: 4752:    {
>         -: 4753:      // concept requirements
>         -: 4754:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4755:				  _RandomAccessIterator>)
>         -: 4756:      __glibcxx_function_requires(_LessThanComparableConcept<
>         -: 4757:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 4758:      __glibcxx_requires_valid_range(__first, __nth);
>         -: 4759:      __glibcxx_requires_valid_range(__nth, __last);
>         -: 4760:      __glibcxx_requires_irreflexive(__first, __last);
>         -: 4761:
>         -: 4762:      if (__first == __last || __nth == __last)
>         -: 4763:	return;
>         -: 4764:
>         -: 4765:      std::__introselect(__first, __nth, __last,
>         -: 4766:			 std::__lg(__last - __first) * 2,
>         -: 4767:			 __gnu_cxx::__ops::__iter_less_iter());
>         -: 4768:    }
>         -: 4769:
>         -: 4770:  /**
>         -: 4771:   *  @brief Sort a sequence just enough to find a particular position
>         -: 4772:   *         using a predicate for comparison.
>         -: 4773:   *  @ingroup sorting_algorithms
>         -: 4774:   *  @param  __first   An iterator.
>         -: 4775:   *  @param  __nth     Another iterator.
>         -: 4776:   *  @param  __last    Another iterator.
>         -: 4777:   *  @param  __comp    A comparison functor.
>         -: 4778:   *  @return  Nothing.
>         -: 4779:   *
>         -: 4780:   *  Rearranges the elements in the range @p [__first,__last) so that @p *__nth
>         -: 4781:   *  is the same element that would have been in that position had the
>         -: 4782:   *  whole sequence been sorted. The elements either side of @p *__nth are
>         -: 4783:   *  not completely sorted, but for any iterator @e i in the range
>         -: 4784:   *  @p [__first,__nth) and any iterator @e j in the range @p [__nth,__last) it
>         -: 4785:   *  holds that @p __comp(*j,*i) is false.
>         -: 4786:  */
>         -: 4787:  template<typename _RandomAccessIterator, typename _Compare>
>         -: 4788:    inline void
>         -: 4789:    nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth,
>         -: 4790:		_RandomAccessIterator __last, _Compare __comp)
>         -: 4791:    {
>         -: 4792:      // concept requirements
>         -: 4793:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4794:				  _RandomAccessIterator>)
>         -: 4795:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 4796:	    typename iterator_traits<_RandomAccessIterator>::value_type,
>         -: 4797:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 4798:      __glibcxx_requires_valid_range(__first, __nth);
>         -: 4799:      __glibcxx_requires_valid_range(__nth, __last);
>         -: 4800:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
>         -: 4801:
>         -: 4802:      if (__first == __last || __nth == __last)
>         -: 4803:	return;
>         -: 4804:
>         -: 4805:      std::__introselect(__first, __nth, __last,
>         -: 4806:			 std::__lg(__last - __first) * 2,
>         -: 4807:			 __gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 4808:    }
>         -: 4809:
>         -: 4810:  /**
>         -: 4811:   *  @brief Sort the elements of a sequence.
>         -: 4812:   *  @ingroup sorting_algorithms
>         -: 4813:   *  @param  __first   An iterator.
>         -: 4814:   *  @param  __last    Another iterator.
>         -: 4815:   *  @return  Nothing.
>         -: 4816:   *
>         -: 4817:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
>         -: 4818:   *  such that for each iterator @e i in the range @p [__first,__last-1),  
>         -: 4819:   *  *(i+1)<*i is false.
>         -: 4820:   *
>         -: 4821:   *  The relative ordering of equivalent elements is not preserved, use
>         -: 4822:   *  @p stable_sort() if this is needed.
>         -: 4823:  */
>         -: 4824:  template<typename _RandomAccessIterator>
>         -: 4825:    inline void
>         -: 4826:    sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
>         -: 4827:    {
>         -: 4828:      // concept requirements
>         -: 4829:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4830:	    _RandomAccessIterator>)
>         -: 4831:      __glibcxx_function_requires(_LessThanComparableConcept<
>         -: 4832:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 4833:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4834:      __glibcxx_requires_irreflexive(__first, __last);
>         -: 4835:
>         -: 4836:      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_less_iter());
>         -: 4837:    }
>         -: 4838:
>         -: 4839:  /**
>         -: 4840:   *  @brief Sort the elements of a sequence using a predicate for comparison.
>         -: 4841:   *  @ingroup sorting_algorithms
>         -: 4842:   *  @param  __first   An iterator.
>         -: 4843:   *  @param  __last    Another iterator.
>         -: 4844:   *  @param  __comp    A comparison functor.
>         -: 4845:   *  @return  Nothing.
>         -: 4846:   *
>         -: 4847:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
>         -: 4848:   *  such that @p __comp(*(i+1),*i) is false for every iterator @e i in the
>         -: 4849:   *  range @p [__first,__last-1).
>         -: 4850:   *
>         -: 4851:   *  The relative ordering of equivalent elements is not preserved, use
>         -: 4852:   *  @p stable_sort() if this is needed.
>         -: 4853:  */
>         -: 4854:  template<typename _RandomAccessIterator, typename _Compare>
>         -: 4855:    inline void
>         -: 4856:    sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
>         -: 4857:	 _Compare __comp)
>         -: 4858:    {
>         -: 4859:      // concept requirements
>         -: 4860:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 4861:	    _RandomAccessIterator>)
>         -: 4862:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 4863:	    typename iterator_traits<_RandomAccessIterator>::value_type,
>         -: 4864:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 4865:      __glibcxx_requires_valid_range(__first, __last);
>         -: 4866:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
>         -: 4867:
>         -: 4868:      std::__sort(__first, __last, __gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 4869:    }
>         -: 4870:
>         -: 4871:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 4872:	   typename _OutputIterator, typename _Compare>
>         -: 4873:    _OutputIterator
>         -: 4874:    __merge(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 4875:	    _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 4876:	    _OutputIterator __result, _Compare __comp)
>         -: 4877:    {
>         -: 4878:      while (__first1 != __last1 && __first2 != __last2)
>         -: 4879:	{
>         -: 4880:	  if (__comp(__first2, __first1))
>         -: 4881:	    {
>         -: 4882:	      *__result = *__first2;
>         -: 4883:	      ++__first2;
>         -: 4884:	    }
>         -: 4885:	  else
>         -: 4886:	    {
>         -: 4887:	      *__result = *__first1;
>         -: 4888:	      ++__first1;
>         -: 4889:	    }
>         -: 4890:	  ++__result;
>         -: 4891:	}
>         -: 4892:      return std::copy(__first2, __last2,
>         -: 4893:		       std::copy(__first1, __last1, __result));
>         -: 4894:    }
>         -: 4895:
>         -: 4896:  /**
>         -: 4897:   *  @brief Merges two sorted ranges.
>         -: 4898:   *  @ingroup sorting_algorithms
>         -: 4899:   *  @param  __first1  An iterator.
>         -: 4900:   *  @param  __first2  Another iterator.
>         -: 4901:   *  @param  __last1   Another iterator.
>         -: 4902:   *  @param  __last2   Another iterator.
>         -: 4903:   *  @param  __result  An iterator pointing to the end of the merged range.
>         -: 4904:   *  @return         An iterator pointing to the first element <em>not less
>         -: 4905:   *                  than</em> @e val.
>         -: 4906:   *
>         -: 4907:   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
>         -: 4908:   *  the sorted range @p [__result, __result + (__last1-__first1) +
>         -: 4909:   *  (__last2-__first2)).  Both input ranges must be sorted, and the
>         -: 4910:   *  output range must not overlap with either of the input ranges.
>         -: 4911:   *  The sort is @e stable, that is, for equivalent elements in the
>         -: 4912:   *  two ranges, elements from the first range will always come
>         -: 4913:   *  before elements from the second.
>         -: 4914:  */
>         -: 4915:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 4916:	   typename _OutputIterator>
>         -: 4917:    inline _OutputIterator
>         -: 4918:    merge(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 4919:	  _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 4920:	  _OutputIterator __result)
>         -: 4921:    {
>         -: 4922:      // concept requirements
>         -: 4923:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 4924:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
4928,4976c4928,4976
<         -: 4926:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 4927:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 4928:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 4929:	    typename iterator_traits<_InputIterator1>::value_type>)	
<         -: 4930:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
<         -: 4931:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
<         -: 4932:      __glibcxx_requires_irreflexive2(__first1, __last1);
<         -: 4933:      __glibcxx_requires_irreflexive2(__first2, __last2);
<         -: 4934:
<         -: 4935:      return _GLIBCXX_STD_A::__merge(__first1, __last1,
<         -: 4936:				     __first2, __last2, __result,
<         -: 4937:				     __gnu_cxx::__ops::__iter_less_iter());
<         -: 4938:    }
<         -: 4939:
<         -: 4940:  /**
<         -: 4941:   *  @brief Merges two sorted ranges.
<         -: 4942:   *  @ingroup sorting_algorithms
<         -: 4943:   *  @param  __first1  An iterator.
<         -: 4944:   *  @param  __first2  Another iterator.
<         -: 4945:   *  @param  __last1   Another iterator.
<         -: 4946:   *  @param  __last2   Another iterator.
<         -: 4947:   *  @param  __result  An iterator pointing to the end of the merged range.
<         -: 4948:   *  @param  __comp    A functor to use for comparisons.
<         -: 4949:   *  @return         An iterator pointing to the first element "not less
<         -: 4950:   *                  than" @e val.
<         -: 4951:   *
<         -: 4952:   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
<         -: 4953:   *  the sorted range @p [__result, __result + (__last1-__first1) +
<         -: 4954:   *  (__last2-__first2)).  Both input ranges must be sorted, and the
<         -: 4955:   *  output range must not overlap with either of the input ranges.
<         -: 4956:   *  The sort is @e stable, that is, for equivalent elements in the
<         -: 4957:   *  two ranges, elements from the first range will always come
<         -: 4958:   *  before elements from the second.
<         -: 4959:   *
<         -: 4960:   *  The comparison function should have the same effects on ordering as
<         -: 4961:   *  the function used for the initial sort.
<         -: 4962:  */
<         -: 4963:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 4964:	   typename _OutputIterator, typename _Compare>
<         -: 4965:    inline _OutputIterator
<         -: 4966:    merge(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 4967:	  _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 4968:	  _OutputIterator __result, _Compare __comp)
<         -: 4969:    {
<         -: 4970:      // concept requirements
<         -: 4971:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 4972:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 4973:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 4974:	    typename iterator_traits<_InputIterator1>::value_type>)
---
>         -: 4926:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 4927:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 4928:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 4929:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 4930:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 4931:	    typename iterator_traits<_InputIterator1>::value_type>)	
>         -: 4932:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>         -: 4933:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>         -: 4934:      __glibcxx_requires_irreflexive2(__first1, __last1);
>         -: 4935:      __glibcxx_requires_irreflexive2(__first2, __last2);
>         -: 4936:
>         -: 4937:      return _GLIBCXX_STD_A::__merge(__first1, __last1,
>         -: 4938:				     __first2, __last2, __result,
>         -: 4939:				     __gnu_cxx::__ops::__iter_less_iter());
>         -: 4940:    }
>         -: 4941:
>         -: 4942:  /**
>         -: 4943:   *  @brief Merges two sorted ranges.
>         -: 4944:   *  @ingroup sorting_algorithms
>         -: 4945:   *  @param  __first1  An iterator.
>         -: 4946:   *  @param  __first2  Another iterator.
>         -: 4947:   *  @param  __last1   Another iterator.
>         -: 4948:   *  @param  __last2   Another iterator.
>         -: 4949:   *  @param  __result  An iterator pointing to the end of the merged range.
>         -: 4950:   *  @param  __comp    A functor to use for comparisons.
>         -: 4951:   *  @return         An iterator pointing to the first element "not less
>         -: 4952:   *                  than" @e val.
>         -: 4953:   *
>         -: 4954:   *  Merges the ranges @p [__first1,__last1) and @p [__first2,__last2) into
>         -: 4955:   *  the sorted range @p [__result, __result + (__last1-__first1) +
>         -: 4956:   *  (__last2-__first2)).  Both input ranges must be sorted, and the
>         -: 4957:   *  output range must not overlap with either of the input ranges.
>         -: 4958:   *  The sort is @e stable, that is, for equivalent elements in the
>         -: 4959:   *  two ranges, elements from the first range will always come
>         -: 4960:   *  before elements from the second.
>         -: 4961:   *
>         -: 4962:   *  The comparison function should have the same effects on ordering as
>         -: 4963:   *  the function used for the initial sort.
>         -: 4964:  */
>         -: 4965:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 4966:	   typename _OutputIterator, typename _Compare>
>         -: 4967:    inline _OutputIterator
>         -: 4968:    merge(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 4969:	  _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 4970:	  _OutputIterator __result, _Compare __comp)
>         -: 4971:    {
>         -: 4972:      // concept requirements
>         -: 4973:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 4974:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
4978,5169c4978,5169
<         -: 4976:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 4977:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 4978:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 4979:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 4980:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
<         -: 4981:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
<         -: 4982:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
<         -: 4983:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
<         -: 4984:
<         -: 4985:      return _GLIBCXX_STD_A::__merge(__first1, __last1,
<         -: 4986:				__first2, __last2, __result,
<         -: 4987:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 4988:    }
<         -: 4989:
<         -: 4990:  template<typename _RandomAccessIterator, typename _Compare>
<         -: 4991:    inline void
<         -: 4992:    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
<         -: 4993:		  _Compare __comp)
<         -: 4994:    {
<         -: 4995:      typedef typename iterator_traits<_RandomAccessIterator>::value_type
<         -: 4996:	_ValueType;
<         -: 4997:      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
<         -: 4998:	_DistanceType;
<         -: 4999:
<         -: 5000:      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
<         -: 5001:      _TmpBuf __buf(__first, __last);
<         -: 5002:
<         -: 5003:      if (__buf.begin() == 0)
<         -: 5004:	std::__inplace_stable_sort(__first, __last, __comp);
<         -: 5005:      else
<         -: 5006:	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
<         -: 5007:				    _DistanceType(__buf.size()), __comp);
<         -: 5008:    }
<         -: 5009:
<         -: 5010:  /**
<         -: 5011:   *  @brief Sort the elements of a sequence, preserving the relative order
<         -: 5012:   *         of equivalent elements.
<         -: 5013:   *  @ingroup sorting_algorithms
<         -: 5014:   *  @param  __first   An iterator.
<         -: 5015:   *  @param  __last    Another iterator.
<         -: 5016:   *  @return  Nothing.
<         -: 5017:   *
<         -: 5018:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
<         -: 5019:   *  such that for each iterator @p i in the range @p [__first,__last-1),
<         -: 5020:   *  @p *(i+1)<*i is false.
<         -: 5021:   *
<         -: 5022:   *  The relative ordering of equivalent elements is preserved, so any two
<         -: 5023:   *  elements @p x and @p y in the range @p [__first,__last) such that
<         -: 5024:   *  @p x<y is false and @p y<x is false will have the same relative
<         -: 5025:   *  ordering after calling @p stable_sort().
<         -: 5026:  */
<         -: 5027:  template<typename _RandomAccessIterator>
<         -: 5028:    inline void
<         -: 5029:    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
<         -: 5030:    {
<         -: 5031:      // concept requirements
<         -: 5032:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 5033:	    _RandomAccessIterator>)
<         -: 5034:      __glibcxx_function_requires(_LessThanComparableConcept<
<         -: 5035:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 5036:      __glibcxx_requires_valid_range(__first, __last);
<         -: 5037:      __glibcxx_requires_irreflexive(__first, __last);
<         -: 5038:
<         -: 5039:      _GLIBCXX_STD_A::__stable_sort(__first, __last,
<         -: 5040:				    __gnu_cxx::__ops::__iter_less_iter());
<         -: 5041:    }
<         -: 5042:
<         -: 5043:  /**
<         -: 5044:   *  @brief Sort the elements of a sequence using a predicate for comparison,
<         -: 5045:   *         preserving the relative order of equivalent elements.
<         -: 5046:   *  @ingroup sorting_algorithms
<         -: 5047:   *  @param  __first   An iterator.
<         -: 5048:   *  @param  __last    Another iterator.
<         -: 5049:   *  @param  __comp    A comparison functor.
<         -: 5050:   *  @return  Nothing.
<         -: 5051:   *
<         -: 5052:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
<         -: 5053:   *  such that for each iterator @p i in the range @p [__first,__last-1),
<         -: 5054:   *  @p __comp(*(i+1),*i) is false.
<         -: 5055:   *
<         -: 5056:   *  The relative ordering of equivalent elements is preserved, so any two
<         -: 5057:   *  elements @p x and @p y in the range @p [__first,__last) such that
<         -: 5058:   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
<         -: 5059:   *  relative ordering after calling @p stable_sort().
<         -: 5060:  */
<         -: 5061:  template<typename _RandomAccessIterator, typename _Compare>
<         -: 5062:    inline void
<         -: 5063:    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
<         -: 5064:		_Compare __comp)
<         -: 5065:    {
<         -: 5066:      // concept requirements
<         -: 5067:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
<         -: 5068:	    _RandomAccessIterator>)
<         -: 5069:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5070:	    typename iterator_traits<_RandomAccessIterator>::value_type,
<         -: 5071:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
<         -: 5072:      __glibcxx_requires_valid_range(__first, __last);
<         -: 5073:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
<         -: 5074:
<         -: 5075:      _GLIBCXX_STD_A::__stable_sort(__first, __last,
<         -: 5076:				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 5077:    }
<         -: 5078:
<         -: 5079:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5080:	   typename _OutputIterator,
<         -: 5081:	   typename _Compare>
<         -: 5082:    _OutputIterator
<         -: 5083:    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5084:		_InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5085:		_OutputIterator __result, _Compare __comp)
<         -: 5086:    {
<         -: 5087:      while (__first1 != __last1 && __first2 != __last2)
<         -: 5088:	{
<         -: 5089:	  if (__comp(__first1, __first2))
<         -: 5090:	    {
<         -: 5091:	      *__result = *__first1;
<         -: 5092:	      ++__first1;
<         -: 5093:	    }
<         -: 5094:	  else if (__comp(__first2, __first1))
<         -: 5095:	    {
<         -: 5096:	      *__result = *__first2;
<         -: 5097:	      ++__first2;
<         -: 5098:	    }
<         -: 5099:	  else
<         -: 5100:	    {
<         -: 5101:	      *__result = *__first1;
<         -: 5102:	      ++__first1;
<         -: 5103:	      ++__first2;
<         -: 5104:	    }
<         -: 5105:	  ++__result;
<         -: 5106:	}
<         -: 5107:      return std::copy(__first2, __last2,
<         -: 5108:		       std::copy(__first1, __last1, __result));
<         -: 5109:    }
<         -: 5110:
<         -: 5111:  /**
<         -: 5112:   *  @brief Return the union of two sorted ranges.
<         -: 5113:   *  @ingroup set_algorithms
<         -: 5114:   *  @param  __first1  Start of first range.
<         -: 5115:   *  @param  __last1   End of first range.
<         -: 5116:   *  @param  __first2  Start of second range.
<         -: 5117:   *  @param  __last2   End of second range.
<         -: 5118:   *  @param  __result  Start of output range.
<         -: 5119:   *  @return  End of the output range.
<         -: 5120:   *  @ingroup set_algorithms
<         -: 5121:   *
<         -: 5122:   *  This operation iterates over both ranges, copying elements present in
<         -: 5123:   *  each range in order to the output range.  Iterators increment for each
<         -: 5124:   *  range.  When the current element of one range is less than the other,
<         -: 5125:   *  that element is copied and the iterator advanced.  If an element is
<         -: 5126:   *  contained in both ranges, the element from the first range is copied and
<         -: 5127:   *  both ranges advance.  The output range may not overlap either input
<         -: 5128:   *  range.
<         -: 5129:  */
<         -: 5130:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5131:	   typename _OutputIterator>
<         -: 5132:    inline _OutputIterator
<         -: 5133:    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5134:	      _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5135:	      _OutputIterator __result)
<         -: 5136:    {
<         -: 5137:      // concept requirements
<         -: 5138:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5139:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5140:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5141:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5142:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5143:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5144:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5145:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5146:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5147:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5148:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5149:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5150:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
<         -: 5151:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
<         -: 5152:      __glibcxx_requires_irreflexive2(__first1, __last1);
<         -: 5153:      __glibcxx_requires_irreflexive2(__first2, __last2);
<         -: 5154:
<         -: 5155:      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
<         -: 5156:				__first2, __last2, __result,
<         -: 5157:				__gnu_cxx::__ops::__iter_less_iter());
<         -: 5158:    }
<         -: 5159:
<         -: 5160:  /**
<         -: 5161:   *  @brief Return the union of two sorted ranges using a comparison functor.
<         -: 5162:   *  @ingroup set_algorithms
<         -: 5163:   *  @param  __first1  Start of first range.
<         -: 5164:   *  @param  __last1   End of first range.
<         -: 5165:   *  @param  __first2  Start of second range.
<         -: 5166:   *  @param  __last2   End of second range.
<         -: 5167:   *  @param  __result  Start of output range.
---
>         -: 4976:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 4977:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 4978:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 4979:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 4980:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 4981:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 4982:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
>         -: 4983:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
>         -: 4984:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
>         -: 4985:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
>         -: 4986:
>         -: 4987:      return _GLIBCXX_STD_A::__merge(__first1, __last1,
>         -: 4988:				__first2, __last2, __result,
>         -: 4989:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 4990:    }
>         -: 4991:
>         -: 4992:  template<typename _RandomAccessIterator, typename _Compare>
>         -: 4993:    inline void
>         -: 4994:    __stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
>         -: 4995:		  _Compare __comp)
>         -: 4996:    {
>         -: 4997:      typedef typename iterator_traits<_RandomAccessIterator>::value_type
>         -: 4998:	_ValueType;
>         -: 4999:      typedef typename iterator_traits<_RandomAccessIterator>::difference_type
>         -: 5000:	_DistanceType;
>         -: 5001:
>         -: 5002:      typedef _Temporary_buffer<_RandomAccessIterator, _ValueType> _TmpBuf;
>         -: 5003:      _TmpBuf __buf(__first, __last);
>         -: 5004:
>         -: 5005:      if (__buf.begin() == 0)
>         -: 5006:	std::__inplace_stable_sort(__first, __last, __comp);
>         -: 5007:      else
>         -: 5008:	std::__stable_sort_adaptive(__first, __last, __buf.begin(),
>         -: 5009:				    _DistanceType(__buf.size()), __comp);
>         -: 5010:    }
>         -: 5011:
>         -: 5012:  /**
>         -: 5013:   *  @brief Sort the elements of a sequence, preserving the relative order
>         -: 5014:   *         of equivalent elements.
>         -: 5015:   *  @ingroup sorting_algorithms
>         -: 5016:   *  @param  __first   An iterator.
>         -: 5017:   *  @param  __last    Another iterator.
>         -: 5018:   *  @return  Nothing.
>         -: 5019:   *
>         -: 5020:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
>         -: 5021:   *  such that for each iterator @p i in the range @p [__first,__last-1),
>         -: 5022:   *  @p *(i+1)<*i is false.
>         -: 5023:   *
>         -: 5024:   *  The relative ordering of equivalent elements is preserved, so any two
>         -: 5025:   *  elements @p x and @p y in the range @p [__first,__last) such that
>         -: 5026:   *  @p x<y is false and @p y<x is false will have the same relative
>         -: 5027:   *  ordering after calling @p stable_sort().
>         -: 5028:  */
>         -: 5029:  template<typename _RandomAccessIterator>
>         -: 5030:    inline void
>         -: 5031:    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
>         -: 5032:    {
>         -: 5033:      // concept requirements
>         -: 5034:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 5035:	    _RandomAccessIterator>)
>         -: 5036:      __glibcxx_function_requires(_LessThanComparableConcept<
>         -: 5037:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 5038:      __glibcxx_requires_valid_range(__first, __last);
>         -: 5039:      __glibcxx_requires_irreflexive(__first, __last);
>         -: 5040:
>         -: 5041:      _GLIBCXX_STD_A::__stable_sort(__first, __last,
>         -: 5042:				    __gnu_cxx::__ops::__iter_less_iter());
>         -: 5043:    }
>         -: 5044:
>         -: 5045:  /**
>         -: 5046:   *  @brief Sort the elements of a sequence using a predicate for comparison,
>         -: 5047:   *         preserving the relative order of equivalent elements.
>         -: 5048:   *  @ingroup sorting_algorithms
>         -: 5049:   *  @param  __first   An iterator.
>         -: 5050:   *  @param  __last    Another iterator.
>         -: 5051:   *  @param  __comp    A comparison functor.
>         -: 5052:   *  @return  Nothing.
>         -: 5053:   *
>         -: 5054:   *  Sorts the elements in the range @p [__first,__last) in ascending order,
>         -: 5055:   *  such that for each iterator @p i in the range @p [__first,__last-1),
>         -: 5056:   *  @p __comp(*(i+1),*i) is false.
>         -: 5057:   *
>         -: 5058:   *  The relative ordering of equivalent elements is preserved, so any two
>         -: 5059:   *  elements @p x and @p y in the range @p [__first,__last) such that
>         -: 5060:   *  @p __comp(x,y) is false and @p __comp(y,x) is false will have the same
>         -: 5061:   *  relative ordering after calling @p stable_sort().
>         -: 5062:  */
>         -: 5063:  template<typename _RandomAccessIterator, typename _Compare>
>         -: 5064:    inline void
>         -: 5065:    stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last,
>         -: 5066:		_Compare __comp)
>         -: 5067:    {
>         -: 5068:      // concept requirements
>         -: 5069:      __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<
>         -: 5070:	    _RandomAccessIterator>)
>         -: 5071:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5072:	    typename iterator_traits<_RandomAccessIterator>::value_type,
>         -: 5073:	    typename iterator_traits<_RandomAccessIterator>::value_type>)
>         -: 5074:      __glibcxx_requires_valid_range(__first, __last);
>         -: 5075:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
>         -: 5076:
>         -: 5077:      _GLIBCXX_STD_A::__stable_sort(__first, __last,
>         -: 5078:				    __gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 5079:    }
>         -: 5080:
>         -: 5081:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5082:	   typename _OutputIterator,
>         -: 5083:	   typename _Compare>
>         -: 5084:    _OutputIterator
>         -: 5085:    __set_union(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5086:		_InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5087:		_OutputIterator __result, _Compare __comp)
>         -: 5088:    {
>         -: 5089:      while (__first1 != __last1 && __first2 != __last2)
>         -: 5090:	{
>         -: 5091:	  if (__comp(__first1, __first2))
>         -: 5092:	    {
>         -: 5093:	      *__result = *__first1;
>         -: 5094:	      ++__first1;
>         -: 5095:	    }
>         -: 5096:	  else if (__comp(__first2, __first1))
>         -: 5097:	    {
>         -: 5098:	      *__result = *__first2;
>         -: 5099:	      ++__first2;
>         -: 5100:	    }
>         -: 5101:	  else
>         -: 5102:	    {
>         -: 5103:	      *__result = *__first1;
>         -: 5104:	      ++__first1;
>         -: 5105:	      ++__first2;
>         -: 5106:	    }
>         -: 5107:	  ++__result;
>         -: 5108:	}
>         -: 5109:      return std::copy(__first2, __last2,
>         -: 5110:		       std::copy(__first1, __last1, __result));
>         -: 5111:    }
>         -: 5112:
>         -: 5113:  /**
>         -: 5114:   *  @brief Return the union of two sorted ranges.
>         -: 5115:   *  @ingroup set_algorithms
>         -: 5116:   *  @param  __first1  Start of first range.
>         -: 5117:   *  @param  __last1   End of first range.
>         -: 5118:   *  @param  __first2  Start of second range.
>         -: 5119:   *  @param  __last2   End of second range.
>         -: 5120:   *  @return  End of the output range.
>         -: 5121:   *  @ingroup set_algorithms
>         -: 5122:   *
>         -: 5123:   *  This operation iterates over both ranges, copying elements present in
>         -: 5124:   *  each range in order to the output range.  Iterators increment for each
>         -: 5125:   *  range.  When the current element of one range is less than the other,
>         -: 5126:   *  that element is copied and the iterator advanced.  If an element is
>         -: 5127:   *  contained in both ranges, the element from the first range is copied and
>         -: 5128:   *  both ranges advance.  The output range may not overlap either input
>         -: 5129:   *  range.
>         -: 5130:  */
>         -: 5131:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5132:	   typename _OutputIterator>
>         -: 5133:    inline _OutputIterator
>         -: 5134:    set_union(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5135:	      _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5136:	      _OutputIterator __result)
>         -: 5137:    {
>         -: 5138:      // concept requirements
>         -: 5139:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5140:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5141:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5142:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5143:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5144:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5145:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5146:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5147:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5148:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5149:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5150:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5151:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>         -: 5152:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>         -: 5153:      __glibcxx_requires_irreflexive2(__first1, __last1);
>         -: 5154:      __glibcxx_requires_irreflexive2(__first2, __last2);
>         -: 5155:
>         -: 5156:      return _GLIBCXX_STD_A::__set_union(__first1, __last1,
>         -: 5157:				__first2, __last2, __result,
>         -: 5158:				__gnu_cxx::__ops::__iter_less_iter());
>         -: 5159:    }
>         -: 5160:
>         -: 5161:  /**
>         -: 5162:   *  @brief Return the union of two sorted ranges using a comparison functor.
>         -: 5163:   *  @ingroup set_algorithms
>         -: 5164:   *  @param  __first1  Start of first range.
>         -: 5165:   *  @param  __last1   End of first range.
>         -: 5166:   *  @param  __first2  Start of second range.
>         -: 5167:   *  @param  __last2   End of second range.
5242,5386c5242,5386
<         -: 5240:   *  @param  __result  Start of output range.
<         -: 5241:   *  @return  End of the output range.
<         -: 5242:   *  @ingroup set_algorithms
<         -: 5243:   *
<         -: 5244:   *  This operation iterates over both ranges, copying elements present in
<         -: 5245:   *  both ranges in order to the output range.  Iterators increment for each
<         -: 5246:   *  range.  When the current element of one range is less than the other,
<         -: 5247:   *  that iterator advances.  If an element is contained in both ranges, the
<         -: 5248:   *  element from the first range is copied and both ranges advance.  The
<         -: 5249:   *  output range may not overlap either input range.
<         -: 5250:  */
<         -: 5251:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5252:	   typename _OutputIterator>
<         -: 5253:    inline _OutputIterator
<         -: 5254:    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5255:		     _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5256:		     _OutputIterator __result)
<         -: 5257:    {
<         -: 5258:      // concept requirements
<         -: 5259:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5260:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5261:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5262:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5263:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5264:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5265:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5266:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5267:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5268:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5269:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
<         -: 5270:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
<         -: 5271:      __glibcxx_requires_irreflexive2(__first1, __last1);
<         -: 5272:      __glibcxx_requires_irreflexive2(__first2, __last2);
<         -: 5273:
<         -: 5274:      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
<         -: 5275:				     __first2, __last2, __result,
<         -: 5276:				     __gnu_cxx::__ops::__iter_less_iter());
<         -: 5277:    }
<         -: 5278:
<         -: 5279:  /**
<         -: 5280:   *  @brief Return the intersection of two sorted ranges using comparison
<         -: 5281:   *  functor.
<         -: 5282:   *  @ingroup set_algorithms
<         -: 5283:   *  @param  __first1  Start of first range.
<         -: 5284:   *  @param  __last1   End of first range.
<         -: 5285:   *  @param  __first2  Start of second range.
<         -: 5286:   *  @param  __last2   End of second range.
<         -: 5287:   *  @param  __result  Start of output range.
<         -: 5288:   *  @param  __comp    The comparison functor.
<         -: 5289:   *  @return  End of the output range.
<         -: 5290:   *  @ingroup set_algorithms
<         -: 5291:   *
<         -: 5292:   *  This operation iterates over both ranges, copying elements present in
<         -: 5293:   *  both ranges in order to the output range.  Iterators increment for each
<         -: 5294:   *  range.  When the current element of one range is less than the other
<         -: 5295:   *  according to @p __comp, that iterator advances.  If an element is
<         -: 5296:   *  contained in both ranges according to @p __comp, the element from the
<         -: 5297:   *  first range is copied and both ranges advance.  The output range may not
<         -: 5298:   *  overlap either input range.
<         -: 5299:  */
<         -: 5300:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5301:	   typename _OutputIterator, typename _Compare>
<         -: 5302:    inline _OutputIterator
<         -: 5303:    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5304:		     _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5305:		     _OutputIterator __result, _Compare __comp)
<         -: 5306:    {
<         -: 5307:      // concept requirements
<         -: 5308:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5309:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5310:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5311:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5312:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5313:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5314:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5315:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5316:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5317:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5318:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
<         -: 5319:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
<         -: 5320:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
<         -: 5321:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
<         -: 5322:
<         -: 5323:      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
<         -: 5324:				__first2, __last2, __result,
<         -: 5325:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 5326:    }
<         -: 5327:
<         -: 5328:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5329:	   typename _OutputIterator,
<         -: 5330:	   typename _Compare>
<         -: 5331:    _OutputIterator
<         -: 5332:    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5333:		     _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5334:		     _OutputIterator __result, _Compare __comp)
<         -: 5335:    {
<         -: 5336:      while (__first1 != __last1 && __first2 != __last2)
<         -: 5337:	if (__comp(__first1, __first2))
<         -: 5338:	  {
<         -: 5339:	    *__result = *__first1;
<         -: 5340:	    ++__first1;
<         -: 5341:	    ++__result;
<         -: 5342:	  }
<         -: 5343:	else if (__comp(__first2, __first1))
<         -: 5344:	  ++__first2;
<         -: 5345:	else
<         -: 5346:	  {
<         -: 5347:	    ++__first1;
<         -: 5348:	    ++__first2;
<         -: 5349:	  }
<         -: 5350:      return std::copy(__first1, __last1, __result);
<         -: 5351:    }
<         -: 5352:
<         -: 5353:  /**
<         -: 5354:   *  @brief Return the difference of two sorted ranges.
<         -: 5355:   *  @ingroup set_algorithms
<         -: 5356:   *  @param  __first1  Start of first range.
<         -: 5357:   *  @param  __last1   End of first range.
<         -: 5358:   *  @param  __first2  Start of second range.
<         -: 5359:   *  @param  __last2   End of second range.
<         -: 5360:   *  @param  __result  Start of output range.
<         -: 5361:   *  @return  End of the output range.
<         -: 5362:   *  @ingroup set_algorithms
<         -: 5363:   *
<         -: 5364:   *  This operation iterates over both ranges, copying elements present in
<         -: 5365:   *  the first range but not the second in order to the output range.
<         -: 5366:   *  Iterators increment for each range.  When the current element of the
<         -: 5367:   *  first range is less than the second, that element is copied and the
<         -: 5368:   *  iterator advances.  If the current element of the second range is less,
<         -: 5369:   *  the iterator advances, but no element is copied.  If an element is
<         -: 5370:   *  contained in both ranges, no elements are copied and both ranges
<         -: 5371:   *  advance.  The output range may not overlap either input range.
<         -: 5372:  */
<         -: 5373:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5374:	   typename _OutputIterator>
<         -: 5375:    inline _OutputIterator
<         -: 5376:    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5377:		   _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5378:		   _OutputIterator __result)
<         -: 5379:    {
<         -: 5380:      // concept requirements
<         -: 5381:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5382:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5383:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5384:	    typename iterator_traits<_InputIterator1>::value_type>)
---
>         -: 5240:   *  @return  End of the output range.
>         -: 5241:   *  @ingroup set_algorithms
>         -: 5242:   *
>         -: 5243:   *  This operation iterates over both ranges, copying elements present in
>         -: 5244:   *  both ranges in order to the output range.  Iterators increment for each
>         -: 5245:   *  range.  When the current element of one range is less than the other,
>         -: 5246:   *  that iterator advances.  If an element is contained in both ranges, the
>         -: 5247:   *  element from the first range is copied and both ranges advance.  The
>         -: 5248:   *  output range may not overlap either input range.
>         -: 5249:  */
>         -: 5250:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5251:	   typename _OutputIterator>
>         -: 5252:    inline _OutputIterator
>         -: 5253:    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5254:		     _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5255:		     _OutputIterator __result)
>         -: 5256:    {
>         -: 5257:      // concept requirements
>         -: 5258:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5259:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5260:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5261:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5262:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5263:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5264:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5265:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5266:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5267:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5268:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>         -: 5269:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>         -: 5270:      __glibcxx_requires_irreflexive2(__first1, __last1);
>         -: 5271:      __glibcxx_requires_irreflexive2(__first2, __last2);
>         -: 5272:
>         -: 5273:      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
>         -: 5274:				     __first2, __last2, __result,
>         -: 5275:				     __gnu_cxx::__ops::__iter_less_iter());
>         -: 5276:    }
>         -: 5277:
>         -: 5278:  /**
>         -: 5279:   *  @brief Return the intersection of two sorted ranges using comparison
>         -: 5280:   *  functor.
>         -: 5281:   *  @ingroup set_algorithms
>         -: 5282:   *  @param  __first1  Start of first range.
>         -: 5283:   *  @param  __last1   End of first range.
>         -: 5284:   *  @param  __first2  Start of second range.
>         -: 5285:   *  @param  __last2   End of second range.
>         -: 5286:   *  @param  __comp    The comparison functor.
>         -: 5287:   *  @return  End of the output range.
>         -: 5288:   *  @ingroup set_algorithms
>         -: 5289:   *
>         -: 5290:   *  This operation iterates over both ranges, copying elements present in
>         -: 5291:   *  both ranges in order to the output range.  Iterators increment for each
>         -: 5292:   *  range.  When the current element of one range is less than the other
>         -: 5293:   *  according to @p __comp, that iterator advances.  If an element is
>         -: 5294:   *  contained in both ranges according to @p __comp, the element from the
>         -: 5295:   *  first range is copied and both ranges advance.  The output range may not
>         -: 5296:   *  overlap either input range.
>         -: 5297:  */
>         -: 5298:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5299:	   typename _OutputIterator, typename _Compare>
>         -: 5300:    inline _OutputIterator
>         -: 5301:    set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5302:		     _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5303:		     _OutputIterator __result, _Compare __comp)
>         -: 5304:    {
>         -: 5305:      // concept requirements
>         -: 5306:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5307:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5308:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5309:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5310:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5311:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5312:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5313:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5314:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5315:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5316:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
>         -: 5317:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
>         -: 5318:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
>         -: 5319:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
>         -: 5320:
>         -: 5321:      return _GLIBCXX_STD_A::__set_intersection(__first1, __last1,
>         -: 5322:				__first2, __last2, __result,
>         -: 5323:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 5324:    }
>         -: 5325:
>         -: 5326:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5327:	   typename _OutputIterator,
>         -: 5328:	   typename _Compare>
>         -: 5329:    _OutputIterator
>         -: 5330:    __set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5331:		     _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5332:		     _OutputIterator __result, _Compare __comp)
>         -: 5333:    {
>         -: 5334:      while (__first1 != __last1 && __first2 != __last2)
>         -: 5335:	if (__comp(__first1, __first2))
>         -: 5336:	  {
>         -: 5337:	    *__result = *__first1;
>         -: 5338:	    ++__first1;
>         -: 5339:	    ++__result;
>         -: 5340:	  }
>         -: 5341:	else if (__comp(__first2, __first1))
>         -: 5342:	  ++__first2;
>         -: 5343:	else
>         -: 5344:	  {
>         -: 5345:	    ++__first1;
>         -: 5346:	    ++__first2;
>         -: 5347:	  }
>         -: 5348:      return std::copy(__first1, __last1, __result);
>         -: 5349:    }
>         -: 5350:
>         -: 5351:  /**
>         -: 5352:   *  @brief Return the difference of two sorted ranges.
>         -: 5353:   *  @ingroup set_algorithms
>         -: 5354:   *  @param  __first1  Start of first range.
>         -: 5355:   *  @param  __last1   End of first range.
>         -: 5356:   *  @param  __first2  Start of second range.
>         -: 5357:   *  @param  __last2   End of second range.
>         -: 5358:   *  @return  End of the output range.
>         -: 5359:   *  @ingroup set_algorithms
>         -: 5360:   *
>         -: 5361:   *  This operation iterates over both ranges, copying elements present in
>         -: 5362:   *  the first range but not the second in order to the output range.
>         -: 5363:   *  Iterators increment for each range.  When the current element of the
>         -: 5364:   *  first range is less than the second, that element is copied and the
>         -: 5365:   *  iterator advances.  If the current element of the second range is less,
>         -: 5366:   *  the iterator advances, but no element is copied.  If an element is
>         -: 5367:   *  contained in both ranges, no elements are copied and both ranges
>         -: 5368:   *  advance.  The output range may not overlap either input range.
>         -: 5369:  */
>         -: 5370:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5371:	   typename _OutputIterator>
>         -: 5372:    inline _OutputIterator
>         -: 5373:    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5374:		   _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5375:		   _OutputIterator __result)
>         -: 5376:    {
>         -: 5377:      // concept requirements
>         -: 5378:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5379:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5380:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5381:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5382:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5383:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5384:	    typename iterator_traits<_InputIterator2>::value_type>)
5388,5528c5388,5528
<         -: 5386:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5387:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5388:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5389:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5390:	    typename iterator_traits<_InputIterator1>::value_type>)	
<         -: 5391:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
<         -: 5392:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
<         -: 5393:      __glibcxx_requires_irreflexive2(__first1, __last1);
<         -: 5394:      __glibcxx_requires_irreflexive2(__first2, __last2);
<         -: 5395:
<         -: 5396:      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
<         -: 5397:				   __first2, __last2, __result,
<         -: 5398:				   __gnu_cxx::__ops::__iter_less_iter());
<         -: 5399:    }
<         -: 5400:
<         -: 5401:  /**
<         -: 5402:   *  @brief  Return the difference of two sorted ranges using comparison
<         -: 5403:   *  functor.
<         -: 5404:   *  @ingroup set_algorithms
<         -: 5405:   *  @param  __first1  Start of first range.
<         -: 5406:   *  @param  __last1   End of first range.
<         -: 5407:   *  @param  __first2  Start of second range.
<         -: 5408:   *  @param  __last2   End of second range.
<         -: 5409:   *  @param  __result  Start of output range.
<         -: 5410:   *  @param  __comp    The comparison functor.
<         -: 5411:   *  @return  End of the output range.
<         -: 5412:   *  @ingroup set_algorithms
<         -: 5413:   *
<         -: 5414:   *  This operation iterates over both ranges, copying elements present in
<         -: 5415:   *  the first range but not the second in order to the output range.
<         -: 5416:   *  Iterators increment for each range.  When the current element of the
<         -: 5417:   *  first range is less than the second according to @p __comp, that element
<         -: 5418:   *  is copied and the iterator advances.  If the current element of the
<         -: 5419:   *  second range is less, no element is copied and the iterator advances.
<         -: 5420:   *  If an element is contained in both ranges according to @p __comp, no
<         -: 5421:   *  elements are copied and both ranges advance.  The output range may not
<         -: 5422:   *  overlap either input range.
<         -: 5423:  */
<         -: 5424:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5425:	   typename _OutputIterator, typename _Compare>
<         -: 5426:    inline _OutputIterator
<         -: 5427:    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5428:		   _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5429:		   _OutputIterator __result, _Compare __comp)
<         -: 5430:    {
<         -: 5431:      // concept requirements
<         -: 5432:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5433:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5434:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5435:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5436:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5437:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5438:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5439:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5440:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5441:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5442:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
<         -: 5443:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
<         -: 5444:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
<         -: 5445:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
<         -: 5446:
<         -: 5447:      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
<         -: 5448:				   __first2, __last2, __result,
<         -: 5449:				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 5450:    }
<         -: 5451:
<         -: 5452:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5453:	   typename _OutputIterator,
<         -: 5454:	   typename _Compare>
<         -: 5455:    _OutputIterator
<         -: 5456:    __set_symmetric_difference(_InputIterator1 __first1,
<         -: 5457:			       _InputIterator1 __last1,
<         -: 5458:			       _InputIterator2 __first2,
<         -: 5459:			       _InputIterator2 __last2,
<         -: 5460:			       _OutputIterator __result,
<         -: 5461:			       _Compare __comp)
<         -: 5462:    {
<         -: 5463:      while (__first1 != __last1 && __first2 != __last2)
<         -: 5464:	if (__comp(__first1, __first2))
<         -: 5465:	  {
<         -: 5466:	    *__result = *__first1;
<         -: 5467:	    ++__first1;
<         -: 5468:	    ++__result;
<         -: 5469:	  }
<         -: 5470:	else if (__comp(__first2, __first1))
<         -: 5471:	  {
<         -: 5472:	    *__result = *__first2;
<         -: 5473:	    ++__first2;
<         -: 5474:	    ++__result;
<         -: 5475:	  }
<         -: 5476:	else
<         -: 5477:	  {
<         -: 5478:	    ++__first1;
<         -: 5479:	    ++__first2;
<         -: 5480:	  }
<         -: 5481:      return std::copy(__first2, __last2, 
<         -: 5482:		       std::copy(__first1, __last1, __result));
<         -: 5483:    }
<         -: 5484:
<         -: 5485:  /**
<         -: 5486:   *  @brief  Return the symmetric difference of two sorted ranges.
<         -: 5487:   *  @ingroup set_algorithms
<         -: 5488:   *  @param  __first1  Start of first range.
<         -: 5489:   *  @param  __last1   End of first range.
<         -: 5490:   *  @param  __first2  Start of second range.
<         -: 5491:   *  @param  __last2   End of second range.
<         -: 5492:   *  @param  __result  Start of output range.
<         -: 5493:   *  @return  End of the output range.
<         -: 5494:   *  @ingroup set_algorithms
<         -: 5495:   *
<         -: 5496:   *  This operation iterates over both ranges, copying elements present in
<         -: 5497:   *  one range but not the other in order to the output range.  Iterators
<         -: 5498:   *  increment for each range.  When the current element of one range is less
<         -: 5499:   *  than the other, that element is copied and the iterator advances.  If an
<         -: 5500:   *  element is contained in both ranges, no elements are copied and both
<         -: 5501:   *  ranges advance.  The output range may not overlap either input range.
<         -: 5502:  */
<         -: 5503:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5504:	   typename _OutputIterator>
<         -: 5505:    inline _OutputIterator
<         -: 5506:    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5507:			     _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5508:			     _OutputIterator __result)
<         -: 5509:    {
<         -: 5510:      // concept requirements
<         -: 5511:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5512:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5513:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5514:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5515:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5516:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5517:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5518:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5519:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5520:      __glibcxx_function_requires(_LessThanOpConcept<
<         -: 5521:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5522:	    typename iterator_traits<_InputIterator1>::value_type>)	
<         -: 5523:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
<         -: 5524:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
<         -: 5525:      __glibcxx_requires_irreflexive2(__first1, __last1);
<         -: 5526:      __glibcxx_requires_irreflexive2(__first2, __last2);
---
>         -: 5386:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5387:	    typename iterator_traits<_InputIterator1>::value_type>)	
>         -: 5388:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>         -: 5389:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>         -: 5390:      __glibcxx_requires_irreflexive2(__first1, __last1);
>         -: 5391:      __glibcxx_requires_irreflexive2(__first2, __last2);
>         -: 5392:
>         -: 5393:      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
>         -: 5394:				   __first2, __last2, __result,
>         -: 5395:				   __gnu_cxx::__ops::__iter_less_iter());
>         -: 5396:    }
>         -: 5397:
>         -: 5398:  /**
>         -: 5399:   *  @brief  Return the difference of two sorted ranges using comparison
>         -: 5400:   *  functor.
>         -: 5401:   *  @ingroup set_algorithms
>         -: 5402:   *  @param  __first1  Start of first range.
>         -: 5403:   *  @param  __last1   End of first range.
>         -: 5404:   *  @param  __first2  Start of second range.
>         -: 5405:   *  @param  __last2   End of second range.
>         -: 5406:   *  @param  __comp    The comparison functor.
>         -: 5407:   *  @return  End of the output range.
>         -: 5408:   *  @ingroup set_algorithms
>         -: 5409:   *
>         -: 5410:   *  This operation iterates over both ranges, copying elements present in
>         -: 5411:   *  the first range but not the second in order to the output range.
>         -: 5412:   *  Iterators increment for each range.  When the current element of the
>         -: 5413:   *  first range is less than the second according to @p __comp, that element
>         -: 5414:   *  is copied and the iterator advances.  If the current element of the
>         -: 5415:   *  second range is less, no element is copied and the iterator advances.
>         -: 5416:   *  If an element is contained in both ranges according to @p __comp, no
>         -: 5417:   *  elements are copied and both ranges advance.  The output range may not
>         -: 5418:   *  overlap either input range.
>         -: 5419:  */
>         -: 5420:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5421:	   typename _OutputIterator, typename _Compare>
>         -: 5422:    inline _OutputIterator
>         -: 5423:    set_difference(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5424:		   _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5425:		   _OutputIterator __result, _Compare __comp)
>         -: 5426:    {
>         -: 5427:      // concept requirements
>         -: 5428:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5429:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5430:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5431:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5432:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5433:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5434:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5435:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5436:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5437:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5438:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
>         -: 5439:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
>         -: 5440:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
>         -: 5441:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
>         -: 5442:
>         -: 5443:      return _GLIBCXX_STD_A::__set_difference(__first1, __last1,
>         -: 5444:				   __first2, __last2, __result,
>         -: 5445:				   __gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 5446:    }
>         -: 5447:
>         -: 5448:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5449:	   typename _OutputIterator,
>         -: 5450:	   typename _Compare>
>         -: 5451:    _OutputIterator
>         -: 5452:    __set_symmetric_difference(_InputIterator1 __first1,
>         -: 5453:			       _InputIterator1 __last1,
>         -: 5454:			       _InputIterator2 __first2,
>         -: 5455:			       _InputIterator2 __last2,
>         -: 5456:			       _OutputIterator __result,
>         -: 5457:			       _Compare __comp)
>         -: 5458:    {
>         -: 5459:      while (__first1 != __last1 && __first2 != __last2)
>         -: 5460:	if (__comp(__first1, __first2))
>         -: 5461:	  {
>         -: 5462:	    *__result = *__first1;
>         -: 5463:	    ++__first1;
>         -: 5464:	    ++__result;
>         -: 5465:	  }
>         -: 5466:	else if (__comp(__first2, __first1))
>         -: 5467:	  {
>         -: 5468:	    *__result = *__first2;
>         -: 5469:	    ++__first2;
>         -: 5470:	    ++__result;
>         -: 5471:	  }
>         -: 5472:	else
>         -: 5473:	  {
>         -: 5474:	    ++__first1;
>         -: 5475:	    ++__first2;
>         -: 5476:	  }
>         -: 5477:      return std::copy(__first2, __last2, 
>         -: 5478:		       std::copy(__first1, __last1, __result));
>         -: 5479:    }
>         -: 5480:
>         -: 5481:  /**
>         -: 5482:   *  @brief  Return the symmetric difference of two sorted ranges.
>         -: 5483:   *  @ingroup set_algorithms
>         -: 5484:   *  @param  __first1  Start of first range.
>         -: 5485:   *  @param  __last1   End of first range.
>         -: 5486:   *  @param  __first2  Start of second range.
>         -: 5487:   *  @param  __last2   End of second range.
>         -: 5488:   *  @return  End of the output range.
>         -: 5489:   *  @ingroup set_algorithms
>         -: 5490:   *
>         -: 5491:   *  This operation iterates over both ranges, copying elements present in
>         -: 5492:   *  one range but not the other in order to the output range.  Iterators
>         -: 5493:   *  increment for each range.  When the current element of one range is less
>         -: 5494:   *  than the other, that element is copied and the iterator advances.  If an
>         -: 5495:   *  element is contained in both ranges, no elements are copied and both
>         -: 5496:   *  ranges advance.  The output range may not overlap either input range.
>         -: 5497:  */
>         -: 5498:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5499:	   typename _OutputIterator>
>         -: 5500:    inline _OutputIterator
>         -: 5501:    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5502:			     _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5503:			     _OutputIterator __result)
>         -: 5504:    {
>         -: 5505:      // concept requirements
>         -: 5506:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5507:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5508:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5509:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5510:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5511:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5512:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5513:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5514:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5515:      __glibcxx_function_requires(_LessThanOpConcept<
>         -: 5516:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5517:	    typename iterator_traits<_InputIterator1>::value_type>)	
>         -: 5518:      __glibcxx_requires_sorted_set(__first1, __last1, __first2);
>         -: 5519:      __glibcxx_requires_sorted_set(__first2, __last2, __first1);
>         -: 5520:      __glibcxx_requires_irreflexive2(__first1, __last1);
>         -: 5521:      __glibcxx_requires_irreflexive2(__first2, __last2);
>         -: 5522:
>         -: 5523:      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
>         -: 5524:					__first2, __last2, __result,
>         -: 5525:					__gnu_cxx::__ops::__iter_less_iter());
>         -: 5526:    }
5530,5729c5530,5729
<         -: 5528:      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
<         -: 5529:					__first2, __last2, __result,
<         -: 5530:					__gnu_cxx::__ops::__iter_less_iter());
<         -: 5531:    }
<         -: 5532:
<         -: 5533:  /**
<         -: 5534:   *  @brief  Return the symmetric difference of two sorted ranges using
<         -: 5535:   *  comparison functor.
<         -: 5536:   *  @ingroup set_algorithms
<         -: 5537:   *  @param  __first1  Start of first range.
<         -: 5538:   *  @param  __last1   End of first range.
<         -: 5539:   *  @param  __first2  Start of second range.
<         -: 5540:   *  @param  __last2   End of second range.
<         -: 5541:   *  @param  __result  Start of output range.
<         -: 5542:   *  @param  __comp    The comparison functor.
<         -: 5543:   *  @return  End of the output range.
<         -: 5544:   *  @ingroup set_algorithms
<         -: 5545:   *
<         -: 5546:   *  This operation iterates over both ranges, copying elements present in
<         -: 5547:   *  one range but not the other in order to the output range.  Iterators
<         -: 5548:   *  increment for each range.  When the current element of one range is less
<         -: 5549:   *  than the other according to @p comp, that element is copied and the
<         -: 5550:   *  iterator advances.  If an element is contained in both ranges according
<         -: 5551:   *  to @p __comp, no elements are copied and both ranges advance.  The output
<         -: 5552:   *  range may not overlap either input range.
<         -: 5553:  */
<         -: 5554:  template<typename _InputIterator1, typename _InputIterator2,
<         -: 5555:	   typename _OutputIterator, typename _Compare>
<         -: 5556:    inline _OutputIterator
<         -: 5557:    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
<         -: 5558:			     _InputIterator2 __first2, _InputIterator2 __last2,
<         -: 5559:			     _OutputIterator __result,
<         -: 5560:			     _Compare __comp)
<         -: 5561:    {
<         -: 5562:      // concept requirements
<         -: 5563:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
<         -: 5564:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
<         -: 5565:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5566:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5567:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
<         -: 5568:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5569:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5570:	    typename iterator_traits<_InputIterator1>::value_type,
<         -: 5571:	    typename iterator_traits<_InputIterator2>::value_type>)
<         -: 5572:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5573:	    typename iterator_traits<_InputIterator2>::value_type,
<         -: 5574:	    typename iterator_traits<_InputIterator1>::value_type>)
<         -: 5575:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
<         -: 5576:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
<         -: 5577:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
<         -: 5578:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
<         -: 5579:
<         -: 5580:      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
<         -: 5581:				__first2, __last2, __result,
<         -: 5582:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 5583:    }
<         -: 5584:
<         -: 5585:  template<typename _ForwardIterator, typename _Compare>
<         -: 5586:    _GLIBCXX14_CONSTEXPR
<         -: 5587:    _ForwardIterator
<         -: 5588:    __min_element(_ForwardIterator __first, _ForwardIterator __last,
<         -: 5589:		  _Compare __comp)
<         -: 5590:    {
<         -: 5591:      if (__first == __last)
<         -: 5592:	return __first;
<         -: 5593:      _ForwardIterator __result = __first;
<         -: 5594:      while (++__first != __last)
<         -: 5595:	if (__comp(__first, __result))
<         -: 5596:	  __result = __first;
<         -: 5597:      return __result;
<         -: 5598:    }
<         -: 5599:
<         -: 5600:  /**
<         -: 5601:   *  @brief  Return the minimum element in a range.
<         -: 5602:   *  @ingroup sorting_algorithms
<         -: 5603:   *  @param  __first  Start of range.
<         -: 5604:   *  @param  __last   End of range.
<         -: 5605:   *  @return  Iterator referencing the first instance of the smallest value.
<         -: 5606:  */
<         -: 5607:  template<typename _ForwardIterator>
<         -: 5608:    _GLIBCXX14_CONSTEXPR
<         -: 5609:    _ForwardIterator
<         -: 5610:    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
<         -: 5611:    {
<         -: 5612:      // concept requirements
<         -: 5613:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 5614:      __glibcxx_function_requires(_LessThanComparableConcept<
<         -: 5615:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 5616:      __glibcxx_requires_valid_range(__first, __last);
<         -: 5617:      __glibcxx_requires_irreflexive(__first, __last);
<         -: 5618:
<         -: 5619:      return _GLIBCXX_STD_A::__min_element(__first, __last,
<         -: 5620:				__gnu_cxx::__ops::__iter_less_iter());
<         -: 5621:    }
<         -: 5622:
<         -: 5623:  /**
<         -: 5624:   *  @brief  Return the minimum element in a range using comparison functor.
<         -: 5625:   *  @ingroup sorting_algorithms
<         -: 5626:   *  @param  __first  Start of range.
<         -: 5627:   *  @param  __last   End of range.
<         -: 5628:   *  @param  __comp   Comparison functor.
<         -: 5629:   *  @return  Iterator referencing the first instance of the smallest value
<         -: 5630:   *  according to __comp.
<         -: 5631:  */
<         -: 5632:  template<typename _ForwardIterator, typename _Compare>
<         -: 5633:    _GLIBCXX14_CONSTEXPR
<         -: 5634:    inline _ForwardIterator
<         -: 5635:    min_element(_ForwardIterator __first, _ForwardIterator __last,
<         -: 5636:		_Compare __comp)
<         -: 5637:    {
<         -: 5638:      // concept requirements
<         -: 5639:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 5640:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5641:	    typename iterator_traits<_ForwardIterator>::value_type,
<         -: 5642:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 5643:      __glibcxx_requires_valid_range(__first, __last);
<         -: 5644:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
<         -: 5645:
<         -: 5646:      return _GLIBCXX_STD_A::__min_element(__first, __last,
<         -: 5647:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 5648:    }
<         -: 5649:
<         -: 5650:  template<typename _ForwardIterator, typename _Compare>
<         -: 5651:    _GLIBCXX14_CONSTEXPR
<         -: 5652:    _ForwardIterator
<         -: 5653:    __max_element(_ForwardIterator __first, _ForwardIterator __last,
<         -: 5654:		  _Compare __comp)
<         -: 5655:    {
<         -: 5656:      if (__first == __last) return __first;
<         -: 5657:      _ForwardIterator __result = __first;
<         -: 5658:      while (++__first != __last)
<         -: 5659:	if (__comp(__result, __first))
<         -: 5660:	  __result = __first;
<         -: 5661:      return __result;
<         -: 5662:    }
<         -: 5663:
<         -: 5664:  /**
<         -: 5665:   *  @brief  Return the maximum element in a range.
<         -: 5666:   *  @ingroup sorting_algorithms
<         -: 5667:   *  @param  __first  Start of range.
<         -: 5668:   *  @param  __last   End of range.
<         -: 5669:   *  @return  Iterator referencing the first instance of the largest value.
<         -: 5670:  */
<         -: 5671:  template<typename _ForwardIterator>
<         -: 5672:    _GLIBCXX14_CONSTEXPR
<         -: 5673:    inline _ForwardIterator
<         -: 5674:    max_element(_ForwardIterator __first, _ForwardIterator __last)
<         -: 5675:    {
<         -: 5676:      // concept requirements
<         -: 5677:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 5678:      __glibcxx_function_requires(_LessThanComparableConcept<
<         -: 5679:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 5680:      __glibcxx_requires_valid_range(__first, __last);
<         -: 5681:      __glibcxx_requires_irreflexive(__first, __last);
<         -: 5682:
<         -: 5683:      return _GLIBCXX_STD_A::__max_element(__first, __last,
<         -: 5684:				__gnu_cxx::__ops::__iter_less_iter());
<         -: 5685:    }
<         -: 5686:
<         -: 5687:  /**
<         -: 5688:   *  @brief  Return the maximum element in a range using comparison functor.
<         -: 5689:   *  @ingroup sorting_algorithms
<         -: 5690:   *  @param  __first  Start of range.
<         -: 5691:   *  @param  __last   End of range.
<         -: 5692:   *  @param  __comp   Comparison functor.
<         -: 5693:   *  @return  Iterator referencing the first instance of the largest value
<         -: 5694:   *  according to __comp.
<         -: 5695:  */
<         -: 5696:  template<typename _ForwardIterator, typename _Compare>
<         -: 5697:    _GLIBCXX14_CONSTEXPR
<         -: 5698:    inline _ForwardIterator
<         -: 5699:    max_element(_ForwardIterator __first, _ForwardIterator __last,
<         -: 5700:		_Compare __comp)
<         -: 5701:    {
<         -: 5702:      // concept requirements
<         -: 5703:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
<         -: 5704:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
<         -: 5705:	    typename iterator_traits<_ForwardIterator>::value_type,
<         -: 5706:	    typename iterator_traits<_ForwardIterator>::value_type>)
<         -: 5707:      __glibcxx_requires_valid_range(__first, __last);
<         -: 5708:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
<         -: 5709:
<         -: 5710:      return _GLIBCXX_STD_A::__max_element(__first, __last,
<         -: 5711:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
<         -: 5712:    }
<         -: 5713:
<         -: 5714:#if __cplusplus >= 201402L
<         -: 5715:  /// Reservoir sampling algorithm.
<         -: 5716:  template<typename _InputIterator, typename _RandomAccessIterator,
<         -: 5717:           typename _Size, typename _UniformRandomBitGenerator>
<         -: 5718:    _RandomAccessIterator
<         -: 5719:    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
<         -: 5720:	     _RandomAccessIterator __out, random_access_iterator_tag,
<         -: 5721:	     _Size __n, _UniformRandomBitGenerator&& __g)
<         -: 5722:    {
<         -: 5723:      using __distrib_type = uniform_int_distribution<_Size>;
<         -: 5724:      using __param_type = typename __distrib_type::param_type;
<         -: 5725:      __distrib_type __d{};
<         -: 5726:      _Size __sample_sz = 0;
<         -: 5727:      while (__first != __last && __sample_sz != __n)
---
>         -: 5528:  /**
>         -: 5529:   *  @brief  Return the symmetric difference of two sorted ranges using
>         -: 5530:   *  comparison functor.
>         -: 5531:   *  @ingroup set_algorithms
>         -: 5532:   *  @param  __first1  Start of first range.
>         -: 5533:   *  @param  __last1   End of first range.
>         -: 5534:   *  @param  __first2  Start of second range.
>         -: 5535:   *  @param  __last2   End of second range.
>         -: 5536:   *  @param  __comp    The comparison functor.
>         -: 5537:   *  @return  End of the output range.
>         -: 5538:   *  @ingroup set_algorithms
>         -: 5539:   *
>         -: 5540:   *  This operation iterates over both ranges, copying elements present in
>         -: 5541:   *  one range but not the other in order to the output range.  Iterators
>         -: 5542:   *  increment for each range.  When the current element of one range is less
>         -: 5543:   *  than the other according to @p comp, that element is copied and the
>         -: 5544:   *  iterator advances.  If an element is contained in both ranges according
>         -: 5545:   *  to @p __comp, no elements are copied and both ranges advance.  The output
>         -: 5546:   *  range may not overlap either input range.
>         -: 5547:  */
>         -: 5548:  template<typename _InputIterator1, typename _InputIterator2,
>         -: 5549:	   typename _OutputIterator, typename _Compare>
>         -: 5550:    inline _OutputIterator
>         -: 5551:    set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,
>         -: 5552:			     _InputIterator2 __first2, _InputIterator2 __last2,
>         -: 5553:			     _OutputIterator __result,
>         -: 5554:			     _Compare __comp)
>         -: 5555:    {
>         -: 5556:      // concept requirements
>         -: 5557:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)
>         -: 5558:      __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)
>         -: 5559:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5560:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5561:      __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,
>         -: 5562:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5563:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5564:	    typename iterator_traits<_InputIterator1>::value_type,
>         -: 5565:	    typename iterator_traits<_InputIterator2>::value_type>)
>         -: 5566:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5567:	    typename iterator_traits<_InputIterator2>::value_type,
>         -: 5568:	    typename iterator_traits<_InputIterator1>::value_type>)
>         -: 5569:      __glibcxx_requires_sorted_set_pred(__first1, __last1, __first2, __comp);
>         -: 5570:      __glibcxx_requires_sorted_set_pred(__first2, __last2, __first1, __comp);
>         -: 5571:      __glibcxx_requires_irreflexive_pred2(__first1, __last1, __comp);
>         -: 5572:      __glibcxx_requires_irreflexive_pred2(__first2, __last2, __comp);
>         -: 5573:
>         -: 5574:      return _GLIBCXX_STD_A::__set_symmetric_difference(__first1, __last1,
>         -: 5575:				__first2, __last2, __result,
>         -: 5576:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 5577:    }
>         -: 5578:
>         -: 5579:  template<typename _ForwardIterator, typename _Compare>
>         -: 5580:    _GLIBCXX14_CONSTEXPR
>         -: 5581:    _ForwardIterator
>         -: 5582:    __min_element(_ForwardIterator __first, _ForwardIterator __last,
>         -: 5583:		  _Compare __comp)
>         -: 5584:    {
>         -: 5585:      if (__first == __last)
>         -: 5586:	return __first;
>         -: 5587:      _ForwardIterator __result = __first;
>         -: 5588:      while (++__first != __last)
>         -: 5589:	if (__comp(__first, __result))
>         -: 5590:	  __result = __first;
>         -: 5591:      return __result;
>         -: 5592:    }
>         -: 5593:
>         -: 5594:  /**
>         -: 5595:   *  @brief  Return the minimum element in a range.
>         -: 5596:   *  @ingroup sorting_algorithms
>         -: 5597:   *  @param  __first  Start of range.
>         -: 5598:   *  @param  __last   End of range.
>         -: 5599:   *  @return  Iterator referencing the first instance of the smallest value.
>         -: 5600:  */
>         -: 5601:  template<typename _ForwardIterator>
>         -: 5602:    _GLIBCXX14_CONSTEXPR
>         -: 5603:    _ForwardIterator
>         -: 5604:    inline min_element(_ForwardIterator __first, _ForwardIterator __last)
>         -: 5605:    {
>         -: 5606:      // concept requirements
>         -: 5607:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 5608:      __glibcxx_function_requires(_LessThanComparableConcept<
>         -: 5609:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 5610:      __glibcxx_requires_valid_range(__first, __last);
>         -: 5611:      __glibcxx_requires_irreflexive(__first, __last);
>         -: 5612:
>         -: 5613:      return _GLIBCXX_STD_A::__min_element(__first, __last,
>         -: 5614:				__gnu_cxx::__ops::__iter_less_iter());
>         -: 5615:    }
>         -: 5616:
>         -: 5617:  /**
>         -: 5618:   *  @brief  Return the minimum element in a range using comparison functor.
>         -: 5619:   *  @ingroup sorting_algorithms
>         -: 5620:   *  @param  __first  Start of range.
>         -: 5621:   *  @param  __last   End of range.
>         -: 5622:   *  @param  __comp   Comparison functor.
>         -: 5623:   *  @return  Iterator referencing the first instance of the smallest value
>         -: 5624:   *  according to __comp.
>         -: 5625:  */
>         -: 5626:  template<typename _ForwardIterator, typename _Compare>
>         -: 5627:    _GLIBCXX14_CONSTEXPR
>         -: 5628:    inline _ForwardIterator
>         -: 5629:    min_element(_ForwardIterator __first, _ForwardIterator __last,
>         -: 5630:		_Compare __comp)
>         -: 5631:    {
>         -: 5632:      // concept requirements
>         -: 5633:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 5634:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5635:	    typename iterator_traits<_ForwardIterator>::value_type,
>         -: 5636:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 5637:      __glibcxx_requires_valid_range(__first, __last);
>         -: 5638:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
>         -: 5639:
>         -: 5640:      return _GLIBCXX_STD_A::__min_element(__first, __last,
>         -: 5641:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 5642:    }
>         -: 5643:
>         -: 5644:  template<typename _ForwardIterator, typename _Compare>
>         -: 5645:    _GLIBCXX14_CONSTEXPR
>         -: 5646:    _ForwardIterator
>         -: 5647:    __max_element(_ForwardIterator __first, _ForwardIterator __last,
>         -: 5648:		  _Compare __comp)
>         -: 5649:    {
>         -: 5650:      if (__first == __last) return __first;
>         -: 5651:      _ForwardIterator __result = __first;
>         -: 5652:      while (++__first != __last)
>         -: 5653:	if (__comp(__result, __first))
>         -: 5654:	  __result = __first;
>         -: 5655:      return __result;
>         -: 5656:    }
>         -: 5657:
>         -: 5658:  /**
>         -: 5659:   *  @brief  Return the maximum element in a range.
>         -: 5660:   *  @ingroup sorting_algorithms
>         -: 5661:   *  @param  __first  Start of range.
>         -: 5662:   *  @param  __last   End of range.
>         -: 5663:   *  @return  Iterator referencing the first instance of the largest value.
>         -: 5664:  */
>         -: 5665:  template<typename _ForwardIterator>
>         -: 5666:    _GLIBCXX14_CONSTEXPR
>         -: 5667:    inline _ForwardIterator
>         -: 5668:    max_element(_ForwardIterator __first, _ForwardIterator __last)
>         -: 5669:    {
>         -: 5670:      // concept requirements
>         -: 5671:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 5672:      __glibcxx_function_requires(_LessThanComparableConcept<
>         -: 5673:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 5674:      __glibcxx_requires_valid_range(__first, __last);
>         -: 5675:      __glibcxx_requires_irreflexive(__first, __last);
>         -: 5676:
>         -: 5677:      return _GLIBCXX_STD_A::__max_element(__first, __last,
>         -: 5678:				__gnu_cxx::__ops::__iter_less_iter());
>         -: 5679:    }
>         -: 5680:
>         -: 5681:  /**
>         -: 5682:   *  @brief  Return the maximum element in a range using comparison functor.
>         -: 5683:   *  @ingroup sorting_algorithms
>         -: 5684:   *  @param  __first  Start of range.
>         -: 5685:   *  @param  __last   End of range.
>         -: 5686:   *  @param  __comp   Comparison functor.
>         -: 5687:   *  @return  Iterator referencing the first instance of the largest value
>         -: 5688:   *  according to __comp.
>         -: 5689:  */
>         -: 5690:  template<typename _ForwardIterator, typename _Compare>
>         -: 5691:    _GLIBCXX14_CONSTEXPR
>         -: 5692:    inline _ForwardIterator
>         -: 5693:    max_element(_ForwardIterator __first, _ForwardIterator __last,
>         -: 5694:		_Compare __comp)
>         -: 5695:    {
>         -: 5696:      // concept requirements
>         -: 5697:      __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
>         -: 5698:      __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,
>         -: 5699:	    typename iterator_traits<_ForwardIterator>::value_type,
>         -: 5700:	    typename iterator_traits<_ForwardIterator>::value_type>)
>         -: 5701:      __glibcxx_requires_valid_range(__first, __last);
>         -: 5702:      __glibcxx_requires_irreflexive_pred(__first, __last, __comp);
>         -: 5703:
>         -: 5704:      return _GLIBCXX_STD_A::__max_element(__first, __last,
>         -: 5705:				__gnu_cxx::__ops::__iter_comp_iter(__comp));
>         -: 5706:    }
>         -: 5707:
>         -: 5708:#if __cplusplus >= 201402L
>         -: 5709:  /// Reservoir sampling algorithm.
>         -: 5710:  template<typename _InputIterator, typename _RandomAccessIterator,
>         -: 5711:           typename _Size, typename _UniformRandomBitGenerator>
>         -: 5712:    _RandomAccessIterator
>         -: 5713:    __sample(_InputIterator __first, _InputIterator __last, input_iterator_tag,
>         -: 5714:	     _RandomAccessIterator __out, random_access_iterator_tag,
>         -: 5715:	     _Size __n, _UniformRandomBitGenerator&& __g)
>         -: 5716:    {
>         -: 5717:      using __distrib_type = uniform_int_distribution<_Size>;
>         -: 5718:      using __param_type = typename __distrib_type::param_type;
>         -: 5719:      __distrib_type __d{};
>         -: 5720:      _Size __sample_sz = 0;
>         -: 5721:      while (__first != __last && __sample_sz != __n)
>         -: 5722:	{
>         -: 5723:	  __out[__sample_sz++] = *__first;
>         -: 5724:	  ++__first;
>         -: 5725:	}
>         -: 5726:      for (auto __pop_sz = __sample_sz; __first != __last;
>         -: 5727:	  ++__first, (void) ++__pop_sz)
5731,5792c5731,5792
<         -: 5729:	  __out[__sample_sz++] = *__first;
<         -: 5730:	  ++__first;
<         -: 5731:	}
<         -: 5732:      for (auto __pop_sz = __sample_sz; __first != __last;
<         -: 5733:	  ++__first, (void) ++__pop_sz)
<         -: 5734:	{
<         -: 5735:	  const auto __k = __d(__g, __param_type{0, __pop_sz});
<         -: 5736:	  if (__k < __n)
<         -: 5737:	    __out[__k] = *__first;
<         -: 5738:	}
<         -: 5739:      return __out + __sample_sz;
<         -: 5740:    }
<         -: 5741:
<         -: 5742:  /// Selection sampling algorithm.
<         -: 5743:  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
<         -: 5744:           typename _Size, typename _UniformRandomBitGenerator>
<         -: 5745:    _OutputIterator
<         -: 5746:    __sample(_ForwardIterator __first, _ForwardIterator __last,
<         -: 5747:	     forward_iterator_tag,
<         -: 5748:	     _OutputIterator __out, _Cat,
<         -: 5749:	     _Size __n, _UniformRandomBitGenerator&& __g)
<         -: 5750:    {
<         -: 5751:      using __distrib_type = uniform_int_distribution<_Size>;
<         -: 5752:      using __param_type = typename __distrib_type::param_type;
<         -: 5753:      using _USize = make_unsigned_t<_Size>;
<         -: 5754:      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
<         -: 5755:      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
<         -: 5756:
<         -: 5757:      __distrib_type __d{};
<         -: 5758:      _Size __unsampled_sz = std::distance(__first, __last);
<         -: 5759:      __n = std::min(__n, __unsampled_sz);
<         -: 5760:
<         -: 5761:      // If possible, we use __gen_two_uniform_ints to efficiently produce
<         -: 5762:      // two random numbers using a single distribution invocation:
<         -: 5763:
<         -: 5764:      const __uc_type __urngrange = __g.max() - __g.min();
<         -: 5765:      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))
<         -: 5766:        // I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without
<         -: 5767:	// wrapping issues.
<         -: 5768:        {
<         -: 5769:	  while (__n != 0 && __unsampled_sz >= 2)
<         -: 5770:	    {
<         -: 5771:	      const pair<_Size, _Size> __p =
<         -: 5772:		__gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);
<         -: 5773:
<         -: 5774:	      --__unsampled_sz;
<         -: 5775:	      if (__p.first < __n)
<         -: 5776:		{
<         -: 5777:		  *__out++ = *__first;
<         -: 5778:		  --__n;
<         -: 5779:		}
<         -: 5780:
<         -: 5781:	      ++__first;
<         -: 5782:
<         -: 5783:	      if (__n == 0) break;
<         -: 5784:
<         -: 5785:	      --__unsampled_sz;
<         -: 5786:	      if (__p.second < __n)
<         -: 5787:		{
<         -: 5788:		  *__out++ = *__first;
<         -: 5789:		  --__n;
<         -: 5790:		}
---
>         -: 5729:	  const auto __k = __d(__g, __param_type{0, __pop_sz});
>         -: 5730:	  if (__k < __n)
>         -: 5731:	    __out[__k] = *__first;
>         -: 5732:	}
>         -: 5733:      return __out + __sample_sz;
>         -: 5734:    }
>         -: 5735:
>         -: 5736:  /// Selection sampling algorithm.
>         -: 5737:  template<typename _ForwardIterator, typename _OutputIterator, typename _Cat,
>         -: 5738:           typename _Size, typename _UniformRandomBitGenerator>
>         -: 5739:    _OutputIterator
>         -: 5740:    __sample(_ForwardIterator __first, _ForwardIterator __last,
>         -: 5741:	     forward_iterator_tag,
>         -: 5742:	     _OutputIterator __out, _Cat,
>         -: 5743:	     _Size __n, _UniformRandomBitGenerator&& __g)
>         -: 5744:    {
>         -: 5745:      using __distrib_type = uniform_int_distribution<_Size>;
>         -: 5746:      using __param_type = typename __distrib_type::param_type;
>         -: 5747:      using _USize = make_unsigned_t<_Size>;
>         -: 5748:      using _Gen = remove_reference_t<_UniformRandomBitGenerator>;
>         -: 5749:      using __uc_type = common_type_t<typename _Gen::result_type, _USize>;
>         -: 5750:
>         -: 5751:      __distrib_type __d{};
>         -: 5752:      _Size __unsampled_sz = std::distance(__first, __last);
>         -: 5753:      __n = std::min(__n, __unsampled_sz);
>         -: 5754:
>         -: 5755:      // If possible, we use __gen_two_uniform_ints to efficiently produce
>         -: 5756:      // two random numbers using a single distribution invocation:
>         -: 5757:
>         -: 5758:      const __uc_type __urngrange = __g.max() - __g.min();
>         -: 5759:      if (__urngrange / __uc_type(__unsampled_sz) >= __uc_type(__unsampled_sz))
>         -: 5760:        // I.e. (__urngrange >= __unsampled_sz * __unsampled_sz) but without
>         -: 5761:	// wrapping issues.
>         -: 5762:        {
>         -: 5763:	  while (__n != 0 && __unsampled_sz >= 2)
>         -: 5764:	    {
>         -: 5765:	      const pair<_Size, _Size> __p =
>         -: 5766:		__gen_two_uniform_ints(__unsampled_sz, __unsampled_sz - 1, __g);
>         -: 5767:
>         -: 5768:	      --__unsampled_sz;
>         -: 5769:	      if (__p.first < __n)
>         -: 5770:		{
>         -: 5771:		  *__out++ = *__first;
>         -: 5772:		  --__n;
>         -: 5773:		}
>         -: 5774:
>         -: 5775:	      ++__first;
>         -: 5776:
>         -: 5777:	      if (__n == 0) break;
>         -: 5778:
>         -: 5779:	      --__unsampled_sz;
>         -: 5780:	      if (__p.second < __n)
>         -: 5781:		{
>         -: 5782:		  *__out++ = *__first;
>         -: 5783:		  --__n;
>         -: 5784:		}
>         -: 5785:
>         -: 5786:	      ++__first;
>         -: 5787:	    }
>         -: 5788:        }
>         -: 5789:
>         -: 5790:      // The loop above is otherwise equivalent to this one-at-a-time version:
5794,5822c5794,5822
<         -: 5792:	      ++__first;
<         -: 5793:	    }
<         -: 5794:        }
<         -: 5795:
<         -: 5796:      // The loop above is otherwise equivalent to this one-at-a-time version:
<         -: 5797:
<         -: 5798:      for (; __n != 0; ++__first)
<         -: 5799:	if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
<         -: 5800:	  {
<         -: 5801:	    *__out++ = *__first;
<         -: 5802:	    --__n;
<         -: 5803:	  }
<         -: 5804:      return __out;
<         -: 5805:    }
<         -: 5806:
<         -: 5807:#if __cplusplus > 201402L
<         -: 5808:#define __cpp_lib_sample 201603
<         -: 5809:  /// Take a random sample from a population.
<         -: 5810:  template<typename _PopulationIterator, typename _SampleIterator,
<         -: 5811:           typename _Distance, typename _UniformRandomBitGenerator>
<         -: 5812:    _SampleIterator
<         -: 5813:    sample(_PopulationIterator __first, _PopulationIterator __last,
<         -: 5814:	   _SampleIterator __out, _Distance __n,
<         -: 5815:	   _UniformRandomBitGenerator&& __g)
<         -: 5816:    {
<         -: 5817:      using __pop_cat = typename
<         -: 5818:	std::iterator_traits<_PopulationIterator>::iterator_category;
<         -: 5819:      using __samp_cat = typename
<         -: 5820:	std::iterator_traits<_SampleIterator>::iterator_category;
---
>         -: 5792:      for (; __n != 0; ++__first)
>         -: 5793:	if (__d(__g, __param_type{0, --__unsampled_sz}) < __n)
>         -: 5794:	  {
>         -: 5795:	    *__out++ = *__first;
>         -: 5796:	    --__n;
>         -: 5797:	  }
>         -: 5798:      return __out;
>         -: 5799:    }
>         -: 5800:
>         -: 5801:#if __cplusplus > 201402L
>         -: 5802:#define __cpp_lib_sample 201603
>         -: 5803:  /// Take a random sample from a population.
>         -: 5804:  template<typename _PopulationIterator, typename _SampleIterator,
>         -: 5805:           typename _Distance, typename _UniformRandomBitGenerator>
>         -: 5806:    _SampleIterator
>         -: 5807:    sample(_PopulationIterator __first, _PopulationIterator __last,
>         -: 5808:	   _SampleIterator __out, _Distance __n,
>         -: 5809:	   _UniformRandomBitGenerator&& __g)
>         -: 5810:    {
>         -: 5811:      using __pop_cat = typename
>         -: 5812:	std::iterator_traits<_PopulationIterator>::iterator_category;
>         -: 5813:      using __samp_cat = typename
>         -: 5814:	std::iterator_traits<_SampleIterator>::iterator_category;
>         -: 5815:
>         -: 5816:      static_assert(
>         -: 5817:	  __or_<is_convertible<__pop_cat, forward_iterator_tag>,
>         -: 5818:		is_convertible<__samp_cat, random_access_iterator_tag>>::value,
>         -: 5819:	  "output range must use a RandomAccessIterator when input range"
>         -: 5820:	  " does not meet the ForwardIterator requirements");
5824,5845c5824,5838
<         -: 5822:      static_assert(
<         -: 5823:	  __or_<is_convertible<__pop_cat, forward_iterator_tag>,
<         -: 5824:		is_convertible<__samp_cat, random_access_iterator_tag>>::value,
<         -: 5825:	  "output range must use a RandomAccessIterator when input range"
<         -: 5826:	  " does not meet the ForwardIterator requirements");
<         -: 5827:
<         -: 5828:      static_assert(is_integral<_Distance>::value,
<         -: 5829:		    "sample size must be an integer type");
<         -: 5830:
<         -: 5831:      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
<         -: 5832:      return _GLIBCXX_STD_A::
<         -: 5833:	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
<         -: 5834:		 std::forward<_UniformRandomBitGenerator>(__g));
<         -: 5835:    }
<         -: 5836:#endif // C++17
<         -: 5837:#endif // C++14
<         -: 5838:
<         -: 5839:_GLIBCXX_END_NAMESPACE_ALGO
<         -: 5840:_GLIBCXX_END_NAMESPACE_VERSION
<         -: 5841:} // namespace std
<         -: 5842:
<         -: 5843:#endif /* _STL_ALGO_H */
---
>         -: 5822:      static_assert(is_integral<_Distance>::value,
>         -: 5823:		    "sample size must be an integer type");
>         -: 5824:
>         -: 5825:      typename iterator_traits<_PopulationIterator>::difference_type __d = __n;
>         -: 5826:      return _GLIBCXX_STD_A::
>         -: 5827:	__sample(__first, __last, __pop_cat{}, __out, __samp_cat{}, __d,
>         -: 5828:		 std::forward<_UniformRandomBitGenerator>(__g));
>         -: 5829:    }
>         -: 5830:#endif // C++17
>         -: 5831:#endif // C++14
>         -: 5832:
>         -: 5833:_GLIBCXX_END_NAMESPACE_ALGO
>         -: 5834:} // namespace std
>         -: 5835:
>         -: 5836:#endif /* _STL_ALGO_H */
