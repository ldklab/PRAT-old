1,2c1,2
<         -:    0:Source:/usr/include/c++/8/bits/vector.tcc
<         -:    0:Programs:51
---
>         -:    0:Source:/usr/include/c++/7/bits/vector.tcc
>         -:    0:Programs:3
5c5
<         -:    3:// Copyright (C) 2001-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 2001-2017 Free Software Foundation, Inc.
63,341c63,253
<         -:   61:_GLIBCXX_BEGIN_NAMESPACE_VERSION
<         -:   62:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
<         -:   63:
<         -:   64:  template<typename _Tp, typename _Alloc>
<         -:   65:    void
<        15:   66:    vector<_Tp, _Alloc>::
<         -:   67:    reserve(size_type __n)
<         -:   68:    {
<        15:   69:      if (__n > this->max_size())
<     #####:   70:	__throw_length_error(__N("vector::reserve"));
<        15:   71:      if (this->capacity() < __n)
<         -:   72:	{
<        15:   73:	  const size_type __old_size = size();
<        15:   74:	  pointer __tmp = _M_allocate_and_copy(__n,
<         -:   75:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
<         -:   76:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
<         -:   77:	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
<        15:   78:	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<        15:   79:			_M_get_Tp_allocator());
<        30:   80:	  _M_deallocate(this->_M_impl._M_start,
<        15:   81:			this->_M_impl._M_end_of_storage
<        15:   82:			- this->_M_impl._M_start);
<        15:   83:	  this->_M_impl._M_start = __tmp;
<        15:   84:	  this->_M_impl._M_finish = __tmp + __old_size;
<        15:   85:	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
<         -:   86:	}
<        15:   87:    }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE7reserveEm:
<         9:   66:    vector<_Tp, _Alloc>::
<         -:   67:    reserve(size_type __n)
<         -:   68:    {
<         9:   69:      if (__n > this->max_size())
<     #####:   70:	__throw_length_error(__N("vector::reserve"));
<         9:   71:      if (this->capacity() < __n)
<         -:   72:	{
<         9:   73:	  const size_type __old_size = size();
<         9:   74:	  pointer __tmp = _M_allocate_and_copy(__n,
<         -:   75:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
<         -:   76:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
<         -:   77:	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         9:   78:	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         9:   79:			_M_get_Tp_allocator());
<        18:   80:	  _M_deallocate(this->_M_impl._M_start,
<         9:   81:			this->_M_impl._M_end_of_storage
<         9:   82:			- this->_M_impl._M_start);
<         9:   83:	  this->_M_impl._M_start = __tmp;
<         9:   84:	  this->_M_impl._M_finish = __tmp + __old_size;
<         9:   85:	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
<         -:   86:	}
<         9:   87:    }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE7reserveEm:
<         6:   66:    vector<_Tp, _Alloc>::
<         -:   67:    reserve(size_type __n)
<         -:   68:    {
<         6:   69:      if (__n > this->max_size())
<     #####:   70:	__throw_length_error(__N("vector::reserve"));
<         6:   71:      if (this->capacity() < __n)
<         -:   72:	{
<         6:   73:	  const size_type __old_size = size();
<         6:   74:	  pointer __tmp = _M_allocate_and_copy(__n,
<         -:   75:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
<         -:   76:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
<         -:   77:	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         6:   78:	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         6:   79:			_M_get_Tp_allocator());
<        12:   80:	  _M_deallocate(this->_M_impl._M_start,
<         6:   81:			this->_M_impl._M_end_of_storage
<         6:   82:			- this->_M_impl._M_start);
<         6:   83:	  this->_M_impl._M_start = __tmp;
<         6:   84:	  this->_M_impl._M_finish = __tmp + __old_size;
<         6:   85:	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
<         -:   86:	}
<         6:   87:    }
< ------------------
<         -:   88:
<         -:   89:#if __cplusplus >= 201103L
<         -:   90:  template<typename _Tp, typename _Alloc>
<         -:   91:    template<typename... _Args>
<         -:   92:#if __cplusplus > 201402L
<         -:   93:      typename vector<_Tp, _Alloc>::reference
<         -:   94:#else
<         -:   95:      void
<         -:   96:#endif
<        47:   97:      vector<_Tp, _Alloc>::
<         -:   98:      emplace_back(_Args&&... __args)
<         -:   99:      {
<        47:  100:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -:  101:	  {
<         -:  102:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<       45*:  103:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -:  104:				     std::forward<_Args>(__args)...);
<       45*:  105:	    ++this->_M_impl._M_finish;
<         -:  106:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  107:	  }
<         -:  108:	else
<        2*:  109:	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
<         -:  110:#if __cplusplus > 201402L
<         -:  111:	return back();
<         -:  112:#endif
<        47:  113:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE12emplace_backIJS7_EEEvDpOT_:
<         2:   97:      vector<_Tp, _Alloc>::
<         -:   98:      emplace_back(_Args&&... __args)
<         -:   99:      {
<         2:  100:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -:  101:	  {
<         -:  102:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####:  103:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -:  104:				     std::forward<_Args>(__args)...);
<     #####:  105:	    ++this->_M_impl._M_finish;
<         -:  106:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  107:	  }
<         -:  108:	else
<         2:  109:	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
<         -:  110:#if __cplusplus > 201402L
<         -:  111:	return back();
<         -:  112:#endif
<         2:  113:      }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE12emplace_backIJS7_EEEvDpOT_:
<        45:   97:      vector<_Tp, _Alloc>::
<         -:   98:      emplace_back(_Args&&... __args)
<         -:   99:      {
<        45:  100:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -:  101:	  {
<         -:  102:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<        45:  103:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -:  104:				     std::forward<_Args>(__args)...);
<        45:  105:	    ++this->_M_impl._M_finish;
<         -:  106:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  107:	  }
<         -:  108:	else
<     #####:  109:	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
<         -:  110:#if __cplusplus > 201402L
<         -:  111:	return back();
<         -:  112:#endif
<        45:  113:      }
< ------------------
<         -:  114:#endif
<         -:  115:
<         -:  116:  template<typename _Tp, typename _Alloc>
<         -:  117:    typename vector<_Tp, _Alloc>::iterator
<        89:  118:    vector<_Tp, _Alloc>::
<         -:  119:#if __cplusplus >= 201103L
<         -:  120:    insert(const_iterator __position, const value_type& __x)
<         -:  121:#else
<         -:  122:    insert(iterator __position, const value_type& __x)
<         -:  123:#endif
<         -:  124:    {
<        89:  125:      const size_type __n = __position - begin();
<        89:  126:      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<     #####:  127:	if (__position == end())
<         -:  128:	  {
<         -:  129:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####:  130:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -:  131:				     __x);
<     #####:  132:	    ++this->_M_impl._M_finish;
<         -:  133:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  134:	  }
<         -:  135:	else
<         -:  136:	  {
<         -:  137:#if __cplusplus >= 201103L
<     #####:  138:	    const auto __pos = begin() + (__position - cbegin());
<         -:  139:	    // __x could be an existing element of this vector, so make a
<         -:  140:	    // copy of it before _M_insert_aux moves elements around.
<     #####:  141:	    _Temporary_value __x_copy(this, __x);
<     #####:  142:	    _M_insert_aux(__pos, std::move(__x_copy._M_val()));
<         -:  143:#else
<         -:  144:	    _M_insert_aux(__position, __x);
<         -:  145:#endif
<         -:  146:	  }
<         -:  147:      else
<         -:  148:#if __cplusplus >= 201103L
<        89:  149:	_M_realloc_insert(begin() + (__position - cbegin()), __x);
<         -:  150:#else
<         -:  151:	_M_realloc_insert(__position, __x);
<         -:  152:#endif
<         -:  153:
<        89:  154:      return iterator(this->_M_impl._M_start + __n);
<         -:  155:    }
<         -:  156:
<         -:  157:  template<typename _Tp, typename _Alloc>
<         -:  158:    typename vector<_Tp, _Alloc>::iterator
<         4:  159:    vector<_Tp, _Alloc>::
<         -:  160:    _M_erase(iterator __position)
<         -:  161:    {
<         4:  162:      if (__position + 1 != end())
<         2:  163:	_GLIBCXX_MOVE3(__position + 1, end(), __position);
<         4:  164:      --this->_M_impl._M_finish;
<         4:  165:      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
<         -:  166:      _GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
<         4:  167:      return __position;
<         -:  168:    }
<         -:  169:
<         -:  170:  template<typename _Tp, typename _Alloc>
<         -:  171:    typename vector<_Tp, _Alloc>::iterator
<         1:  172:    vector<_Tp, _Alloc>::
<         -:  173:    _M_erase(iterator __first, iterator __last)
<         -:  174:    {
<         1:  175:      if (__first != __last)
<         -:  176:	{
<     #####:  177:	  if (__last != end())
<     #####:  178:	    _GLIBCXX_MOVE3(__last, end(), __first);
<     #####:  179:	  _M_erase_at_end(__first.base() + (end() - __last));
<         -:  180:	}
<         1:  181:      return __first;
<         -:  182:    }
<         -:  183:
<         -:  184:  template<typename _Tp, typename _Alloc>
<         -:  185:    vector<_Tp, _Alloc>&
<         -:  186:    vector<_Tp, _Alloc>::
<         -:  187:    operator=(const vector<_Tp, _Alloc>& __x)
<         -:  188:    {
<         -:  189:      if (&__x != this)
<         -:  190:	{
<         -:  191:	  _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         -:  192:#if __cplusplus >= 201103L
<         -:  193:	  if (_Alloc_traits::_S_propagate_on_copy_assign())
<         -:  194:	    {
<         -:  195:	      if (!_Alloc_traits::_S_always_equal()
<         -:  196:	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
<         -:  197:	        {
<         -:  198:		  // replacement allocator cannot free existing storage
<         -:  199:		  this->clear();
<         -:  200:		  _M_deallocate(this->_M_impl._M_start,
<         -:  201:				this->_M_impl._M_end_of_storage
<         -:  202:				- this->_M_impl._M_start);
<         -:  203:		  this->_M_impl._M_start = nullptr;
<         -:  204:		  this->_M_impl._M_finish = nullptr;
<         -:  205:		  this->_M_impl._M_end_of_storage = nullptr;
<         -:  206:		}
<         -:  207:	      std::__alloc_on_copy(_M_get_Tp_allocator(),
<         -:  208:				   __x._M_get_Tp_allocator());
<         -:  209:	    }
<         -:  210:#endif
<         -:  211:	  const size_type __xlen = __x.size();
<         -:  212:	  if (__xlen > capacity())
<         -:  213:	    {
<         -:  214:	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
<         -:  215:						   __x.end());
<         -:  216:	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         -:  217:			    _M_get_Tp_allocator());
<         -:  218:	      _M_deallocate(this->_M_impl._M_start,
<         -:  219:			    this->_M_impl._M_end_of_storage
<         -:  220:			    - this->_M_impl._M_start);
<         -:  221:	      this->_M_impl._M_start = __tmp;
<         -:  222:	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
<         -:  223:	    }
<         -:  224:	  else if (size() >= __xlen)
<         -:  225:	    {
<         -:  226:	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
<         -:  227:			    end(), _M_get_Tp_allocator());
<         -:  228:	    }
<         -:  229:	  else
<         -:  230:	    {
<         -:  231:	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
<         -:  232:			this->_M_impl._M_start);
<         -:  233:	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
<         -:  234:					  __x._M_impl._M_finish,
<         -:  235:					  this->_M_impl._M_finish,
<         -:  236:					  _M_get_Tp_allocator());
<         -:  237:	    }
<         -:  238:	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
<         -:  239:	}
<         -:  240:      return *this;
<         -:  241:    }
<         -:  242:
<         -:  243:  template<typename _Tp, typename _Alloc>
<         -:  244:    void
<         -:  245:    vector<_Tp, _Alloc>::
<         -:  246:    _M_fill_assign(size_t __n, const value_type& __val)
<         -:  247:    {
<         -:  248:      if (__n > capacity())
<         -:  249:	{
<         -:  250:	  vector __tmp(__n, __val, _M_get_Tp_allocator());
<         -:  251:	  __tmp._M_impl._M_swap_data(this->_M_impl);
---
>         -:   61:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
>         -:   62:
>         -:   63:  template<typename _Tp, typename _Alloc>
>         -:   64:    void
>         -:   65:    vector<_Tp, _Alloc>::
>         -:   66:    reserve(size_type __n)
>         -:   67:    {
>         -:   68:      if (__n > this->max_size())
>         -:   69:	__throw_length_error(__N("vector::reserve"));
>         -:   70:      if (this->capacity() < __n)
>         -:   71:	{
>         -:   72:	  const size_type __old_size = size();
>         -:   73:	  pointer __tmp = _M_allocate_and_copy(__n,
>         -:   74:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_start),
>         -:   75:	    _GLIBCXX_MAKE_MOVE_IF_NOEXCEPT_ITERATOR(this->_M_impl._M_finish));
>         -:   76:	  std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:   77:			_M_get_Tp_allocator());
>         -:   78:	  _M_deallocate(this->_M_impl._M_start,
>         -:   79:			this->_M_impl._M_end_of_storage
>         -:   80:			- this->_M_impl._M_start);
>         -:   81:	  this->_M_impl._M_start = __tmp;
>         -:   82:	  this->_M_impl._M_finish = __tmp + __old_size;
>         -:   83:	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
>         -:   84:	}
>         -:   85:    }
>         -:   86:
>         -:   87:#if __cplusplus >= 201103L
>         -:   88:  template<typename _Tp, typename _Alloc>
>         -:   89:    template<typename... _Args>
>         -:   90:#if __cplusplus > 201402L
>         -:   91:      typename vector<_Tp, _Alloc>::reference
>         -:   92:#else
>         -:   93:      void
>         -:   94:#endif
>     #####:   95:      vector<_Tp, _Alloc>::
>         -:   96:      emplace_back(_Args&&... __args)
>         -:   97:      {
>     #####:   98:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
>         -:   99:	  {
>     #####:  100:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
>         -:  101:				     std::forward<_Args>(__args)...);
>     #####:  102:	    ++this->_M_impl._M_finish;
>         -:  103:	  }
>         -:  104:	else
>     #####:  105:	  _M_realloc_insert(end(), std::forward<_Args>(__args)...);
>         -:  106:#if __cplusplus > 201402L
>         -:  107:	return back();
>         -:  108:#endif
>     #####:  109:      }
>         -:  110:#endif
>         -:  111:
>         -:  112:  template<typename _Tp, typename _Alloc>
>         -:  113:    typename vector<_Tp, _Alloc>::iterator
>         -:  114:    vector<_Tp, _Alloc>::
>         -:  115:#if __cplusplus >= 201103L
>         -:  116:    insert(const_iterator __position, const value_type& __x)
>         -:  117:#else
>         -:  118:    insert(iterator __position, const value_type& __x)
>         -:  119:#endif
>         -:  120:    {
>         -:  121:      const size_type __n = __position - begin();
>         -:  122:      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
>         -:  123:	if (__position == end())
>         -:  124:	  {
>         -:  125:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
>         -:  126:				     __x);
>         -:  127:	    ++this->_M_impl._M_finish;
>         -:  128:	  }
>         -:  129:	else
>         -:  130:	  {
>         -:  131:#if __cplusplus >= 201103L
>         -:  132:	    const auto __pos = begin() + (__position - cbegin());
>         -:  133:	    // __x could be an existing element of this vector, so make a
>         -:  134:	    // copy of it before _M_insert_aux moves elements around.
>         -:  135:	    _Temporary_value __x_copy(this, __x);
>         -:  136:	    _M_insert_aux(__pos, std::move(__x_copy._M_val()));
>         -:  137:#else
>         -:  138:	    _M_insert_aux(__position, __x);
>         -:  139:#endif
>         -:  140:	  }
>         -:  141:      else
>         -:  142:#if __cplusplus >= 201103L
>         -:  143:	_M_realloc_insert(begin() + (__position - cbegin()), __x);
>         -:  144:#else
>         -:  145:	_M_realloc_insert(__position, __x);
>         -:  146:#endif
>         -:  147:
>         -:  148:      return iterator(this->_M_impl._M_start + __n);
>         -:  149:    }
>         -:  150:
>         -:  151:  template<typename _Tp, typename _Alloc>
>         -:  152:    typename vector<_Tp, _Alloc>::iterator
>         -:  153:    vector<_Tp, _Alloc>::
>         -:  154:    _M_erase(iterator __position)
>         -:  155:    {
>         -:  156:      if (__position + 1 != end())
>         -:  157:	_GLIBCXX_MOVE3(__position + 1, end(), __position);
>         -:  158:      --this->_M_impl._M_finish;
>         -:  159:      _Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
>         -:  160:      return __position;
>         -:  161:    }
>         -:  162:
>         -:  163:  template<typename _Tp, typename _Alloc>
>         -:  164:    typename vector<_Tp, _Alloc>::iterator
>         -:  165:    vector<_Tp, _Alloc>::
>         -:  166:    _M_erase(iterator __first, iterator __last)
>         -:  167:    {
>         -:  168:      if (__first != __last)
>         -:  169:	{
>         -:  170:	  if (__last != end())
>         -:  171:	    _GLIBCXX_MOVE3(__last, end(), __first);
>         -:  172:	  _M_erase_at_end(__first.base() + (end() - __last));
>         -:  173:	}
>         -:  174:      return __first;
>         -:  175:    }
>         -:  176:
>         -:  177:  template<typename _Tp, typename _Alloc>
>         -:  178:    vector<_Tp, _Alloc>&
>         -:  179:    vector<_Tp, _Alloc>::
>         -:  180:    operator=(const vector<_Tp, _Alloc>& __x)
>         -:  181:    {
>         -:  182:      if (&__x != this)
>         -:  183:	{
>         -:  184:#if __cplusplus >= 201103L
>         -:  185:	  if (_Alloc_traits::_S_propagate_on_copy_assign())
>         -:  186:	    {
>         -:  187:	      if (!_Alloc_traits::_S_always_equal()
>         -:  188:	          && _M_get_Tp_allocator() != __x._M_get_Tp_allocator())
>         -:  189:	        {
>         -:  190:		  // replacement allocator cannot free existing storage
>         -:  191:		  this->clear();
>         -:  192:		  _M_deallocate(this->_M_impl._M_start,
>         -:  193:				this->_M_impl._M_end_of_storage
>         -:  194:				- this->_M_impl._M_start);
>         -:  195:		  this->_M_impl._M_start = nullptr;
>         -:  196:		  this->_M_impl._M_finish = nullptr;
>         -:  197:		  this->_M_impl._M_end_of_storage = nullptr;
>         -:  198:		}
>         -:  199:	      std::__alloc_on_copy(_M_get_Tp_allocator(),
>         -:  200:				   __x._M_get_Tp_allocator());
>         -:  201:	    }
>         -:  202:#endif
>         -:  203:	  const size_type __xlen = __x.size();
>         -:  204:	  if (__xlen > capacity())
>         -:  205:	    {
>         -:  206:	      pointer __tmp = _M_allocate_and_copy(__xlen, __x.begin(),
>         -:  207:						   __x.end());
>         -:  208:	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:  209:			    _M_get_Tp_allocator());
>         -:  210:	      _M_deallocate(this->_M_impl._M_start,
>         -:  211:			    this->_M_impl._M_end_of_storage
>         -:  212:			    - this->_M_impl._M_start);
>         -:  213:	      this->_M_impl._M_start = __tmp;
>         -:  214:	      this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __xlen;
>         -:  215:	    }
>         -:  216:	  else if (size() >= __xlen)
>         -:  217:	    {
>         -:  218:	      std::_Destroy(std::copy(__x.begin(), __x.end(), begin()),
>         -:  219:			    end(), _M_get_Tp_allocator());
>         -:  220:	    }
>         -:  221:	  else
>         -:  222:	    {
>         -:  223:	      std::copy(__x._M_impl._M_start, __x._M_impl._M_start + size(),
>         -:  224:			this->_M_impl._M_start);
>         -:  225:	      std::__uninitialized_copy_a(__x._M_impl._M_start + size(),
>         -:  226:					  __x._M_impl._M_finish,
>         -:  227:					  this->_M_impl._M_finish,
>         -:  228:					  _M_get_Tp_allocator());
>         -:  229:	    }
>         -:  230:	  this->_M_impl._M_finish = this->_M_impl._M_start + __xlen;
>         -:  231:	}
>         -:  232:      return *this;
>         -:  233:    }
>         -:  234:
>         -:  235:  template<typename _Tp, typename _Alloc>
>         -:  236:    void
>         -:  237:    vector<_Tp, _Alloc>::
>         -:  238:    _M_fill_assign(size_t __n, const value_type& __val)
>         -:  239:    {
>         -:  240:      if (__n > capacity())
>         -:  241:	{
>         -:  242:	  vector __tmp(__n, __val, _M_get_Tp_allocator());
>         -:  243:	  __tmp._M_impl._M_swap_data(this->_M_impl);
>         -:  244:	}
>         -:  245:      else if (__n > size())
>         -:  246:	{
>         -:  247:	  std::fill(begin(), end(), __val);
>         -:  248:	  this->_M_impl._M_finish =
>         -:  249:	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
>         -:  250:					  __n - size(), __val,
>         -:  251:					  _M_get_Tp_allocator());
343,1490c255,697
<         -:  253:      else if (__n > size())
<         -:  254:	{
<         -:  255:	  std::fill(begin(), end(), __val);
<         -:  256:	  const size_type __add = __n - size();
<         -:  257:	  _GLIBCXX_ASAN_ANNOTATE_GROW(__add);
<         -:  258:	  this->_M_impl._M_finish =
<         -:  259:	    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
<         -:  260:					  __add, __val, _M_get_Tp_allocator());
<         -:  261:	  _GLIBCXX_ASAN_ANNOTATE_GREW(__add);
<         -:  262:	}
<         -:  263:      else
<         -:  264:        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
<         -:  265:    }
<         -:  266:
<         -:  267:  template<typename _Tp, typename _Alloc>
<         -:  268:    template<typename _InputIterator>
<         -:  269:      void
<         -:  270:      vector<_Tp, _Alloc>::
<         -:  271:      _M_assign_aux(_InputIterator __first, _InputIterator __last,
<         -:  272:		    std::input_iterator_tag)
<         -:  273:      {
<         -:  274:	pointer __cur(this->_M_impl._M_start);
<         -:  275:	for (; __first != __last && __cur != this->_M_impl._M_finish;
<         -:  276:	     ++__cur, ++__first)
<         -:  277:	  *__cur = *__first;
<         -:  278:	if (__first == __last)
<         -:  279:	  _M_erase_at_end(__cur);
<         -:  280:	else
<         -:  281:	  _M_range_insert(end(), __first, __last,
<         -:  282:			  std::__iterator_category(__first));
<         -:  283:      }
<         -:  284:
<         -:  285:  template<typename _Tp, typename _Alloc>
<         -:  286:    template<typename _ForwardIterator>
<         -:  287:      void
<         -:  288:      vector<_Tp, _Alloc>::
<         -:  289:      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
<         -:  290:		    std::forward_iterator_tag)
<         -:  291:      {
<         -:  292:	const size_type __len = std::distance(__first, __last);
<         -:  293:
<         -:  294:	if (__len > capacity())
<         -:  295:	  {
<         -:  296:	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
<         -:  297:	    _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         -:  298:	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         -:  299:			  _M_get_Tp_allocator());
<         -:  300:	    _M_deallocate(this->_M_impl._M_start,
<         -:  301:			  this->_M_impl._M_end_of_storage
<         -:  302:			  - this->_M_impl._M_start);
<         -:  303:	    this->_M_impl._M_start = __tmp;
<         -:  304:	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
<         -:  305:	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
<         -:  306:	  }
<         -:  307:	else if (size() >= __len)
<         -:  308:	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
<         -:  309:	else
<         -:  310:	  {
<         -:  311:	    _ForwardIterator __mid = __first;
<         -:  312:	    std::advance(__mid, size());
<         -:  313:	    std::copy(__first, __mid, this->_M_impl._M_start);
<         -:  314:	    const size_type __attribute__((__unused__)) __n = __len - size();
<         -:  315:	    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
<         -:  316:	    this->_M_impl._M_finish =
<         -:  317:	      std::__uninitialized_copy_a(__mid, __last,
<         -:  318:					  this->_M_impl._M_finish,
<         -:  319:					  _M_get_Tp_allocator());
<         -:  320:	    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
<         -:  321:	  }
<         -:  322:      }
<         -:  323:
<         -:  324:#if __cplusplus >= 201103L
<         -:  325:  template<typename _Tp, typename _Alloc>
<         -:  326:    auto
<         -:  327:    vector<_Tp, _Alloc>::
<         -:  328:    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
<         -:  329:    {
<         -:  330:      const auto __n = __position - cbegin();
<         -:  331:      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -:  332:	if (__position == cend())
<         -:  333:	  {
<         -:  334:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<         -:  335:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -:  336:				     std::move(__v));
<         -:  337:	    ++this->_M_impl._M_finish;
<         -:  338:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  339:	  }
<         -:  340:	else
<         -:  341:	  _M_insert_aux(begin() + __n, std::move(__v));
<         -:  342:      else
<         -:  343:	_M_realloc_insert(begin() + __n, std::move(__v));
<         -:  344:
<         -:  345:      return iterator(this->_M_impl._M_start + __n);
<         -:  346:    }
<         -:  347:
<         -:  348:  template<typename _Tp, typename _Alloc>
<         -:  349:    template<typename... _Args>
<         -:  350:      auto
<         -:  351:      vector<_Tp, _Alloc>::
<         -:  352:      _M_emplace_aux(const_iterator __position, _Args&&... __args)
<         -:  353:      -> iterator
<         -:  354:      {
<         -:  355:	const auto __n = __position - cbegin();
<         -:  356:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -:  357:	  if (__position == cend())
<         -:  358:	    {
<         -:  359:	      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<         -:  360:	      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -:  361:				       std::forward<_Args>(__args)...);
<         -:  362:	      ++this->_M_impl._M_finish;
<         -:  363:	      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  364:	    }
<         -:  365:	  else
<         -:  366:	    {
<         -:  367:	      // We need to construct a temporary because something in __args...
<         -:  368:	      // could alias one of the elements of the container and so we
<         -:  369:	      // need to use it before _M_insert_aux moves elements around.
<         -:  370:	      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
<         -:  371:	      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
<         -:  372:	    }
<         -:  373:	else
<         -:  374:	  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
<         -:  375:
<         -:  376:	return iterator(this->_M_impl._M_start + __n);
<         -:  377:      }
<         -:  378:
<         -:  379:  template<typename _Tp, typename _Alloc>
<         -:  380:    template<typename _Arg>
<         -:  381:      void
<     #####:  382:      vector<_Tp, _Alloc>::
<         -:  383:      _M_insert_aux(iterator __position, _Arg&& __arg)
<         -:  384:#else
<         -:  385:  template<typename _Tp, typename _Alloc>
<         -:  386:    void
<         -:  387:    vector<_Tp, _Alloc>::
<         -:  388:    _M_insert_aux(iterator __position, const _Tp& __x)
<         -:  389:#endif
<         -:  390:    {
<         -:  391:      _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####:  392:      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<     #####:  393:			       _GLIBCXX_MOVE(*(this->_M_impl._M_finish - 1)));
<     #####:  394:      ++this->_M_impl._M_finish;
<         -:  395:      _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -:  396:#if __cplusplus < 201103L
<         -:  397:      _Tp __x_copy = __x;
<         -:  398:#endif
<     #####:  399:      _GLIBCXX_MOVE_BACKWARD3(__position.base(),
<         -:  400:			      this->_M_impl._M_finish - 2,
<         -:  401:			      this->_M_impl._M_finish - 1);
<         -:  402:#if __cplusplus < 201103L
<         -:  403:      *__position = __x_copy;
<         -:  404:#else
<     #####:  405:      *__position = std::forward<_Arg>(__arg);
<         -:  406:#endif
<     #####:  407:    }
<         -:  408:
<         -:  409:#if __cplusplus >= 201103L
<         -:  410:  template<typename _Tp, typename _Alloc>
<         -:  411:    template<typename... _Args>
<         -:  412:      void
<      166*:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<      166*:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<      166*:  424:      pointer __old_start = this->_M_impl._M_start;
<      166*:  425:      pointer __old_finish = this->_M_impl._M_finish;
<      166*:  426:      const size_type __elems_before = __position - begin();
<      166*:  427:      pointer __new_start(this->_M_allocate(__len));
<      166*:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<      166*:  436:	  _Alloc_traits::construct(this->_M_impl,
<      166*:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<      166*:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<      166*:  447:	    (__old_start, __position.base(),
<      166*:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<      166*:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<      166*:  454:	    (__position.base(), __old_finish,
<      166*:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<      166*:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<      332*:  469:      _M_deallocate(__old_start,
<      166*:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<      166*:  471:      this->_M_impl._M_start = __new_start;
<      166*:  472:      this->_M_impl._M_finish = __new_finish;
<      166*:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<      166*:  474:    }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE17_M_realloc_insertIJS7_EEEvN9__gnu_cxx17__normal_iteratorIPS7_S9_EEDpOT_:
<         2:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<         2:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<         2:  424:      pointer __old_start = this->_M_impl._M_start;
<         2:  425:      pointer __old_finish = this->_M_impl._M_finish;
<         2:  426:      const size_type __elems_before = __position - begin();
<         2:  427:      pointer __new_start(this->_M_allocate(__len));
<         2:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<         2:  436:	  _Alloc_traits::construct(this->_M_impl,
<         2:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<         2:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<         2:  447:	    (__old_start, __position.base(),
<         2:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<         2:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<         2:  454:	    (__position.base(), __old_finish,
<         2:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         2:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<         4:  469:      _M_deallocate(__old_start,
<         2:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<         2:  471:      this->_M_impl._M_start = __new_start;
<         2:  472:      this->_M_impl._M_finish = __new_finish;
<         2:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<         2:  474:    }
< ------------------
< _ZNSt6vectorI13ACE_INET_AddrSaIS0_EE17_M_realloc_insertIJRKS0_EEEvN9__gnu_cxx17__normal_iteratorIPS0_S2_EEDpOT_:
<     #####:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<     #####:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<     #####:  424:      pointer __old_start = this->_M_impl._M_start;
<     #####:  425:      pointer __old_finish = this->_M_impl._M_finish;
<     #####:  426:      const size_type __elems_before = __position - begin();
<     #####:  427:      pointer __new_start(this->_M_allocate(__len));
<     #####:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<     #####:  436:	  _Alloc_traits::construct(this->_M_impl,
<     #####:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<     #####:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  447:	    (__old_start, __position.base(),
<     #####:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<     #####:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  454:	    (__position.base(), __old_finish,
<     #####:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<     #####:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<     #####:  469:      _M_deallocate(__old_start,
<     #####:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<     #####:  471:      this->_M_impl._M_start = __new_start;
<     #####:  472:      this->_M_impl._M_finish = __new_finish;
<     #####:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<     #####:  474:    }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE17_M_realloc_insertIJRKS2_EEEvN9__gnu_cxx17__normal_iteratorIPS2_S4_EEDpOT_:
<         6:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<         6:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<         6:  424:      pointer __old_start = this->_M_impl._M_start;
<         6:  425:      pointer __old_finish = this->_M_impl._M_finish;
<         6:  426:      const size_type __elems_before = __position - begin();
<         6:  427:      pointer __new_start(this->_M_allocate(__len));
<         6:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<         6:  436:	  _Alloc_traits::construct(this->_M_impl,
<         6:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<         6:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<         6:  447:	    (__old_start, __position.base(),
<         6:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<         6:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<         6:  454:	    (__position.base(), __old_finish,
<         6:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         6:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<        12:  469:      _M_deallocate(__old_start,
<         6:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<         6:  471:      this->_M_impl._M_start = __new_start;
<         6:  472:      this->_M_impl._M_finish = __new_finish;
<         6:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<         6:  474:    }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE17_M_realloc_insertIJRKS4_EEEvN9__gnu_cxx17__normal_iteratorIPS4_S6_EEDpOT_:
<        42:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<        42:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<        42:  424:      pointer __old_start = this->_M_impl._M_start;
<        42:  425:      pointer __old_finish = this->_M_impl._M_finish;
<        42:  426:      const size_type __elems_before = __position - begin();
<        42:  427:      pointer __new_start(this->_M_allocate(__len));
<        42:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<        42:  436:	  _Alloc_traits::construct(this->_M_impl,
<        42:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<        42:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<        42:  447:	    (__old_start, __position.base(),
<        42:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<        42:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<        42:  454:	    (__position.base(), __old_finish,
<        42:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<        42:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<        84:  469:      _M_deallocate(__old_start,
<        42:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<        42:  471:      this->_M_impl._M_start = __new_start;
<        42:  472:      this->_M_impl._M_finish = __new_finish;
<        42:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<        42:  474:    }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE17_M_realloc_insertIJRKS3_EEEvN9__gnu_cxx17__normal_iteratorIPS3_S5_EEDpOT_:
<        23:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<        23:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<        23:  424:      pointer __old_start = this->_M_impl._M_start;
<        23:  425:      pointer __old_finish = this->_M_impl._M_finish;
<        23:  426:      const size_type __elems_before = __position - begin();
<        23:  427:      pointer __new_start(this->_M_allocate(__len));
<        23:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<        23:  436:	  _Alloc_traits::construct(this->_M_impl,
<        23:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<        23:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<        23:  447:	    (__old_start, __position.base(),
<        23:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<        23:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<        23:  454:	    (__position.base(), __old_finish,
<        23:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<        23:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<        46:  469:      _M_deallocate(__old_start,
<        23:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<        23:  471:      this->_M_impl._M_start = __new_start;
<        23:  472:      this->_M_impl._M_finish = __new_finish;
<        23:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<        23:  474:    }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE17_M_realloc_insertIJRKS4_EEEvN9__gnu_cxx17__normal_iteratorIPS4_S6_EEDpOT_:
<     #####:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<     #####:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<     #####:  424:      pointer __old_start = this->_M_impl._M_start;
<     #####:  425:      pointer __old_finish = this->_M_impl._M_finish;
<     #####:  426:      const size_type __elems_before = __position - begin();
<     #####:  427:      pointer __new_start(this->_M_allocate(__len));
<     #####:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<     #####:  436:	  _Alloc_traits::construct(this->_M_impl,
<     #####:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<     #####:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  447:	    (__old_start, __position.base(),
<     #####:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<     #####:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  454:	    (__position.base(), __old_finish,
<     #####:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<     #####:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<     #####:  469:      _M_deallocate(__old_start,
<     #####:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<     #####:  471:      this->_M_impl._M_start = __new_start;
<     #####:  472:      this->_M_impl._M_finish = __new_finish;
<     #####:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<     #####:  474:    }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE17_M_realloc_insertIJRKS4_EEEvN9__gnu_cxx17__normal_iteratorIPS4_S6_EEDpOT_:
<        89:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<        89:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<        89:  424:      pointer __old_start = this->_M_impl._M_start;
<        89:  425:      pointer __old_finish = this->_M_impl._M_finish;
<        89:  426:      const size_type __elems_before = __position - begin();
<        89:  427:      pointer __new_start(this->_M_allocate(__len));
<        89:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<        89:  436:	  _Alloc_traits::construct(this->_M_impl,
<        89:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<        89:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<        89:  447:	    (__old_start, __position.base(),
<        89:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<        89:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<        89:  454:	    (__position.base(), __old_finish,
<        89:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<        89:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<       178:  469:      _M_deallocate(__old_start,
<        89:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<        89:  471:      this->_M_impl._M_start = __new_start;
<        89:  472:      this->_M_impl._M_finish = __new_finish;
<        89:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<        89:  474:    }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE17_M_realloc_insertIJRKSE_EEEvN9__gnu_cxx17__normal_iteratorIPSE_SG_EEDpOT_:
<     #####:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<     #####:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<     #####:  424:      pointer __old_start = this->_M_impl._M_start;
<     #####:  425:      pointer __old_finish = this->_M_impl._M_finish;
<     #####:  426:      const size_type __elems_before = __position - begin();
<     #####:  427:      pointer __new_start(this->_M_allocate(__len));
<     #####:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<     #####:  436:	  _Alloc_traits::construct(this->_M_impl,
<     #####:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<     #####:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  447:	    (__old_start, __position.base(),
<     #####:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<     #####:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  454:	    (__position.base(), __old_finish,
<     #####:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<     #####:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<     #####:  469:      _M_deallocate(__old_start,
<     #####:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<     #####:  471:      this->_M_impl._M_start = __new_start;
<     #####:  472:      this->_M_impl._M_finish = __new_finish;
<     #####:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<     #####:  474:    }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE17_M_realloc_insertIJRKS5_EEEvN9__gnu_cxx17__normal_iteratorIPS5_S7_EEDpOT_:
<     #####:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<     #####:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<     #####:  424:      pointer __old_start = this->_M_impl._M_start;
<     #####:  425:      pointer __old_finish = this->_M_impl._M_finish;
<     #####:  426:      const size_type __elems_before = __position - begin();
<     #####:  427:      pointer __new_start(this->_M_allocate(__len));
<     #####:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<     #####:  436:	  _Alloc_traits::construct(this->_M_impl,
<     #####:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<     #####:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  447:	    (__old_start, __position.base(),
<     #####:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<     #####:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  454:	    (__position.base(), __old_finish,
<     #####:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<     #####:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<     #####:  469:      _M_deallocate(__old_start,
<     #####:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<     #####:  471:      this->_M_impl._M_start = __new_start;
<     #####:  472:      this->_M_impl._M_finish = __new_finish;
<     #####:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<     #####:  474:    }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE17_M_realloc_insertIJS7_EEEvN9__gnu_cxx17__normal_iteratorIPS7_S9_EEDpOT_:
<     #####:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<     #####:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<     #####:  424:      pointer __old_start = this->_M_impl._M_start;
<     #####:  425:      pointer __old_finish = this->_M_impl._M_finish;
<     #####:  426:      const size_type __elems_before = __position - begin();
<     #####:  427:      pointer __new_start(this->_M_allocate(__len));
<     #####:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<     #####:  436:	  _Alloc_traits::construct(this->_M_impl,
<     #####:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<     #####:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  447:	    (__old_start, __position.base(),
<     #####:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<     #####:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<     #####:  454:	    (__position.base(), __old_finish,
<     #####:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<     #####:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<     #####:  469:      _M_deallocate(__old_start,
<     #####:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<     #####:  471:      this->_M_impl._M_start = __new_start;
<     #####:  472:      this->_M_impl._M_finish = __new_finish;
<     #####:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<     #####:  474:    }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE17_M_realloc_insertIJRKS7_EEEvN9__gnu_cxx17__normal_iteratorIPS7_S9_EEDpOT_:
<         4:  413:      vector<_Tp, _Alloc>::
<         -:  414:      _M_realloc_insert(iterator __position, _Args&&... __args)
<         -:  415:#else
<         -:  416:  template<typename _Tp, typename _Alloc>
<         -:  417:    void
<         -:  418:    vector<_Tp, _Alloc>::
<         -:  419:    _M_realloc_insert(iterator __position, const _Tp& __x)
<         -:  420:#endif
<         -:  421:    {
<         4:  422:      const size_type __len =
<         -:  423:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
<         4:  424:      pointer __old_start = this->_M_impl._M_start;
<         4:  425:      pointer __old_finish = this->_M_impl._M_finish;
<         4:  426:      const size_type __elems_before = __position - begin();
<         4:  427:      pointer __new_start(this->_M_allocate(__len));
<         4:  428:      pointer __new_finish(__new_start);
<         -:  429:      __try
<         -:  430:	{
<         -:  431:	  // The order of the three operations is dictated by the C++11
<         -:  432:	  // case, where the moves could alter a new element belonging
<         -:  433:	  // to the existing vector.  This is an issue only for callers
<         -:  434:	  // taking the element by lvalue ref (see last bullet of C++11
<         -:  435:	  // [res.on.arguments]).
<         4:  436:	  _Alloc_traits::construct(this->_M_impl,
<         4:  437:				   __new_start + __elems_before,
<         -:  438:#if __cplusplus >= 201103L
<         -:  439:				   std::forward<_Args>(__args)...);
<         -:  440:#else
<         -:  441:				   __x);
<         -:  442:#endif
<         4:  443:	  __new_finish = pointer();
<         -:  444:
<         -:  445:	  __new_finish
<         -:  446:	    = std::__uninitialized_move_if_noexcept_a
<         4:  447:	    (__old_start, __position.base(),
<         4:  448:	     __new_start, _M_get_Tp_allocator());
<         -:  449:
<         4:  450:	  ++__new_finish;
<         -:  451:
<         -:  452:	  __new_finish
<         -:  453:	    = std::__uninitialized_move_if_noexcept_a
<         4:  454:	    (__position.base(), __old_finish,
<         4:  455:	     __new_finish, _M_get_Tp_allocator());
<         -:  456:	}
<     =====:  457:      __catch(...)
<         -:  458:	{
<     =====:  459:	  if (!__new_finish)
<     =====:  460:	    _Alloc_traits::destroy(this->_M_impl,
<     =====:  461:				   __new_start + __elems_before);
<         -:  462:	  else
<     =====:  463:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
<     =====:  464:	  _M_deallocate(__new_start, __len);
<     =====:  465:	  __throw_exception_again;
<         -:  466:	}
<         -:  467:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         4:  468:      std::_Destroy(__old_start, __old_finish, _M_get_Tp_allocator());
<         8:  469:      _M_deallocate(__old_start,
<         4:  470:		    this->_M_impl._M_end_of_storage - __old_start);
<         4:  471:      this->_M_impl._M_start = __new_start;
<         4:  472:      this->_M_impl._M_finish = __new_finish;
<         4:  473:      this->_M_impl._M_end_of_storage = __new_start + __len;
<         4:  474:    }
< ------------------
<         -:  475:
<         -:  476:  template<typename _Tp, typename _Alloc>
<         -:  477:    void
<         -:  478:    vector<_Tp, _Alloc>::
<         -:  479:    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
<         -:  480:    {
<         -:  481:      if (__n != 0)
<         -:  482:	{
<         -:  483:	  if (size_type(this->_M_impl._M_end_of_storage
<         -:  484:			- this->_M_impl._M_finish) >= __n)
<         -:  485:	    {
<         -:  486:#if __cplusplus < 201103L
<         -:  487:	      value_type __x_copy = __x;
<         -:  488:#else
<         -:  489:	      _Temporary_value __tmp(this, __x);
<         -:  490:	      value_type& __x_copy = __tmp._M_val();
<         -:  491:#endif
<         -:  492:	      const size_type __elems_after = end() - __position;
<         -:  493:	      pointer __old_finish(this->_M_impl._M_finish);
<         -:  494:	      if (__elems_after > __n)
<         -:  495:		{
<         -:  496:		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
<         -:  497:		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
<         -:  498:					      this->_M_impl._M_finish,
<         -:  499:					      this->_M_impl._M_finish,
<         -:  500:					      _M_get_Tp_allocator());
<         -:  501:		  this->_M_impl._M_finish += __n;
<         -:  502:		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
<         -:  503:		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
<         -:  504:					  __old_finish - __n, __old_finish);
<         -:  505:		  std::fill(__position.base(), __position.base() + __n,
<         -:  506:			    __x_copy);
<         -:  507:		}
<         -:  508:	      else
<         -:  509:		{
<         -:  510:		  _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
<         -:  511:		  this->_M_impl._M_finish =
<         -:  512:		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
<         -:  513:						  __n - __elems_after,
<         -:  514:						  __x_copy,
<         -:  515:						  _M_get_Tp_allocator());
<         -:  516:		  _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
<         -:  517:		  std::__uninitialized_move_a(__position.base(), __old_finish,
<         -:  518:					      this->_M_impl._M_finish,
<         -:  519:					      _M_get_Tp_allocator());
<         -:  520:		  this->_M_impl._M_finish += __elems_after;
<         -:  521:		  _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
<         -:  522:		  std::fill(__position.base(), __old_finish, __x_copy);
<         -:  523:		}
<         -:  524:	    }
<         -:  525:	  else
<         -:  526:	    {
<         -:  527:	      const size_type __len =
<         -:  528:		_M_check_len(__n, "vector::_M_fill_insert");
<         -:  529:	      const size_type __elems_before = __position - begin();
<         -:  530:	      pointer __new_start(this->_M_allocate(__len));
<         -:  531:	      pointer __new_finish(__new_start);
<         -:  532:	      __try
<         -:  533:		{
<         -:  534:		  // See _M_realloc_insert above.
<         -:  535:		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
<         -:  536:						__n, __x,
<         -:  537:						_M_get_Tp_allocator());
<         -:  538:		  __new_finish = pointer();
<         -:  539:
<         -:  540:		  __new_finish
<         -:  541:		    = std::__uninitialized_move_if_noexcept_a
<         -:  542:		    (this->_M_impl._M_start, __position.base(),
<         -:  543:		     __new_start, _M_get_Tp_allocator());
<         -:  544:
<         -:  545:		  __new_finish += __n;
<         -:  546:
<         -:  547:		  __new_finish
<         -:  548:		    = std::__uninitialized_move_if_noexcept_a
<         -:  549:		    (__position.base(), this->_M_impl._M_finish,
<         -:  550:		     __new_finish, _M_get_Tp_allocator());
<         -:  551:		}
<         -:  552:	      __catch(...)
<         -:  553:		{
<         -:  554:		  if (!__new_finish)
<         -:  555:		    std::_Destroy(__new_start + __elems_before,
<         -:  556:				  __new_start + __elems_before + __n,
<         -:  557:				  _M_get_Tp_allocator());
<         -:  558:		  else
<         -:  559:		    std::_Destroy(__new_start, __new_finish,
<         -:  560:				  _M_get_Tp_allocator());
<         -:  561:		  _M_deallocate(__new_start, __len);
<         -:  562:		  __throw_exception_again;
<         -:  563:		}
<         -:  564:	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         -:  565:	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         -:  566:			    _M_get_Tp_allocator());
<         -:  567:	      _M_deallocate(this->_M_impl._M_start,
<         -:  568:			    this->_M_impl._M_end_of_storage
<         -:  569:			    - this->_M_impl._M_start);
<         -:  570:	      this->_M_impl._M_start = __new_start;
<         -:  571:	      this->_M_impl._M_finish = __new_finish;
<         -:  572:	      this->_M_impl._M_end_of_storage = __new_start + __len;
<         -:  573:	    }
<         -:  574:	}
<         -:  575:    }
<         -:  576:
<         -:  577:#if __cplusplus >= 201103L
<         -:  578:  template<typename _Tp, typename _Alloc>
<         -:  579:    void
<         -:  580:    vector<_Tp, _Alloc>::
<         -:  581:    _M_default_append(size_type __n)
<         -:  582:    {
<         -:  583:      if (__n != 0)
<         -:  584:	{
<         -:  585:	  const size_type __size = size();
<         -:  586:	  size_type __navail = size_type(this->_M_impl._M_end_of_storage
<         -:  587:					 - this->_M_impl._M_finish);
<         -:  588:
<         -:  589:	  if (__size > max_size() || __navail > max_size() - __size)
<         -:  590:	    __builtin_unreachable();
<         -:  591:
<         -:  592:	  if (__navail >= __n)
<         -:  593:	    {
<         -:  594:	      _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
<         -:  595:	      this->_M_impl._M_finish =
<         -:  596:		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
<         -:  597:						 __n, _M_get_Tp_allocator());
<         -:  598:	      _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
<         -:  599:	    }
<         -:  600:	  else
<         -:  601:	    {
<         -:  602:	      const size_type __len =
<         -:  603:		_M_check_len(__n, "vector::_M_default_append");
<         -:  604:	      pointer __new_start(this->_M_allocate(__len));
<         -:  605:	      pointer __destroy_from = pointer();
<         -:  606:	      __try
<         -:  607:		{
<         -:  608:		  std::__uninitialized_default_n_a(__new_start + __size,
<         -:  609:						   __n, _M_get_Tp_allocator());
<         -:  610:		  __destroy_from = __new_start + __size;
<         -:  611:		  std::__uninitialized_move_if_noexcept_a(
<         -:  612:		      this->_M_impl._M_start, this->_M_impl._M_finish,
<         -:  613:		      __new_start, _M_get_Tp_allocator());
<         -:  614:		}
<         -:  615:	      __catch(...)
<         -:  616:		{
<         -:  617:		  if (__destroy_from)
<         -:  618:		    std::_Destroy(__destroy_from, __destroy_from + __n,
<         -:  619:				  _M_get_Tp_allocator());
<         -:  620:		  _M_deallocate(__new_start, __len);
<         -:  621:		  __throw_exception_again;
<         -:  622:		}
<         -:  623:	      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         -:  624:	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         -:  625:			    _M_get_Tp_allocator());
<         -:  626:	      _M_deallocate(this->_M_impl._M_start,
<         -:  627:			    this->_M_impl._M_end_of_storage
<         -:  628:			    - this->_M_impl._M_start);
<         -:  629:	      this->_M_impl._M_start = __new_start;
<         -:  630:	      this->_M_impl._M_finish = __new_start + __size + __n;
<         -:  631:	      this->_M_impl._M_end_of_storage = __new_start + __len;
<         -:  632:	    }
<         -:  633:	}
<         -:  634:    }
<         -:  635:
<         -:  636:  template<typename _Tp, typename _Alloc>
<         -:  637:    bool
<         -:  638:    vector<_Tp, _Alloc>::
<         -:  639:    _M_shrink_to_fit()
<         -:  640:    {
<         -:  641:      if (capacity() == size())
<         -:  642:	return false;
<         -:  643:      _GLIBCXX_ASAN_ANNOTATE_REINIT;
<         -:  644:      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
<         -:  645:    }
<         -:  646:#endif
<         -:  647:
<         -:  648:  template<typename _Tp, typename _Alloc>
<         -:  649:    template<typename _InputIterator>
<         -:  650:      void
<         -:  651:      vector<_Tp, _Alloc>::
<         -:  652:      _M_range_insert(iterator __pos, _InputIterator __first,
<         -:  653:		      _InputIterator __last, std::input_iterator_tag)
<         -:  654:      {
<         -:  655:	if (__pos == end())
<         -:  656:	  {
<         -:  657:	    for (; __first != __last; ++__first)
<         -:  658:	      insert(end(), *__first);
<         -:  659:	  }
<         -:  660:	else if (__first != __last)
<         -:  661:	  {
<         -:  662:	    vector __tmp(__first, __last, _M_get_Tp_allocator());
<         -:  663:	    insert(__pos,
<         -:  664:		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.begin()),
<         -:  665:		   _GLIBCXX_MAKE_MOVE_ITERATOR(__tmp.end()));
<         -:  666:	  }
<         -:  667:      }
<         -:  668:
<         -:  669:  template<typename _Tp, typename _Alloc>
<         -:  670:    template<typename _ForwardIterator>
<         -:  671:      void
<         -:  672:      vector<_Tp, _Alloc>::
<         -:  673:      _M_range_insert(iterator __position, _ForwardIterator __first,
<         -:  674:		      _ForwardIterator __last, std::forward_iterator_tag)
<         -:  675:      {
<         -:  676:	if (__first != __last)
<         -:  677:	  {
<         -:  678:	    const size_type __n = std::distance(__first, __last);
<         -:  679:	    if (size_type(this->_M_impl._M_end_of_storage
<         -:  680:			  - this->_M_impl._M_finish) >= __n)
<         -:  681:	      {
<         -:  682:		const size_type __elems_after = end() - __position;
<         -:  683:		pointer __old_finish(this->_M_impl._M_finish);
<         -:  684:		if (__elems_after > __n)
<         -:  685:		  {
<         -:  686:		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
<         -:  687:		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
<         -:  688:						this->_M_impl._M_finish,
<         -:  689:						this->_M_impl._M_finish,
<         -:  690:						_M_get_Tp_allocator());
<         -:  691:		    this->_M_impl._M_finish += __n;
<         -:  692:		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n);
<         -:  693:		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
<         -:  694:					    __old_finish - __n, __old_finish);
<         -:  695:		    std::copy(__first, __last, __position);
---
>         -:  253:      else
>         -:  254:        _M_erase_at_end(std::fill_n(this->_M_impl._M_start, __n, __val));
>         -:  255:    }
>         -:  256:
>         -:  257:  template<typename _Tp, typename _Alloc>
>         -:  258:    template<typename _InputIterator>
>         -:  259:      void
>         -:  260:      vector<_Tp, _Alloc>::
>         -:  261:      _M_assign_aux(_InputIterator __first, _InputIterator __last,
>         -:  262:		    std::input_iterator_tag)
>         -:  263:      {
>         -:  264:	pointer __cur(this->_M_impl._M_start);
>         -:  265:	for (; __first != __last && __cur != this->_M_impl._M_finish;
>         -:  266:	     ++__cur, ++__first)
>         -:  267:	  *__cur = *__first;
>         -:  268:	if (__first == __last)
>         -:  269:	  _M_erase_at_end(__cur);
>         -:  270:	else
>         -:  271:	  _M_range_insert(end(), __first, __last,
>         -:  272:			  std::__iterator_category(__first));
>         -:  273:      }
>         -:  274:
>         -:  275:  template<typename _Tp, typename _Alloc>
>         -:  276:    template<typename _ForwardIterator>
>         -:  277:      void
>         -:  278:      vector<_Tp, _Alloc>::
>         -:  279:      _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
>         -:  280:		    std::forward_iterator_tag)
>         -:  281:      {
>         -:  282:	const size_type __len = std::distance(__first, __last);
>         -:  283:
>         -:  284:	if (__len > capacity())
>         -:  285:	  {
>         -:  286:	    pointer __tmp(_M_allocate_and_copy(__len, __first, __last));
>         -:  287:	    std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:  288:			  _M_get_Tp_allocator());
>         -:  289:	    _M_deallocate(this->_M_impl._M_start,
>         -:  290:			  this->_M_impl._M_end_of_storage
>         -:  291:			  - this->_M_impl._M_start);
>         -:  292:	    this->_M_impl._M_start = __tmp;
>         -:  293:	    this->_M_impl._M_finish = this->_M_impl._M_start + __len;
>         -:  294:	    this->_M_impl._M_end_of_storage = this->_M_impl._M_finish;
>         -:  295:	  }
>         -:  296:	else if (size() >= __len)
>         -:  297:	  _M_erase_at_end(std::copy(__first, __last, this->_M_impl._M_start));
>         -:  298:	else
>         -:  299:	  {
>         -:  300:	    _ForwardIterator __mid = __first;
>         -:  301:	    std::advance(__mid, size());
>         -:  302:	    std::copy(__first, __mid, this->_M_impl._M_start);
>         -:  303:	    this->_M_impl._M_finish =
>         -:  304:	      std::__uninitialized_copy_a(__mid, __last,
>         -:  305:					  this->_M_impl._M_finish,
>         -:  306:					  _M_get_Tp_allocator());
>         -:  307:	  }
>         -:  308:      }
>         -:  309:
>         -:  310:#if __cplusplus >= 201103L
>         -:  311:  template<typename _Tp, typename _Alloc>
>         -:  312:    auto
>         -:  313:    vector<_Tp, _Alloc>::
>         -:  314:    _M_insert_rval(const_iterator __position, value_type&& __v) -> iterator
>         -:  315:    {
>         -:  316:      const auto __n = __position - cbegin();
>         -:  317:      if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
>         -:  318:	if (__position == cend())
>         -:  319:	  {
>         -:  320:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
>         -:  321:				     std::move(__v));
>         -:  322:	    ++this->_M_impl._M_finish;
>         -:  323:	  }
>         -:  324:	else
>         -:  325:	  _M_insert_aux(begin() + __n, std::move(__v));
>         -:  326:      else
>         -:  327:	_M_realloc_insert(begin() + __n, std::move(__v));
>         -:  328:
>         -:  329:      return iterator(this->_M_impl._M_start + __n);
>         -:  330:    }
>         -:  331:
>         -:  332:  template<typename _Tp, typename _Alloc>
>         -:  333:    template<typename... _Args>
>         -:  334:      auto
>         -:  335:      vector<_Tp, _Alloc>::
>         -:  336:      _M_emplace_aux(const_iterator __position, _Args&&... __args)
>         -:  337:      -> iterator
>         -:  338:      {
>         -:  339:	const auto __n = __position - cbegin();
>         -:  340:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
>         -:  341:	  if (__position == cend())
>         -:  342:	    {
>         -:  343:	      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
>         -:  344:				       std::forward<_Args>(__args)...);
>         -:  345:	      ++this->_M_impl._M_finish;
>         -:  346:	    }
>         -:  347:	  else
>         -:  348:	    {
>         -:  349:	      // We need to construct a temporary because something in __args...
>         -:  350:	      // could alias one of the elements of the container and so we
>         -:  351:	      // need to use it before _M_insert_aux moves elements around.
>         -:  352:	      _Temporary_value __tmp(this, std::forward<_Args>(__args)...);
>         -:  353:	      _M_insert_aux(begin() + __n, std::move(__tmp._M_val()));
>         -:  354:	    }
>         -:  355:	else
>         -:  356:	  _M_realloc_insert(begin() + __n, std::forward<_Args>(__args)...);
>         -:  357:
>         -:  358:	return iterator(this->_M_impl._M_start + __n);
>         -:  359:      }
>         -:  360:
>         -:  361:  template<typename _Tp, typename _Alloc>
>         -:  362:    template<typename _Arg>
>         -:  363:      void
>         -:  364:      vector<_Tp, _Alloc>::
>         -:  365:      _M_insert_aux(iterator __position, _Arg&& __arg)
>         -:  366:#else
>         -:  367:  template<typename _Tp, typename _Alloc>
>         -:  368:    void
>         -:  369:    vector<_Tp, _Alloc>::
>         -:  370:    _M_insert_aux(iterator __position, const _Tp& __x)
>         -:  371:#endif
>         -:  372:    {
>         -:  373:      _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
>         -:  374:			       _GLIBCXX_MOVE(*(this->_M_impl._M_finish
>         -:  375:					       - 1)));
>         -:  376:      ++this->_M_impl._M_finish;
>         -:  377:#if __cplusplus < 201103L
>         -:  378:      _Tp __x_copy = __x;
>         -:  379:#endif
>         -:  380:      _GLIBCXX_MOVE_BACKWARD3(__position.base(),
>         -:  381:			      this->_M_impl._M_finish - 2,
>         -:  382:			      this->_M_impl._M_finish - 1);
>         -:  383:#if __cplusplus < 201103L
>         -:  384:      *__position = __x_copy;
>         -:  385:#else
>         -:  386:      *__position = std::forward<_Arg>(__arg);
>         -:  387:#endif
>         -:  388:    }
>         -:  389:
>         -:  390:#if __cplusplus >= 201103L
>         -:  391:  template<typename _Tp, typename _Alloc>
>         -:  392:    template<typename... _Args>
>         -:  393:      void
>     #####:  394:      vector<_Tp, _Alloc>::
>         -:  395:      _M_realloc_insert(iterator __position, _Args&&... __args)
>         -:  396:#else
>         -:  397:  template<typename _Tp, typename _Alloc>
>         -:  398:    void
>         -:  399:    vector<_Tp, _Alloc>::
>         -:  400:    _M_realloc_insert(iterator __position, const _Tp& __x)
>         -:  401:#endif
>         -:  402:    {
>     #####:  403:      const size_type __len =
>         -:  404:	_M_check_len(size_type(1), "vector::_M_realloc_insert");
>     #####:  405:      const size_type __elems_before = __position - begin();
>     #####:  406:      pointer __new_start(this->_M_allocate(__len));
>     #####:  407:      pointer __new_finish(__new_start);
>         -:  408:      __try
>         -:  409:	{
>         -:  410:	  // The order of the three operations is dictated by the C++11
>         -:  411:	  // case, where the moves could alter a new element belonging
>         -:  412:	  // to the existing vector.  This is an issue only for callers
>         -:  413:	  // taking the element by lvalue ref (see last bullet of C++11
>         -:  414:	  // [res.on.arguments]).
>     #####:  415:	  _Alloc_traits::construct(this->_M_impl,
>     #####:  416:				   __new_start + __elems_before,
>         -:  417:#if __cplusplus >= 201103L
>         -:  418:				   std::forward<_Args>(__args)...);
>         -:  419:#else
>         -:  420:				   __x);
>         -:  421:#endif
>     #####:  422:	  __new_finish = pointer();
>         -:  423:
>     #####:  424:	  __new_finish
>         -:  425:	    = std::__uninitialized_move_if_noexcept_a
>     #####:  426:	    (this->_M_impl._M_start, __position.base(),
>     #####:  427:	     __new_start, _M_get_Tp_allocator());
>         -:  428:
>     #####:  429:	  ++__new_finish;
>         -:  430:
>     #####:  431:	  __new_finish
>         -:  432:	    = std::__uninitialized_move_if_noexcept_a
>     #####:  433:	    (__position.base(), this->_M_impl._M_finish,
>     #####:  434:	     __new_finish, _M_get_Tp_allocator());
>         -:  435:	}
>     =====:  436:      __catch(...)
>         -:  437:	{
>     =====:  438:	  if (!__new_finish)
>     =====:  439:	    _Alloc_traits::destroy(this->_M_impl,
>     =====:  440:				   __new_start + __elems_before);
>         -:  441:	  else
>     =====:  442:	    std::_Destroy(__new_start, __new_finish, _M_get_Tp_allocator());
>     =====:  443:	  _M_deallocate(__new_start, __len);
>     =====:  444:	  __throw_exception_again;
>         -:  445:	}
>     #####:  446:      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>     #####:  447:		    _M_get_Tp_allocator());
>     #####:  448:      _M_deallocate(this->_M_impl._M_start,
>     #####:  449:		    this->_M_impl._M_end_of_storage
>     #####:  450:		    - this->_M_impl._M_start);
>     #####:  451:      this->_M_impl._M_start = __new_start;
>     #####:  452:      this->_M_impl._M_finish = __new_finish;
>     #####:  453:      this->_M_impl._M_end_of_storage = __new_start + __len;
>     #####:  454:    }
>         -:  455:
>         -:  456:  template<typename _Tp, typename _Alloc>
>         -:  457:    void
>         -:  458:    vector<_Tp, _Alloc>::
>         -:  459:    _M_fill_insert(iterator __position, size_type __n, const value_type& __x)
>         -:  460:    {
>         -:  461:      if (__n != 0)
>         -:  462:	{
>         -:  463:	  if (size_type(this->_M_impl._M_end_of_storage
>         -:  464:			- this->_M_impl._M_finish) >= __n)
>         -:  465:	    {
>         -:  466:#if __cplusplus < 201103L
>         -:  467:	      value_type __x_copy = __x;
>         -:  468:#else
>         -:  469:	      _Temporary_value __tmp(this, __x);
>         -:  470:	      value_type& __x_copy = __tmp._M_val();
>         -:  471:#endif
>         -:  472:	      const size_type __elems_after = end() - __position;
>         -:  473:	      pointer __old_finish(this->_M_impl._M_finish);
>         -:  474:	      if (__elems_after > __n)
>         -:  475:		{
>         -:  476:		  std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
>         -:  477:					      this->_M_impl._M_finish,
>         -:  478:					      this->_M_impl._M_finish,
>         -:  479:					      _M_get_Tp_allocator());
>         -:  480:		  this->_M_impl._M_finish += __n;
>         -:  481:		  _GLIBCXX_MOVE_BACKWARD3(__position.base(),
>         -:  482:					  __old_finish - __n, __old_finish);
>         -:  483:		  std::fill(__position.base(), __position.base() + __n,
>         -:  484:			    __x_copy);
>         -:  485:		}
>         -:  486:	      else
>         -:  487:		{
>         -:  488:		  this->_M_impl._M_finish =
>         -:  489:		    std::__uninitialized_fill_n_a(this->_M_impl._M_finish,
>         -:  490:						  __n - __elems_after,
>         -:  491:						  __x_copy,
>         -:  492:						  _M_get_Tp_allocator());
>         -:  493:		  std::__uninitialized_move_a(__position.base(), __old_finish,
>         -:  494:					      this->_M_impl._M_finish,
>         -:  495:					      _M_get_Tp_allocator());
>         -:  496:		  this->_M_impl._M_finish += __elems_after;
>         -:  497:		  std::fill(__position.base(), __old_finish, __x_copy);
>         -:  498:		}
>         -:  499:	    }
>         -:  500:	  else
>         -:  501:	    {
>         -:  502:	      const size_type __len =
>         -:  503:		_M_check_len(__n, "vector::_M_fill_insert");
>         -:  504:	      const size_type __elems_before = __position - begin();
>         -:  505:	      pointer __new_start(this->_M_allocate(__len));
>         -:  506:	      pointer __new_finish(__new_start);
>         -:  507:	      __try
>         -:  508:		{
>         -:  509:		  // See _M_realloc_insert above.
>         -:  510:		  std::__uninitialized_fill_n_a(__new_start + __elems_before,
>         -:  511:						__n, __x,
>         -:  512:						_M_get_Tp_allocator());
>         -:  513:		  __new_finish = pointer();
>         -:  514:
>         -:  515:		  __new_finish
>         -:  516:		    = std::__uninitialized_move_if_noexcept_a
>         -:  517:		    (this->_M_impl._M_start, __position.base(),
>         -:  518:		     __new_start, _M_get_Tp_allocator());
>         -:  519:
>         -:  520:		  __new_finish += __n;
>         -:  521:
>         -:  522:		  __new_finish
>         -:  523:		    = std::__uninitialized_move_if_noexcept_a
>         -:  524:		    (__position.base(), this->_M_impl._M_finish,
>         -:  525:		     __new_finish, _M_get_Tp_allocator());
>         -:  526:		}
>         -:  527:	      __catch(...)
>         -:  528:		{
>         -:  529:		  if (!__new_finish)
>         -:  530:		    std::_Destroy(__new_start + __elems_before,
>         -:  531:				  __new_start + __elems_before + __n,
>         -:  532:				  _M_get_Tp_allocator());
>         -:  533:		  else
>         -:  534:		    std::_Destroy(__new_start, __new_finish,
>         -:  535:				  _M_get_Tp_allocator());
>         -:  536:		  _M_deallocate(__new_start, __len);
>         -:  537:		  __throw_exception_again;
>         -:  538:		}
>         -:  539:	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:  540:			    _M_get_Tp_allocator());
>         -:  541:	      _M_deallocate(this->_M_impl._M_start,
>         -:  542:			    this->_M_impl._M_end_of_storage
>         -:  543:			    - this->_M_impl._M_start);
>         -:  544:	      this->_M_impl._M_start = __new_start;
>         -:  545:	      this->_M_impl._M_finish = __new_finish;
>         -:  546:	      this->_M_impl._M_end_of_storage = __new_start + __len;
>         -:  547:	    }
>         -:  548:	}
>         -:  549:    }
>         -:  550:
>         -:  551:#if __cplusplus >= 201103L
>         -:  552:  template<typename _Tp, typename _Alloc>
>         -:  553:    void
>         -:  554:    vector<_Tp, _Alloc>::
>         -:  555:    _M_default_append(size_type __n)
>         -:  556:    {
>         -:  557:      if (__n != 0)
>         -:  558:	{
>         -:  559:	  if (size_type(this->_M_impl._M_end_of_storage
>         -:  560:			- this->_M_impl._M_finish) >= __n)
>         -:  561:	    {
>         -:  562:	      this->_M_impl._M_finish =
>         -:  563:		std::__uninitialized_default_n_a(this->_M_impl._M_finish,
>         -:  564:						 __n, _M_get_Tp_allocator());
>         -:  565:	    }
>         -:  566:	  else
>         -:  567:	    {
>         -:  568:	      const size_type __len =
>         -:  569:		_M_check_len(__n, "vector::_M_default_append");
>         -:  570:	      const size_type __size = this->size();
>         -:  571:	      pointer __new_start(this->_M_allocate(__len));
>         -:  572:	      pointer __destroy_from = pointer();
>         -:  573:	      __try
>         -:  574:		{
>         -:  575:		  std::__uninitialized_default_n_a(__new_start + __size,
>         -:  576:						   __n, _M_get_Tp_allocator());
>         -:  577:		  __destroy_from = __new_start + __size;
>         -:  578:		  std::__uninitialized_move_if_noexcept_a(
>         -:  579:		      this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:  580:		      __new_start, _M_get_Tp_allocator());
>         -:  581:		}
>         -:  582:	      __catch(...)
>         -:  583:		{
>         -:  584:		  if (__destroy_from)
>         -:  585:		    std::_Destroy(__destroy_from, __destroy_from + __n,
>         -:  586:				  _M_get_Tp_allocator());
>         -:  587:		  _M_deallocate(__new_start, __len);
>         -:  588:		  __throw_exception_again;
>         -:  589:		}
>         -:  590:	      std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:  591:			    _M_get_Tp_allocator());
>         -:  592:	      _M_deallocate(this->_M_impl._M_start,
>         -:  593:			    this->_M_impl._M_end_of_storage
>         -:  594:			    - this->_M_impl._M_start);
>         -:  595:	      this->_M_impl._M_start = __new_start;
>         -:  596:	      this->_M_impl._M_finish = __new_start + __size + __n;
>         -:  597:	      this->_M_impl._M_end_of_storage = __new_start + __len;
>         -:  598:	    }
>         -:  599:	}
>         -:  600:    }
>         -:  601:
>         -:  602:  template<typename _Tp, typename _Alloc>
>         -:  603:    bool
>         -:  604:    vector<_Tp, _Alloc>::
>         -:  605:    _M_shrink_to_fit()
>         -:  606:    {
>         -:  607:      if (capacity() == size())
>         -:  608:	return false;
>         -:  609:      return std::__shrink_to_fit_aux<vector>::_S_do_it(*this);
>         -:  610:    }
>         -:  611:#endif
>         -:  612:
>         -:  613:  template<typename _Tp, typename _Alloc>
>         -:  614:    template<typename _InputIterator>
>         -:  615:      void
>         -:  616:      vector<_Tp, _Alloc>::
>         -:  617:      _M_range_insert(iterator __pos, _InputIterator __first,
>         -:  618:		      _InputIterator __last, std::input_iterator_tag)
>         -:  619:      {
>         -:  620:	for (; __first != __last; ++__first)
>         -:  621:	  {
>         -:  622:	    __pos = insert(__pos, *__first);
>         -:  623:	    ++__pos;
>         -:  624:	  }
>         -:  625:      }
>         -:  626:
>         -:  627:  template<typename _Tp, typename _Alloc>
>         -:  628:    template<typename _ForwardIterator>
>         -:  629:      void
>         -:  630:      vector<_Tp, _Alloc>::
>         -:  631:      _M_range_insert(iterator __position, _ForwardIterator __first,
>         -:  632:		      _ForwardIterator __last, std::forward_iterator_tag)
>         -:  633:      {
>         -:  634:	if (__first != __last)
>         -:  635:	  {
>         -:  636:	    const size_type __n = std::distance(__first, __last);
>         -:  637:	    if (size_type(this->_M_impl._M_end_of_storage
>         -:  638:			  - this->_M_impl._M_finish) >= __n)
>         -:  639:	      {
>         -:  640:		const size_type __elems_after = end() - __position;
>         -:  641:		pointer __old_finish(this->_M_impl._M_finish);
>         -:  642:		if (__elems_after > __n)
>         -:  643:		  {
>         -:  644:		    std::__uninitialized_move_a(this->_M_impl._M_finish - __n,
>         -:  645:						this->_M_impl._M_finish,
>         -:  646:						this->_M_impl._M_finish,
>         -:  647:						_M_get_Tp_allocator());
>         -:  648:		    this->_M_impl._M_finish += __n;
>         -:  649:		    _GLIBCXX_MOVE_BACKWARD3(__position.base(),
>         -:  650:					    __old_finish - __n, __old_finish);
>         -:  651:		    std::copy(__first, __last, __position);
>         -:  652:		  }
>         -:  653:		else
>         -:  654:		  {
>         -:  655:		    _ForwardIterator __mid = __first;
>         -:  656:		    std::advance(__mid, __elems_after);
>         -:  657:		    std::__uninitialized_copy_a(__mid, __last,
>         -:  658:						this->_M_impl._M_finish,
>         -:  659:						_M_get_Tp_allocator());
>         -:  660:		    this->_M_impl._M_finish += __n - __elems_after;
>         -:  661:		    std::__uninitialized_move_a(__position.base(),
>         -:  662:						__old_finish,
>         -:  663:						this->_M_impl._M_finish,
>         -:  664:						_M_get_Tp_allocator());
>         -:  665:		    this->_M_impl._M_finish += __elems_after;
>         -:  666:		    std::copy(__first, __mid, __position);
>         -:  667:		  }
>         -:  668:	      }
>         -:  669:	    else
>         -:  670:	      {
>         -:  671:		const size_type __len =
>         -:  672:		  _M_check_len(__n, "vector::_M_range_insert");
>         -:  673:		pointer __new_start(this->_M_allocate(__len));
>         -:  674:		pointer __new_finish(__new_start);
>         -:  675:		__try
>         -:  676:		  {
>         -:  677:		    __new_finish
>         -:  678:		      = std::__uninitialized_move_if_noexcept_a
>         -:  679:		      (this->_M_impl._M_start, __position.base(),
>         -:  680:		       __new_start, _M_get_Tp_allocator());
>         -:  681:		    __new_finish
>         -:  682:		      = std::__uninitialized_copy_a(__first, __last,
>         -:  683:						    __new_finish,
>         -:  684:						    _M_get_Tp_allocator());
>         -:  685:		    __new_finish
>         -:  686:		      = std::__uninitialized_move_if_noexcept_a
>         -:  687:		      (__position.base(), this->_M_impl._M_finish,
>         -:  688:		       __new_finish, _M_get_Tp_allocator());
>         -:  689:		  }
>         -:  690:		__catch(...)
>         -:  691:		  {
>         -:  692:		    std::_Destroy(__new_start, __new_finish,
>         -:  693:				  _M_get_Tp_allocator());
>         -:  694:		    _M_deallocate(__new_start, __len);
>         -:  695:		    __throw_exception_again;
1492,1660c699,867
<         -:  697:		else
<         -:  698:		  {
<         -:  699:		    _ForwardIterator __mid = __first;
<         -:  700:		    std::advance(__mid, __elems_after);
<         -:  701:		    _GLIBCXX_ASAN_ANNOTATE_GROW(__n);
<         -:  702:		    std::__uninitialized_copy_a(__mid, __last,
<         -:  703:						this->_M_impl._M_finish,
<         -:  704:						_M_get_Tp_allocator());
<         -:  705:		    this->_M_impl._M_finish += __n - __elems_after;
<         -:  706:		    _GLIBCXX_ASAN_ANNOTATE_GREW(__n - __elems_after);
<         -:  707:		    std::__uninitialized_move_a(__position.base(),
<         -:  708:						__old_finish,
<         -:  709:						this->_M_impl._M_finish,
<         -:  710:						_M_get_Tp_allocator());
<         -:  711:		    this->_M_impl._M_finish += __elems_after;
<         -:  712:		    _GLIBCXX_ASAN_ANNOTATE_GREW(__elems_after);
<         -:  713:		    std::copy(__first, __mid, __position);
<         -:  714:		  }
<         -:  715:	      }
<         -:  716:	    else
<         -:  717:	      {
<         -:  718:		const size_type __len =
<         -:  719:		  _M_check_len(__n, "vector::_M_range_insert");
<         -:  720:		pointer __new_start(this->_M_allocate(__len));
<         -:  721:		pointer __new_finish(__new_start);
<         -:  722:		__try
<         -:  723:		  {
<         -:  724:		    __new_finish
<         -:  725:		      = std::__uninitialized_move_if_noexcept_a
<         -:  726:		      (this->_M_impl._M_start, __position.base(),
<         -:  727:		       __new_start, _M_get_Tp_allocator());
<         -:  728:		    __new_finish
<         -:  729:		      = std::__uninitialized_copy_a(__first, __last,
<         -:  730:						    __new_finish,
<         -:  731:						    _M_get_Tp_allocator());
<         -:  732:		    __new_finish
<         -:  733:		      = std::__uninitialized_move_if_noexcept_a
<         -:  734:		      (__position.base(), this->_M_impl._M_finish,
<         -:  735:		       __new_finish, _M_get_Tp_allocator());
<         -:  736:		  }
<         -:  737:		__catch(...)
<         -:  738:		  {
<         -:  739:		    std::_Destroy(__new_start, __new_finish,
<         -:  740:				  _M_get_Tp_allocator());
<         -:  741:		    _M_deallocate(__new_start, __len);
<         -:  742:		    __throw_exception_again;
<         -:  743:		  }
<         -:  744:		_GLIBCXX_ASAN_ANNOTATE_REINIT;
<         -:  745:		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         -:  746:			      _M_get_Tp_allocator());
<         -:  747:		_M_deallocate(this->_M_impl._M_start,
<         -:  748:			      this->_M_impl._M_end_of_storage
<         -:  749:			      - this->_M_impl._M_start);
<         -:  750:		this->_M_impl._M_start = __new_start;
<         -:  751:		this->_M_impl._M_finish = __new_finish;
<         -:  752:		this->_M_impl._M_end_of_storage = __new_start + __len;
<         -:  753:	      }
<         -:  754:	  }
<         -:  755:      }
<         -:  756:
<         -:  757:
<         -:  758:  // vector<bool>
<         -:  759:  template<typename _Alloc>
<         -:  760:    void
<         -:  761:    vector<bool, _Alloc>::
<         -:  762:    _M_reallocate(size_type __n)
<         -:  763:    {
<         -:  764:      _Bit_pointer __q = this->_M_allocate(__n);
<         -:  765:      iterator __start(std::__addressof(*__q), 0);
<         -:  766:      iterator __finish(_M_copy_aligned(begin(), end(), __start));
<         -:  767:      this->_M_deallocate();
<         -:  768:      this->_M_impl._M_start = __start;
<         -:  769:      this->_M_impl._M_finish = __finish;
<         -:  770:      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
<         -:  771:    }
<         -:  772:
<         -:  773:  template<typename _Alloc>
<         -:  774:    void
<         -:  775:    vector<bool, _Alloc>::
<         -:  776:    _M_fill_insert(iterator __position, size_type __n, bool __x)
<         -:  777:    {
<         -:  778:      if (__n == 0)
<         -:  779:	return;
<         -:  780:      if (capacity() - size() >= __n)
<         -:  781:	{
<         -:  782:	  std::copy_backward(__position, end(),
<         -:  783:			     this->_M_impl._M_finish + difference_type(__n));
<         -:  784:	  std::fill(__position, __position + difference_type(__n), __x);
<         -:  785:	  this->_M_impl._M_finish += difference_type(__n);
<         -:  786:	}
<         -:  787:      else
<         -:  788:	{
<         -:  789:	  const size_type __len = 
<         -:  790:	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
<         -:  791:	  _Bit_pointer __q = this->_M_allocate(__len);
<         -:  792:	  iterator __start(std::__addressof(*__q), 0);
<         -:  793:	  iterator __i = _M_copy_aligned(begin(), __position, __start);
<         -:  794:	  std::fill(__i, __i + difference_type(__n), __x);
<         -:  795:	  iterator __finish = std::copy(__position, end(),
<         -:  796:					__i + difference_type(__n));
<         -:  797:	  this->_M_deallocate();
<         -:  798:	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
<         -:  799:	  this->_M_impl._M_start = __start;
<         -:  800:	  this->_M_impl._M_finish = __finish;
<         -:  801:	}
<         -:  802:    }
<         -:  803:
<         -:  804:  template<typename _Alloc>
<         -:  805:    template<typename _ForwardIterator>
<         -:  806:      void
<         -:  807:      vector<bool, _Alloc>::
<         -:  808:      _M_insert_range(iterator __position, _ForwardIterator __first, 
<         -:  809:		      _ForwardIterator __last, std::forward_iterator_tag)
<         -:  810:      {
<         -:  811:	if (__first != __last)
<         -:  812:	  {
<         -:  813:	    size_type __n = std::distance(__first, __last);
<         -:  814:	    if (capacity() - size() >= __n)
<         -:  815:	      {
<         -:  816:		std::copy_backward(__position, end(),
<         -:  817:				   this->_M_impl._M_finish
<         -:  818:				   + difference_type(__n));
<         -:  819:		std::copy(__first, __last, __position);
<         -:  820:		this->_M_impl._M_finish += difference_type(__n);
<         -:  821:	      }
<         -:  822:	    else
<         -:  823:	      {
<         -:  824:		const size_type __len =
<         -:  825:		  _M_check_len(__n, "vector<bool>::_M_insert_range");
<         -:  826:		_Bit_pointer __q = this->_M_allocate(__len);
<         -:  827:		iterator __start(std::__addressof(*__q), 0);
<         -:  828:		iterator __i = _M_copy_aligned(begin(), __position, __start);
<         -:  829:		__i = std::copy(__first, __last, __i);
<         -:  830:		iterator __finish = std::copy(__position, end(), __i);
<         -:  831:		this->_M_deallocate();
<         -:  832:		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
<         -:  833:		this->_M_impl._M_start = __start;
<         -:  834:		this->_M_impl._M_finish = __finish;
<         -:  835:	      }
<         -:  836:	  }
<         -:  837:      }
<         -:  838:
<         -:  839:  template<typename _Alloc>
<         -:  840:    void
<         -:  841:    vector<bool, _Alloc>::
<         -:  842:    _M_insert_aux(iterator __position, bool __x)
<         -:  843:    {
<         -:  844:      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
<         -:  845:	{
<         -:  846:	  std::copy_backward(__position, this->_M_impl._M_finish, 
<         -:  847:			     this->_M_impl._M_finish + 1);
<         -:  848:	  *__position = __x;
<         -:  849:	  ++this->_M_impl._M_finish;
<         -:  850:	}
<         -:  851:      else
<         -:  852:	{
<         -:  853:	  const size_type __len =
<         -:  854:	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
<         -:  855:	  _Bit_pointer __q = this->_M_allocate(__len);
<         -:  856:	  iterator __start(std::__addressof(*__q), 0);
<         -:  857:	  iterator __i = _M_copy_aligned(begin(), __position, __start);
<         -:  858:	  *__i++ = __x;
<         -:  859:	  iterator __finish = std::copy(__position, end(), __i);
<         -:  860:	  this->_M_deallocate();
<         -:  861:	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
<         -:  862:	  this->_M_impl._M_start = __start;
<         -:  863:	  this->_M_impl._M_finish = __finish;
<         -:  864:	}
<         -:  865:    }
---
>         -:  697:		std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>         -:  698:			      _M_get_Tp_allocator());
>         -:  699:		_M_deallocate(this->_M_impl._M_start,
>         -:  700:			      this->_M_impl._M_end_of_storage
>         -:  701:			      - this->_M_impl._M_start);
>         -:  702:		this->_M_impl._M_start = __new_start;
>         -:  703:		this->_M_impl._M_finish = __new_finish;
>         -:  704:		this->_M_impl._M_end_of_storage = __new_start + __len;
>         -:  705:	      }
>         -:  706:	  }
>         -:  707:      }
>         -:  708:
>         -:  709:
>         -:  710:  // vector<bool>
>         -:  711:  template<typename _Alloc>
>         -:  712:    void
>         -:  713:    vector<bool, _Alloc>::
>         -:  714:    _M_reallocate(size_type __n)
>         -:  715:    {
>         -:  716:      _Bit_pointer __q = this->_M_allocate(__n);
>         -:  717:      iterator __start(std::__addressof(*__q), 0);
>         -:  718:      iterator __finish(_M_copy_aligned(begin(), end(), __start));
>         -:  719:      this->_M_deallocate();
>         -:  720:      this->_M_impl._M_start = __start;
>         -:  721:      this->_M_impl._M_finish = __finish;
>         -:  722:      this->_M_impl._M_end_of_storage = __q + _S_nword(__n);
>         -:  723:    }
>         -:  724:
>         -:  725:  template<typename _Alloc>
>         -:  726:    void
>         -:  727:    vector<bool, _Alloc>::
>         -:  728:    _M_fill_insert(iterator __position, size_type __n, bool __x)
>         -:  729:    {
>         -:  730:      if (__n == 0)
>         -:  731:	return;
>         -:  732:      if (capacity() - size() >= __n)
>         -:  733:	{
>         -:  734:	  std::copy_backward(__position, end(),
>         -:  735:			     this->_M_impl._M_finish + difference_type(__n));
>         -:  736:	  std::fill(__position, __position + difference_type(__n), __x);
>         -:  737:	  this->_M_impl._M_finish += difference_type(__n);
>         -:  738:	}
>         -:  739:      else
>         -:  740:	{
>         -:  741:	  const size_type __len = 
>         -:  742:	    _M_check_len(__n, "vector<bool>::_M_fill_insert");
>         -:  743:	  _Bit_pointer __q = this->_M_allocate(__len);
>         -:  744:	  iterator __start(std::__addressof(*__q), 0);
>         -:  745:	  iterator __i = _M_copy_aligned(begin(), __position, __start);
>         -:  746:	  std::fill(__i, __i + difference_type(__n), __x);
>         -:  747:	  iterator __finish = std::copy(__position, end(),
>         -:  748:					__i + difference_type(__n));
>         -:  749:	  this->_M_deallocate();
>         -:  750:	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
>         -:  751:	  this->_M_impl._M_start = __start;
>         -:  752:	  this->_M_impl._M_finish = __finish;
>         -:  753:	}
>         -:  754:    }
>         -:  755:
>         -:  756:  template<typename _Alloc>
>         -:  757:    template<typename _ForwardIterator>
>         -:  758:      void
>         -:  759:      vector<bool, _Alloc>::
>         -:  760:      _M_insert_range(iterator __position, _ForwardIterator __first, 
>         -:  761:		      _ForwardIterator __last, std::forward_iterator_tag)
>         -:  762:      {
>         -:  763:	if (__first != __last)
>         -:  764:	  {
>         -:  765:	    size_type __n = std::distance(__first, __last);
>         -:  766:	    if (capacity() - size() >= __n)
>         -:  767:	      {
>         -:  768:		std::copy_backward(__position, end(),
>         -:  769:				   this->_M_impl._M_finish
>         -:  770:				   + difference_type(__n));
>         -:  771:		std::copy(__first, __last, __position);
>         -:  772:		this->_M_impl._M_finish += difference_type(__n);
>         -:  773:	      }
>         -:  774:	    else
>         -:  775:	      {
>         -:  776:		const size_type __len =
>         -:  777:		  _M_check_len(__n, "vector<bool>::_M_insert_range");
>         -:  778:		_Bit_pointer __q = this->_M_allocate(__len);
>         -:  779:		iterator __start(std::__addressof(*__q), 0);
>         -:  780:		iterator __i = _M_copy_aligned(begin(), __position, __start);
>         -:  781:		__i = std::copy(__first, __last, __i);
>         -:  782:		iterator __finish = std::copy(__position, end(), __i);
>         -:  783:		this->_M_deallocate();
>         -:  784:		this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
>         -:  785:		this->_M_impl._M_start = __start;
>         -:  786:		this->_M_impl._M_finish = __finish;
>         -:  787:	      }
>         -:  788:	  }
>         -:  789:      }
>         -:  790:
>         -:  791:  template<typename _Alloc>
>         -:  792:    void
>         -:  793:    vector<bool, _Alloc>::
>         -:  794:    _M_insert_aux(iterator __position, bool __x)
>         -:  795:    {
>         -:  796:      if (this->_M_impl._M_finish._M_p != this->_M_impl._M_end_addr())
>         -:  797:	{
>         -:  798:	  std::copy_backward(__position, this->_M_impl._M_finish, 
>         -:  799:			     this->_M_impl._M_finish + 1);
>         -:  800:	  *__position = __x;
>         -:  801:	  ++this->_M_impl._M_finish;
>         -:  802:	}
>         -:  803:      else
>         -:  804:	{
>         -:  805:	  const size_type __len =
>         -:  806:	    _M_check_len(size_type(1), "vector<bool>::_M_insert_aux");
>         -:  807:	  _Bit_pointer __q = this->_M_allocate(__len);
>         -:  808:	  iterator __start(std::__addressof(*__q), 0);
>         -:  809:	  iterator __i = _M_copy_aligned(begin(), __position, __start);
>         -:  810:	  *__i++ = __x;
>         -:  811:	  iterator __finish = std::copy(__position, end(), __i);
>         -:  812:	  this->_M_deallocate();
>         -:  813:	  this->_M_impl._M_end_of_storage = __q + _S_nword(__len);
>         -:  814:	  this->_M_impl._M_start = __start;
>         -:  815:	  this->_M_impl._M_finish = __finish;
>         -:  816:	}
>         -:  817:    }
>         -:  818:
>         -:  819:  template<typename _Alloc>
>         -:  820:    typename vector<bool, _Alloc>::iterator
>         -:  821:    vector<bool, _Alloc>::
>         -:  822:    _M_erase(iterator __position)
>         -:  823:    {
>         -:  824:      if (__position + 1 != end())
>         -:  825:        std::copy(__position + 1, end(), __position);
>         -:  826:      --this->_M_impl._M_finish;
>         -:  827:      return __position;
>         -:  828:    }
>         -:  829:
>         -:  830:  template<typename _Alloc>
>         -:  831:    typename vector<bool, _Alloc>::iterator
>         -:  832:    vector<bool, _Alloc>::
>         -:  833:    _M_erase(iterator __first, iterator __last)
>         -:  834:    {
>         -:  835:      if (__first != __last)
>         -:  836:	_M_erase_at_end(std::copy(__last, end(), __first));
>         -:  837:      return __first;
>         -:  838:    }
>         -:  839:
>         -:  840:#if __cplusplus >= 201103L
>         -:  841:  template<typename _Alloc>
>         -:  842:    bool
>         -:  843:    vector<bool, _Alloc>::
>         -:  844:    _M_shrink_to_fit()
>         -:  845:    {
>         -:  846:      if (capacity() - size() < int(_S_word_bit))
>         -:  847:	return false;
>         -:  848:      __try
>         -:  849:	{
>         -:  850:	  _M_reallocate(size());
>         -:  851:	  return true;
>         -:  852:	}
>         -:  853:      __catch(...)
>         -:  854:	{ return false; }
>         -:  855:    }
>         -:  856:#endif
>         -:  857:
>         -:  858:_GLIBCXX_END_NAMESPACE_CONTAINER
>         -:  859:} // namespace std
>         -:  860:
>         -:  861:#if __cplusplus >= 201103L
>         -:  862:
>         -:  863:namespace std _GLIBCXX_VISIBILITY(default)
>         -:  864:{
>         -:  865:_GLIBCXX_BEGIN_NAMESPACE_VERSION
1663,1665c870,872
<         -:  868:    typename vector<bool, _Alloc>::iterator
<         -:  869:    vector<bool, _Alloc>::
<         -:  870:    _M_erase(iterator __position)
---
>         -:  868:    size_t
>         -:  869:    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
>         -:  870:    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
1667,1754c874,907
<         -:  872:      if (__position + 1 != end())
<         -:  873:        std::copy(__position + 1, end(), __position);
<         -:  874:      --this->_M_impl._M_finish;
<         -:  875:      return __position;
<         -:  876:    }
<         -:  877:
<         -:  878:  template<typename _Alloc>
<         -:  879:    typename vector<bool, _Alloc>::iterator
<         -:  880:    vector<bool, _Alloc>::
<         -:  881:    _M_erase(iterator __first, iterator __last)
<         -:  882:    {
<         -:  883:      if (__first != __last)
<         -:  884:	_M_erase_at_end(std::copy(__last, end(), __first));
<         -:  885:      return __first;
<         -:  886:    }
<         -:  887:
<         -:  888:#if __cplusplus >= 201103L
<         -:  889:  template<typename _Alloc>
<         -:  890:    bool
<         -:  891:    vector<bool, _Alloc>::
<         -:  892:    _M_shrink_to_fit()
<         -:  893:    {
<         -:  894:      if (capacity() - size() < int(_S_word_bit))
<         -:  895:	return false;
<         -:  896:      __try
<         -:  897:	{
<         -:  898:	  _M_reallocate(size());
<         -:  899:	  return true;
<         -:  900:	}
<         -:  901:      __catch(...)
<         -:  902:	{ return false; }
<         -:  903:    }
<         -:  904:#endif
<         -:  905:
<         -:  906:_GLIBCXX_END_NAMESPACE_CONTAINER
<         -:  907:_GLIBCXX_END_NAMESPACE_VERSION
<         -:  908:} // namespace std
<         -:  909:
<         -:  910:#if __cplusplus >= 201103L
<         -:  911:
<         -:  912:namespace std _GLIBCXX_VISIBILITY(default)
<         -:  913:{
<         -:  914:_GLIBCXX_BEGIN_NAMESPACE_VERSION
<         -:  915:
<         -:  916:  template<typename _Alloc>
<         -:  917:    size_t
<         -:  918:    hash<_GLIBCXX_STD_C::vector<bool, _Alloc>>::
<         -:  919:    operator()(const _GLIBCXX_STD_C::vector<bool, _Alloc>& __b) const noexcept
<         -:  920:    {
<         -:  921:      size_t __hash = 0;
<         -:  922:      using _GLIBCXX_STD_C::_S_word_bit;
<         -:  923:      using _GLIBCXX_STD_C::_Bit_type;
<         -:  924:
<         -:  925:      const size_t __words = __b.size() / _S_word_bit;
<         -:  926:      if (__words)
<         -:  927:	{
<         -:  928:	  const size_t __clength = __words * sizeof(_Bit_type);
<         -:  929:	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
<         -:  930:	}
<         -:  931:
<         -:  932:      const size_t __extrabits = __b.size() % _S_word_bit;
<         -:  933:      if (__extrabits)
<         -:  934:	{
<         -:  935:	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
<         -:  936:	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
<         -:  937:
<         -:  938:	  const size_t __clength
<         -:  939:	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
<         -:  940:	  if (__words)
<         -:  941:	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
<         -:  942:	  else
<         -:  943:	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
<         -:  944:	}
<         -:  945:
<         -:  946:      return __hash;
<         -:  947:    }
<         -:  948:
<         -:  949:_GLIBCXX_END_NAMESPACE_VERSION
<         -:  950:} // namespace std
<         -:  951:
<         -:  952:#endif // C++11
<         -:  953:
<         -:  954:#undef _GLIBCXX_ASAN_ANNOTATE_REINIT
<         -:  955:#undef _GLIBCXX_ASAN_ANNOTATE_GROW
<         -:  956:#undef _GLIBCXX_ASAN_ANNOTATE_GREW
<         -:  957:#undef _GLIBCXX_ASAN_ANNOTATE_SHRINK
<         -:  958:
<         -:  959:#endif /* _VECTOR_TCC */
---
>         -:  872:      size_t __hash = 0;
>         -:  873:      using _GLIBCXX_STD_C::_S_word_bit;
>         -:  874:      using _GLIBCXX_STD_C::_Bit_type;
>         -:  875:
>         -:  876:      const size_t __words = __b.size() / _S_word_bit;
>         -:  877:      if (__words)
>         -:  878:	{
>         -:  879:	  const size_t __clength = __words * sizeof(_Bit_type);
>         -:  880:	  __hash = std::_Hash_impl::hash(__b._M_impl._M_start._M_p, __clength);
>         -:  881:	}
>         -:  882:
>         -:  883:      const size_t __extrabits = __b.size() % _S_word_bit;
>         -:  884:      if (__extrabits)
>         -:  885:	{
>         -:  886:	  _Bit_type __hiword = *__b._M_impl._M_finish._M_p;
>         -:  887:	  __hiword &= ~((~static_cast<_Bit_type>(0)) << __extrabits);
>         -:  888:
>         -:  889:	  const size_t __clength
>         -:  890:	    = (__extrabits + __CHAR_BIT__ - 1) / __CHAR_BIT__;
>         -:  891:	  if (__words)
>         -:  892:	    __hash = std::_Hash_impl::hash(&__hiword, __clength, __hash);
>         -:  893:	  else
>         -:  894:	    __hash = std::_Hash_impl::hash(&__hiword, __clength);
>         -:  895:	}
>         -:  896:
>         -:  897:      return __hash;
>         -:  898:    }
>         -:  899:
>         -:  900:_GLIBCXX_END_NAMESPACE_VERSION
>         -:  901:} // namespace std
>         -:  902:
>         -:  903:#endif // C++11
>         -:  904:
>         -:  905:#endif /* _VECTOR_TCC */
