1c1
<         -:    0:Source:/home/ryan/git/TARGETS/OpenDDS-debloat/ACE_wrappers/ace/Timer_Queue_T.cpp
---
>         -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/ace/Timer_Queue_T.cpp
3c3
<         -:    1:// $Id$
---
>         -:    1:// $Id: Timer_Queue_T.cpp 2179 2013-05-28 22:16:51Z mesnierp $
66,86d65
< ------------------
< _ZN27ACE_Timer_Queue_Upcall_BaseIP17ACE_Event_Handler39ACE_Event_Handler_Handle_Timeout_UpcallED0Ev:
<     #####:   56:ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::~ACE_Timer_Queue_Upcall_Base ()
<         -:   57:{
<         -:   58:  ACE_TRACE ("ACE_Timer_Queue_Upcall_Base::~ACE_Timer_Queue_Upcall_Base");
<         -:   59:  if (this->delete_upcall_functor_)
<         -:   60:    {
<         -:   61:      delete this->upcall_functor_;
<         -:   62:    }
<     #####:   63:}
< ------------------
< _ZN27ACE_Timer_Queue_Upcall_BaseIP17ACE_Event_Handler39ACE_Event_Handler_Handle_Timeout_UpcallED2Ev:
<     #####:   56:ACE_Timer_Queue_Upcall_Base<TYPE, FUNCTOR>::~ACE_Timer_Queue_Upcall_Base ()
<         -:   57:{
<         -:   58:  ACE_TRACE ("ACE_Timer_Queue_Upcall_Base::~ACE_Timer_Queue_Upcall_Base");
<     #####:   59:  if (this->delete_upcall_functor_)
<         -:   60:    {
<     #####:   61:      delete this->upcall_functor_;
<         -:   62:    }
<     #####:   63:}
< ------------------
229,249d207
< ------------------
< _ZN17ACE_Timer_Queue_TIP17ACE_Event_Handler39ACE_Event_Handler_Handle_Timeout_Upcall26ACE_Recursive_Thread_Mutex24ACE_FPointer_Time_PolicyED0Ev:
<     #####:  198:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::~ACE_Timer_Queue_T (void)
<         -:  199:{
<         -:  200:  ACE_TRACE ("ACE_Timer_Queue_T::~ACE_Timer_Queue_T");
<         -:  201:
<         -:  202:  // Cleanup the free_list on the way out
<         -:  203:  if (this->delete_free_list_)
<         -:  204:    delete this->free_list_;
<     #####:  205:}
< ------------------
< _ZN17ACE_Timer_Queue_TIP17ACE_Event_Handler39ACE_Event_Handler_Handle_Timeout_Upcall26ACE_Recursive_Thread_Mutex24ACE_FPointer_Time_PolicyED2Ev:
<     #####:  198:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::~ACE_Timer_Queue_T (void)
<         -:  199:{
<         -:  200:  ACE_TRACE ("ACE_Timer_Queue_T::~ACE_Timer_Queue_T");
<         -:  201:
<         -:  202:  // Cleanup the free_list on the way out
<     #####:  203:  if (this->delete_free_list_)
<     #####:  204:    delete this->free_list_;
<     #####:  205:}
< ------------------
297,319c255,277
<         -:  253:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
<     #####:  254:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire (void)
<         -:  255:{
<         -:  256:  // We can't check here is the timer queue is empty, in some
<         -:  257:  // implementations (like the timer heap) calling is_empty()
<         -:  258:  // would at that moment access member variables without having
<         -:  259:  // locked ourself for thread safety
<     #####:  260:  return this->expire (this->gettimeofday_static () + timer_skew_);
<         -:  261:}
<         -:  262:
<         -:  263:// Run the <handle_timeout> method for all Timers whose values are <=
<         -:  264:// <cur_time>.
<         -:  265:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
<     #####:  266:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire (const ACE_Time_Value &cur_time)
<         -:  267:{
<         -:  268:  ACE_TRACE ("ACE_Timer_Queue_T::expire");
<     #####:  269:  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
<         -:  270:
<         -:  271:  // Keep looping while there are timers remaining and the earliest
<         -:  272:  // timer is <= the <cur_time> passed in to the method.
<         -:  273:
<     #####:  274:  if (this->is_empty ())
<     #####:  275:    return 0;
---
>         -:  253:// Run the <handle_timeout> method for all Timers whose values are <=
>         -:  254:// <cur_time>.
>         -:  255:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
>     #####:  256:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire (const ACE_Time_Value &cur_time)
>         -:  257:{
>         -:  258:  ACE_TRACE ("ACE_Timer_Queue_T::expire");
>     #####:  259:  ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
>         -:  260:
>         -:  261:  // Keep looping while there are timers remaining and the earliest
>         -:  262:  // timer is <= the <cur_time> passed in to the method.
>         -:  263:
>     #####:  264:  if (this->is_empty ())
>     #####:  265:    return 0;
>         -:  266:
>     #####:  267:  int number_of_timers_expired = 0;
>     #####:  268:  int result = 0;
>         -:  269:
>         -:  270:  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
>         -:  271:
>     #####:  272:  while ((result = this->dispatch_info_i (cur_time, info)) != 0)
>         -:  273:    {
>     #####:  274:      ACE_MT (ACE_Reverse_Lock<ACE_LOCK> rev_lk(this->mutex_));
>     #####:  275:      ACE_MT (ACE_GUARD_RETURN (ACE_Reverse_Lock<ACE_LOCK>, rmon, rev_lk, -1));
321,329c279,287
<     #####:  277:  int number_of_timers_expired = 0;
<     #####:  278:  int result = 0;
<         -:  279:
<         -:  280:  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
<         -:  281:
<     #####:  282:  while ((result = this->dispatch_info_i (cur_time, info)) != 0)
<         -:  283:    {
<     #####:  284:      ACE_MT (ACE_Reverse_Lock<ACE_LOCK> rev_lk(this->mutex_));
<     #####:  285:      ACE_MT (ACE_GUARD_RETURN (ACE_Reverse_Lock<ACE_LOCK>, rmon, rev_lk, -1));
---
>     #####:  277:      const void *upcall_act = 0;
>         -:  278:
>     #####:  279:      this->preinvoke (info, cur_time, upcall_act);
>         -:  280:
>     #####:  281:      this->upcall (info, cur_time);
>         -:  282:
>     #####:  283:      this->postinvoke (info, cur_time, upcall_act);
>         -:  284:
>     #####:  285:      ++number_of_timers_expired;
331c289
<     #####:  287:      const void *upcall_act = 0;
---
>         -:  287:    }
333,335c291,293
<     #####:  289:      this->preinvoke (info, cur_time, upcall_act);
<         -:  290:
<     #####:  291:      this->upcall (info, cur_time);
---
>         -:  289:  ACE_UNUSED_ARG (result);
>     #####:  290:  return number_of_timers_expired;
>         -:  291:}
337,439c295,397
<     #####:  293:      this->postinvoke (info, cur_time, upcall_act);
<         -:  294:
<     #####:  295:      ++number_of_timers_expired;
<         -:  296:
<         -:  297:    }
<         -:  298:
<         -:  299:  ACE_UNUSED_ARG (result);
<     #####:  300:  return number_of_timers_expired;
<         -:  301:}
<         -:  302:
<         -:  303:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
<     #####:  304:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recompute_next_abs_interval_time
<         -:  305:    (ACE_Timer_Node_T<TYPE> *expired,
<         -:  306:     const ACE_Time_Value &cur_time)
<         -:  307:{
<     #####:  308:  if ( expired->get_timer_value () <= cur_time )
<         -:  309:    {
<         -:  310:      /*
<         -:  311:       * Somehow the current time is past when this time was
<         -:  312:       * supposed to expire (e.g., timer took too long,
<         -:  313:       * somebody changed system time, etc.).  There used to
<         -:  314:       * be a simple loop here that skipped ahead one timer
<         -:  315:       * interval at a time, but that was horribly inefficient
<         -:  316:       * (an O(n) algorithm) when the timer duration was small
<         -:  317:       * relative to the amount of time skipped.
<         -:  318:       *
<         -:  319:       * So, we replace the loop with a simple computation,
<         -:  320:       * which also happens to be O(1).  All times get
<         -:  321:       * normalized in the computation to microseconds.
<         -:  322:       *
<         -:  323:       * For reference, the loop looked like this:
<         -:  324:       *
<         -:  325:       *   do
<         -:  326:       *     expired->set_timer_value (expired->get_timer_value () +
<         -:  327:       *                               expired->get_interval ());
<         -:  328:       *   while (expired->get_timer_value () <= cur_time);
<         -:  329:       *
<         -:  330:       */
<         -:  331:
<         -:  332:      // Compute the duration of the timer's interval
<         -:  333:      ACE_UINT64 interval_usec;
<     #####:  334:      expired->get_interval ().to_usec (interval_usec);
<         -:  335:
<         -:  336:      // Compute the span between the current time and when
<         -:  337:      // the timer would have expired in the past (and
<         -:  338:      // normalize to microseconds).
<     #####:  339:      ACE_Time_Value old_diff = cur_time - expired->get_timer_value ();
<         -:  340:      ACE_UINT64 old_diff_usec;
<     #####:  341:      old_diff.to_usec (old_diff_usec);
<         -:  342:
<         -:  343:      // Compute the delta time in the future when the timer
<         -:  344:      // should fire as if it had advanced incrementally.  The
<         -:  345:      // modulo arithmetic accomodates the likely case that
<         -:  346:      // the current time doesn't fall precisely on a timer
<         -:  347:      // firing interval.
<     #####:  348:      ACE_UINT64 new_timer_usec =
<     #####:  349:        interval_usec - (old_diff_usec % interval_usec);
<         -:  350:
<         -:  351:      // Compute the absolute time in the future when this
<         -:  352:      // interval timer should expire.
<     #####:  353:      ACE_Time_Value new_timer_value
<     #####:  354:        (cur_time.sec ()
<     #####:  355:         + static_cast<time_t>(new_timer_usec / ACE_ONE_SECOND_IN_USECS),
<     #####:  356:         cur_time.usec ()
<     #####:  357:         + static_cast<suseconds_t>(new_timer_usec % ACE_ONE_SECOND_IN_USECS));
<         -:  358:
<     #####:  359:      expired->set_timer_value (new_timer_value);
<         -:  360:    }
<     #####:  361:}
<         -:  362:
<         -:  363:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
<     #####:  364:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire_single (
<         -:  365:    ACE_Command_Base & pre_dispatch_command)
<         -:  366:{
<         -:  367:  ACE_TRACE ("ACE_Timer_Queue_T::expire_single");
<         -:  368:  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
<     #####:  369:  ACE_Time_Value cur_time;
<         -:  370:  {
<         -:  371:    // Create a scope for the lock ...
<     #####:  372:    ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
<         -:  373:
<     #####:  374:    if (this->is_empty ())
<     #####:  375:      return 0;
<         -:  376:
<         -:  377:    // Get the current time
<     #####:  378:    cur_time = this->gettimeofday_static () + this->timer_skew ();
<         -:  379:
<         -:  380:    // Look for a node in the timer queue whose timer <= the present
<         -:  381:    // time.
<     #####:  382:    if (!this->dispatch_info_i (cur_time, info))
<         -:  383:      {
<     #####:  384:        return 0;
<         -:  385:      }
<         -:  386:  }
<         -:  387:  // We do not need the lock anymore, all these operations take place
<         -:  388:  // with local variables.
<     #####:  389:  const void *upcall_act = 0;
<         -:  390:
<         -:  391:  // Preinvoke (handles refcount if needed, etc.)
<     #####:  392:  this->preinvoke (info, cur_time, upcall_act);
<         -:  393:
<         -:  394:  // Release the token before expiration upcall.
<     #####:  395:  pre_dispatch_command.execute();
---
>         -:  293:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
>     #####:  294:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::recompute_next_abs_interval_time
>         -:  295:    (ACE_Timer_Node_T<TYPE> *expired,
>         -:  296:     const ACE_Time_Value &cur_time)
>         -:  297:{
>     #####:  298:  if ( expired->get_timer_value () <= cur_time )
>         -:  299:    {
>         -:  300:      /*
>         -:  301:       * Somehow the current time is past when this time was
>         -:  302:       * supposed to expire (e.g., timer took too long,
>         -:  303:       * somebody changed system time, etc.).  There used to
>         -:  304:       * be a simple loop here that skipped ahead one timer
>         -:  305:       * interval at a time, but that was horribly inefficient
>         -:  306:       * (an O(n) algorithm) when the timer duration was small
>         -:  307:       * relative to the amount of time skipped.
>         -:  308:       *
>         -:  309:       * So, we replace the loop with a simple computation,
>         -:  310:       * which also happens to be O(1).  All times get
>         -:  311:       * normalized in the computation to microseconds.
>         -:  312:       *
>         -:  313:       * For reference, the loop looked like this:
>         -:  314:       *
>         -:  315:       *   do
>         -:  316:       *     expired->set_timer_value (expired->get_timer_value () +
>         -:  317:       *                               expired->get_interval ());
>         -:  318:       *   while (expired->get_timer_value () <= cur_time);
>         -:  319:       *
>         -:  320:       */
>         -:  321:
>         -:  322:      // Compute the duration of the timer's interval
>         -:  323:      ACE_UINT64 interval_usec;
>     #####:  324:      expired->get_interval ().to_usec (interval_usec);
>         -:  325:
>         -:  326:      // Compute the span between the current time and when
>         -:  327:      // the timer would have expired in the past (and
>         -:  328:      // normalize to microseconds).
>     #####:  329:      ACE_Time_Value old_diff = cur_time - expired->get_timer_value ();
>         -:  330:      ACE_UINT64 old_diff_usec;
>     #####:  331:      old_diff.to_usec (old_diff_usec);
>         -:  332:
>         -:  333:      // Compute the delta time in the future when the timer
>         -:  334:      // should fire as if it had advanced incrementally.  The
>         -:  335:      // modulo arithmetic accomodates the likely case that
>         -:  336:      // the current time doesn't fall precisely on a timer
>         -:  337:      // firing interval.
>     #####:  338:      ACE_UINT64 new_timer_usec =
>     #####:  339:        interval_usec - (old_diff_usec % interval_usec);
>         -:  340:
>         -:  341:      // Compute the absolute time in the future when this
>         -:  342:      // interval timer should expire.
>     #####:  343:      ACE_Time_Value new_timer_value
>     #####:  344:        (cur_time.sec ()
>     #####:  345:         + static_cast<time_t>(new_timer_usec / ACE_ONE_SECOND_IN_USECS),
>     #####:  346:         cur_time.usec ()
>     #####:  347:         + static_cast<suseconds_t>(new_timer_usec % ACE_ONE_SECOND_IN_USECS));
>         -:  348:
>     #####:  349:      expired->set_timer_value (new_timer_value);
>         -:  350:    }
>     #####:  351:}
>         -:  352:
>         -:  353:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
>     #####:  354:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::expire_single (
>         -:  355:    ACE_Command_Base & pre_dispatch_command)
>         -:  356:{
>         -:  357:  ACE_TRACE ("ACE_Timer_Queue_T::expire_single");
>         -:  358:  ACE_Timer_Node_Dispatch_Info_T<TYPE> info;
>     #####:  359:  ACE_Time_Value cur_time;
>         -:  360:  {
>         -:  361:    // Create a scope for the lock ...
>     #####:  362:    ACE_MT (ACE_GUARD_RETURN (ACE_LOCK, ace_mon, this->mutex_, -1));
>         -:  363:
>     #####:  364:    if (this->is_empty ())
>     #####:  365:      return 0;
>         -:  366:
>         -:  367:    // Get the current time
>     #####:  368:    cur_time = this->gettimeofday_static () + this->timer_skew ();
>         -:  369:
>         -:  370:    // Look for a node in the timer queue whose timer <= the present
>         -:  371:    // time.
>     #####:  372:    if (!this->dispatch_info_i (cur_time, info))
>         -:  373:      {
>     #####:  374:        return 0;
>         -:  375:      }
>         -:  376:  }
>         -:  377:  // We do not need the lock anymore, all these operations take place
>         -:  378:  // with local variables.
>     #####:  379:  const void *upcall_act = 0;
>         -:  380:
>         -:  381:  // Preinvoke (handles refcount if needed, etc.)
>     #####:  382:  this->preinvoke (info, cur_time, upcall_act);
>         -:  383:
>         -:  384:  // Release the token before expiration upcall.
>     #####:  385:  pre_dispatch_command.execute();
>         -:  386:
>         -:  387:  // call the functor
>     #####:  388:  this->upcall (info, cur_time);
>         -:  389:
>         -:  390:  // Postinvoke (undo refcount if needed, etc.)
>     #####:  391:  this->postinvoke (info, cur_time, upcall_act);
>         -:  392:
>         -:  393:  // We have dispatched a timer
>     #####:  394:  return 1;
>         -:  395:}
441,445c399,403
<         -:  397:  // call the functor
<     #####:  398:  this->upcall (info, cur_time);
<         -:  399:
<         -:  400:  // Postinvoke (undo refcount if needed, etc.)
<     #####:  401:  this->postinvoke (info, cur_time, upcall_act);
---
>         -:  397:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
>     #####:  398:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dispatch_info_i (const ACE_Time_Value &cur_time,
>         -:  399:                                                             ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
>         -:  400:{
>         -:  401:  ACE_TRACE ("ACE_Timer_Queue_T::dispatch_info_i");
447,499c405,449
<         -:  403:  // We have dispatched a timer
<     #####:  404:  return 1;
<         -:  405:}
<         -:  406:
<         -:  407:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> int
<     #####:  408:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::dispatch_info_i (const ACE_Time_Value &cur_time,
<         -:  409:                                                             ACE_Timer_Node_Dispatch_Info_T<TYPE> &info)
<         -:  410:{
<         -:  411:  ACE_TRACE ("ACE_Timer_Queue_T::dispatch_info_i");
<         -:  412:
<     #####:  413:  if (this->is_empty ())
<     #####:  414:    return 0;
<         -:  415:
<     #####:  416:  if (this->earliest_time () <= cur_time)
<         -:  417:    {
<     #####:  418:      ACE_Timer_Node_T<TYPE> *expired = this->remove_first ();
<         -:  419:
<         -:  420:      // Get the dispatch info
<     #####:  421:      expired->get_dispatch_info (info);
<         -:  422:
<         -:  423:      // Check if this is an interval timer.
<     #####:  424:      if (expired->get_interval () > ACE_Time_Value::zero)
<         -:  425:        {
<         -:  426:          // Make sure that we skip past values that have already
<         -:  427:          // "expired".
<     #####:  428:          this->recompute_next_abs_interval_time (expired, cur_time);
<         -:  429:
<         -:  430:          // Since this is an interval timer, we need to reschedule
<         -:  431:          // it.
<     #####:  432:          this->reschedule (expired);
<         -:  433:        }
<         -:  434:      else
<         -:  435:        {
<         -:  436:          // Call the factory method to free up the node.
<     #####:  437:          this->free_node (expired);
<         -:  438:        }
<         -:  439:
<     #####:  440:      return 1;
<         -:  441:    }
<         -:  442:
<     #####:  443:  return 0;
<         -:  444:}
<         -:  445:
<         -:  446:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
<     #####:  447:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::return_node (ACE_Timer_Node_T<TYPE> *node)
<         -:  448:{
<     #####:  449:  ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
<     #####:  450:  this->free_node (node);
<         -:  451:}
<         -:  452:
<         -:  453:ACE_END_VERSIONED_NAMESPACE_DECL
<         -:  454:
<         -:  455:#endif /* ACE_TIMER_QUEUE_T_CPP */
---
>     #####:  403:  if (this->is_empty ())
>     #####:  404:    return 0;
>         -:  405:
>     #####:  406:  ACE_Timer_Node_T<TYPE> *expired = 0;
>         -:  407:
>     #####:  408:  if (this->earliest_time () <= cur_time)
>         -:  409:    {
>     #####:  410:      expired = this->remove_first ();
>         -:  411:
>         -:  412:      // Get the dispatch info
>     #####:  413:      expired->get_dispatch_info (info);
>         -:  414:
>         -:  415:      // Check if this is an interval timer.
>     #####:  416:      if (expired->get_interval () > ACE_Time_Value::zero)
>         -:  417:        {
>         -:  418:          // Make sure that we skip past values that have already
>         -:  419:          // "expired".
>     #####:  420:          this->recompute_next_abs_interval_time (expired, cur_time);
>         -:  421:
>         -:  422:          // Since this is an interval timer, we need to reschedule
>         -:  423:          // it.
>     #####:  424:          this->reschedule (expired);
>         -:  425:        }
>         -:  426:      else
>         -:  427:        {
>         -:  428:          // Call the factory method to free up the node.
>     #####:  429:          this->free_node (expired);
>         -:  430:        }
>         -:  431:
>     #####:  432:      return 1;
>         -:  433:    }
>         -:  434:
>     #####:  435:  return 0;
>         -:  436:}
>         -:  437:
>         -:  438:template <class TYPE, class FUNCTOR, class ACE_LOCK, typename TIME_POLICY> void
>     #####:  439:ACE_Timer_Queue_T<TYPE, FUNCTOR, ACE_LOCK, TIME_POLICY>::return_node (ACE_Timer_Node_T<TYPE> *node)
>         -:  440:{
>     #####:  441:  ACE_MT (ACE_GUARD (ACE_LOCK, ace_mon, this->mutex_));
>     #####:  442:  this->free_node (node);
>         -:  443:}
>         -:  444:
>         -:  445:ACE_END_VERSIONED_NAMESPACE_DECL
>         -:  446:
>         -:  447:#endif /* ACE_TIMER_QUEUE_T_CPP */
