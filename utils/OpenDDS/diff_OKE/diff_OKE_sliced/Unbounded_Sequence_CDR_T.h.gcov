1c1
<         -:    0:Source:/home/ryan/git/TARGETS/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Sequence_CDR_T.h
---
>         -:    0:Source:/home/ryan/git/OpenDDS-debloat/ACE_wrappers/TAO/tao/Unbounded_Sequence_CDR_T.h
10c10
<         -:    8: * $Id$
---
>         -:    8: * $Id: Unbounded_Sequence_CDR_T.h 1861 2011-08-31 16:18:08Z mesnierp $
105c105
<        57:  103:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Octet> & target) {
---
>        80:  103:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <CORBA::Octet> & target) {
107,108c107,108
<        57:  105:    ::CORBA::ULong new_length = 0;
<        57:  106:    if (!(strm >> new_length)) {
---
>        80:  105:    ::CORBA::ULong new_length = 0;
>        80:  106:    if (!(strm >> new_length)) {
111c111
<        57:  109:    if (new_length > strm.length()) {
---
>        80:  109:    if (new_length > strm.length()) {
114,116c114,116
<       114:  112:    sequence tmp(new_length);
<        57:  113:    tmp.length(new_length);
<        57:  114:    if (ACE_BIT_DISABLED (strm.start ()->flags (), ACE_Message_Block::DONT_DELETE))
---
>       160:  112:    sequence tmp(new_length);
>        80:  113:    tmp.length(new_length);
>        80:  114:    if (ACE_BIT_DISABLED (strm.start ()->flags (), ACE_Message_Block::DONT_DELETE))
118,120c118,120
<        12:  116:      TAO_ORB_Core* orb_core = strm.orb_core ();
<       24*:  117:      if (orb_core != 0 && strm.orb_core ()->resource_factory ()->
<        12:  118:        input_cdr_allocator_type_locked () == 1)
---
>     #####:  116:      TAO_ORB_Core* orb_core = strm.orb_core ();
>     #####:  117:      if (orb_core != 0 && strm.orb_core ()->resource_factory ()->
>     #####:  118:        input_cdr_allocator_type_locked () == 1)
122,126c122,126
<        12:  120:        tmp.replace (new_length, strm.start ());
<        12:  121:        tmp.mb ()->wr_ptr (tmp.mb()->rd_ptr () + new_length);
<        12:  122:        strm.skip_bytes (new_length);
<        12:  123:        tmp.swap(target);
<        12:  124:        return true;
---
>     #####:  120:        tmp.replace (new_length, strm.start ());
>     #####:  121:        tmp.mb ()->wr_ptr (tmp.mb()->rd_ptr () + new_length);
>     #####:  122:        strm.skip_bytes (new_length);
>     #####:  123:        tmp.swap(target);
>     #####:  124:        return true;
129,130c129,130
<        45:  127:    typename sequence::value_type * buffer = tmp.get_buffer();
<        45:  128:    if (!strm.read_octet_array (buffer, new_length)) {
---
>        80:  127:    typename sequence::value_type * buffer = tmp.get_buffer();
>        80:  128:    if (!strm.read_octet_array (buffer, new_length)) {
133,134c133,134
<        45:  131:    tmp.swap(target);
<        45:  132:    return true;
---
>        80:  131:    tmp.swap(target);
>        80:  132:    return true;
321c321
<       19*:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
---
>        37:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
323,324c323,324
<       19*:  321:    ::CORBA::ULong new_length = 0;
<       19*:  322:    if (!(strm >> new_length)) {
---
>        37:  321:    ::CORBA::ULong new_length = 0;
>        37:  322:    if (!(strm >> new_length)) {
327c327
<       19*:  325:    if (new_length > strm.length()) {
---
>        37:  325:    if (new_length > strm.length()) {
330,334c330,334
<       38*:  328:    sequence tmp(new_length);
<       19*:  329:    tmp.length(new_length);
<       19*:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<       34*:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<       15*:  332:      if (!(strm >> buffer[i])) {
---
>        74:  328:    sequence tmp(new_length);
>        37:  329:    tmp.length(new_length);
>        37:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
>        62:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
>        25:  332:      if (!(strm >> buffer[i])) {
338,339c338,339
<       19*:  336:    tmp.swap(target);
<       19*:  337:    return true;
---
>        37:  336:    tmp.swap(target);
>        37:  337:    return true;
341,539d340
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN3DDS10SampleInfoEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<     #####:  321:    ::CORBA::ULong new_length = 0;
<     #####:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<     #####:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<     #####:  328:    sequence tmp(new_length);
<     #####:  329:    tmp.length(new_length);
<     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<     #####:  336:    tmp.swap(target);
<     #####:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN3DDS16BinaryProperty_tEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<         2:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<         2:  321:    ::CORBA::ULong new_length = 0;
<         2:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<         2:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<         4:  328:    sequence tmp(new_length);
<         2:  329:    tmp.length(new_length);
<         2:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<        2*:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<         2:  336:    tmp.swap(target);
<         2:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN3DDS10Property_tEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<         2:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<         2:  321:    ::CORBA::ULong new_length = 0;
<         2:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<         2:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<         4:  328:    sequence tmp(new_length);
<         2:  329:    tmp.length(new_length);
<         2:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<        2*:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<         2:  336:    tmp.swap(target);
<         2:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN3DDS14QosPolicyCountEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<     #####:  321:    ::CORBA::ULong new_length = 0;
<     #####:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<     #####:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<     #####:  328:    sequence tmp(new_length);
<     #####:  329:    tmp.length(new_length);
<     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<     #####:  336:    tmp.swap(target);
<     #####:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN7OpenDDS4DCPS6GUID_tEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<     #####:  321:    ::CORBA::ULong new_length = 0;
<     #####:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<     #####:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<     #####:  328:    sequence tmp(new_length);
<     #####:  329:    tmp.length(new_length);
<     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<     #####:  336:    tmp.swap(target);
<     #####:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN7OpenDDS4DCPS9Locator_tEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<     #####:  321:    ::CORBA::ULong new_length = 0;
<     #####:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<     #####:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<     #####:  328:    sequence tmp(new_length);
<     #####:  329:    tmp.length(new_length);
<     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<     #####:  336:    tmp.swap(target);
<     #####:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN7OpenDDS4DCPS6GUID_tEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<     #####:  321:    ::CORBA::ULong new_length = 0;
<     #####:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<     #####:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<     #####:  328:    sequence tmp(new_length);
<     #####:  329:    tmp.length(new_length);
<     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<     #####:  336:    tmp.swap(target);
<     #####:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN7OpenDDS4DCPS16TransportLocatorEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<        15:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<        15:  321:    ::CORBA::ULong new_length = 0;
<        15:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<        15:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<        30:  328:    sequence tmp(new_length);
<        15:  329:    tmp.length(new_length);
<        15:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<        30:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<        15:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<        15:  336:    tmp.swap(target);
<        15:  337:    return true;
<         -:  338:  }
< ------------------
< _ZN3TAO18demarshal_sequenceI12TAO_InputCDRN7OpenDDS4DCPS17LatencyStatisticsEEEbRT_RNS_24unbounded_value_sequenceIT0_EE:
<     #####:  319:  bool demarshal_sequence(stream & strm, TAO::unbounded_value_sequence <value_t> & target) {
<         -:  320:    typedef TAO::unbounded_value_sequence <value_t> sequence;
<     #####:  321:    ::CORBA::ULong new_length = 0;
<     #####:  322:    if (!(strm >> new_length)) {
<     #####:  323:      return false;
<         -:  324:    }
<     #####:  325:    if (new_length > strm.length()) {
<     #####:  326:      return false;
<         -:  327:    }
<     #####:  328:    sequence tmp(new_length);
<     #####:  329:    tmp.length(new_length);
<     #####:  330:    typename sequence::value_type * buffer = tmp.get_buffer();
<     #####:  331:    for(CORBA::ULong i = 0; i < new_length; ++i) {
<     #####:  332:      if (!(strm >> buffer[i])) {
<     #####:  333:        return false;
<         -:  334:      }
<         -:  335:    }
<     #####:  336:    tmp.swap(target);
<     #####:  337:    return true;
<         -:  338:  }
< ------------------
542c343
<        25:  341:  bool demarshal_sequence(stream & strm, TAO::unbounded_basic_string_sequence <charT> & target) {
---
>        34:  341:  bool demarshal_sequence(stream & strm, TAO::unbounded_basic_string_sequence <charT> & target) {
546,547c347,348
<        25:  345:    ::CORBA::ULong new_length = 0;
<        25:  346:    if (!(strm >> new_length)) {
---
>        34:  345:    ::CORBA::ULong new_length = 0;
>        34:  346:    if (!(strm >> new_length)) {
550c351
<        25:  349:    if (new_length > strm.length()) {
---
>        34:  349:    if (new_length > strm.length()) {
553c354
<        50:  352:    sequence tmp(new_length, new_length,
---
>        68:  352:    sequence tmp(new_length, new_length,
556c357
<       25*:  355:    for(CORBA::ULong i = 0; i < new_length; ++i) {
---
>        34:  355:    for(CORBA::ULong i = 0; i < new_length; ++i) {
565,566c366,367
<        25:  364:    tmp.swap(target);
<        25:  365:    return true;
---
>        34:  364:    tmp.swap(target);
>        34:  365:    return true;
665,667c466,468
<        51:  464:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Octet> & source) {
<        51:  465:    ::CORBA::ULong const length = source.length ();
<        51:  466:    if (!(strm << length)) {
---
>        86:  464:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <CORBA::Octet> & source) {
>        86:  465:    ::CORBA::ULong const length = source.length ();
>        86:  466:    if (!(strm << length)) {
670c471
<        51:  469:    if (source.mb ()) {
---
>        86:  469:    if (source.mb ()) {
673c474
<        51:  472:    return strm.write_octet_array (source.get_buffer (), length);
---
>        86:  472:    return strm.write_octet_array (source.get_buffer (), length);
761,889c562,564
<       18*:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<       18*:  561:    ::CORBA::ULong const length = source.length ();
<       18*:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<       34*:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<       16*:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<       18*:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN3DDS10SampleInfoEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<     #####:  561:    ::CORBA::ULong const length = source.length ();
<     #####:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<     #####:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN3DDS16BinaryProperty_tEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<         1:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<         1:  561:    ::CORBA::ULong const length = source.length ();
<         1:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<        1*:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<         1:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN3DDS10Property_tEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<         1:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<         1:  561:    ::CORBA::ULong const length = source.length ();
<         1:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<        1*:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<         1:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN3DDS14QosPolicyCountEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<     #####:  561:    ::CORBA::ULong const length = source.length ();
<     #####:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<     #####:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN7OpenDDS4DCPS6GUID_tEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<         1:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<         1:  561:    ::CORBA::ULong const length = source.length ();
<         1:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<         2:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<         1:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<         1:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN7OpenDDS4DCPS9Locator_tEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<     #####:  561:    ::CORBA::ULong const length = source.length ();
<     #####:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<     #####:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN7OpenDDS4DCPS6GUID_tEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<     #####:  561:    ::CORBA::ULong const length = source.length ();
<     #####:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<     #####:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN7OpenDDS4DCPS16TransportLocatorEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<        15:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<        15:  561:    ::CORBA::ULong const length = source.length ();
<        15:  562:    if (!(strm << length)) {
<     #####:  563:      return false;
<         -:  564:    }
<        30:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<        15:  566:      if (!(strm << source[i])) {
<     #####:  567:        return false;
<         -:  568:      }
<         -:  569:    }
<        15:  570:    return true;
<         -:  571:  }
< ------------------
< _ZN3TAO16marshal_sequenceI13TAO_OutputCDRN7OpenDDS4DCPS17LatencyStatisticsEEEbRT_RKNS_24unbounded_value_sequenceIT0_EE:
<     #####:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
<     #####:  561:    ::CORBA::ULong const length = source.length ();
<     #####:  562:    if (!(strm << length)) {
---
>        45:  560:  bool marshal_sequence(stream & strm, const TAO::unbounded_value_sequence <value_t> & source) {
>        45:  561:    ::CORBA::ULong const length = source.length ();
>        45:  562:    if (!(strm << length)) {
892,893c567,568
<     #####:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
<     #####:  566:      if (!(strm << source[i])) {
---
>        74:  565:    for(CORBA::ULong i = 0; i < length; ++i) {
>        29:  566:      if (!(strm << source[i])) {
897c572
<     #####:  570:    return true;
---
>        45:  570:    return true;
899d573
< ------------------
902,904c576,578
<        20:  574:  bool marshal_sequence(stream & strm, const TAO::unbounded_basic_string_sequence <charT> & source) {
<        20:  575:    ::CORBA::ULong const length = source.length ();
<        20:  576:    if (!(strm << length)) {
---
>        31:  574:  bool marshal_sequence(stream & strm, const TAO::unbounded_basic_string_sequence <charT> & source) {
>        31:  575:    ::CORBA::ULong const length = source.length ();
>        31:  576:    if (!(strm << length)) {
907c581
<       20*:  579:    for(CORBA::ULong i = 0; i < length; ++i) {
---
>        31:  579:    for(CORBA::ULong i = 0; i < length; ++i) {
912c586
<        20:  584:    return true;
---
>        31:  584:    return true;
