1c1
<         -:    0:Source:/usr/include/c++/8/bits/stl_set.h
---
>         -:    0:Source:/usr/include/c++/7/bits/stl_set.h
5c5
<         -:    3:// Copyright (C) 2001-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 2001-2017 Free Software Foundation, Inc.
68,127c68,127
<         -:   66:_GLIBCXX_BEGIN_NAMESPACE_VERSION
<         -:   67:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
<         -:   68:
<         -:   69:  template<typename _Key, typename _Compare, typename _Alloc>
<         -:   70:    class multiset;
<         -:   71:
<         -:   72:  /**
<         -:   73:   *  @brief A standard container made up of unique keys, which can be
<         -:   74:   *  retrieved in logarithmic time.
<         -:   75:   *
<         -:   76:   *  @ingroup associative_containers
<         -:   77:   *
<         -:   78:   *  @tparam _Key  Type of key objects.
<         -:   79:   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
<         -:   80:   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
<         -:   81:   *
<         -:   82:   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
<         -:   83:   *  <a href="tables.html#66">reversible container</a>, and an
<         -:   84:   *  <a href="tables.html#69">associative container</a> (using unique keys).
<         -:   85:   *
<         -:   86:   *  Sets support bidirectional iterators.
<         -:   87:   *
<         -:   88:   *  The private tree data is declared exactly the same way for set and
<         -:   89:   *  multiset; the distinction is made entirely in how the tree functions are
<         -:   90:   *  called (*_unique versus *_equal, same as the standard).
<         -:   91:  */
<         -:   92:  template<typename _Key, typename _Compare = std::less<_Key>,
<         -:   93:	   typename _Alloc = std::allocator<_Key> >
<         -:   94:    class set
<         -:   95:    {
<         -:   96:#ifdef _GLIBCXX_CONCEPT_CHECKS
<         -:   97:      // concept requirements
<         -:   98:      typedef typename _Alloc::value_type		_Alloc_value_type;
<         -:   99:# if __cplusplus < 201103L
<         -:  100:      __glibcxx_class_requires(_Key, _SGIAssignableConcept)
<         -:  101:# endif
<         -:  102:      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
<         -:  103:				_BinaryFunctionConcept)
<         -:  104:      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)
<         -:  105:#endif
<         -:  106:
<         -:  107:#if __cplusplus >= 201103L
<         -:  108:      static_assert(is_same<typename remove_cv<_Key>::type, _Key>::value,
<         -:  109:	  "std::set must have a non-const, non-volatile value_type");
<         -:  110:# ifdef __STRICT_ANSI__
<         -:  111:      static_assert(is_same<typename _Alloc::value_type, _Key>::value,
<         -:  112:	  "std::set must have the same value_type as its allocator");
<         -:  113:# endif
<         -:  114:#endif
<         -:  115:
<         -:  116:    public:
<         -:  117:      // typedefs:
<         -:  118:      //@{
<         -:  119:      /// Public typedefs.
<         -:  120:      typedef _Key     key_type;
<         -:  121:      typedef _Key     value_type;
<         -:  122:      typedef _Compare key_compare;
<         -:  123:      typedef _Compare value_compare;
<         -:  124:      typedef _Alloc   allocator_type;
<         -:  125:      //@}
---
>         -:   66:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
>         -:   67:
>         -:   68:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:   69:    class multiset;
>         -:   70:
>         -:   71:  /**
>         -:   72:   *  @brief A standard container made up of unique keys, which can be
>         -:   73:   *  retrieved in logarithmic time.
>         -:   74:   *
>         -:   75:   *  @ingroup associative_containers
>         -:   76:   *
>         -:   77:   *  @tparam _Key  Type of key objects.
>         -:   78:   *  @tparam _Compare  Comparison function object type, defaults to less<_Key>.
>         -:   79:   *  @tparam _Alloc  Allocator type, defaults to allocator<_Key>.
>         -:   80:   *
>         -:   81:   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
>         -:   82:   *  <a href="tables.html#66">reversible container</a>, and an
>         -:   83:   *  <a href="tables.html#69">associative container</a> (using unique keys).
>         -:   84:   *
>         -:   85:   *  Sets support bidirectional iterators.
>         -:   86:   *
>         -:   87:   *  The private tree data is declared exactly the same way for set and
>         -:   88:   *  multiset; the distinction is made entirely in how the tree functions are
>         -:   89:   *  called (*_unique versus *_equal, same as the standard).
>         -:   90:  */
>         -:   91:  template<typename _Key, typename _Compare = std::less<_Key>,
>         -:   92:	   typename _Alloc = std::allocator<_Key> >
>         -:   93:    class set
>         -:   94:    {
>         -:   95:#ifdef _GLIBCXX_CONCEPT_CHECKS
>         -:   96:      // concept requirements
>         -:   97:      typedef typename _Alloc::value_type		_Alloc_value_type;
>         -:   98:# if __cplusplus < 201103L
>         -:   99:      __glibcxx_class_requires(_Key, _SGIAssignableConcept)
>         -:  100:# endif
>         -:  101:      __glibcxx_class_requires4(_Compare, bool, _Key, _Key,
>         -:  102:				_BinaryFunctionConcept)
>         -:  103:      __glibcxx_class_requires2(_Key, _Alloc_value_type, _SameTypeConcept)
>         -:  104:#endif
>         -:  105:
>         -:  106:    public:
>         -:  107:      // typedefs:
>         -:  108:      //@{
>         -:  109:      /// Public typedefs.
>         -:  110:      typedef _Key     key_type;
>         -:  111:      typedef _Key     value_type;
>         -:  112:      typedef _Compare key_compare;
>         -:  113:      typedef _Compare value_compare;
>         -:  114:      typedef _Alloc   allocator_type;
>         -:  115:      //@}
>         -:  116:
>         -:  117:    private:
>         -:  118:      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
>         -:  119:	rebind<_Key>::other _Key_alloc_type;
>         -:  120:
>         -:  121:      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
>         -:  122:		       key_compare, _Key_alloc_type> _Rep_type;
>         -:  123:      _Rep_type _M_t;  // Red-black tree representing set.
>         -:  124:
>         -:  125:      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
129,159c129,159
<         -:  127:    private:
<         -:  128:      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
<         -:  129:	rebind<_Key>::other _Key_alloc_type;
<         -:  130:
<         -:  131:      typedef _Rb_tree<key_type, value_type, _Identity<value_type>,
<         -:  132:		       key_compare, _Key_alloc_type> _Rep_type;
<         -:  133:      _Rep_type _M_t;  // Red-black tree representing set.
<         -:  134:
<         -:  135:      typedef __gnu_cxx::__alloc_traits<_Key_alloc_type> _Alloc_traits;
<         -:  136:
<         -:  137:    public:
<         -:  138:      //@{
<         -:  139:      ///  Iterator-related typedefs.
<         -:  140:      typedef typename _Alloc_traits::pointer		 pointer;
<         -:  141:      typedef typename _Alloc_traits::const_pointer	 const_pointer;
<         -:  142:      typedef typename _Alloc_traits::reference		 reference;
<         -:  143:      typedef typename _Alloc_traits::const_reference	 const_reference;
<         -:  144:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -:  145:      // DR 103. set::iterator is required to be modifiable,
<         -:  146:      // but this allows modification of keys.
<         -:  147:      typedef typename _Rep_type::const_iterator	 iterator;
<         -:  148:      typedef typename _Rep_type::const_iterator	 const_iterator;
<         -:  149:      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
<         -:  150:      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
<         -:  151:      typedef typename _Rep_type::size_type		 size_type;
<         -:  152:      typedef typename _Rep_type::difference_type	 difference_type;
<         -:  153:      //@}
<         -:  154:
<         -:  155:#if __cplusplus > 201402L
<         -:  156:      using node_type = typename _Rep_type::node_type;
<         -:  157:      using insert_return_type = typename _Rep_type::insert_return_type;
---
>         -:  127:    public:
>         -:  128:      //@{
>         -:  129:      ///  Iterator-related typedefs.
>         -:  130:      typedef typename _Alloc_traits::pointer		 pointer;
>         -:  131:      typedef typename _Alloc_traits::const_pointer	 const_pointer;
>         -:  132:      typedef typename _Alloc_traits::reference		 reference;
>         -:  133:      typedef typename _Alloc_traits::const_reference	 const_reference;
>         -:  134:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  135:      // DR 103. set::iterator is required to be modifiable,
>         -:  136:      // but this allows modification of keys.
>         -:  137:      typedef typename _Rep_type::const_iterator	 iterator;
>         -:  138:      typedef typename _Rep_type::const_iterator	 const_iterator;
>         -:  139:      typedef typename _Rep_type::const_reverse_iterator reverse_iterator;
>         -:  140:      typedef typename _Rep_type::const_reverse_iterator const_reverse_iterator;
>         -:  141:      typedef typename _Rep_type::size_type		 size_type;
>         -:  142:      typedef typename _Rep_type::difference_type	 difference_type;
>         -:  143:      //@}
>         -:  144:
>         -:  145:#if __cplusplus > 201402L
>         -:  146:      using node_type = typename _Rep_type::node_type;
>         -:  147:      using insert_return_type = typename _Rep_type::insert_return_type;
>         -:  148:#endif
>         -:  149:
>         -:  150:      // allocation/deallocation
>         -:  151:      /**
>         -:  152:       *  @brief  Default constructor creates no elements.
>         -:  153:       */
>         -:  154:#if __cplusplus < 201103L
>         -:  155:      set() : _M_t() { }
>         -:  156:#else
>     #####:  157:      set() = default;
162,170c162,170
<         -:  160:      // allocation/deallocation
<         -:  161:      /**
<         -:  162:       *  @brief  Default constructor creates no elements.
<         -:  163:       */
<         -:  164:#if __cplusplus < 201103L
<         -:  165:      set() : _M_t() { }
<         -:  166:#else
<     #####:  167:      set() = default;
<         -:  168:#endif
---
>         -:  160:      /**
>         -:  161:       *  @brief  Creates a %set with no elements.
>         -:  162:       *  @param  __comp  Comparator to use.
>         -:  163:       *  @param  __a  An allocator object.
>         -:  164:       */
>         -:  165:      explicit
>         -:  166:      set(const _Compare& __comp,
>         -:  167:	  const allocator_type& __a = allocator_type())
>         -:  168:      : _M_t(__comp, _Key_alloc_type(__a)) { }
173,254c173,254
<         -:  171:       *  @brief  Creates a %set with no elements.
<         -:  172:       *  @param  __comp  Comparator to use.
<         -:  173:       *  @param  __a  An allocator object.
<         -:  174:       */
<         -:  175:      explicit
<         -:  176:      set(const _Compare& __comp,
<         -:  177:	  const allocator_type& __a = allocator_type())
<         -:  178:      : _M_t(__comp, _Key_alloc_type(__a)) { }
<         -:  179:
<         -:  180:      /**
<         -:  181:       *  @brief  Builds a %set from a range.
<         -:  182:       *  @param  __first  An input iterator.
<         -:  183:       *  @param  __last  An input iterator.
<         -:  184:       *
<         -:  185:       *  Create a %set consisting of copies of the elements from
<         -:  186:       *  [__first,__last).  This is linear in N if the range is
<         -:  187:       *  already sorted, and NlogN otherwise (where N is
<         -:  188:       *  distance(__first,__last)).
<         -:  189:       */
<         -:  190:      template<typename _InputIterator>
<         -:  191:	set(_InputIterator __first, _InputIterator __last)
<         -:  192:	: _M_t()
<         -:  193:	{ _M_t._M_insert_unique(__first, __last); }
<         -:  194:
<         -:  195:      /**
<         -:  196:       *  @brief  Builds a %set from a range.
<         -:  197:       *  @param  __first  An input iterator.
<         -:  198:       *  @param  __last  An input iterator.
<         -:  199:       *  @param  __comp  A comparison functor.
<         -:  200:       *  @param  __a  An allocator object.
<         -:  201:       *
<         -:  202:       *  Create a %set consisting of copies of the elements from
<         -:  203:       *  [__first,__last).  This is linear in N if the range is
<         -:  204:       *  already sorted, and NlogN otherwise (where N is
<         -:  205:       *  distance(__first,__last)).
<         -:  206:       */
<         -:  207:      template<typename _InputIterator>
<         -:  208:	set(_InputIterator __first, _InputIterator __last,
<         -:  209:	    const _Compare& __comp,
<         -:  210:	    const allocator_type& __a = allocator_type())
<         -:  211:	: _M_t(__comp, _Key_alloc_type(__a))
<         -:  212:	{ _M_t._M_insert_unique(__first, __last); }
<         -:  213:
<         -:  214:      /**
<         -:  215:       *  @brief  %Set copy constructor.
<         -:  216:       *
<         -:  217:       *  Whether the allocator is copied depends on the allocator traits.
<         -:  218:       */
<         -:  219:#if __cplusplus < 201103L
<         -:  220:      set(const set& __x)
<         -:  221:      : _M_t(__x._M_t) { }
<         -:  222:#else
<     #####:  223:      set(const set&) = default;
<         -:  224:
<         -:  225:     /**
<         -:  226:       *  @brief %Set move constructor
<         -:  227:       *
<         -:  228:       *  The newly-created %set contains the exact contents of the moved
<         -:  229:       *  instance. The moved instance is a valid, but unspecified, %set.
<         -:  230:       */
<         -:  231:      set(set&&) = default;
<         -:  232:
<         -:  233:      /**
<         -:  234:       *  @brief  Builds a %set from an initializer_list.
<         -:  235:       *  @param  __l  An initializer_list.
<         -:  236:       *  @param  __comp  A comparison functor.
<         -:  237:       *  @param  __a  An allocator object.
<         -:  238:       *
<         -:  239:       *  Create a %set consisting of copies of the elements in the list.
<         -:  240:       *  This is linear in N if the list is already sorted, and NlogN
<         -:  241:       *  otherwise (where N is @a __l.size()).
<         -:  242:       */
<         -:  243:      set(initializer_list<value_type> __l,
<         -:  244:	  const _Compare& __comp = _Compare(),
<         -:  245:	  const allocator_type& __a = allocator_type())
<         -:  246:      : _M_t(__comp, _Key_alloc_type(__a))
<         -:  247:      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
<         -:  248:
<         -:  249:      /// Allocator-extended default constructor.
<         -:  250:      explicit
<         -:  251:      set(const allocator_type& __a)
<         -:  252:      : _M_t(_Compare(), _Key_alloc_type(__a)) { }
---
>         -:  171:       *  @brief  Builds a %set from a range.
>         -:  172:       *  @param  __first  An input iterator.
>         -:  173:       *  @param  __last  An input iterator.
>         -:  174:       *
>         -:  175:       *  Create a %set consisting of copies of the elements from
>         -:  176:       *  [__first,__last).  This is linear in N if the range is
>         -:  177:       *  already sorted, and NlogN otherwise (where N is
>         -:  178:       *  distance(__first,__last)).
>         -:  179:       */
>         -:  180:      template<typename _InputIterator>
>         -:  181:	set(_InputIterator __first, _InputIterator __last)
>         -:  182:	: _M_t()
>         -:  183:	{ _M_t._M_insert_unique(__first, __last); }
>         -:  184:
>         -:  185:      /**
>         -:  186:       *  @brief  Builds a %set from a range.
>         -:  187:       *  @param  __first  An input iterator.
>         -:  188:       *  @param  __last  An input iterator.
>         -:  189:       *  @param  __comp  A comparison functor.
>         -:  190:       *  @param  __a  An allocator object.
>         -:  191:       *
>         -:  192:       *  Create a %set consisting of copies of the elements from
>         -:  193:       *  [__first,__last).  This is linear in N if the range is
>         -:  194:       *  already sorted, and NlogN otherwise (where N is
>         -:  195:       *  distance(__first,__last)).
>         -:  196:       */
>         -:  197:      template<typename _InputIterator>
>         -:  198:	set(_InputIterator __first, _InputIterator __last,
>         -:  199:	    const _Compare& __comp,
>         -:  200:	    const allocator_type& __a = allocator_type())
>         -:  201:	: _M_t(__comp, _Key_alloc_type(__a))
>         -:  202:	{ _M_t._M_insert_unique(__first, __last); }
>         -:  203:
>         -:  204:      /**
>         -:  205:       *  @brief  %Set copy constructor.
>         -:  206:       *
>         -:  207:       *  Whether the allocator is copied depends on the allocator traits.
>         -:  208:       */
>         -:  209:#if __cplusplus < 201103L
>         -:  210:      set(const set& __x)
>         -:  211:      : _M_t(__x._M_t) { }
>         -:  212:#else
>     #####:  213:      set(const set&) = default;
>         -:  214:
>         -:  215:     /**
>         -:  216:       *  @brief %Set move constructor
>         -:  217:       *
>         -:  218:       *  The newly-created %set contains the exact contents of the moved
>         -:  219:       *  instance. The moved instance is a valid, but unspecified, %set.
>         -:  220:       */
>         -:  221:      set(set&&) = default;
>         -:  222:
>         -:  223:      /**
>         -:  224:       *  @brief  Builds a %set from an initializer_list.
>         -:  225:       *  @param  __l  An initializer_list.
>         -:  226:       *  @param  __comp  A comparison functor.
>         -:  227:       *  @param  __a  An allocator object.
>         -:  228:       *
>         -:  229:       *  Create a %set consisting of copies of the elements in the list.
>         -:  230:       *  This is linear in N if the list is already sorted, and NlogN
>         -:  231:       *  otherwise (where N is @a __l.size()).
>         -:  232:       */
>         -:  233:      set(initializer_list<value_type> __l,
>         -:  234:	  const _Compare& __comp = _Compare(),
>         -:  235:	  const allocator_type& __a = allocator_type())
>         -:  236:      : _M_t(__comp, _Key_alloc_type(__a))
>         -:  237:      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
>         -:  238:
>         -:  239:      /// Allocator-extended default constructor.
>         -:  240:      explicit
>         -:  241:      set(const allocator_type& __a)
>         -:  242:      : _M_t(_Compare(), _Key_alloc_type(__a)) { }
>         -:  243:
>         -:  244:      /// Allocator-extended copy constructor.
>         -:  245:      set(const set& __x, const allocator_type& __a)
>         -:  246:      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }
>         -:  247:
>         -:  248:      /// Allocator-extended move constructor.
>         -:  249:      set(set&& __x, const allocator_type& __a)
>         -:  250:      noexcept(is_nothrow_copy_constructible<_Compare>::value
>         -:  251:	       && _Alloc_traits::_S_always_equal())
>         -:  252:      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }
256,366c256,366
<         -:  254:      /// Allocator-extended copy constructor.
<         -:  255:      set(const set& __x, const allocator_type& __a)
<         -:  256:      : _M_t(__x._M_t, _Key_alloc_type(__a)) { }
<         -:  257:
<         -:  258:      /// Allocator-extended move constructor.
<         -:  259:      set(set&& __x, const allocator_type& __a)
<         -:  260:      noexcept(is_nothrow_copy_constructible<_Compare>::value
<         -:  261:	       && _Alloc_traits::_S_always_equal())
<         -:  262:      : _M_t(std::move(__x._M_t), _Key_alloc_type(__a)) { }
<         -:  263:
<         -:  264:      /// Allocator-extended initialier-list constructor.
<         -:  265:      set(initializer_list<value_type> __l, const allocator_type& __a)
<         -:  266:      : _M_t(_Compare(), _Key_alloc_type(__a))
<         -:  267:      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
<         -:  268:
<         -:  269:      /// Allocator-extended range constructor.
<         -:  270:      template<typename _InputIterator>
<         -:  271:	set(_InputIterator __first, _InputIterator __last,
<         -:  272:	    const allocator_type& __a)
<         -:  273:	: _M_t(_Compare(), _Key_alloc_type(__a))
<         -:  274:	{ _M_t._M_insert_unique(__first, __last); }
<         -:  275:
<         -:  276:      /**
<         -:  277:       *  The dtor only erases the elements, and note that if the elements
<         -:  278:       *  themselves are pointers, the pointed-to memory is not touched in any
<         -:  279:       *  way. Managing the pointer is the user's responsibility.
<         -:  280:       */
<     #####:  281:      ~set() = default;
<         -:  282:#endif
<         -:  283:
<         -:  284:      /**
<         -:  285:       *  @brief  %Set assignment operator.
<         -:  286:       *
<         -:  287:       *  Whether the allocator is copied depends on the allocator traits.
<         -:  288:       */
<         -:  289:#if __cplusplus < 201103L
<         -:  290:      set&
<         -:  291:      operator=(const set& __x)
<         -:  292:      {
<         -:  293:	_M_t = __x._M_t;
<         -:  294:	return *this;
<         -:  295:      }
<         -:  296:#else
<         -:  297:      set&
<         -:  298:      operator=(const set&) = default;
<         -:  299:
<         -:  300:      /// Move assignment operator.
<         -:  301:      set&
<         -:  302:      operator=(set&&) = default;
<         -:  303:
<         -:  304:      /**
<         -:  305:       *  @brief  %Set list assignment operator.
<         -:  306:       *  @param  __l  An initializer_list.
<         -:  307:       *
<         -:  308:       *  This function fills a %set with copies of the elements in the
<         -:  309:       *  initializer list @a __l.
<         -:  310:       *
<         -:  311:       *  Note that the assignment completely changes the %set and
<         -:  312:       *  that the resulting %set's size is the same as the number
<         -:  313:       *  of elements assigned.
<         -:  314:       */
<         -:  315:      set&
<         -:  316:      operator=(initializer_list<value_type> __l)
<         -:  317:      {
<         -:  318:	_M_t._M_assign_unique(__l.begin(), __l.end());
<         -:  319:	return *this;
<         -:  320:      }
<         -:  321:#endif
<         -:  322:
<         -:  323:      // accessors:
<         -:  324:
<         -:  325:      ///  Returns the comparison object with which the %set was constructed.
<         -:  326:      key_compare
<         -:  327:      key_comp() const
<         -:  328:      { return _M_t.key_comp(); }
<         -:  329:      ///  Returns the comparison object with which the %set was constructed.
<         -:  330:      value_compare
<         -:  331:      value_comp() const
<         -:  332:      { return _M_t.key_comp(); }
<         -:  333:      ///  Returns the allocator object with which the %set was constructed.
<         -:  334:      allocator_type
<         -:  335:      get_allocator() const _GLIBCXX_NOEXCEPT
<         -:  336:      { return allocator_type(_M_t.get_allocator()); }
<         -:  337:
<         -:  338:      /**
<         -:  339:       *  Returns a read-only (constant) iterator that points to the first
<         -:  340:       *  element in the %set.  Iteration is done in ascending order according
<         -:  341:       *  to the keys.
<         -:  342:       */
<         -:  343:      iterator
<     #####:  344:      begin() const _GLIBCXX_NOEXCEPT
<     #####:  345:      { return _M_t.begin(); }
<         -:  346:
<         -:  347:      /**
<         -:  348:       *  Returns a read-only (constant) iterator that points one past the last
<         -:  349:       *  element in the %set.  Iteration is done in ascending order according
<         -:  350:       *  to the keys.
<         -:  351:       */
<         -:  352:      iterator
<     #####:  353:      end() const _GLIBCXX_NOEXCEPT
<     #####:  354:      { return _M_t.end(); }
<         -:  355:
<         -:  356:      /**
<         -:  357:       *  Returns a read-only (constant) iterator that points to the last
<         -:  358:       *  element in the %set.  Iteration is done in descending order according
<         -:  359:       *  to the keys.
<         -:  360:       */
<         -:  361:      reverse_iterator
<         -:  362:      rbegin() const _GLIBCXX_NOEXCEPT
<         -:  363:      { return _M_t.rbegin(); }
<         -:  364:
---
>         -:  254:      /// Allocator-extended initialier-list constructor.
>         -:  255:      set(initializer_list<value_type> __l, const allocator_type& __a)
>         -:  256:      : _M_t(_Compare(), _Key_alloc_type(__a))
>         -:  257:      { _M_t._M_insert_unique(__l.begin(), __l.end()); }
>         -:  258:
>         -:  259:      /// Allocator-extended range constructor.
>         -:  260:      template<typename _InputIterator>
>         -:  261:	set(_InputIterator __first, _InputIterator __last,
>         -:  262:	    const allocator_type& __a)
>         -:  263:	: _M_t(_Compare(), _Key_alloc_type(__a))
>         -:  264:	{ _M_t._M_insert_unique(__first, __last); }
>         -:  265:
>         -:  266:      /**
>         -:  267:       *  The dtor only erases the elements, and note that if the elements
>         -:  268:       *  themselves are pointers, the pointed-to memory is not touched in any
>         -:  269:       *  way. Managing the pointer is the user's responsibility.
>         -:  270:       */
>     #####:  271:      ~set() = default;
>         -:  272:#endif
>         -:  273:
>         -:  274:      /**
>         -:  275:       *  @brief  %Set assignment operator.
>         -:  276:       *
>         -:  277:       *  Whether the allocator is copied depends on the allocator traits.
>         -:  278:       */
>         -:  279:#if __cplusplus < 201103L
>         -:  280:      set&
>         -:  281:      operator=(const set& __x)
>         -:  282:      {
>         -:  283:	_M_t = __x._M_t;
>         -:  284:	return *this;
>         -:  285:      }
>         -:  286:#else
>         -:  287:      set&
>         -:  288:      operator=(const set&) = default;
>         -:  289:
>         -:  290:      /// Move assignment operator.
>         -:  291:      set&
>         -:  292:      operator=(set&&) = default;
>         -:  293:
>         -:  294:      /**
>         -:  295:       *  @brief  %Set list assignment operator.
>         -:  296:       *  @param  __l  An initializer_list.
>         -:  297:       *
>         -:  298:       *  This function fills a %set with copies of the elements in the
>         -:  299:       *  initializer list @a __l.
>         -:  300:       *
>         -:  301:       *  Note that the assignment completely changes the %set and
>         -:  302:       *  that the resulting %set's size is the same as the number
>         -:  303:       *  of elements assigned.
>         -:  304:       */
>         -:  305:      set&
>         -:  306:      operator=(initializer_list<value_type> __l)
>         -:  307:      {
>         -:  308:	_M_t._M_assign_unique(__l.begin(), __l.end());
>         -:  309:	return *this;
>         -:  310:      }
>         -:  311:#endif
>         -:  312:
>         -:  313:      // accessors:
>         -:  314:
>         -:  315:      ///  Returns the comparison object with which the %set was constructed.
>         -:  316:      key_compare
>         -:  317:      key_comp() const
>         -:  318:      { return _M_t.key_comp(); }
>         -:  319:      ///  Returns the comparison object with which the %set was constructed.
>         -:  320:      value_compare
>         -:  321:      value_comp() const
>         -:  322:      { return _M_t.key_comp(); }
>         -:  323:      ///  Returns the allocator object with which the %set was constructed.
>         -:  324:      allocator_type
>         -:  325:      get_allocator() const _GLIBCXX_NOEXCEPT
>         -:  326:      { return allocator_type(_M_t.get_allocator()); }
>         -:  327:
>         -:  328:      /**
>         -:  329:       *  Returns a read-only (constant) iterator that points to the first
>         -:  330:       *  element in the %set.  Iteration is done in ascending order according
>         -:  331:       *  to the keys.
>         -:  332:       */
>         -:  333:      iterator
>     #####:  334:      begin() const _GLIBCXX_NOEXCEPT
>     #####:  335:      { return _M_t.begin(); }
>         -:  336:
>         -:  337:      /**
>         -:  338:       *  Returns a read-only (constant) iterator that points one past the last
>         -:  339:       *  element in the %set.  Iteration is done in ascending order according
>         -:  340:       *  to the keys.
>         -:  341:       */
>         -:  342:      iterator
>     #####:  343:      end() const _GLIBCXX_NOEXCEPT
>     #####:  344:      { return _M_t.end(); }
>         -:  345:
>         -:  346:      /**
>         -:  347:       *  Returns a read-only (constant) iterator that points to the last
>         -:  348:       *  element in the %set.  Iteration is done in descending order according
>         -:  349:       *  to the keys.
>         -:  350:       */
>         -:  351:      reverse_iterator
>         -:  352:      rbegin() const _GLIBCXX_NOEXCEPT
>         -:  353:      { return _M_t.rbegin(); }
>         -:  354:
>         -:  355:      /**
>         -:  356:       *  Returns a read-only (constant) reverse iterator that points to the
>         -:  357:       *  last pair in the %set.  Iteration is done in descending order
>         -:  358:       *  according to the keys.
>         -:  359:       */
>         -:  360:      reverse_iterator
>         -:  361:      rend() const _GLIBCXX_NOEXCEPT
>         -:  362:      { return _M_t.rend(); }
>         -:  363:
>         -:  364:#if __cplusplus >= 201103L
368,370c368,370
<         -:  366:       *  Returns a read-only (constant) reverse iterator that points to the
<         -:  367:       *  last pair in the %set.  Iteration is done in descending order
<         -:  368:       *  according to the keys.
---
>         -:  366:       *  Returns a read-only (constant) iterator that points to the first
>         -:  367:       *  element in the %set.  Iteration is done in ascending order according
>         -:  368:       *  to the keys.
372,374c372,374
<         -:  370:      reverse_iterator
<         -:  371:      rend() const _GLIBCXX_NOEXCEPT
<         -:  372:      { return _M_t.rend(); }
---
>         -:  370:      iterator
>         -:  371:      cbegin() const noexcept
>         -:  372:      { return _M_t.begin(); }
376,402c376,402
<         -:  374:#if __cplusplus >= 201103L
<         -:  375:      /**
<         -:  376:       *  Returns a read-only (constant) iterator that points to the first
<         -:  377:       *  element in the %set.  Iteration is done in ascending order according
<         -:  378:       *  to the keys.
<         -:  379:       */
<         -:  380:      iterator
<         -:  381:      cbegin() const noexcept
<         -:  382:      { return _M_t.begin(); }
<         -:  383:
<         -:  384:      /**
<         -:  385:       *  Returns a read-only (constant) iterator that points one past the last
<         -:  386:       *  element in the %set.  Iteration is done in ascending order according
<         -:  387:       *  to the keys.
<         -:  388:       */
<         -:  389:      iterator
<         -:  390:      cend() const noexcept
<         -:  391:      { return _M_t.end(); }
<         -:  392:
<         -:  393:      /**
<         -:  394:       *  Returns a read-only (constant) iterator that points to the last
<         -:  395:       *  element in the %set.  Iteration is done in descending order according
<         -:  396:       *  to the keys.
<         -:  397:       */
<         -:  398:      reverse_iterator
<         -:  399:      crbegin() const noexcept
<         -:  400:      { return _M_t.rbegin(); }
---
>         -:  374:      /**
>         -:  375:       *  Returns a read-only (constant) iterator that points one past the last
>         -:  376:       *  element in the %set.  Iteration is done in ascending order according
>         -:  377:       *  to the keys.
>         -:  378:       */
>         -:  379:      iterator
>         -:  380:      cend() const noexcept
>         -:  381:      { return _M_t.end(); }
>         -:  382:
>         -:  383:      /**
>         -:  384:       *  Returns a read-only (constant) iterator that points to the last
>         -:  385:       *  element in the %set.  Iteration is done in descending order according
>         -:  386:       *  to the keys.
>         -:  387:       */
>         -:  388:      reverse_iterator
>         -:  389:      crbegin() const noexcept
>         -:  390:      { return _M_t.rbegin(); }
>         -:  391:
>         -:  392:      /**
>         -:  393:       *  Returns a read-only (constant) reverse iterator that points to the
>         -:  394:       *  last pair in the %set.  Iteration is done in descending order
>         -:  395:       *  according to the keys.
>         -:  396:       */
>         -:  397:      reverse_iterator
>         -:  398:      crend() const noexcept
>         -:  399:      { return _M_t.rend(); }
>         -:  400:#endif
404,412c404,412
<         -:  402:      /**
<         -:  403:       *  Returns a read-only (constant) reverse iterator that points to the
<         -:  404:       *  last pair in the %set.  Iteration is done in descending order
<         -:  405:       *  according to the keys.
<         -:  406:       */
<         -:  407:      reverse_iterator
<         -:  408:      crend() const noexcept
<         -:  409:      { return _M_t.rend(); }
<         -:  410:#endif
---
>         -:  402:      ///  Returns true if the %set is empty.
>         -:  403:      bool
>     #####:  404:      empty() const _GLIBCXX_NOEXCEPT
>     #####:  405:      { return _M_t.empty(); }
>         -:  406:
>         -:  407:      ///  Returns the size of the %set.
>         -:  408:      size_type
>     #####:  409:      size() const _GLIBCXX_NOEXCEPT
>     #####:  410:      { return _M_t.size(); }
414,417c414,417
<         -:  412:      ///  Returns true if the %set is empty.
<         -:  413:      bool
<     #####:  414:      empty() const _GLIBCXX_NOEXCEPT
<     #####:  415:      { return _M_t.empty(); }
---
>         -:  412:      ///  Returns the maximum size of the %set.
>         -:  413:      size_type
>         -:  414:      max_size() const _GLIBCXX_NOEXCEPT
>         -:  415:      { return _M_t.max_size(); }
419,533c419,516
<         -:  417:      ///  Returns the size of the %set.
<         -:  418:      size_type
<     #####:  419:      size() const _GLIBCXX_NOEXCEPT
<     #####:  420:      { return _M_t.size(); }
<         -:  421:
<         -:  422:      ///  Returns the maximum size of the %set.
<         -:  423:      size_type
<         -:  424:      max_size() const _GLIBCXX_NOEXCEPT
<         -:  425:      { return _M_t.max_size(); }
<         -:  426:
<         -:  427:      /**
<         -:  428:       *  @brief  Swaps data with another %set.
<         -:  429:       *  @param  __x  A %set of the same element and allocator types.
<         -:  430:       *
<         -:  431:       *  This exchanges the elements between two sets in constant
<         -:  432:       *  time.  (It is only swapping a pointer, an integer, and an
<         -:  433:       *  instance of the @c Compare type (which itself is often
<         -:  434:       *  stateless and empty), so it should be quite fast.)  Note
<         -:  435:       *  that the global std::swap() function is specialized such
<         -:  436:       *  that std::swap(s1,s2) will feed to this function.
<         -:  437:       *
<         -:  438:       *  Whether the allocators are swapped depends on the allocator traits.
<         -:  439:       */
<         -:  440:      void
<         -:  441:      swap(set& __x)
<         -:  442:      _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value)
<         -:  443:      { _M_t.swap(__x._M_t); }
<         -:  444:
<         -:  445:      // insert/erase
<         -:  446:#if __cplusplus >= 201103L
<         -:  447:      /**
<         -:  448:       *  @brief Attempts to build and insert an element into the %set.
<         -:  449:       *  @param __args  Arguments used to generate an element.
<         -:  450:       *  @return  A pair, of which the first element is an iterator that points
<         -:  451:       *           to the possibly inserted element, and the second is a bool
<         -:  452:       *           that is true if the element was actually inserted.
<         -:  453:       *
<         -:  454:       *  This function attempts to build and insert an element into the %set.
<         -:  455:       *  A %set relies on unique keys and thus an element is only inserted if
<         -:  456:       *  it is not already present in the %set.
<         -:  457:       *
<         -:  458:       *  Insertion requires logarithmic time.
<         -:  459:       */
<         -:  460:      template<typename... _Args>
<         -:  461:	std::pair<iterator, bool>
<         -:  462:	emplace(_Args&&... __args)
<         -:  463:	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
<         -:  464:
<         -:  465:      /**
<         -:  466:       *  @brief Attempts to insert an element into the %set.
<         -:  467:       *  @param  __pos  An iterator that serves as a hint as to where the
<         -:  468:       *                element should be inserted.
<         -:  469:       *  @param  __args  Arguments used to generate the element to be
<         -:  470:       *                 inserted.
<         -:  471:       *  @return An iterator that points to the element with key equivalent to
<         -:  472:       *          the one generated from @a __args (may or may not be the
<         -:  473:       *          element itself).
<         -:  474:       *
<         -:  475:       *  This function is not concerned about whether the insertion took place,
<         -:  476:       *  and thus does not return a boolean like the single-argument emplace()
<         -:  477:       *  does.  Note that the first parameter is only a hint and can
<         -:  478:       *  potentially improve the performance of the insertion process.  A bad
<         -:  479:       *  hint would cause no gains in efficiency.
<         -:  480:       *
<         -:  481:       *  For more on @a hinting, see:
<         -:  482:       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
<         -:  483:       *
<         -:  484:       *  Insertion requires logarithmic time (if the hint is not taken).
<         -:  485:       */
<         -:  486:      template<typename... _Args>
<         -:  487:	iterator
<         -:  488:	emplace_hint(const_iterator __pos, _Args&&... __args)
<         -:  489:	{
<         -:  490:	  return _M_t._M_emplace_hint_unique(__pos,
<         -:  491:					     std::forward<_Args>(__args)...);
<         -:  492:	}
<         -:  493:#endif
<         -:  494:
<         -:  495:      /**
<         -:  496:       *  @brief Attempts to insert an element into the %set.
<         -:  497:       *  @param  __x  Element to be inserted.
<         -:  498:       *  @return  A pair, of which the first element is an iterator that points
<         -:  499:       *           to the possibly inserted element, and the second is a bool
<         -:  500:       *           that is true if the element was actually inserted.
<         -:  501:       *
<         -:  502:       *  This function attempts to insert an element into the %set.  A %set
<         -:  503:       *  relies on unique keys and thus an element is only inserted if it is
<         -:  504:       *  not already present in the %set.
<         -:  505:       *
<         -:  506:       *  Insertion requires logarithmic time.
<         -:  507:       */
<         -:  508:      std::pair<iterator, bool>
<     #####:  509:      insert(const value_type& __x)
<         -:  510:      {
<     #####:  511:	std::pair<typename _Rep_type::iterator, bool> __p =
<         -:  512:	  _M_t._M_insert_unique(__x);
<     #####:  513:	return std::pair<iterator, bool>(__p.first, __p.second);
<         -:  514:      }
< ------------------
< _ZNSt3setIN7OpenDDS4DCPS6GUID_tENS1_17GUID_tKeyLessThanESaIS2_EE6insertERKS2_:
<     #####:  509:      insert(const value_type& __x)
<         -:  510:      {
<     #####:  511:	std::pair<typename _Rep_type::iterator, bool> __p =
<         -:  512:	  _M_t._M_insert_unique(__x);
<     #####:  513:	return std::pair<iterator, bool>(__p.first, __p.second);
<         -:  514:      }
< ------------------
< _ZNSt3setIN7OpenDDS4DCPS19TransportReassembly7FragKeyESt4lessIS3_ESaIS3_EE6insertERKS3_:
<     #####:  509:      insert(const value_type& __x)
<         -:  510:      {
<     #####:  511:	std::pair<typename _Rep_type::iterator, bool> __p =
<         -:  512:	  _M_t._M_insert_unique(__x);
<     #####:  513:	return std::pair<iterator, bool>(__p.first, __p.second);
<         -:  514:      }
< ------------------
---
>         -:  417:      /**
>         -:  418:       *  @brief  Swaps data with another %set.
>         -:  419:       *  @param  __x  A %set of the same element and allocator types.
>         -:  420:       *
>         -:  421:       *  This exchanges the elements between two sets in constant
>         -:  422:       *  time.  (It is only swapping a pointer, an integer, and an
>         -:  423:       *  instance of the @c Compare type (which itself is often
>         -:  424:       *  stateless and empty), so it should be quite fast.)  Note
>         -:  425:       *  that the global std::swap() function is specialized such
>         -:  426:       *  that std::swap(s1,s2) will feed to this function.
>         -:  427:       *
>         -:  428:       *  Whether the allocators are swapped depends on the allocator traits.
>         -:  429:       */
>         -:  430:      void
>         -:  431:      swap(set& __x)
>         -:  432:      _GLIBCXX_NOEXCEPT_IF(__is_nothrow_swappable<_Compare>::value)
>         -:  433:      { _M_t.swap(__x._M_t); }
>         -:  434:
>         -:  435:      // insert/erase
>         -:  436:#if __cplusplus >= 201103L
>         -:  437:      /**
>         -:  438:       *  @brief Attempts to build and insert an element into the %set.
>         -:  439:       *  @param __args  Arguments used to generate an element.
>         -:  440:       *  @return  A pair, of which the first element is an iterator that points
>         -:  441:       *           to the possibly inserted element, and the second is a bool
>         -:  442:       *           that is true if the element was actually inserted.
>         -:  443:       *
>         -:  444:       *  This function attempts to build and insert an element into the %set.
>         -:  445:       *  A %set relies on unique keys and thus an element is only inserted if
>         -:  446:       *  it is not already present in the %set.
>         -:  447:       *
>         -:  448:       *  Insertion requires logarithmic time.
>         -:  449:       */
>         -:  450:      template<typename... _Args>
>         -:  451:	std::pair<iterator, bool>
>         -:  452:	emplace(_Args&&... __args)
>         -:  453:	{ return _M_t._M_emplace_unique(std::forward<_Args>(__args)...); }
>         -:  454:
>         -:  455:      /**
>         -:  456:       *  @brief Attempts to insert an element into the %set.
>         -:  457:       *  @param  __pos  An iterator that serves as a hint as to where the
>         -:  458:       *                element should be inserted.
>         -:  459:       *  @param  __args  Arguments used to generate the element to be
>         -:  460:       *                 inserted.
>         -:  461:       *  @return An iterator that points to the element with key equivalent to
>         -:  462:       *          the one generated from @a __args (may or may not be the
>         -:  463:       *          element itself).
>         -:  464:       *
>         -:  465:       *  This function is not concerned about whether the insertion took place,
>         -:  466:       *  and thus does not return a boolean like the single-argument emplace()
>         -:  467:       *  does.  Note that the first parameter is only a hint and can
>         -:  468:       *  potentially improve the performance of the insertion process.  A bad
>         -:  469:       *  hint would cause no gains in efficiency.
>         -:  470:       *
>         -:  471:       *  For more on @a hinting, see:
>         -:  472:       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
>         -:  473:       *
>         -:  474:       *  Insertion requires logarithmic time (if the hint is not taken).
>         -:  475:       */
>         -:  476:      template<typename... _Args>
>         -:  477:	iterator
>         -:  478:	emplace_hint(const_iterator __pos, _Args&&... __args)
>         -:  479:	{
>         -:  480:	  return _M_t._M_emplace_hint_unique(__pos,
>         -:  481:					     std::forward<_Args>(__args)...);
>         -:  482:	}
>         -:  483:#endif
>         -:  484:
>         -:  485:      /**
>         -:  486:       *  @brief Attempts to insert an element into the %set.
>         -:  487:       *  @param  __x  Element to be inserted.
>         -:  488:       *  @return  A pair, of which the first element is an iterator that points
>         -:  489:       *           to the possibly inserted element, and the second is a bool
>         -:  490:       *           that is true if the element was actually inserted.
>         -:  491:       *
>         -:  492:       *  This function attempts to insert an element into the %set.  A %set
>         -:  493:       *  relies on unique keys and thus an element is only inserted if it is
>         -:  494:       *  not already present in the %set.
>         -:  495:       *
>         -:  496:       *  Insertion requires logarithmic time.
>         -:  497:       */
>         -:  498:      std::pair<iterator, bool>
>     #####:  499:      insert(const value_type& __x)
>         -:  500:      {
>     #####:  501:	std::pair<typename _Rep_type::iterator, bool> __p =
>         -:  502:	  _M_t._M_insert_unique(__x);
>     #####:  503:	return std::pair<iterator, bool>(__p.first, __p.second);
>         -:  504:      }
>         -:  505:
>         -:  506:#if __cplusplus >= 201103L
>         -:  507:      std::pair<iterator, bool>
>         -:  508:      insert(value_type&& __x)
>         -:  509:      {
>         -:  510:	std::pair<typename _Rep_type::iterator, bool> __p =
>         -:  511:	  _M_t._M_insert_unique(std::move(__x));
>         -:  512:	return std::pair<iterator, bool>(__p.first, __p.second);
>         -:  513:      }
>         -:  514:#endif
535,608c518,591
<         -:  516:#if __cplusplus >= 201103L
<         -:  517:      std::pair<iterator, bool>
<         -:  518:      insert(value_type&& __x)
<         -:  519:      {
<         -:  520:	std::pair<typename _Rep_type::iterator, bool> __p =
<         -:  521:	  _M_t._M_insert_unique(std::move(__x));
<         -:  522:	return std::pair<iterator, bool>(__p.first, __p.second);
<         -:  523:      }
<         -:  524:#endif
<         -:  525:
<         -:  526:      /**
<         -:  527:       *  @brief Attempts to insert an element into the %set.
<         -:  528:       *  @param  __position  An iterator that serves as a hint as to where the
<         -:  529:       *                    element should be inserted.
<         -:  530:       *  @param  __x  Element to be inserted.
<         -:  531:       *  @return An iterator that points to the element with key of
<         -:  532:       *           @a __x (may or may not be the element passed in).
<         -:  533:       *
<         -:  534:       *  This function is not concerned about whether the insertion took place,
<         -:  535:       *  and thus does not return a boolean like the single-argument insert()
<         -:  536:       *  does.  Note that the first parameter is only a hint and can
<         -:  537:       *  potentially improve the performance of the insertion process.  A bad
<         -:  538:       *  hint would cause no gains in efficiency.
<         -:  539:       *
<         -:  540:       *  For more on @a hinting, see:
<         -:  541:       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
<         -:  542:       *
<         -:  543:       *  Insertion requires logarithmic time (if the hint is not taken).
<         -:  544:       */
<         -:  545:      iterator
<         -:  546:      insert(const_iterator __position, const value_type& __x)
<         -:  547:      { return _M_t._M_insert_unique_(__position, __x); }
<         -:  548:
<         -:  549:#if __cplusplus >= 201103L
<         -:  550:      iterator
<         -:  551:      insert(const_iterator __position, value_type&& __x)
<         -:  552:      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
<         -:  553:#endif
<         -:  554:
<         -:  555:      /**
<         -:  556:       *  @brief A template function that attempts to insert a range
<         -:  557:       *  of elements.
<         -:  558:       *  @param  __first  Iterator pointing to the start of the range to be
<         -:  559:       *                   inserted.
<         -:  560:       *  @param  __last  Iterator pointing to the end of the range.
<         -:  561:       *
<         -:  562:       *  Complexity similar to that of the range constructor.
<         -:  563:       */
<         -:  564:      template<typename _InputIterator>
<         -:  565:	void
<         -:  566:	insert(_InputIterator __first, _InputIterator __last)
<         -:  567:	{ _M_t._M_insert_unique(__first, __last); }
<         -:  568:
<         -:  569:#if __cplusplus >= 201103L
<         -:  570:      /**
<         -:  571:       *  @brief Attempts to insert a list of elements into the %set.
<         -:  572:       *  @param  __l  A std::initializer_list<value_type> of elements
<         -:  573:       *               to be inserted.
<         -:  574:       *
<         -:  575:       *  Complexity similar to that of the range constructor.
<         -:  576:       */
<         -:  577:      void
<         -:  578:      insert(initializer_list<value_type> __l)
<         -:  579:      { this->insert(__l.begin(), __l.end()); }
<         -:  580:#endif
<         -:  581:
<         -:  582:#if __cplusplus > 201402L
<         -:  583:      /// Extract a node.
<         -:  584:      node_type
<         -:  585:      extract(const_iterator __pos)
<         -:  586:      {
<         -:  587:	__glibcxx_assert(__pos != end());
<         -:  588:	return _M_t.extract(__pos);
<         -:  589:      }
---
>         -:  516:      /**
>         -:  517:       *  @brief Attempts to insert an element into the %set.
>         -:  518:       *  @param  __position  An iterator that serves as a hint as to where the
>         -:  519:       *                    element should be inserted.
>         -:  520:       *  @param  __x  Element to be inserted.
>         -:  521:       *  @return An iterator that points to the element with key of
>         -:  522:       *           @a __x (may or may not be the element passed in).
>         -:  523:       *
>         -:  524:       *  This function is not concerned about whether the insertion took place,
>         -:  525:       *  and thus does not return a boolean like the single-argument insert()
>         -:  526:       *  does.  Note that the first parameter is only a hint and can
>         -:  527:       *  potentially improve the performance of the insertion process.  A bad
>         -:  528:       *  hint would cause no gains in efficiency.
>         -:  529:       *
>         -:  530:       *  For more on @a hinting, see:
>         -:  531:       *  https://gcc.gnu.org/onlinedocs/libstdc++/manual/associative.html#containers.associative.insert_hints
>         -:  532:       *
>         -:  533:       *  Insertion requires logarithmic time (if the hint is not taken).
>         -:  534:       */
>         -:  535:      iterator
>         -:  536:      insert(const_iterator __position, const value_type& __x)
>         -:  537:      { return _M_t._M_insert_unique_(__position, __x); }
>         -:  538:
>         -:  539:#if __cplusplus >= 201103L
>         -:  540:      iterator
>         -:  541:      insert(const_iterator __position, value_type&& __x)
>         -:  542:      { return _M_t._M_insert_unique_(__position, std::move(__x)); }
>         -:  543:#endif
>         -:  544:
>         -:  545:      /**
>         -:  546:       *  @brief A template function that attempts to insert a range
>         -:  547:       *  of elements.
>         -:  548:       *  @param  __first  Iterator pointing to the start of the range to be
>         -:  549:       *                   inserted.
>         -:  550:       *  @param  __last  Iterator pointing to the end of the range.
>         -:  551:       *
>         -:  552:       *  Complexity similar to that of the range constructor.
>         -:  553:       */
>         -:  554:      template<typename _InputIterator>
>         -:  555:	void
>         -:  556:	insert(_InputIterator __first, _InputIterator __last)
>         -:  557:	{ _M_t._M_insert_unique(__first, __last); }
>         -:  558:
>         -:  559:#if __cplusplus >= 201103L
>         -:  560:      /**
>         -:  561:       *  @brief Attempts to insert a list of elements into the %set.
>         -:  562:       *  @param  __l  A std::initializer_list<value_type> of elements
>         -:  563:       *               to be inserted.
>         -:  564:       *
>         -:  565:       *  Complexity similar to that of the range constructor.
>         -:  566:       */
>         -:  567:      void
>         -:  568:      insert(initializer_list<value_type> __l)
>         -:  569:      { this->insert(__l.begin(), __l.end()); }
>         -:  570:#endif
>         -:  571:
>         -:  572:#if __cplusplus > 201402L
>         -:  573:      /// Extract a node.
>         -:  574:      node_type
>         -:  575:      extract(const_iterator __pos)
>         -:  576:      {
>         -:  577:	__glibcxx_assert(__pos != end());
>         -:  578:	return _M_t.extract(__pos);
>         -:  579:      }
>         -:  580:
>         -:  581:      /// Extract a node.
>         -:  582:      node_type
>         -:  583:      extract(const key_type& __x)
>         -:  584:      { return _M_t.extract(__x); }
>         -:  585:
>         -:  586:      /// Re-insert an extracted node.
>         -:  587:      insert_return_type
>         -:  588:      insert(node_type&& __nh)
>         -:  589:      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }
610,613c593,596
<         -:  591:      /// Extract a node.
<         -:  592:      node_type
<         -:  593:      extract(const key_type& __x)
<         -:  594:      { return _M_t.extract(__x); }
---
>         -:  591:      /// Re-insert an extracted node.
>         -:  592:      iterator
>         -:  593:      insert(const_iterator __hint, node_type&& __nh)
>         -:  594:      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }
615,752c598,726
<         -:  596:      /// Re-insert an extracted node.
<         -:  597:      insert_return_type
<         -:  598:      insert(node_type&& __nh)
<         -:  599:      { return _M_t._M_reinsert_node_unique(std::move(__nh)); }
<         -:  600:
<         -:  601:      /// Re-insert an extracted node.
<         -:  602:      iterator
<         -:  603:      insert(const_iterator __hint, node_type&& __nh)
<         -:  604:      { return _M_t._M_reinsert_node_hint_unique(__hint, std::move(__nh)); }
<         -:  605:
<         -:  606:      template<typename, typename>
<         -:  607:	friend class std::_Rb_tree_merge_helper;
<         -:  608:
<         -:  609:      template<typename _Compare1>
<         -:  610:	void
<         -:  611:	merge(set<_Key, _Compare1, _Alloc>& __source)
<         -:  612:	{
<         -:  613:	  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
<         -:  614:	  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
<         -:  615:	}
<         -:  616:
<         -:  617:      template<typename _Compare1>
<         -:  618:	void
<         -:  619:	merge(set<_Key, _Compare1, _Alloc>&& __source)
<         -:  620:	{ merge(__source); }
<         -:  621:
<         -:  622:      template<typename _Compare1>
<         -:  623:	void
<         -:  624:	merge(multiset<_Key, _Compare1, _Alloc>& __source)
<         -:  625:	{
<         -:  626:	  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
<         -:  627:	  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
<         -:  628:	}
<         -:  629:
<         -:  630:      template<typename _Compare1>
<         -:  631:	void
<         -:  632:	merge(multiset<_Key, _Compare1, _Alloc>&& __source)
<         -:  633:	{ merge(__source); }
<         -:  634:#endif // C++17
<         -:  635:
<         -:  636:#if __cplusplus >= 201103L
<         -:  637:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -:  638:      // DR 130. Associative erase should return an iterator.
<         -:  639:      /**
<         -:  640:       *  @brief Erases an element from a %set.
<         -:  641:       *  @param  __position  An iterator pointing to the element to be erased.
<         -:  642:       *  @return An iterator pointing to the element immediately following
<         -:  643:       *          @a __position prior to the element being erased. If no such
<         -:  644:       *          element exists, end() is returned.
<         -:  645:       *
<         -:  646:       *  This function erases an element, pointed to by the given iterator,
<         -:  647:       *  from a %set.  Note that this function only erases the element, and
<         -:  648:       *  that if the element is itself a pointer, the pointed-to memory is not
<         -:  649:       *  touched in any way.  Managing the pointer is the user's
<         -:  650:       *  responsibility.
<         -:  651:       */
<         -:  652:      _GLIBCXX_ABI_TAG_CXX11
<         -:  653:      iterator
<         -:  654:      erase(const_iterator __position)
<         -:  655:      { return _M_t.erase(__position); }
<         -:  656:#else
<         -:  657:      /**
<         -:  658:       *  @brief Erases an element from a %set.
<         -:  659:       *  @param  position  An iterator pointing to the element to be erased.
<         -:  660:       *
<         -:  661:       *  This function erases an element, pointed to by the given iterator,
<         -:  662:       *  from a %set.  Note that this function only erases the element, and
<         -:  663:       *  that if the element is itself a pointer, the pointed-to memory is not
<         -:  664:       *  touched in any way.  Managing the pointer is the user's
<         -:  665:       *  responsibility.
<         -:  666:       */
<         -:  667:      void
<         -:  668:      erase(iterator __position)
<         -:  669:      { _M_t.erase(__position); }
<         -:  670:#endif
<         -:  671:
<         -:  672:      /**
<         -:  673:       *  @brief Erases elements according to the provided key.
<         -:  674:       *  @param  __x  Key of element to be erased.
<         -:  675:       *  @return  The number of elements erased.
<         -:  676:       *
<         -:  677:       *  This function erases all the elements located by the given key from
<         -:  678:       *  a %set.
<         -:  679:       *  Note that this function only erases the element, and that if
<         -:  680:       *  the element is itself a pointer, the pointed-to memory is not touched
<         -:  681:       *  in any way.  Managing the pointer is the user's responsibility.
<         -:  682:       */
<         -:  683:      size_type
<     #####:  684:      erase(const key_type& __x)
<     #####:  685:      { return _M_t.erase(__x); }
< ------------------
< _ZNSt3setIN7OpenDDS4DCPS6GUID_tENS1_17GUID_tKeyLessThanESaIS2_EE5eraseERKS2_:
<     #####:  684:      erase(const key_type& __x)
<     #####:  685:      { return _M_t.erase(__x); }
< ------------------
< _ZNSt3setIN7OpenDDS4DCPS19TransportReassembly7FragKeyESt4lessIS3_ESaIS3_EE5eraseERKS3_:
<     #####:  684:      erase(const key_type& __x)
<     #####:  685:      { return _M_t.erase(__x); }
< ------------------
<         -:  686:
<         -:  687:#if __cplusplus >= 201103L
<         -:  688:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -:  689:      // DR 130. Associative erase should return an iterator.
<         -:  690:      /**
<         -:  691:       *  @brief Erases a [__first,__last) range of elements from a %set.
<         -:  692:       *  @param  __first  Iterator pointing to the start of the range to be
<         -:  693:       *                 erased.
<         -:  694:
<         -:  695:       *  @param __last Iterator pointing to the end of the range to
<         -:  696:       *  be erased.
<         -:  697:       *  @return The iterator @a __last.
<         -:  698:       *
<         -:  699:       *  This function erases a sequence of elements from a %set.
<         -:  700:       *  Note that this function only erases the element, and that if
<         -:  701:       *  the element is itself a pointer, the pointed-to memory is not touched
<         -:  702:       *  in any way.  Managing the pointer is the user's responsibility.
<         -:  703:       */
<         -:  704:      _GLIBCXX_ABI_TAG_CXX11
<         -:  705:      iterator
<         -:  706:      erase(const_iterator __first, const_iterator __last)
<         -:  707:      { return _M_t.erase(__first, __last); }
<         -:  708:#else
<         -:  709:      /**
<         -:  710:       *  @brief Erases a [first,last) range of elements from a %set.
<         -:  711:       *  @param  __first  Iterator pointing to the start of the range to be
<         -:  712:       *                 erased.
<         -:  713:       *  @param __last Iterator pointing to the end of the range to
<         -:  714:       *  be erased.
<         -:  715:       *
<         -:  716:       *  This function erases a sequence of elements from a %set.
<         -:  717:       *  Note that this function only erases the element, and that if
<         -:  718:       *  the element is itself a pointer, the pointed-to memory is not touched
<         -:  719:       *  in any way.  Managing the pointer is the user's responsibility.
<         -:  720:       */
<         -:  721:      void
<         -:  722:      erase(iterator __first, iterator __last)
<         -:  723:      { _M_t.erase(__first, __last); }
<         -:  724:#endif
---
>         -:  596:      template<typename, typename>
>         -:  597:	friend class _Rb_tree_merge_helper;
>         -:  598:
>         -:  599:      template<typename _Compare1>
>         -:  600:	void
>         -:  601:	merge(set<_Key, _Compare1, _Alloc>& __source)
>         -:  602:	{
>         -:  603:	  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
>         -:  604:	  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
>         -:  605:	}
>         -:  606:
>         -:  607:      template<typename _Compare1>
>         -:  608:	void
>         -:  609:	merge(set<_Key, _Compare1, _Alloc>&& __source)
>         -:  610:	{ merge(__source); }
>         -:  611:
>         -:  612:      template<typename _Compare1>
>         -:  613:	void
>         -:  614:	merge(multiset<_Key, _Compare1, _Alloc>& __source)
>         -:  615:	{
>         -:  616:	  using _Merge_helper = _Rb_tree_merge_helper<set, _Compare1>;
>         -:  617:	  _M_t._M_merge_unique(_Merge_helper::_S_get_tree(__source));
>         -:  618:	}
>         -:  619:
>         -:  620:      template<typename _Compare1>
>         -:  621:	void
>         -:  622:	merge(multiset<_Key, _Compare1, _Alloc>&& __source)
>         -:  623:	{ merge(__source); }
>         -:  624:#endif // C++17
>         -:  625:
>         -:  626:#if __cplusplus >= 201103L
>         -:  627:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  628:      // DR 130. Associative erase should return an iterator.
>         -:  629:      /**
>         -:  630:       *  @brief Erases an element from a %set.
>         -:  631:       *  @param  __position  An iterator pointing to the element to be erased.
>         -:  632:       *  @return An iterator pointing to the element immediately following
>         -:  633:       *          @a __position prior to the element being erased. If no such
>         -:  634:       *          element exists, end() is returned.
>         -:  635:       *
>         -:  636:       *  This function erases an element, pointed to by the given iterator,
>         -:  637:       *  from a %set.  Note that this function only erases the element, and
>         -:  638:       *  that if the element is itself a pointer, the pointed-to memory is not
>         -:  639:       *  touched in any way.  Managing the pointer is the user's
>         -:  640:       *  responsibility.
>         -:  641:       */
>         -:  642:      _GLIBCXX_ABI_TAG_CXX11
>         -:  643:      iterator
>         -:  644:      erase(const_iterator __position)
>         -:  645:      { return _M_t.erase(__position); }
>         -:  646:#else
>         -:  647:      /**
>         -:  648:       *  @brief Erases an element from a %set.
>         -:  649:       *  @param  position  An iterator pointing to the element to be erased.
>         -:  650:       *
>         -:  651:       *  This function erases an element, pointed to by the given iterator,
>         -:  652:       *  from a %set.  Note that this function only erases the element, and
>         -:  653:       *  that if the element is itself a pointer, the pointed-to memory is not
>         -:  654:       *  touched in any way.  Managing the pointer is the user's
>         -:  655:       *  responsibility.
>         -:  656:       */
>         -:  657:      void
>         -:  658:      erase(iterator __position)
>         -:  659:      { _M_t.erase(__position); }
>         -:  660:#endif
>         -:  661:
>         -:  662:      /**
>         -:  663:       *  @brief Erases elements according to the provided key.
>         -:  664:       *  @param  __x  Key of element to be erased.
>         -:  665:       *  @return  The number of elements erased.
>         -:  666:       *
>         -:  667:       *  This function erases all the elements located by the given key from
>         -:  668:       *  a %set.
>         -:  669:       *  Note that this function only erases the element, and that if
>         -:  670:       *  the element is itself a pointer, the pointed-to memory is not touched
>         -:  671:       *  in any way.  Managing the pointer is the user's responsibility.
>         -:  672:       */
>         -:  673:      size_type
>     #####:  674:      erase(const key_type& __x)
>     #####:  675:      { return _M_t.erase(__x); }
>         -:  676:
>         -:  677:#if __cplusplus >= 201103L
>         -:  678:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  679:      // DR 130. Associative erase should return an iterator.
>         -:  680:      /**
>         -:  681:       *  @brief Erases a [__first,__last) range of elements from a %set.
>         -:  682:       *  @param  __first  Iterator pointing to the start of the range to be
>         -:  683:       *                 erased.
>         -:  684:
>         -:  685:       *  @param __last Iterator pointing to the end of the range to
>         -:  686:       *  be erased.
>         -:  687:       *  @return The iterator @a __last.
>         -:  688:       *
>         -:  689:       *  This function erases a sequence of elements from a %set.
>         -:  690:       *  Note that this function only erases the element, and that if
>         -:  691:       *  the element is itself a pointer, the pointed-to memory is not touched
>         -:  692:       *  in any way.  Managing the pointer is the user's responsibility.
>         -:  693:       */
>         -:  694:      _GLIBCXX_ABI_TAG_CXX11
>         -:  695:      iterator
>         -:  696:      erase(const_iterator __first, const_iterator __last)
>         -:  697:      { return _M_t.erase(__first, __last); }
>         -:  698:#else
>         -:  699:      /**
>         -:  700:       *  @brief Erases a [first,last) range of elements from a %set.
>         -:  701:       *  @param  __first  Iterator pointing to the start of the range to be
>         -:  702:       *                 erased.
>         -:  703:       *  @param __last Iterator pointing to the end of the range to
>         -:  704:       *  be erased.
>         -:  705:       *
>         -:  706:       *  This function erases a sequence of elements from a %set.
>         -:  707:       *  Note that this function only erases the element, and that if
>         -:  708:       *  the element is itself a pointer, the pointed-to memory is not touched
>         -:  709:       *  in any way.  Managing the pointer is the user's responsibility.
>         -:  710:       */
>         -:  711:      void
>         -:  712:      erase(iterator __first, iterator __last)
>         -:  713:      { _M_t.erase(__first, __last); }
>         -:  714:#endif
>         -:  715:
>         -:  716:      /**
>         -:  717:       *  Erases all elements in a %set.  Note that this function only erases
>         -:  718:       *  the elements, and that if the elements themselves are pointers, the
>         -:  719:       *  pointed-to memory is not touched in any way.  Managing the pointer is
>         -:  720:       *  the user's responsibility.
>         -:  721:       */
>         -:  722:      void
>         -:  723:      clear() _GLIBCXX_NOEXCEPT
>         -:  724:      { _M_t.clear(); }
754,940c728,901
<         -:  726:      /**
<         -:  727:       *  Erases all elements in a %set.  Note that this function only erases
<         -:  728:       *  the elements, and that if the elements themselves are pointers, the
<         -:  729:       *  pointed-to memory is not touched in any way.  Managing the pointer is
<         -:  730:       *  the user's responsibility.
<         -:  731:       */
<         -:  732:      void
<         -:  733:      clear() _GLIBCXX_NOEXCEPT
<         -:  734:      { _M_t.clear(); }
<         -:  735:
<         -:  736:      // set operations:
<         -:  737:
<         -:  738:      //@{
<         -:  739:      /**
<         -:  740:       *  @brief  Finds the number of elements.
<         -:  741:       *  @param  __x  Element to located.
<         -:  742:       *  @return  Number of elements with specified key.
<         -:  743:       *
<         -:  744:       *  This function only makes sense for multisets; for set the result will
<         -:  745:       *  either be 0 (not present) or 1 (present).
<         -:  746:       */
<         -:  747:      size_type
<     #####:  748:      count(const key_type& __x) const
<     #####:  749:      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
< ------------------
< _ZNKSt3setIN7OpenDDS4DCPS6GUID_tENS1_17GUID_tKeyLessThanESaIS2_EE5countERKS2_:
<     #####:  748:      count(const key_type& __x) const
<     #####:  749:      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
< ------------------
< _ZNKSt3setIN7OpenDDS4DCPS6GUID_tENS1_17GUID_tKeyLessThanESaIS2_EE5countERKS2_:
<     #####:  748:      count(const key_type& __x) const
<     #####:  749:      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
< ------------------
< _ZNKSt3setIN7OpenDDS4DCPS19TransportReassembly7FragKeyESt4lessIS3_ESaIS3_EE5countERKS3_:
<     #####:  748:      count(const key_type& __x) const
<     #####:  749:      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
< ------------------
<         -:  750:
<         -:  751:#if __cplusplus > 201103L
<         -:  752:      template<typename _Kt>
<         -:  753:	auto
<         -:  754:	count(const _Kt& __x) const
<         -:  755:	-> decltype(_M_t._M_count_tr(__x))
<         -:  756:	{ return _M_t._M_count_tr(__x); }
<         -:  757:#endif
<         -:  758:      //@}
<         -:  759:
<         -:  760:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -:  761:      // 214.  set::find() missing const overload
<         -:  762:      //@{
<         -:  763:      /**
<         -:  764:       *  @brief Tries to locate an element in a %set.
<         -:  765:       *  @param  __x  Element to be located.
<         -:  766:       *  @return  Iterator pointing to sought-after element, or end() if not
<         -:  767:       *           found.
<         -:  768:       *
<         -:  769:       *  This function takes a key and tries to locate the element with which
<         -:  770:       *  the key matches.  If successful the function returns an iterator
<         -:  771:       *  pointing to the sought after element.  If unsuccessful it returns the
<         -:  772:       *  past-the-end ( @c end() ) iterator.
<         -:  773:       */
<         -:  774:      iterator
<         -:  775:      find(const key_type& __x)
<         -:  776:      { return _M_t.find(__x); }
<         -:  777:
<         -:  778:      const_iterator
<         -:  779:      find(const key_type& __x) const
<         -:  780:      { return _M_t.find(__x); }
<         -:  781:
<         -:  782:#if __cplusplus > 201103L
<         -:  783:      template<typename _Kt>
<         -:  784:	auto
<         -:  785:	find(const _Kt& __x)
<         -:  786:	-> decltype(iterator{_M_t._M_find_tr(__x)})
<         -:  787:	{ return iterator{_M_t._M_find_tr(__x)}; }
<         -:  788:
<         -:  789:      template<typename _Kt>
<         -:  790:	auto
<         -:  791:	find(const _Kt& __x) const
<         -:  792:	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
<         -:  793:	{ return const_iterator{_M_t._M_find_tr(__x)}; }
<         -:  794:#endif
<         -:  795:      //@}
<         -:  796:
<         -:  797:      //@{
<         -:  798:      /**
<         -:  799:       *  @brief Finds the beginning of a subsequence matching given key.
<         -:  800:       *  @param  __x  Key to be located.
<         -:  801:       *  @return  Iterator pointing to first element equal to or greater
<         -:  802:       *           than key, or end().
<         -:  803:       *
<         -:  804:       *  This function returns the first element of a subsequence of elements
<         -:  805:       *  that matches the given key.  If unsuccessful it returns an iterator
<         -:  806:       *  pointing to the first element that has a greater value than given key
<         -:  807:       *  or end() if no such element exists.
<         -:  808:       */
<         -:  809:      iterator
<         -:  810:      lower_bound(const key_type& __x)
<         -:  811:      { return _M_t.lower_bound(__x); }
<         -:  812:
<         -:  813:      const_iterator
<         -:  814:      lower_bound(const key_type& __x) const
<         -:  815:      { return _M_t.lower_bound(__x); }
<         -:  816:
<         -:  817:#if __cplusplus > 201103L
<         -:  818:      template<typename _Kt>
<         -:  819:	auto
<         -:  820:	lower_bound(const _Kt& __x)
<         -:  821:	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
<         -:  822:	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
<         -:  823:
<         -:  824:      template<typename _Kt>
<         -:  825:	auto
<         -:  826:	lower_bound(const _Kt& __x) const
<         -:  827:	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
<         -:  828:	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
<         -:  829:#endif
<         -:  830:      //@}
<         -:  831:
<         -:  832:      //@{
<         -:  833:      /**
<         -:  834:       *  @brief Finds the end of a subsequence matching given key.
<         -:  835:       *  @param  __x  Key to be located.
<         -:  836:       *  @return Iterator pointing to the first element
<         -:  837:       *          greater than key, or end().
<         -:  838:       */
<         -:  839:      iterator
<         -:  840:      upper_bound(const key_type& __x)
<         -:  841:      { return _M_t.upper_bound(__x); }
<         -:  842:
<         -:  843:      const_iterator
<         -:  844:      upper_bound(const key_type& __x) const
<         -:  845:      { return _M_t.upper_bound(__x); }
<         -:  846:
<         -:  847:#if __cplusplus > 201103L
<         -:  848:      template<typename _Kt>
<         -:  849:	auto
<         -:  850:	upper_bound(const _Kt& __x)
<         -:  851:	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
<         -:  852:	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
<         -:  853:
<         -:  854:      template<typename _Kt>
<         -:  855:	auto
<         -:  856:	upper_bound(const _Kt& __x) const
<         -:  857:	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
<         -:  858:	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
<         -:  859:#endif
<         -:  860:      //@}
<         -:  861:
<         -:  862:      //@{
<         -:  863:      /**
<         -:  864:       *  @brief Finds a subsequence matching given key.
<         -:  865:       *  @param  __x  Key to be located.
<         -:  866:       *  @return  Pair of iterators that possibly points to the subsequence
<         -:  867:       *           matching given key.
<         -:  868:       *
<         -:  869:       *  This function is equivalent to
<         -:  870:       *  @code
<         -:  871:       *    std::make_pair(c.lower_bound(val),
<         -:  872:       *                   c.upper_bound(val))
<         -:  873:       *  @endcode
<         -:  874:       *  (but is faster than making the calls separately).
<         -:  875:       *
<         -:  876:       *  This function probably only makes sense for multisets.
<         -:  877:       */
<         -:  878:      std::pair<iterator, iterator>
<         -:  879:      equal_range(const key_type& __x)
<         -:  880:      { return _M_t.equal_range(__x); }
<         -:  881:
<         -:  882:      std::pair<const_iterator, const_iterator>
<         -:  883:      equal_range(const key_type& __x) const
<         -:  884:      { return _M_t.equal_range(__x); }
<         -:  885:
<         -:  886:#if __cplusplus > 201103L
<         -:  887:      template<typename _Kt>
<         -:  888:	auto
<         -:  889:	equal_range(const _Kt& __x)
<         -:  890:	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
<         -:  891:	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
<         -:  892:
<         -:  893:      template<typename _Kt>
<         -:  894:	auto
<         -:  895:	equal_range(const _Kt& __x) const
<         -:  896:	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
<         -:  897:	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
<         -:  898:#endif
<         -:  899:      //@}
---
>         -:  726:      // set operations:
>         -:  727:
>         -:  728:      //@{
>         -:  729:      /**
>         -:  730:       *  @brief  Finds the number of elements.
>         -:  731:       *  @param  __x  Element to located.
>         -:  732:       *  @return  Number of elements with specified key.
>         -:  733:       *
>         -:  734:       *  This function only makes sense for multisets; for set the result will
>         -:  735:       *  either be 0 (not present) or 1 (present).
>         -:  736:       */
>         -:  737:      size_type
>     #####:  738:      count(const key_type& __x) const
>     #####:  739:      { return _M_t.find(__x) == _M_t.end() ? 0 : 1; }
>         -:  740:
>         -:  741:#if __cplusplus > 201103L
>         -:  742:      template<typename _Kt>
>         -:  743:	auto
>         -:  744:	count(const _Kt& __x) const
>         -:  745:	-> decltype(_M_t._M_count_tr(__x))
>         -:  746:	{ return _M_t._M_count_tr(__x); }
>         -:  747:#endif
>         -:  748:      //@}
>         -:  749:
>         -:  750:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  751:      // 214.  set::find() missing const overload
>         -:  752:      //@{
>         -:  753:      /**
>         -:  754:       *  @brief Tries to locate an element in a %set.
>         -:  755:       *  @param  __x  Element to be located.
>         -:  756:       *  @return  Iterator pointing to sought-after element, or end() if not
>         -:  757:       *           found.
>         -:  758:       *
>         -:  759:       *  This function takes a key and tries to locate the element with which
>         -:  760:       *  the key matches.  If successful the function returns an iterator
>         -:  761:       *  pointing to the sought after element.  If unsuccessful it returns the
>         -:  762:       *  past-the-end ( @c end() ) iterator.
>         -:  763:       */
>         -:  764:      iterator
>         -:  765:      find(const key_type& __x)
>         -:  766:      { return _M_t.find(__x); }
>         -:  767:
>         -:  768:      const_iterator
>         -:  769:      find(const key_type& __x) const
>         -:  770:      { return _M_t.find(__x); }
>         -:  771:
>         -:  772:#if __cplusplus > 201103L
>         -:  773:      template<typename _Kt>
>         -:  774:	auto
>         -:  775:	find(const _Kt& __x)
>         -:  776:	-> decltype(iterator{_M_t._M_find_tr(__x)})
>         -:  777:	{ return iterator{_M_t._M_find_tr(__x)}; }
>         -:  778:
>         -:  779:      template<typename _Kt>
>         -:  780:	auto
>         -:  781:	find(const _Kt& __x) const
>         -:  782:	-> decltype(const_iterator{_M_t._M_find_tr(__x)})
>         -:  783:	{ return const_iterator{_M_t._M_find_tr(__x)}; }
>         -:  784:#endif
>         -:  785:      //@}
>         -:  786:
>         -:  787:      //@{
>         -:  788:      /**
>         -:  789:       *  @brief Finds the beginning of a subsequence matching given key.
>         -:  790:       *  @param  __x  Key to be located.
>         -:  791:       *  @return  Iterator pointing to first element equal to or greater
>         -:  792:       *           than key, or end().
>         -:  793:       *
>         -:  794:       *  This function returns the first element of a subsequence of elements
>         -:  795:       *  that matches the given key.  If unsuccessful it returns an iterator
>         -:  796:       *  pointing to the first element that has a greater value than given key
>         -:  797:       *  or end() if no such element exists.
>         -:  798:       */
>         -:  799:      iterator
>         -:  800:      lower_bound(const key_type& __x)
>         -:  801:      { return _M_t.lower_bound(__x); }
>         -:  802:
>         -:  803:      const_iterator
>         -:  804:      lower_bound(const key_type& __x) const
>         -:  805:      { return _M_t.lower_bound(__x); }
>         -:  806:
>         -:  807:#if __cplusplus > 201103L
>         -:  808:      template<typename _Kt>
>         -:  809:	auto
>         -:  810:	lower_bound(const _Kt& __x)
>         -:  811:	-> decltype(iterator(_M_t._M_lower_bound_tr(__x)))
>         -:  812:	{ return iterator(_M_t._M_lower_bound_tr(__x)); }
>         -:  813:
>         -:  814:      template<typename _Kt>
>         -:  815:	auto
>         -:  816:	lower_bound(const _Kt& __x) const
>         -:  817:	-> decltype(const_iterator(_M_t._M_lower_bound_tr(__x)))
>         -:  818:	{ return const_iterator(_M_t._M_lower_bound_tr(__x)); }
>         -:  819:#endif
>         -:  820:      //@}
>         -:  821:
>         -:  822:      //@{
>         -:  823:      /**
>         -:  824:       *  @brief Finds the end of a subsequence matching given key.
>         -:  825:       *  @param  __x  Key to be located.
>         -:  826:       *  @return Iterator pointing to the first element
>         -:  827:       *          greater than key, or end().
>         -:  828:       */
>         -:  829:      iterator
>         -:  830:      upper_bound(const key_type& __x)
>         -:  831:      { return _M_t.upper_bound(__x); }
>         -:  832:
>         -:  833:      const_iterator
>         -:  834:      upper_bound(const key_type& __x) const
>         -:  835:      { return _M_t.upper_bound(__x); }
>         -:  836:
>         -:  837:#if __cplusplus > 201103L
>         -:  838:      template<typename _Kt>
>         -:  839:	auto
>         -:  840:	upper_bound(const _Kt& __x)
>         -:  841:	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
>         -:  842:	{ return iterator(_M_t._M_upper_bound_tr(__x)); }
>         -:  843:
>         -:  844:      template<typename _Kt>
>         -:  845:	auto
>         -:  846:	upper_bound(const _Kt& __x) const
>         -:  847:	-> decltype(iterator(_M_t._M_upper_bound_tr(__x)))
>         -:  848:	{ return const_iterator(_M_t._M_upper_bound_tr(__x)); }
>         -:  849:#endif
>         -:  850:      //@}
>         -:  851:
>         -:  852:      //@{
>         -:  853:      /**
>         -:  854:       *  @brief Finds a subsequence matching given key.
>         -:  855:       *  @param  __x  Key to be located.
>         -:  856:       *  @return  Pair of iterators that possibly points to the subsequence
>         -:  857:       *           matching given key.
>         -:  858:       *
>         -:  859:       *  This function is equivalent to
>         -:  860:       *  @code
>         -:  861:       *    std::make_pair(c.lower_bound(val),
>         -:  862:       *                   c.upper_bound(val))
>         -:  863:       *  @endcode
>         -:  864:       *  (but is faster than making the calls separately).
>         -:  865:       *
>         -:  866:       *  This function probably only makes sense for multisets.
>         -:  867:       */
>         -:  868:      std::pair<iterator, iterator>
>         -:  869:      equal_range(const key_type& __x)
>         -:  870:      { return _M_t.equal_range(__x); }
>         -:  871:
>         -:  872:      std::pair<const_iterator, const_iterator>
>         -:  873:      equal_range(const key_type& __x) const
>         -:  874:      { return _M_t.equal_range(__x); }
>         -:  875:
>         -:  876:#if __cplusplus > 201103L
>         -:  877:      template<typename _Kt>
>         -:  878:	auto
>         -:  879:	equal_range(const _Kt& __x)
>         -:  880:	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
>         -:  881:	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
>         -:  882:
>         -:  883:      template<typename _Kt>
>         -:  884:	auto
>         -:  885:	equal_range(const _Kt& __x) const
>         -:  886:	-> decltype(pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)))
>         -:  887:	{ return pair<iterator, iterator>(_M_t._M_equal_range_tr(__x)); }
>         -:  888:#endif
>         -:  889:      //@}
>         -:  890:
>         -:  891:      template<typename _K1, typename _C1, typename _A1>
>         -:  892:	friend bool
>         -:  893:	operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
>         -:  894:
>         -:  895:      template<typename _K1, typename _C1, typename _A1>
>         -:  896:	friend bool
>         -:  897:	operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
>         -:  898:    };
>         -:  899:
942,996c903,957
<         -:  901:      template<typename _K1, typename _C1, typename _A1>
<         -:  902:	friend bool
<         -:  903:	operator==(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
<         -:  904:
<         -:  905:      template<typename _K1, typename _C1, typename _A1>
<         -:  906:	friend bool
<         -:  907:	operator<(const set<_K1, _C1, _A1>&, const set<_K1, _C1, _A1>&);
<         -:  908:    };
<         -:  909:
<         -:  910:#if __cpp_deduction_guides >= 201606
<         -:  911:
<         -:  912:  template<typename _InputIterator,
<         -:  913:	   typename _Compare =
<         -:  914:	     less<typename iterator_traits<_InputIterator>::value_type>,
<         -:  915:	   typename _Allocator =
<         -:  916:	     allocator<typename iterator_traits<_InputIterator>::value_type>,
<         -:  917:	   typename = _RequireInputIter<_InputIterator>,
<         -:  918:	   typename = _RequireAllocator<_Allocator>>
<         -:  919:    set(_InputIterator, _InputIterator,
<         -:  920:	_Compare = _Compare(), _Allocator = _Allocator())
<         -:  921:    -> set<typename iterator_traits<_InputIterator>::value_type,
<         -:  922:	  _Compare, _Allocator>;
<         -:  923:
<         -:  924:  template<typename _Key, typename _Compare = less<_Key>,
<         -:  925:	   typename _Allocator = allocator<_Key>,
<         -:  926:	   typename = _RequireAllocator<_Allocator>>
<         -:  927:    set(initializer_list<_Key>,
<         -:  928:	_Compare = _Compare(), _Allocator = _Allocator())
<         -:  929:    -> set<_Key, _Compare, _Allocator>;
<         -:  930:
<         -:  931:  template<typename _InputIterator, typename _Allocator,
<         -:  932:	   typename = _RequireInputIter<_InputIterator>,
<         -:  933:	   typename = _RequireAllocator<_Allocator>>
<         -:  934:    set(_InputIterator, _InputIterator, _Allocator)
<         -:  935:    -> set<typename iterator_traits<_InputIterator>::value_type,
<         -:  936:	   less<typename iterator_traits<_InputIterator>::value_type>,
<         -:  937:	   _Allocator>;
<         -:  938:
<         -:  939:  template<typename _Key, typename _Allocator,
<         -:  940:	   typename = _RequireAllocator<_Allocator>>
<         -:  941:    set(initializer_list<_Key>, _Allocator)
<         -:  942:    -> set<_Key, less<_Key>, _Allocator>;
<         -:  943:
<         -:  944:#endif
<         -:  945:
<         -:  946:  /**
<         -:  947:   *  @brief  Set equality comparison.
<         -:  948:   *  @param  __x  A %set.
<         -:  949:   *  @param  __y  A %set of the same type as @a x.
<         -:  950:   *  @return  True iff the size and elements of the sets are equal.
<         -:  951:   *
<         -:  952:   *  This is an equivalence relation.  It is linear in the size of the sets.
<         -:  953:   *  Sets are considered equivalent if their sizes are equal, and if
<         -:  954:   *  corresponding elements compare equal.
<         -:  955:  */
---
>         -:  901:  /**
>         -:  902:   *  @brief  Set equality comparison.
>         -:  903:   *  @param  __x  A %set.
>         -:  904:   *  @param  __y  A %set of the same type as @a x.
>         -:  905:   *  @return  True iff the size and elements of the sets are equal.
>         -:  906:   *
>         -:  907:   *  This is an equivalence relation.  It is linear in the size of the sets.
>         -:  908:   *  Sets are considered equivalent if their sizes are equal, and if
>         -:  909:   *  corresponding elements compare equal.
>         -:  910:  */
>         -:  911:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:  912:    inline bool
>         -:  913:    operator==(const set<_Key, _Compare, _Alloc>& __x,
>         -:  914:	       const set<_Key, _Compare, _Alloc>& __y)
>         -:  915:    { return __x._M_t == __y._M_t; }
>         -:  916:
>         -:  917:  /**
>         -:  918:   *  @brief  Set ordering relation.
>         -:  919:   *  @param  __x  A %set.
>         -:  920:   *  @param  __y  A %set of the same type as @a x.
>         -:  921:   *  @return  True iff @a __x is lexicographically less than @a __y.
>         -:  922:   *
>         -:  923:   *  This is a total ordering relation.  It is linear in the size of the
>         -:  924:   *  sets.  The elements must be comparable with @c <.
>         -:  925:   *
>         -:  926:   *  See std::lexicographical_compare() for how the determination is made.
>         -:  927:  */
>         -:  928:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:  929:    inline bool
>         -:  930:    operator<(const set<_Key, _Compare, _Alloc>& __x,
>         -:  931:	      const set<_Key, _Compare, _Alloc>& __y)
>         -:  932:    { return __x._M_t < __y._M_t; }
>         -:  933:
>         -:  934:  ///  Returns !(x == y).
>         -:  935:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:  936:    inline bool
>         -:  937:    operator!=(const set<_Key, _Compare, _Alloc>& __x,
>         -:  938:	       const set<_Key, _Compare, _Alloc>& __y)
>         -:  939:    { return !(__x == __y); }
>         -:  940:
>         -:  941:  ///  Returns y < x.
>         -:  942:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:  943:    inline bool
>         -:  944:    operator>(const set<_Key, _Compare, _Alloc>& __x,
>         -:  945:	      const set<_Key, _Compare, _Alloc>& __y)
>         -:  946:    { return __y < __x; }
>         -:  947:
>         -:  948:  ///  Returns !(y < x)
>         -:  949:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:  950:    inline bool
>         -:  951:    operator<=(const set<_Key, _Compare, _Alloc>& __x,
>         -:  952:	       const set<_Key, _Compare, _Alloc>& __y)
>         -:  953:    { return !(__y < __x); }
>         -:  954:
>         -:  955:  ///  Returns !(x < y)
999c960
<         -:  958:    operator==(const set<_Key, _Compare, _Alloc>& __x,
---
>         -:  958:    operator>=(const set<_Key, _Compare, _Alloc>& __x,
1001c962
<         -:  960:    { return __x._M_t == __y._M_t; }
---
>         -:  960:    { return !(__x < __y); }
1003,1078c964,995
<         -:  962:  /**
<         -:  963:   *  @brief  Set ordering relation.
<         -:  964:   *  @param  __x  A %set.
<         -:  965:   *  @param  __y  A %set of the same type as @a x.
<         -:  966:   *  @return  True iff @a __x is lexicographically less than @a __y.
<         -:  967:   *
<         -:  968:   *  This is a total ordering relation.  It is linear in the size of the
<         -:  969:   *  sets.  The elements must be comparable with @c <.
<         -:  970:   *
<         -:  971:   *  See std::lexicographical_compare() for how the determination is made.
<         -:  972:  */
<         -:  973:  template<typename _Key, typename _Compare, typename _Alloc>
<         -:  974:    inline bool
<         -:  975:    operator<(const set<_Key, _Compare, _Alloc>& __x,
<         -:  976:	      const set<_Key, _Compare, _Alloc>& __y)
<         -:  977:    { return __x._M_t < __y._M_t; }
<         -:  978:
<         -:  979:  ///  Returns !(x == y).
<         -:  980:  template<typename _Key, typename _Compare, typename _Alloc>
<         -:  981:    inline bool
<         -:  982:    operator!=(const set<_Key, _Compare, _Alloc>& __x,
<         -:  983:	       const set<_Key, _Compare, _Alloc>& __y)
<         -:  984:    { return !(__x == __y); }
<         -:  985:
<         -:  986:  ///  Returns y < x.
<         -:  987:  template<typename _Key, typename _Compare, typename _Alloc>
<         -:  988:    inline bool
<         -:  989:    operator>(const set<_Key, _Compare, _Alloc>& __x,
<         -:  990:	      const set<_Key, _Compare, _Alloc>& __y)
<         -:  991:    { return __y < __x; }
<         -:  992:
<         -:  993:  ///  Returns !(y < x)
<         -:  994:  template<typename _Key, typename _Compare, typename _Alloc>
<         -:  995:    inline bool
<         -:  996:    operator<=(const set<_Key, _Compare, _Alloc>& __x,
<         -:  997:	       const set<_Key, _Compare, _Alloc>& __y)
<         -:  998:    { return !(__y < __x); }
<         -:  999:
<         -: 1000:  ///  Returns !(x < y)
<         -: 1001:  template<typename _Key, typename _Compare, typename _Alloc>
<         -: 1002:    inline bool
<         -: 1003:    operator>=(const set<_Key, _Compare, _Alloc>& __x,
<         -: 1004:	       const set<_Key, _Compare, _Alloc>& __y)
<         -: 1005:    { return !(__x < __y); }
<         -: 1006:
<         -: 1007:  /// See std::set::swap().
<         -: 1008:  template<typename _Key, typename _Compare, typename _Alloc>
<         -: 1009:    inline void
<         -: 1010:    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
<         -: 1011:    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
<         -: 1012:    { __x.swap(__y); }
<         -: 1013:
<         -: 1014:_GLIBCXX_END_NAMESPACE_CONTAINER
<         -: 1015:
<         -: 1016:#if __cplusplus > 201402L
<         -: 1017:  // Allow std::set access to internals of compatible sets.
<         -: 1018:  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>
<         -: 1019:    struct
<         -: 1020:    _Rb_tree_merge_helper<_GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>, _Cmp2>
<         -: 1021:    {
<         -: 1022:    private:
<         -: 1023:      friend class _GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>;
<         -: 1024:
<         -: 1025:      static auto&
<         -: 1026:      _S_get_tree(_GLIBCXX_STD_C::set<_Val, _Cmp2, _Alloc>& __set)
<         -: 1027:      { return __set._M_t; }
<         -: 1028:
<         -: 1029:      static auto&
<         -: 1030:      _S_get_tree(_GLIBCXX_STD_C::multiset<_Val, _Cmp2, _Alloc>& __set)
<         -: 1031:      { return __set._M_t; }
<         -: 1032:    };
<         -: 1033:#endif // C++17
<         -: 1034:
<         -: 1035:_GLIBCXX_END_NAMESPACE_VERSION
<         -: 1036:} //namespace std
<         -: 1037:#endif /* _STL_SET_H */
---
>         -:  962:  /// See std::set::swap().
>         -:  963:  template<typename _Key, typename _Compare, typename _Alloc>
>         -:  964:    inline void
>         -:  965:    swap(set<_Key, _Compare, _Alloc>& __x, set<_Key, _Compare, _Alloc>& __y)
>         -:  966:    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
>         -:  967:    { __x.swap(__y); }
>         -:  968:
>         -:  969:_GLIBCXX_END_NAMESPACE_CONTAINER
>         -:  970:
>         -:  971:#if __cplusplus > 201402L
>         -:  972:_GLIBCXX_BEGIN_NAMESPACE_VERSION
>         -:  973:  // Allow std::set access to internals of compatible sets.
>         -:  974:  template<typename _Val, typename _Cmp1, typename _Alloc, typename _Cmp2>
>         -:  975:    struct
>         -:  976:    _Rb_tree_merge_helper<_GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>, _Cmp2>
>         -:  977:    {
>         -:  978:    private:
>         -:  979:      friend class _GLIBCXX_STD_C::set<_Val, _Cmp1, _Alloc>;
>         -:  980:
>         -:  981:      static auto&
>         -:  982:      _S_get_tree(_GLIBCXX_STD_C::set<_Val, _Cmp2, _Alloc>& __set)
>         -:  983:      { return __set._M_t; }
>         -:  984:
>         -:  985:      static auto&
>         -:  986:      _S_get_tree(_GLIBCXX_STD_C::multiset<_Val, _Cmp2, _Alloc>& __set)
>         -:  987:      { return __set._M_t; }
>         -:  988:    };
>         -:  989:_GLIBCXX_END_NAMESPACE_VERSION
>         -:  990:#endif // C++17
>         -:  991:
>         -:  992:} //namespace std
>         -:  993:#endif /* _STL_SET_H */
