1,2c1,2
<         -:    0:Source:/usr/include/c++/8/bits/stl_vector.h
<         -:    0:Programs:51
---
>         -:    0:Source:/usr/include/c++/7/bits/stl_vector.h
>         -:    0:Programs:3
5c5
<         -:    3:// Copyright (C) 2001-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 2001-2017 Free Software Foundation, Inc.
70,88c70,88
<         -:   68:#if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
<         -:   69:extern "C" void
<         -:   70:__sanitizer_annotate_contiguous_container(const void*, const void*,
<         -:   71:					  const void*, const void*);
<         -:   72:#endif
<         -:   73:
<         -:   74:namespace std _GLIBCXX_VISIBILITY(default)
<         -:   75:{
<         -:   76:_GLIBCXX_BEGIN_NAMESPACE_VERSION
<         -:   77:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
<         -:   78:
<         -:   79:  /// See bits/stl_deque.h's _Deque_base for an explanation.
<         -:   80:  template<typename _Tp, typename _Alloc>
<         -:   81:    struct _Vector_base
<         -:   82:    {
<         -:   83:      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
<         -:   84:	rebind<_Tp>::other _Tp_alloc_type;
<         -:   85:      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
<         -:   86:       	pointer;
---
>         -:   68:namespace std _GLIBCXX_VISIBILITY(default)
>         -:   69:{
>         -:   70:_GLIBCXX_BEGIN_NAMESPACE_CONTAINER
>         -:   71:
>         -:   72:  /// See bits/stl_deque.h's _Deque_base for an explanation.
>         -:   73:  template<typename _Tp, typename _Alloc>
>         -:   74:    struct _Vector_base
>         -:   75:    {
>         -:   76:      typedef typename __gnu_cxx::__alloc_traits<_Alloc>::template
>         -:   77:	rebind<_Tp>::other _Tp_alloc_type;
>         -:   78:      typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>::pointer
>         -:   79:       	pointer;
>         -:   80:
>     #####:   81:      struct _Vector_impl
>         -:   82:      : public _Tp_alloc_type
>         -:   83:      {
>         -:   84:	pointer _M_start;
>         -:   85:	pointer _M_finish;
>         -:   86:	pointer _M_end_of_storage;
90,144c90,103
<         -:   88:      struct _Vector_impl
<         -:   89:      : public _Tp_alloc_type
<         -:   90:      {
<         -:   91:	pointer _M_start;
<         -:   92:	pointer _M_finish;
<         -:   93:	pointer _M_end_of_storage;
<         -:   94:
<      390*:   95:	_Vector_impl()
<      390*:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<      390*:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE12_Vector_implC2Ev:
<         6:   95:	_Vector_impl()
<         6:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<         6:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE12_Vector_implC2Ev:
<         3:   95:	_Vector_impl()
<         3:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<         3:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE12_Vector_implC2Ev:
<        42:   95:	_Vector_impl()
<        42:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<        42:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EE12_Vector_implC2Ev:
<        32:   95:	_Vector_impl()
<        32:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<        32:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE12_Vector_implC2Ev:
<       208:   95:	_Vector_impl()
<       208:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<       208:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE12_Vector_implC2Ev:
<     #####:   95:	_Vector_impl()
<     #####:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<     #####:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EE12_Vector_implC2Ev:
<     #####:   95:	_Vector_impl()
<     #####:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<     #####:   97:	{ }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE12_Vector_implC2Ev:
<        99:   95:	_Vector_impl()
<        99:   96:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
<        99:   97:	{ }
< ------------------
<         -:   98:
<     #####:   99:	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
<     #####:  100:	: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
<     #####:  101:	{ }
---
>     #####:   88:	_Vector_impl()
>     #####:   89:	: _Tp_alloc_type(), _M_start(), _M_finish(), _M_end_of_storage()
>     #####:   90:	{ }
>         -:   91:
>     #####:   92:	_Vector_impl(_Tp_alloc_type const& __a) _GLIBCXX_NOEXCEPT
>     #####:   93:	: _Tp_alloc_type(__a), _M_start(), _M_finish(), _M_end_of_storage()
>     #####:   94:	{ }
>         -:   95:
>         -:   96:#if __cplusplus >= 201103L
>         -:   97:	_Vector_impl(_Tp_alloc_type&& __a) noexcept
>         -:   98:	: _Tp_alloc_type(std::move(__a)),
>         -:   99:	  _M_start(), _M_finish(), _M_end_of_storage()
>         -:  100:	{ }
>         -:  101:#endif
146,170c105,129
<         -:  103:#if __cplusplus >= 201103L
<         -:  104:	_Vector_impl(_Tp_alloc_type&& __a) noexcept
<         -:  105:	: _Tp_alloc_type(std::move(__a)),
<         -:  106:	  _M_start(), _M_finish(), _M_end_of_storage()
<         -:  107:	{ }
<         -:  108:#endif
<         -:  109:
<         -:  110:	void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT
<         -:  111:	{
<         -:  112:	  std::swap(_M_start, __x._M_start);
<         -:  113:	  std::swap(_M_finish, __x._M_finish);
<         -:  114:	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
<         -:  115:	}
<         -:  116:
<         -:  117:#if _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
<         -:  118:	template<typename = _Tp_alloc_type>
<         -:  119:	  struct _Asan
<         -:  120:	  {
<         -:  121:	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
<         -:  122:	      ::size_type size_type;
<         -:  123:
<         -:  124:	    static void _S_shrink(_Vector_impl&, size_type) { }
<         -:  125:	    static void _S_on_dealloc(_Vector_impl&) { }
<         -:  126:
<         -:  127:	    typedef _Vector_impl& _Reinit;
---
>         -:  103:	void _M_swap_data(_Vector_impl& __x) _GLIBCXX_NOEXCEPT
>         -:  104:	{
>         -:  105:	  std::swap(_M_start, __x._M_start);
>         -:  106:	  std::swap(_M_finish, __x._M_finish);
>         -:  107:	  std::swap(_M_end_of_storage, __x._M_end_of_storage);
>         -:  108:	}
>         -:  109:      };
>         -:  110:
>         -:  111:    public:
>         -:  112:      typedef _Alloc allocator_type;
>         -:  113:
>         -:  114:      _Tp_alloc_type&
>     #####:  115:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
>     #####:  116:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
>         -:  117:
>         -:  118:      const _Tp_alloc_type&
>     #####:  119:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
>     #####:  120:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
>         -:  121:
>         -:  122:      allocator_type
>         -:  123:      get_allocator() const _GLIBCXX_NOEXCEPT
>         -:  124:      { return allocator_type(_M_get_Tp_allocator()); }
>         -:  125:
>     #####:  126:      _Vector_base()
>     #####:  127:      : _M_impl() { }
172,177c131,136
<         -:  129:	    struct _Grow
<         -:  130:	    {
<         -:  131:	      _Grow(_Vector_impl&, size_type) { }
<         -:  132:	      void _M_grew(size_type) { }
<         -:  133:	    };
<         -:  134:	  };
---
>         -:  129:      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
>         -:  130:      : _M_impl(__a) { }
>         -:  131:
>         -:  132:      _Vector_base(size_t __n)
>         -:  133:      : _M_impl()
>         -:  134:      { _M_create_storage(__n); }
179,933c138,488
<         -:  136:	// Enable ASan annotations for memory obtained from std::allocator.
<         -:  137:	template<typename _Up>
<         -:  138:	  struct _Asan<allocator<_Up> >
<         -:  139:	  {
<         -:  140:	    typedef typename __gnu_cxx::__alloc_traits<_Tp_alloc_type>
<         -:  141:	      ::size_type size_type;
<         -:  142:
<         -:  143:	    // Adjust ASan annotation for [_M_start, _M_end_of_storage) to
<         -:  144:	    // mark end of valid region as __curr instead of __prev.
<         -:  145:	    static void
<         -:  146:	    _S_adjust(_Vector_impl& __impl, pointer __prev, pointer __curr)
<         -:  147:	    {
<         -:  148:	      __sanitizer_annotate_contiguous_container(__impl._M_start,
<         -:  149:		  __impl._M_end_of_storage, __prev, __curr);
<         -:  150:	    }
<         -:  151:
<         -:  152:	    static void
<         -:  153:	    _S_grow(_Vector_impl& __impl, size_type __n)
<         -:  154:	    { _S_adjust(__impl, __impl._M_finish, __impl._M_finish + __n); }
<         -:  155:
<         -:  156:	    static void
<         -:  157:	    _S_shrink(_Vector_impl& __impl, size_type __n)
<         -:  158:	    { _S_adjust(__impl, __impl._M_finish + __n, __impl._M_finish); }
<         -:  159:
<         -:  160:	    static void
<         -:  161:	    _S_on_dealloc(_Vector_impl& __impl)
<         -:  162:	    {
<         -:  163:	      if (__impl._M_start)
<         -:  164:		_S_adjust(__impl, __impl._M_finish, __impl._M_end_of_storage);
<         -:  165:	    }
<         -:  166:
<         -:  167:	    // Used on reallocation to tell ASan unused capacity is invalid.
<         -:  168:	    struct _Reinit
<         -:  169:	    {
<         -:  170:	      explicit _Reinit(_Vector_impl& __impl) : _M_impl(__impl)
<         -:  171:	      {
<         -:  172:		// Mark unused capacity as valid again before deallocating it.
<         -:  173:		_S_on_dealloc(_M_impl);
<         -:  174:	      }
<         -:  175:
<         -:  176:	      ~_Reinit()
<         -:  177:	      {
<         -:  178:		// Mark unused capacity as invalid after reallocation.
<         -:  179:		if (_M_impl._M_start)
<         -:  180:		  _S_adjust(_M_impl, _M_impl._M_end_of_storage,
<         -:  181:			    _M_impl._M_finish);
<         -:  182:	      }
<         -:  183:
<         -:  184:	      _Vector_impl& _M_impl;
<         -:  185:
<         -:  186:#if __cplusplus >= 201103L
<         -:  187:	      _Reinit(const _Reinit&) = delete;
<         -:  188:	      _Reinit& operator=(const _Reinit&) = delete;
<         -:  189:#endif
<         -:  190:	    };
<         -:  191:
<         -:  192:	    // Tell ASan when unused capacity is initialized to be valid.
<         -:  193:	    struct _Grow
<         -:  194:	    {
<         -:  195:	      _Grow(_Vector_impl& __impl, size_type __n)
<         -:  196:	      : _M_impl(__impl), _M_n(__n)
<         -:  197:	      { _S_grow(_M_impl, __n); }
<         -:  198:
<         -:  199:	      ~_Grow() { if (_M_n) _S_shrink(_M_impl, _M_n); }
<         -:  200:
<         -:  201:	      void _M_grew(size_type __n) { _M_n -= __n; }
<         -:  202:
<         -:  203:#if __cplusplus >= 201103L
<         -:  204:	      _Grow(const _Grow&) = delete;
<         -:  205:	      _Grow& operator=(const _Grow&) = delete;
<         -:  206:#endif
<         -:  207:	    private:
<         -:  208:	      _Vector_impl& _M_impl;
<         -:  209:	      size_type _M_n;
<         -:  210:	    };
<         -:  211:	  };
<         -:  212:
<         -:  213:#define _GLIBCXX_ASAN_ANNOTATE_REINIT \
<         -:  214:  typename _Base::_Vector_impl::template _Asan<>::_Reinit const \
<         -:  215:	__attribute__((__unused__)) __reinit_guard(this->_M_impl)
<         -:  216:#define _GLIBCXX_ASAN_ANNOTATE_GROW(n) \
<         -:  217:  typename _Base::_Vector_impl::template _Asan<>::_Grow \
<         -:  218:	__attribute__((__unused__)) __grow_guard(this->_M_impl, (n))
<         -:  219:#define _GLIBCXX_ASAN_ANNOTATE_GREW(n) __grow_guard._M_grew(n)
<         -:  220:#define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n) \
<         -:  221:  _Base::_Vector_impl::template _Asan<>::_S_shrink(this->_M_impl, n)
<         -:  222:#define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC \
<         -:  223:  _Base::_Vector_impl::template _Asan<>::_S_on_dealloc(this->_M_impl)
<         -:  224:#else // ! (_GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR)
<         -:  225:#define _GLIBCXX_ASAN_ANNOTATE_REINIT
<         -:  226:#define _GLIBCXX_ASAN_ANNOTATE_GROW(n)
<         -:  227:#define _GLIBCXX_ASAN_ANNOTATE_GREW(n)
<         -:  228:#define _GLIBCXX_ASAN_ANNOTATE_SHRINK(n)
<         -:  229:#define _GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC
<         -:  230:#endif // _GLIBCXX_SANITIZE_STD_ALLOCATOR && _GLIBCXX_SANITIZE_VECTOR
<         -:  231:      };
<         -:  232:
<         -:  233:    public:
<         -:  234:      typedef _Alloc allocator_type;
<         -:  235:
<         -:  236:      _Tp_alloc_type&
<      959*:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<      959*:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE19_M_get_Tp_allocatorEv:
<     #####:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE19_M_get_Tp_allocatorEv:
<        12:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<        12:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseI13ACE_INET_AddrSaIS0_EE19_M_get_Tp_allocatorEv:
<     #####:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE19_M_get_Tp_allocatorEv:
<        21:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<        21:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE19_M_get_Tp_allocatorEv:
<       168:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<       168:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EE19_M_get_Tp_allocatorEv:
<       119:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<       119:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE19_M_get_Tp_allocatorEv:
<     #####:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE19_M_get_Tp_allocatorEv:
<       475:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<       475:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE19_M_get_Tp_allocatorEv:
<     #####:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EE19_M_get_Tp_allocatorEv:
<     #####:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS14SequenceNumberES3_ESaIS4_EE19_M_get_Tp_allocatorEv:
<     #####:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<     #####:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE19_M_get_Tp_allocatorEv:
<       164:  237:      _M_get_Tp_allocator() _GLIBCXX_NOEXCEPT
<       164:  238:      { return *static_cast<_Tp_alloc_type*>(&this->_M_impl); }
< ------------------
<         -:  239:
<         -:  240:      const _Tp_alloc_type&
<      347*:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<      347*:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE19_M_get_Tp_allocatorEv:
<         4:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<         4:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseI13ACE_INET_AddrSaIS0_EE19_M_get_Tp_allocatorEv:
<     #####:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE19_M_get_Tp_allocatorEv:
<        12:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<        12:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE19_M_get_Tp_allocatorEv:
<        84:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<        84:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EE19_M_get_Tp_allocatorEv:
<        55:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<        55:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE19_M_get_Tp_allocatorEv:
<     #####:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE19_M_get_Tp_allocatorEv:
<       178:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<       178:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EE19_M_get_Tp_allocatorEv:
<     #####:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE19_M_get_Tp_allocatorEv:
<     #####:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<     #####:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
< _ZNKSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE19_M_get_Tp_allocatorEv:
<        14:  241:      _M_get_Tp_allocator() const _GLIBCXX_NOEXCEPT
<        14:  242:      { return *static_cast<const _Tp_alloc_type*>(&this->_M_impl); }
< ------------------
<         -:  243:
<         -:  244:      allocator_type
<         -:  245:      get_allocator() const _GLIBCXX_NOEXCEPT
<         -:  246:      { return allocator_type(_M_get_Tp_allocator()); }
<         -:  247:
<      390*:  248:      _Vector_base()
<      390*:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EEC2Ev:
<         6:  248:      _Vector_base()
<         6:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EEC2Ev:
<         3:  248:      _Vector_base()
<         3:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EEC2Ev:
<        42:  248:      _Vector_base()
<        42:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EEC2Ev:
<        32:  248:      _Vector_base()
<        32:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EEC2Ev:
<       208:  248:      _Vector_base()
<       208:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EEC2Ev:
<     #####:  248:      _Vector_base()
<     #####:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EEC2Ev:
<     #####:  248:      _Vector_base()
<     #####:  249:      : _M_impl() { }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EEC2Ev:
<        99:  248:      _Vector_base()
<        99:  249:      : _M_impl() { }
< ------------------
<         -:  250:
<         -:  251:      _Vector_base(const allocator_type& __a) _GLIBCXX_NOEXCEPT
<         -:  252:      : _M_impl(__a) { }
<         -:  253:
<         -:  254:      _Vector_base(size_t __n)
<         -:  255:      : _M_impl()
<         -:  256:      { _M_create_storage(__n); }
<         -:  257:
<     #####:  258:      _Vector_base(size_t __n, const allocator_type& __a)
<     #####:  259:      : _M_impl(__a)
<     #####:  260:      { _M_create_storage(__n); }
<         -:  261:
<         -:  262:#if __cplusplus >= 201103L
<         -:  263:      _Vector_base(_Tp_alloc_type&& __a) noexcept
<         -:  264:      : _M_impl(std::move(__a)) { }
<         -:  265:
<         -:  266:      _Vector_base(_Vector_base&& __x) noexcept
<         -:  267:      : _M_impl(std::move(__x._M_get_Tp_allocator()))
<         -:  268:      { this->_M_impl._M_swap_data(__x._M_impl); }
<         -:  269:
<         -:  270:      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
<         -:  271:      : _M_impl(__a)
<         -:  272:      {
<         -:  273:	if (__x.get_allocator() == __a)
<         -:  274:	  this->_M_impl._M_swap_data(__x._M_impl);
<         -:  275:	else
<         -:  276:	  {
<         -:  277:	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
<         -:  278:	    _M_create_storage(__n);
<         -:  279:	  }
<         -:  280:      }
<         -:  281:#endif
<         -:  282:
<      390*:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<      390*:  285:	_M_deallocate(_M_impl._M_start,
<      390*:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<      390*:  287:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EED2Ev:
<         6:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<         6:  285:	_M_deallocate(_M_impl._M_start,
<         6:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<         6:  287:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EED2Ev:
<         3:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<         3:  285:	_M_deallocate(_M_impl._M_start,
<         3:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<         3:  287:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EED2Ev:
<        42:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<        42:  285:	_M_deallocate(_M_impl._M_start,
<        42:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<        42:  287:      }
< ------------------
< _ZNSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EED2Ev:
<        32:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<        32:  285:	_M_deallocate(_M_impl._M_start,
<        32:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<        32:  287:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EED2Ev:
<       208:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<       208:  285:	_M_deallocate(_M_impl._M_start,
<       208:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<       208:  287:      }
< ------------------
< _ZNSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EED2Ev:
<     #####:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<     #####:  285:	_M_deallocate(_M_impl._M_start,
<     #####:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<     #####:  287:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EED2Ev:
<     #####:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<     #####:  285:	_M_deallocate(_M_impl._M_start,
<     #####:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<     #####:  287:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS14SequenceNumberES3_ESaIS4_EED2Ev:
<     #####:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<     #####:  285:	_M_deallocate(_M_impl._M_start,
<     #####:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<     #####:  287:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EED2Ev:
<        99:  283:      ~_Vector_base() _GLIBCXX_NOEXCEPT
<         -:  284:      {
<        99:  285:	_M_deallocate(_M_impl._M_start,
<        99:  286:		      _M_impl._M_end_of_storage - _M_impl._M_start);
<        99:  287:      }
< ------------------
<         -:  288:
<         -:  289:    public:
<         -:  290:      _Vector_impl _M_impl;
<         -:  291:
<         -:  292:      pointer
<      181*:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<      181*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE11_M_allocateEm:
<         2:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<        2*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseI13ACE_INET_AddrSaIS0_EE11_M_allocateEm:
<     #####:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE11_M_allocateEm:
<         6:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<        6*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE11_M_allocateEm:
<        42:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<       42*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EE11_M_allocateEm:
<        32:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<       32*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE11_M_allocateEm:
<     #####:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE11_M_allocateEm:
<        89:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<       89*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EE11_M_allocateEm:
<     #####:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE11_M_allocateEm:
<     #####:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE11_M_allocateEm:
<        10:  293:      _M_allocate(size_t __n)
<         -:  294:      {
<         -:  295:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<       10*:  296:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
<         -:  297:      }
< ------------------
<         -:  298:
<         -:  299:      void
<      571*:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<      571*:  303:	if (__p)
<      270*:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<      571*:  305:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE13_M_deallocateEPS7_m:
<         8:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<         8:  303:	if (__p)
<         2:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<         8:  305:      }
< ------------------
< _ZNSt12_Vector_baseI13ACE_INET_AddrSaIS0_EE13_M_deallocateEPS0_m:
<     #####:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  303:	if (__p)
<     #####:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<     #####:  305:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE13_M_deallocateEPS2_m:
<         9:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<         9:  303:	if (__p)
<         6:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<         9:  305:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE13_M_deallocateEPS4_m:
<        84:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<        84:  303:	if (__p)
<        42:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<        84:  305:      }
< ------------------
< _ZNSt12_Vector_baseIPN7OpenDDS4DCPS13TransportImplESaIS3_EE13_M_deallocateEPS3_m:
<        64:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<        64:  303:	if (__p)
<        32:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<        64:  305:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE13_M_deallocateEPS4_m:
<     #####:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  303:	if (__p)
<     #####:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<     #####:  305:      }
< ------------------
< _ZNSt12_Vector_baseIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE13_M_deallocateEPS4_m:
<       297:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<       297:  303:	if (__p)
<       178:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<       297:  305:      }
< ------------------
< _ZNSt12_Vector_baseINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE13_M_deallocateEPS5_m:
<     #####:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  303:	if (__p)
<     #####:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<     #####:  305:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEESt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISC_EEESaISF_EE13_M_deallocateEPSF_m:
<     #####:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  303:	if (__p)
<     #####:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<     #####:  305:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIN7OpenDDS4DCPS14SequenceNumberES3_ESaIS4_EE13_M_deallocateEPS4_m:
<     #####:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<     #####:  303:	if (__p)
<     #####:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<     #####:  305:      }
< ------------------
< _ZNSt12_Vector_baseISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE13_M_deallocateEPS7_m:
<       109:  300:      _M_deallocate(pointer __p, size_t __n)
<         -:  301:      {
<         -:  302:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
<       109:  303:	if (__p)
<        10:  304:	  _Tr::deallocate(_M_impl, __p, __n);
<       109:  305:      }
< ------------------
<         -:  306:
<         -:  307:    private:
<         -:  308:      void
<     #####:  309:      _M_create_storage(size_t __n)
<         -:  310:      {
<     #####:  311:	this->_M_impl._M_start = this->_M_allocate(__n);
<     #####:  312:	this->_M_impl._M_finish = this->_M_impl._M_start;
<     #####:  313:	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
<     #####:  314:      }
<         -:  315:    };
<         -:  316:
<         -:  317:  /**
<         -:  318:   *  @brief A standard container which offers fixed time access to
<         -:  319:   *  individual elements in any order.
<         -:  320:   *
<         -:  321:   *  @ingroup sequences
<         -:  322:   *
<         -:  323:   *  @tparam _Tp  Type of element.
<         -:  324:   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
<         -:  325:   *
<         -:  326:   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
<         -:  327:   *  <a href="tables.html#66">reversible container</a>, and a
<         -:  328:   *  <a href="tables.html#67">sequence</a>, including the
<         -:  329:   *  <a href="tables.html#68">optional sequence requirements</a> with the
<         -:  330:   *  %exception of @c push_front and @c pop_front.
<         -:  331:   *
<         -:  332:   *  In some terminology a %vector can be described as a dynamic
<         -:  333:   *  C-style array, it offers fast and efficient access to individual
<         -:  334:   *  elements in any order and saves the user from worrying about
<         -:  335:   *  memory and size allocation.  Subscripting ( @c [] ) access is
<         -:  336:   *  also provided as with C-style arrays.
<         -:  337:  */
<         -:  338:  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
<         -:  339:    class vector : protected _Vector_base<_Tp, _Alloc>
<         -:  340:    {
<         -:  341:#ifdef _GLIBCXX_CONCEPT_CHECKS
<         -:  342:      // Concept requirements.
<         -:  343:      typedef typename _Alloc::value_type		_Alloc_value_type;
<         -:  344:# if __cplusplus < 201103L
<         -:  345:      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
<         -:  346:# endif
<         -:  347:      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
<         -:  348:#endif
<         -:  349:
<         -:  350:#if __cplusplus >= 201103L
<         -:  351:      static_assert(is_same<typename remove_cv<_Tp>::type, _Tp>::value,
<         -:  352:	  "std::vector must have a non-const, non-volatile value_type");
<         -:  353:# ifdef __STRICT_ANSI__
<         -:  354:      static_assert(is_same<typename _Alloc::value_type, _Tp>::value,
<         -:  355:	  "std::vector must have the same value_type as its allocator");
<         -:  356:# endif
<         -:  357:#endif
<         -:  358:
<         -:  359:      typedef _Vector_base<_Tp, _Alloc>			_Base;
<         -:  360:      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
<         -:  361:      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
<         -:  362:
<         -:  363:    public:
<         -:  364:      typedef _Tp					value_type;
<         -:  365:      typedef typename _Base::pointer			pointer;
<         -:  366:      typedef typename _Alloc_traits::const_pointer	const_pointer;
<         -:  367:      typedef typename _Alloc_traits::reference		reference;
<         -:  368:      typedef typename _Alloc_traits::const_reference	const_reference;
<         -:  369:      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
<         -:  370:      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
<         -:  371:      const_iterator;
<         -:  372:      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
<         -:  373:      typedef std::reverse_iterator<iterator>		reverse_iterator;
<         -:  374:      typedef size_t					size_type;
<         -:  375:      typedef ptrdiff_t					difference_type;
<         -:  376:      typedef _Alloc					allocator_type;
<         -:  377:
<         -:  378:    protected:
<         -:  379:      using _Base::_M_allocate;
<         -:  380:      using _Base::_M_deallocate;
<         -:  381:      using _Base::_M_impl;
<         -:  382:      using _Base::_M_get_Tp_allocator;
<         -:  383:
<         -:  384:    public:
<         -:  385:      // [23.2.4.1] construct/copy/destroy
<         -:  386:      // (assign() and get_allocator() are also listed in this section)
<         -:  387:
<         -:  388:      /**
<         -:  389:       *  @brief  Creates a %vector with no elements.
<         -:  390:       */
<      390*:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<      390*:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EEC2Ev:
<         6:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<         6:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EEC2Ev:
<         3:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<         3:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EEC2Ev:
<        42:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<        42:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EEC2Ev:
<        32:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<        32:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EEC2Ev:
<       208:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<       208:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EEC2Ev:
<     #####:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<     #####:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EEC2Ev:
<     #####:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<     #####:  395:      : _Base() { }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EEC2Ev:
<        99:  391:      vector()
<         -:  392:#if __cplusplus >= 201103L
<         -:  393:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
<         -:  394:#endif
<        99:  395:      : _Base() { }
< ------------------
<         -:  396:
<         -:  397:      /**
<         -:  398:       *  @brief  Creates a %vector with no elements.
<         -:  399:       *  @param  __a  An allocator object.
<         -:  400:       */
<         -:  401:      explicit
<         -:  402:      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
<         -:  403:      : _Base(__a) { }
<         -:  404:
<         -:  405:#if __cplusplus >= 201103L
<         -:  406:      /**
<         -:  407:       *  @brief  Creates a %vector with default constructed elements.
<         -:  408:       *  @param  __n  The number of elements to initially create.
<         -:  409:       *  @param  __a  An allocator.
<         -:  410:       *
<         -:  411:       *  This constructor fills the %vector with @a __n default
<         -:  412:       *  constructed elements.
<         -:  413:       */
<         -:  414:      explicit
<         -:  415:      vector(size_type __n, const allocator_type& __a = allocator_type())
<         -:  416:      : _Base(__n, __a)
<         -:  417:      { _M_default_initialize(__n); }
<         -:  418:
<         -:  419:      /**
<         -:  420:       *  @brief  Creates a %vector with copies of an exemplar element.
<         -:  421:       *  @param  __n  The number of elements to initially create.
<         -:  422:       *  @param  __value  An element to copy.
<         -:  423:       *  @param  __a  An allocator.
<         -:  424:       *
<         -:  425:       *  This constructor fills the %vector with @a __n copies of @a __value.
<         -:  426:       */
<         -:  427:      vector(size_type __n, const value_type& __value,
<         -:  428:	     const allocator_type& __a = allocator_type())
<         -:  429:      : _Base(__n, __a)
<         -:  430:      { _M_fill_initialize(__n, __value); }
<         -:  431:#else
<         -:  432:      /**
<         -:  433:       *  @brief  Creates a %vector with copies of an exemplar element.
<         -:  434:       *  @param  __n  The number of elements to initially create.
<         -:  435:       *  @param  __value  An element to copy.
<         -:  436:       *  @param  __a  An allocator.
<         -:  437:       *
<         -:  438:       *  This constructor fills the %vector with @a __n copies of @a __value.
<         -:  439:       */
<         -:  440:      explicit
<         -:  441:      vector(size_type __n, const value_type& __value = value_type(),
<         -:  442:	     const allocator_type& __a = allocator_type())
<         -:  443:      : _Base(__n, __a)
<         -:  444:      { _M_fill_initialize(__n, __value); }
<         -:  445:#endif
<         -:  446:
<         -:  447:      /**
<         -:  448:       *  @brief  %Vector copy constructor.
<         -:  449:       *  @param  __x  A %vector of identical element and allocator types.
<         -:  450:       *
<         -:  451:       *  All the elements of @a __x are copied, but any unused capacity in
<         -:  452:       *  @a __x  will not be copied
<         -:  453:       *  (i.e. capacity() == size() in the new %vector).
<         -:  454:       *
<         -:  455:       *  The newly-created %vector uses a copy of the allocator object used
<         -:  456:       *  by @a __x (unless the allocator traits dictate a different object).
<         -:  457:       */
<     #####:  458:      vector(const vector& __x)
<         -:  459:      : _Base(__x.size(),
<     #####:  460:	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
<         -:  461:      {
<     #####:  462:	this->_M_impl._M_finish =
<     #####:  463:	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
<         -:  464:				      this->_M_impl._M_start,
<     #####:  465:				      _M_get_Tp_allocator());
<     #####:  466:      }
<         -:  467:
<         -:  468:#if __cplusplus >= 201103L
<         -:  469:      /**
<         -:  470:       *  @brief  %Vector move constructor.
<         -:  471:       *  @param  __x  A %vector of identical element and allocator types.
<         -:  472:       *
<         -:  473:       *  The newly-created %vector contains the exact contents of @a __x.
<         -:  474:       *  The contents of @a __x are a valid, but unspecified %vector.
<         -:  475:       */
<         -:  476:      vector(vector&& __x) noexcept
<         -:  477:      : _Base(std::move(__x)) { }
<         -:  478:
<         -:  479:      /// Copy constructor with alternative allocator
<         -:  480:      vector(const vector& __x, const allocator_type& __a)
<         -:  481:      : _Base(__x.size(), __a)
<         -:  482:      {
<         -:  483:	this->_M_impl._M_finish =
<         -:  484:	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
<         -:  485:				      this->_M_impl._M_start,
<         -:  486:				      _M_get_Tp_allocator());
---
>     #####:  136:      _Vector_base(size_t __n, const allocator_type& __a)
>     #####:  137:      : _M_impl(__a)
>     #####:  138:      { _M_create_storage(__n); }
>         -:  139:
>         -:  140:#if __cplusplus >= 201103L
>         -:  141:      _Vector_base(_Tp_alloc_type&& __a) noexcept
>         -:  142:      : _M_impl(std::move(__a)) { }
>         -:  143:
>         -:  144:      _Vector_base(_Vector_base&& __x) noexcept
>         -:  145:      : _M_impl(std::move(__x._M_get_Tp_allocator()))
>         -:  146:      { this->_M_impl._M_swap_data(__x._M_impl); }
>         -:  147:
>         -:  148:      _Vector_base(_Vector_base&& __x, const allocator_type& __a)
>         -:  149:      : _M_impl(__a)
>         -:  150:      {
>         -:  151:	if (__x.get_allocator() == __a)
>         -:  152:	  this->_M_impl._M_swap_data(__x._M_impl);
>         -:  153:	else
>         -:  154:	  {
>         -:  155:	    size_t __n = __x._M_impl._M_finish - __x._M_impl._M_start;
>         -:  156:	    _M_create_storage(__n);
>         -:  157:	  }
>         -:  158:      }
>         -:  159:#endif
>         -:  160:
>     #####:  161:      ~_Vector_base() _GLIBCXX_NOEXCEPT
>     #####:  162:      { _M_deallocate(this->_M_impl._M_start, this->_M_impl._M_end_of_storage
>     #####:  163:		      - this->_M_impl._M_start); }
>         -:  164:
>         -:  165:    public:
>         -:  166:      _Vector_impl _M_impl;
>         -:  167:
>         -:  168:      pointer
>     #####:  169:      _M_allocate(size_t __n)
>         -:  170:      {
>         -:  171:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
>     #####:  172:	return __n != 0 ? _Tr::allocate(_M_impl, __n) : pointer();
>         -:  173:      }
>         -:  174:
>         -:  175:      void
>     #####:  176:      _M_deallocate(pointer __p, size_t __n)
>         -:  177:      {
>         -:  178:	typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type> _Tr;
>     #####:  179:	if (__p)
>     #####:  180:	  _Tr::deallocate(_M_impl, __p, __n);
>     #####:  181:      }
>         -:  182:
>         -:  183:    private:
>         -:  184:      void
>     #####:  185:      _M_create_storage(size_t __n)
>         -:  186:      {
>     #####:  187:	this->_M_impl._M_start = this->_M_allocate(__n);
>     #####:  188:	this->_M_impl._M_finish = this->_M_impl._M_start;
>     #####:  189:	this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
>     #####:  190:      }
>         -:  191:    };
>         -:  192:
>         -:  193:
>         -:  194:  /**
>         -:  195:   *  @brief A standard container which offers fixed time access to
>         -:  196:   *  individual elements in any order.
>         -:  197:   *
>         -:  198:   *  @ingroup sequences
>         -:  199:   *
>         -:  200:   *  @tparam _Tp  Type of element.
>         -:  201:   *  @tparam _Alloc  Allocator type, defaults to allocator<_Tp>.
>         -:  202:   *
>         -:  203:   *  Meets the requirements of a <a href="tables.html#65">container</a>, a
>         -:  204:   *  <a href="tables.html#66">reversible container</a>, and a
>         -:  205:   *  <a href="tables.html#67">sequence</a>, including the
>         -:  206:   *  <a href="tables.html#68">optional sequence requirements</a> with the
>         -:  207:   *  %exception of @c push_front and @c pop_front.
>         -:  208:   *
>         -:  209:   *  In some terminology a %vector can be described as a dynamic
>         -:  210:   *  C-style array, it offers fast and efficient access to individual
>         -:  211:   *  elements in any order and saves the user from worrying about
>         -:  212:   *  memory and size allocation.  Subscripting ( @c [] ) access is
>         -:  213:   *  also provided as with C-style arrays.
>         -:  214:  */
>         -:  215:  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
>         -:  216:    class vector : protected _Vector_base<_Tp, _Alloc>
>         -:  217:    {
>         -:  218:#ifdef _GLIBCXX_CONCEPT_CHECKS
>         -:  219:      // Concept requirements.
>         -:  220:      typedef typename _Alloc::value_type		_Alloc_value_type;
>         -:  221:# if __cplusplus < 201103L
>         -:  222:      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
>         -:  223:# endif
>         -:  224:      __glibcxx_class_requires2(_Tp, _Alloc_value_type, _SameTypeConcept)
>         -:  225:#endif
>         -:  226:
>         -:  227:      typedef _Vector_base<_Tp, _Alloc>			_Base;
>         -:  228:      typedef typename _Base::_Tp_alloc_type		_Tp_alloc_type;
>         -:  229:      typedef __gnu_cxx::__alloc_traits<_Tp_alloc_type>	_Alloc_traits;
>         -:  230:
>         -:  231:    public:
>         -:  232:      typedef _Tp					value_type;
>         -:  233:      typedef typename _Base::pointer			pointer;
>         -:  234:      typedef typename _Alloc_traits::const_pointer	const_pointer;
>         -:  235:      typedef typename _Alloc_traits::reference		reference;
>         -:  236:      typedef typename _Alloc_traits::const_reference	const_reference;
>         -:  237:      typedef __gnu_cxx::__normal_iterator<pointer, vector> iterator;
>         -:  238:      typedef __gnu_cxx::__normal_iterator<const_pointer, vector>
>         -:  239:      const_iterator;
>         -:  240:      typedef std::reverse_iterator<const_iterator>	const_reverse_iterator;
>         -:  241:      typedef std::reverse_iterator<iterator>		reverse_iterator;
>         -:  242:      typedef size_t					size_type;
>         -:  243:      typedef ptrdiff_t					difference_type;
>         -:  244:      typedef _Alloc					allocator_type;
>         -:  245:
>         -:  246:    protected:
>         -:  247:      using _Base::_M_allocate;
>         -:  248:      using _Base::_M_deallocate;
>         -:  249:      using _Base::_M_impl;
>         -:  250:      using _Base::_M_get_Tp_allocator;
>         -:  251:
>         -:  252:    public:
>         -:  253:      // [23.2.4.1] construct/copy/destroy
>         -:  254:      // (assign() and get_allocator() are also listed in this section)
>         -:  255:
>         -:  256:      /**
>         -:  257:       *  @brief  Creates a %vector with no elements.
>         -:  258:       */
>     #####:  259:      vector()
>         -:  260:#if __cplusplus >= 201103L
>         -:  261:      noexcept(is_nothrow_default_constructible<_Alloc>::value)
>         -:  262:#endif
>     #####:  263:      : _Base() { }
>         -:  264:
>         -:  265:      /**
>         -:  266:       *  @brief  Creates a %vector with no elements.
>         -:  267:       *  @param  __a  An allocator object.
>         -:  268:       */
>         -:  269:      explicit
>         -:  270:      vector(const allocator_type& __a) _GLIBCXX_NOEXCEPT
>         -:  271:      : _Base(__a) { }
>         -:  272:
>         -:  273:#if __cplusplus >= 201103L
>         -:  274:      /**
>         -:  275:       *  @brief  Creates a %vector with default constructed elements.
>         -:  276:       *  @param  __n  The number of elements to initially create.
>         -:  277:       *  @param  __a  An allocator.
>         -:  278:       *
>         -:  279:       *  This constructor fills the %vector with @a __n default
>         -:  280:       *  constructed elements.
>         -:  281:       */
>         -:  282:      explicit
>         -:  283:      vector(size_type __n, const allocator_type& __a = allocator_type())
>         -:  284:      : _Base(__n, __a)
>         -:  285:      { _M_default_initialize(__n); }
>         -:  286:
>         -:  287:      /**
>         -:  288:       *  @brief  Creates a %vector with copies of an exemplar element.
>         -:  289:       *  @param  __n  The number of elements to initially create.
>         -:  290:       *  @param  __value  An element to copy.
>         -:  291:       *  @param  __a  An allocator.
>         -:  292:       *
>         -:  293:       *  This constructor fills the %vector with @a __n copies of @a __value.
>         -:  294:       */
>         -:  295:      vector(size_type __n, const value_type& __value,
>         -:  296:	     const allocator_type& __a = allocator_type())
>         -:  297:      : _Base(__n, __a)
>         -:  298:      { _M_fill_initialize(__n, __value); }
>         -:  299:#else
>         -:  300:      /**
>         -:  301:       *  @brief  Creates a %vector with copies of an exemplar element.
>         -:  302:       *  @param  __n  The number of elements to initially create.
>         -:  303:       *  @param  __value  An element to copy.
>         -:  304:       *  @param  __a  An allocator.
>         -:  305:       *
>         -:  306:       *  This constructor fills the %vector with @a __n copies of @a __value.
>         -:  307:       */
>         -:  308:      explicit
>         -:  309:      vector(size_type __n, const value_type& __value = value_type(),
>         -:  310:	     const allocator_type& __a = allocator_type())
>         -:  311:      : _Base(__n, __a)
>         -:  312:      { _M_fill_initialize(__n, __value); }
>         -:  313:#endif
>         -:  314:
>         -:  315:      /**
>         -:  316:       *  @brief  %Vector copy constructor.
>         -:  317:       *  @param  __x  A %vector of identical element and allocator types.
>         -:  318:       *
>         -:  319:       *  All the elements of @a __x are copied, but any unused capacity in
>         -:  320:       *  @a __x  will not be copied
>         -:  321:       *  (i.e. capacity() == size() in the new %vector).
>         -:  322:       *
>         -:  323:       *  The newly-created %vector uses a copy of the allocator object used
>         -:  324:       *  by @a __x (unless the allocator traits dictate a different object).
>         -:  325:       */
>     #####:  326:      vector(const vector& __x)
>         -:  327:      : _Base(__x.size(),
>     #####:  328:	_Alloc_traits::_S_select_on_copy(__x._M_get_Tp_allocator()))
>         -:  329:      {
>     #####:  330:	this->_M_impl._M_finish =
>     #####:  331:	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
>         -:  332:				      this->_M_impl._M_start,
>     #####:  333:				      _M_get_Tp_allocator());
>     #####:  334:      }
>         -:  335:
>         -:  336:#if __cplusplus >= 201103L
>         -:  337:      /**
>         -:  338:       *  @brief  %Vector move constructor.
>         -:  339:       *  @param  __x  A %vector of identical element and allocator types.
>         -:  340:       *
>         -:  341:       *  The newly-created %vector contains the exact contents of @a __x.
>         -:  342:       *  The contents of @a __x are a valid, but unspecified %vector.
>         -:  343:       */
>         -:  344:      vector(vector&& __x) noexcept
>         -:  345:      : _Base(std::move(__x)) { }
>         -:  346:
>         -:  347:      /// Copy constructor with alternative allocator
>         -:  348:      vector(const vector& __x, const allocator_type& __a)
>         -:  349:      : _Base(__x.size(), __a)
>         -:  350:      {
>         -:  351:	this->_M_impl._M_finish =
>         -:  352:	  std::__uninitialized_copy_a(__x.begin(), __x.end(),
>         -:  353:				      this->_M_impl._M_start,
>         -:  354:				      _M_get_Tp_allocator());
>         -:  355:      }
>         -:  356:
>         -:  357:      /// Move constructor with alternative allocator
>         -:  358:      vector(vector&& __rv, const allocator_type& __m)
>         -:  359:      noexcept(_Alloc_traits::_S_always_equal())
>         -:  360:      : _Base(std::move(__rv), __m)
>         -:  361:      {
>         -:  362:	if (__rv.get_allocator() != __m)
>         -:  363:	  {
>         -:  364:	    this->_M_impl._M_finish =
>         -:  365:	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
>         -:  366:					  this->_M_impl._M_start,
>         -:  367:					  _M_get_Tp_allocator());
>         -:  368:	    __rv.clear();
>         -:  369:	  }
>         -:  370:      }
>         -:  371:
>         -:  372:      /**
>         -:  373:       *  @brief  Builds a %vector from an initializer list.
>         -:  374:       *  @param  __l  An initializer_list.
>         -:  375:       *  @param  __a  An allocator.
>         -:  376:       *
>         -:  377:       *  Create a %vector consisting of copies of the elements in the
>         -:  378:       *  initializer_list @a __l.
>         -:  379:       *
>         -:  380:       *  This will call the element type's copy constructor N times
>         -:  381:       *  (where N is @a __l.size()) and do no memory reallocation.
>         -:  382:       */
>         -:  383:      vector(initializer_list<value_type> __l,
>         -:  384:	     const allocator_type& __a = allocator_type())
>         -:  385:      : _Base(__a)
>         -:  386:      {
>         -:  387:	_M_range_initialize(__l.begin(), __l.end(),
>         -:  388:			    random_access_iterator_tag());
>         -:  389:      }
>         -:  390:#endif
>         -:  391:
>         -:  392:      /**
>         -:  393:       *  @brief  Builds a %vector from a range.
>         -:  394:       *  @param  __first  An input iterator.
>         -:  395:       *  @param  __last  An input iterator.
>         -:  396:       *  @param  __a  An allocator.
>         -:  397:       *
>         -:  398:       *  Create a %vector consisting of copies of the elements from
>         -:  399:       *  [first,last).
>         -:  400:       *
>         -:  401:       *  If the iterators are forward, bidirectional, or
>         -:  402:       *  random-access, then this will call the elements' copy
>         -:  403:       *  constructor N times (where N is distance(first,last)) and do
>         -:  404:       *  no memory reallocation.  But if only input iterators are
>         -:  405:       *  used, then this will do at most 2N calls to the copy
>         -:  406:       *  constructor, and logN memory reallocations.
>         -:  407:       */
>         -:  408:#if __cplusplus >= 201103L
>         -:  409:      template<typename _InputIterator,
>         -:  410:	       typename = std::_RequireInputIter<_InputIterator>>
>         -:  411:	vector(_InputIterator __first, _InputIterator __last,
>         -:  412:	       const allocator_type& __a = allocator_type())
>         -:  413:	: _Base(__a)
>         -:  414:	{ _M_initialize_dispatch(__first, __last, __false_type()); }
>         -:  415:#else
>         -:  416:      template<typename _InputIterator>
>         -:  417:	vector(_InputIterator __first, _InputIterator __last,
>         -:  418:	       const allocator_type& __a = allocator_type())
>         -:  419:	: _Base(__a)
>         -:  420:	{
>         -:  421:	  // Check whether it's an integral type.  If so, it's not an iterator.
>         -:  422:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
>         -:  423:	  _M_initialize_dispatch(__first, __last, _Integral());
>         -:  424:	}
>         -:  425:#endif
>         -:  426:
>         -:  427:      /**
>         -:  428:       *  The dtor only erases the elements, and note that if the
>         -:  429:       *  elements themselves are pointers, the pointed-to memory is
>         -:  430:       *  not touched in any way.  Managing the pointer is the user's
>         -:  431:       *  responsibility.
>         -:  432:       */
>     #####:  433:      ~vector() _GLIBCXX_NOEXCEPT
>     #####:  434:      { std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
>     #####:  435:		      _M_get_Tp_allocator()); }
>         -:  436:
>         -:  437:      /**
>         -:  438:       *  @brief  %Vector assignment operator.
>         -:  439:       *  @param  __x  A %vector of identical element and allocator types.
>         -:  440:       *
>         -:  441:       *  All the elements of @a __x are copied, but any unused capacity in
>         -:  442:       *  @a __x will not be copied.
>         -:  443:       *
>         -:  444:       *  Whether the allocator is copied depends on the allocator traits.
>         -:  445:       */
>         -:  446:      vector&
>         -:  447:      operator=(const vector& __x);
>         -:  448:
>         -:  449:#if __cplusplus >= 201103L
>         -:  450:      /**
>         -:  451:       *  @brief  %Vector move assignment operator.
>         -:  452:       *  @param  __x  A %vector of identical element and allocator types.
>         -:  453:       *
>         -:  454:       *  The contents of @a __x are moved into this %vector (without copying,
>         -:  455:       *  if the allocators permit it).
>         -:  456:       *  Afterwards @a __x is a valid, but unspecified %vector.
>         -:  457:       *
>         -:  458:       *  Whether the allocator is moved depends on the allocator traits.
>         -:  459:       */
>         -:  460:      vector&
>         -:  461:      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
>         -:  462:      {
>         -:  463:	constexpr bool __move_storage =
>         -:  464:	  _Alloc_traits::_S_propagate_on_move_assign()
>         -:  465:	  || _Alloc_traits::_S_always_equal();
>         -:  466:	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
>         -:  467:	return *this;
>         -:  468:      }
>         -:  469:
>         -:  470:      /**
>         -:  471:       *  @brief  %Vector list assignment operator.
>         -:  472:       *  @param  __l  An initializer_list.
>         -:  473:       *
>         -:  474:       *  This function fills a %vector with copies of the elements in the
>         -:  475:       *  initializer list @a __l.
>         -:  476:       *
>         -:  477:       *  Note that the assignment completely changes the %vector and
>         -:  478:       *  that the resulting %vector's size is the same as the number
>         -:  479:       *  of elements assigned.
>         -:  480:       */
>         -:  481:      vector&
>         -:  482:      operator=(initializer_list<value_type> __l)
>         -:  483:      {
>         -:  484:	this->_M_assign_aux(__l.begin(), __l.end(),
>         -:  485:			    random_access_iterator_tag());
>         -:  486:	return *this;
935,949c490,504
<         -:  488:
<         -:  489:      /// Move constructor with alternative allocator
<         -:  490:      vector(vector&& __rv, const allocator_type& __m)
<         -:  491:      noexcept(_Alloc_traits::_S_always_equal())
<         -:  492:      : _Base(std::move(__rv), __m)
<         -:  493:      {
<         -:  494:	if (__rv.get_allocator() != __m)
<         -:  495:	  {
<         -:  496:	    this->_M_impl._M_finish =
<         -:  497:	      std::__uninitialized_move_a(__rv.begin(), __rv.end(),
<         -:  498:					  this->_M_impl._M_start,
<         -:  499:					  _M_get_Tp_allocator());
<         -:  500:	    __rv.clear();
<         -:  501:	  }
<         -:  502:      }
---
>         -:  488:#endif
>         -:  489:
>         -:  490:      /**
>         -:  491:       *  @brief  Assigns a given value to a %vector.
>         -:  492:       *  @param  __n  Number of elements to be assigned.
>         -:  493:       *  @param  __val  Value to be assigned.
>         -:  494:       *
>         -:  495:       *  This function fills a %vector with @a __n copies of the given
>         -:  496:       *  value.  Note that the assignment completely changes the
>         -:  497:       *  %vector and that the resulting %vector's size is the same as
>         -:  498:       *  the number of elements assigned.
>         -:  499:       */
>         -:  500:      void
>         -:  501:      assign(size_type __n, const value_type& __val)
>         -:  502:      { _M_fill_assign(__n, __val); }
952,954c507,509
<         -:  505:       *  @brief  Builds a %vector from an initializer list.
<         -:  506:       *  @param  __l  An initializer_list.
<         -:  507:       *  @param  __a  An allocator.
---
>         -:  505:       *  @brief  Assigns a range to a %vector.
>         -:  506:       *  @param  __first  An input iterator.
>         -:  507:       *  @param  __last   An input iterator.
956,957c511,512
<         -:  509:       *  Create a %vector consisting of copies of the elements in the
<         -:  510:       *  initializer_list @a __l.
---
>         -:  509:       *  This function fills a %vector with copies of the elements in the
>         -:  510:       *  range [__first,__last).
959,1102c514,584
<         -:  512:       *  This will call the element type's copy constructor N times
<         -:  513:       *  (where N is @a __l.size()) and do no memory reallocation.
<         -:  514:       */
<         -:  515:      vector(initializer_list<value_type> __l,
<         -:  516:	     const allocator_type& __a = allocator_type())
<         -:  517:      : _Base(__a)
<         -:  518:      {
<         -:  519:	_M_range_initialize(__l.begin(), __l.end(),
<         -:  520:			    random_access_iterator_tag());
<         -:  521:      }
<         -:  522:#endif
<         -:  523:
<         -:  524:      /**
<         -:  525:       *  @brief  Builds a %vector from a range.
<         -:  526:       *  @param  __first  An input iterator.
<         -:  527:       *  @param  __last  An input iterator.
<         -:  528:       *  @param  __a  An allocator.
<         -:  529:       *
<         -:  530:       *  Create a %vector consisting of copies of the elements from
<         -:  531:       *  [first,last).
<         -:  532:       *
<         -:  533:       *  If the iterators are forward, bidirectional, or
<         -:  534:       *  random-access, then this will call the elements' copy
<         -:  535:       *  constructor N times (where N is distance(first,last)) and do
<         -:  536:       *  no memory reallocation.  But if only input iterators are
<         -:  537:       *  used, then this will do at most 2N calls to the copy
<         -:  538:       *  constructor, and logN memory reallocations.
<         -:  539:       */
<         -:  540:#if __cplusplus >= 201103L
<         -:  541:      template<typename _InputIterator,
<         -:  542:	       typename = std::_RequireInputIter<_InputIterator>>
<         -:  543:	vector(_InputIterator __first, _InputIterator __last,
<         -:  544:	       const allocator_type& __a = allocator_type())
<         -:  545:	: _Base(__a)
<         -:  546:	{ _M_initialize_dispatch(__first, __last, __false_type()); }
<         -:  547:#else
<         -:  548:      template<typename _InputIterator>
<         -:  549:	vector(_InputIterator __first, _InputIterator __last,
<         -:  550:	       const allocator_type& __a = allocator_type())
<         -:  551:	: _Base(__a)
<         -:  552:	{
<         -:  553:	  // Check whether it's an integral type.  If so, it's not an iterator.
<         -:  554:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
<         -:  555:	  _M_initialize_dispatch(__first, __last, _Integral());
<         -:  556:	}
<         -:  557:#endif
<         -:  558:
<         -:  559:      /**
<         -:  560:       *  The dtor only erases the elements, and note that if the
<         -:  561:       *  elements themselves are pointers, the pointed-to memory is
<         -:  562:       *  not touched in any way.  Managing the pointer is the user's
<         -:  563:       *  responsibility.
<         -:  564:       */
<      390*:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<      390*:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<      390*:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<      390*:  570:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EED2Ev:
<         6:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<         6:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         6:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<         6:  570:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EED2Ev:
<         3:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<         3:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<         3:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<         3:  570:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EED2Ev:
<        42:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<        42:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<        42:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<        42:  570:      }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EED2Ev:
<        32:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<        32:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<        32:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<        32:  570:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EED2Ev:
<       208:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<       208:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<       208:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<       208:  570:      }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EED2Ev:
<     #####:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<     #####:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<     #####:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<     #####:  570:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EED2Ev:
<     #####:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<     #####:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<     #####:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<     #####:  570:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS14SequenceNumberES3_ESaIS4_EED2Ev:
<     #####:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<     #####:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<     #####:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<     #####:  570:      }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EED2Ev:
<        99:  565:      ~vector() _GLIBCXX_NOEXCEPT
<         -:  566:      {
<        99:  567:	std::_Destroy(this->_M_impl._M_start, this->_M_impl._M_finish,
<        99:  568:		      _M_get_Tp_allocator());
<         -:  569:	_GLIBCXX_ASAN_ANNOTATE_BEFORE_DEALLOC;
<        99:  570:      }
< ------------------
<         -:  571:
<         -:  572:      /**
<         -:  573:       *  @brief  %Vector assignment operator.
<         -:  574:       *  @param  __x  A %vector of identical element and allocator types.
<         -:  575:       *
<         -:  576:       *  All the elements of @a __x are copied, but any unused capacity in
<         -:  577:       *  @a __x will not be copied.
<         -:  578:       *
<         -:  579:       *  Whether the allocator is copied depends on the allocator traits.
<         -:  580:       */
<         -:  581:      vector&
<         -:  582:      operator=(const vector& __x);
---
>         -:  512:       *  Note that the assignment completely changes the %vector and
>         -:  513:       *  that the resulting %vector's size is the same as the number
>         -:  514:       *  of elements assigned.
>         -:  515:       */
>         -:  516:#if __cplusplus >= 201103L
>         -:  517:      template<typename _InputIterator,
>         -:  518:	       typename = std::_RequireInputIter<_InputIterator>>
>         -:  519:	void
>         -:  520:	assign(_InputIterator __first, _InputIterator __last)
>         -:  521:	{ _M_assign_dispatch(__first, __last, __false_type()); }
>         -:  522:#else
>         -:  523:      template<typename _InputIterator>
>         -:  524:	void
>         -:  525:	assign(_InputIterator __first, _InputIterator __last)
>         -:  526:	{
>         -:  527:	  // Check whether it's an integral type.  If so, it's not an iterator.
>         -:  528:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
>         -:  529:	  _M_assign_dispatch(__first, __last, _Integral());
>         -:  530:	}
>         -:  531:#endif
>         -:  532:
>         -:  533:#if __cplusplus >= 201103L
>         -:  534:      /**
>         -:  535:       *  @brief  Assigns an initializer list to a %vector.
>         -:  536:       *  @param  __l  An initializer_list.
>         -:  537:       *
>         -:  538:       *  This function fills a %vector with copies of the elements in the
>         -:  539:       *  initializer list @a __l.
>         -:  540:       *
>         -:  541:       *  Note that the assignment completely changes the %vector and
>         -:  542:       *  that the resulting %vector's size is the same as the number
>         -:  543:       *  of elements assigned.
>         -:  544:       */
>         -:  545:      void
>         -:  546:      assign(initializer_list<value_type> __l)
>         -:  547:      {
>         -:  548:	this->_M_assign_aux(__l.begin(), __l.end(),
>         -:  549:			    random_access_iterator_tag());
>         -:  550:      }
>         -:  551:#endif
>         -:  552:
>         -:  553:      /// Get a copy of the memory allocation object.
>         -:  554:      using _Base::get_allocator;
>         -:  555:
>         -:  556:      // iterators
>         -:  557:      /**
>         -:  558:       *  Returns a read/write iterator that points to the first
>         -:  559:       *  element in the %vector.  Iteration is done in ordinary
>         -:  560:       *  element order.
>         -:  561:       */
>         -:  562:      iterator
>     #####:  563:      begin() _GLIBCXX_NOEXCEPT
>     #####:  564:      { return iterator(this->_M_impl._M_start); }
>         -:  565:
>         -:  566:      /**
>         -:  567:       *  Returns a read-only (constant) iterator that points to the
>         -:  568:       *  first element in the %vector.  Iteration is done in ordinary
>         -:  569:       *  element order.
>         -:  570:       */
>         -:  571:      const_iterator
>     #####:  572:      begin() const _GLIBCXX_NOEXCEPT
>     #####:  573:      { return const_iterator(this->_M_impl._M_start); }
>         -:  574:
>         -:  575:      /**
>         -:  576:       *  Returns a read/write iterator that points one past the last
>         -:  577:       *  element in the %vector.  Iteration is done in ordinary
>         -:  578:       *  element order.
>         -:  579:       */
>         -:  580:      iterator
>     #####:  581:      end() _GLIBCXX_NOEXCEPT
>     #####:  582:      { return iterator(this->_M_impl._M_finish); }
1104,1134c586,616
<         -:  584:#if __cplusplus >= 201103L
<         -:  585:      /**
<         -:  586:       *  @brief  %Vector move assignment operator.
<         -:  587:       *  @param  __x  A %vector of identical element and allocator types.
<         -:  588:       *
<         -:  589:       *  The contents of @a __x are moved into this %vector (without copying,
<         -:  590:       *  if the allocators permit it).
<         -:  591:       *  Afterwards @a __x is a valid, but unspecified %vector.
<         -:  592:       *
<         -:  593:       *  Whether the allocator is moved depends on the allocator traits.
<         -:  594:       */
<         -:  595:      vector&
<         -:  596:      operator=(vector&& __x) noexcept(_Alloc_traits::_S_nothrow_move())
<         -:  597:      {
<         -:  598:	constexpr bool __move_storage =
<         -:  599:	  _Alloc_traits::_S_propagate_on_move_assign()
<         -:  600:	  || _Alloc_traits::_S_always_equal();
<         -:  601:	_M_move_assign(std::move(__x), __bool_constant<__move_storage>());
<         -:  602:	return *this;
<         -:  603:      }
<         -:  604:
<         -:  605:      /**
<         -:  606:       *  @brief  %Vector list assignment operator.
<         -:  607:       *  @param  __l  An initializer_list.
<         -:  608:       *
<         -:  609:       *  This function fills a %vector with copies of the elements in the
<         -:  610:       *  initializer list @a __l.
<         -:  611:       *
<         -:  612:       *  Note that the assignment completely changes the %vector and
<         -:  613:       *  that the resulting %vector's size is the same as the number
<         -:  614:       *  of elements assigned.
---
>         -:  584:      /**
>         -:  585:       *  Returns a read-only (constant) iterator that points one past
>         -:  586:       *  the last element in the %vector.  Iteration is done in
>         -:  587:       *  ordinary element order.
>         -:  588:       */
>         -:  589:      const_iterator
>     #####:  590:      end() const _GLIBCXX_NOEXCEPT
>     #####:  591:      { return const_iterator(this->_M_impl._M_finish); }
>         -:  592:
>         -:  593:      /**
>         -:  594:       *  Returns a read/write reverse iterator that points to the
>         -:  595:       *  last element in the %vector.  Iteration is done in reverse
>         -:  596:       *  element order.
>         -:  597:       */
>         -:  598:      reverse_iterator
>         -:  599:      rbegin() _GLIBCXX_NOEXCEPT
>         -:  600:      { return reverse_iterator(end()); }
>         -:  601:
>         -:  602:      /**
>         -:  603:       *  Returns a read-only (constant) reverse iterator that points
>         -:  604:       *  to the last element in the %vector.  Iteration is done in
>         -:  605:       *  reverse element order.
>         -:  606:       */
>         -:  607:      const_reverse_iterator
>         -:  608:      rbegin() const _GLIBCXX_NOEXCEPT
>         -:  609:      { return const_reverse_iterator(end()); }
>         -:  610:
>         -:  611:      /**
>         -:  612:       *  Returns a read/write reverse iterator that points to one
>         -:  613:       *  before the first element in the %vector.  Iteration is done
>         -:  614:       *  in reverse element order.
1136,1153c618,635
<         -:  616:      vector&
<         -:  617:      operator=(initializer_list<value_type> __l)
<         -:  618:      {
<         -:  619:	this->_M_assign_aux(__l.begin(), __l.end(),
<         -:  620:			    random_access_iterator_tag());
<         -:  621:	return *this;
<         -:  622:      }
<         -:  623:#endif
<         -:  624:
<         -:  625:      /**
<         -:  626:       *  @brief  Assigns a given value to a %vector.
<         -:  627:       *  @param  __n  Number of elements to be assigned.
<         -:  628:       *  @param  __val  Value to be assigned.
<         -:  629:       *
<         -:  630:       *  This function fills a %vector with @a __n copies of the given
<         -:  631:       *  value.  Note that the assignment completely changes the
<         -:  632:       *  %vector and that the resulting %vector's size is the same as
<         -:  633:       *  the number of elements assigned.
---
>         -:  616:      reverse_iterator
>         -:  617:      rend() _GLIBCXX_NOEXCEPT
>         -:  618:      { return reverse_iterator(begin()); }
>         -:  619:
>         -:  620:      /**
>         -:  621:       *  Returns a read-only (constant) reverse iterator that points
>         -:  622:       *  to one before the first element in the %vector.  Iteration
>         -:  623:       *  is done in reverse element order.
>         -:  624:       */
>         -:  625:      const_reverse_iterator
>         -:  626:      rend() const _GLIBCXX_NOEXCEPT
>         -:  627:      { return const_reverse_iterator(begin()); }
>         -:  628:
>         -:  629:#if __cplusplus >= 201103L
>         -:  630:      /**
>         -:  631:       *  Returns a read-only (constant) iterator that points to the
>         -:  632:       *  first element in the %vector.  Iteration is done in ordinary
>         -:  633:       *  element order.
1155,1157c637,639
<         -:  635:      void
<         -:  636:      assign(size_type __n, const value_type& __val)
<         -:  637:      { _M_fill_assign(__n, __val); }
---
>         -:  635:      const_iterator
>         -:  636:      cbegin() const noexcept
>         -:  637:      { return const_iterator(this->_M_impl._M_start); }
1160,1450c642,779
<         -:  640:       *  @brief  Assigns a range to a %vector.
<         -:  641:       *  @param  __first  An input iterator.
<         -:  642:       *  @param  __last   An input iterator.
<         -:  643:       *
<         -:  644:       *  This function fills a %vector with copies of the elements in the
<         -:  645:       *  range [__first,__last).
<         -:  646:       *
<         -:  647:       *  Note that the assignment completely changes the %vector and
<         -:  648:       *  that the resulting %vector's size is the same as the number
<         -:  649:       *  of elements assigned.
<         -:  650:       */
<         -:  651:#if __cplusplus >= 201103L
<         -:  652:      template<typename _InputIterator,
<         -:  653:	       typename = std::_RequireInputIter<_InputIterator>>
<         -:  654:	void
<         -:  655:	assign(_InputIterator __first, _InputIterator __last)
<         -:  656:	{ _M_assign_dispatch(__first, __last, __false_type()); }
<         -:  657:#else
<         -:  658:      template<typename _InputIterator>
<         -:  659:	void
<         -:  660:	assign(_InputIterator __first, _InputIterator __last)
<         -:  661:	{
<         -:  662:	  // Check whether it's an integral type.  If so, it's not an iterator.
<         -:  663:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
<         -:  664:	  _M_assign_dispatch(__first, __last, _Integral());
<         -:  665:	}
<         -:  666:#endif
<         -:  667:
<         -:  668:#if __cplusplus >= 201103L
<         -:  669:      /**
<         -:  670:       *  @brief  Assigns an initializer list to a %vector.
<         -:  671:       *  @param  __l  An initializer_list.
<         -:  672:       *
<         -:  673:       *  This function fills a %vector with copies of the elements in the
<         -:  674:       *  initializer list @a __l.
<         -:  675:       *
<         -:  676:       *  Note that the assignment completely changes the %vector and
<         -:  677:       *  that the resulting %vector's size is the same as the number
<         -:  678:       *  of elements assigned.
<         -:  679:       */
<         -:  680:      void
<         -:  681:      assign(initializer_list<value_type> __l)
<         -:  682:      {
<         -:  683:	this->_M_assign_aux(__l.begin(), __l.end(),
<         -:  684:			    random_access_iterator_tag());
<         -:  685:      }
<         -:  686:#endif
<         -:  687:
<         -:  688:      /// Get a copy of the memory allocation object.
<         -:  689:      using _Base::get_allocator;
<         -:  690:
<         -:  691:      // iterators
<         -:  692:      /**
<         -:  693:       *  Returns a read/write iterator that points to the first
<         -:  694:       *  element in the %vector.  Iteration is done in ordinary
<         -:  695:       *  element order.
<         -:  696:       */
<         -:  697:      iterator
<      453*:  698:      begin() _GLIBCXX_NOEXCEPT
<      453*:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE5beginEv:
<         4:  698:      begin() _GLIBCXX_NOEXCEPT
<         4:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorI13ACE_INET_AddrSaIS0_EE5beginEv:
<     #####:  698:      begin() _GLIBCXX_NOEXCEPT
<     #####:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE5beginEv:
<         9:  698:      begin() _GLIBCXX_NOEXCEPT
<         9:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE5beginEv:
<        42:  698:      begin() _GLIBCXX_NOEXCEPT
<        42:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE5beginEv:
<        32:  698:      begin() _GLIBCXX_NOEXCEPT
<        32:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5beginEv:
<     #####:  698:      begin() _GLIBCXX_NOEXCEPT
<     #####:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5beginEv:
<       356:  698:      begin() _GLIBCXX_NOEXCEPT
<       356:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE5beginEv:
<     #####:  698:      begin() _GLIBCXX_NOEXCEPT
<     #####:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE5beginEv:
<     #####:  698:      begin() _GLIBCXX_NOEXCEPT
<     #####:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE5beginEv:
<        10:  698:      begin() _GLIBCXX_NOEXCEPT
<        10:  699:      { return iterator(this->_M_impl._M_start); }
< ------------------
<         -:  700:
<         -:  701:      /**
<         -:  702:       *  Returns a read-only (constant) iterator that points to the
<         -:  703:       *  first element in the %vector.  Iteration is done in ordinary
<         -:  704:       *  element order.
<         -:  705:       */
<         -:  706:      const_iterator
<       57*:  707:      begin() const _GLIBCXX_NOEXCEPT
<       57*:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE5beginEv:
<        14:  707:      begin() const _GLIBCXX_NOEXCEPT
<        14:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorI13ACE_INET_AddrSaIS0_EE5beginEv:
<     #####:  707:      begin() const _GLIBCXX_NOEXCEPT
<     #####:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE5beginEv:
<        41:  707:      begin() const _GLIBCXX_NOEXCEPT
<        41:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5beginEv:
<     #####:  707:      begin() const _GLIBCXX_NOEXCEPT
<     #####:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5beginEv:
<     #####:  707:      begin() const _GLIBCXX_NOEXCEPT
<     #####:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5beginEv:
<         2:  707:      begin() const _GLIBCXX_NOEXCEPT
<         2:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE5beginEv:
<     #####:  707:      begin() const _GLIBCXX_NOEXCEPT
<     #####:  708:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
<         -:  709:
<         -:  710:      /**
<         -:  711:       *  Returns a read/write iterator that points one past the last
<         -:  712:       *  element in the %vector.  Iteration is done in ordinary
<         -:  713:       *  element order.
<         -:  714:       */
<         -:  715:      iterator
<      203*:  716:      end() _GLIBCXX_NOEXCEPT
<      203*:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE3endEv:
<         6:  716:      end() _GLIBCXX_NOEXCEPT
<         6:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorI13ACE_INET_AddrSaIS0_EE3endEv:
<     #####:  716:      end() _GLIBCXX_NOEXCEPT
<     #####:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE3endEv:
<         9:  716:      end() _GLIBCXX_NOEXCEPT
<         9:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE3endEv:
<        42:  716:      end() _GLIBCXX_NOEXCEPT
<        42:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE3endEv:
<        41:  716:      end() _GLIBCXX_NOEXCEPT
<        41:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE3endEv:
<     #####:  716:      end() _GLIBCXX_NOEXCEPT
<     #####:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE3endEv:
<        89:  716:      end() _GLIBCXX_NOEXCEPT
<        89:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE3endEv:
<     #####:  716:      end() _GLIBCXX_NOEXCEPT
<     #####:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE3endEv:
<     #####:  716:      end() _GLIBCXX_NOEXCEPT
<     #####:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE3endEv:
<        16:  716:      end() _GLIBCXX_NOEXCEPT
<        16:  717:      { return iterator(this->_M_impl._M_finish); }
< ------------------
<         -:  718:
<         -:  719:      /**
<         -:  720:       *  Returns a read-only (constant) iterator that points one past
<         -:  721:       *  the last element in the %vector.  Iteration is done in
<         -:  722:       *  ordinary element order.
<         -:  723:       */
<         -:  724:      const_iterator
<       57*:  725:      end() const _GLIBCXX_NOEXCEPT
<       57*:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE3endEv:
<        14:  725:      end() const _GLIBCXX_NOEXCEPT
<        14:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorI13ACE_INET_AddrSaIS0_EE3endEv:
<     #####:  725:      end() const _GLIBCXX_NOEXCEPT
<     #####:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE3endEv:
<        41:  725:      end() const _GLIBCXX_NOEXCEPT
<        41:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE3endEv:
<     #####:  725:      end() const _GLIBCXX_NOEXCEPT
<     #####:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE3endEv:
<     #####:  725:      end() const _GLIBCXX_NOEXCEPT
<     #####:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE3endEv:
<         2:  725:      end() const _GLIBCXX_NOEXCEPT
<         2:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
< _ZNKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE3endEv:
<     #####:  725:      end() const _GLIBCXX_NOEXCEPT
<     #####:  726:      { return const_iterator(this->_M_impl._M_finish); }
< ------------------
<         -:  727:
<         -:  728:      /**
<         -:  729:       *  Returns a read/write reverse iterator that points to the
<         -:  730:       *  last element in the %vector.  Iteration is done in reverse
<         -:  731:       *  element order.
<         -:  732:       */
<         -:  733:      reverse_iterator
<         -:  734:      rbegin() _GLIBCXX_NOEXCEPT
<         -:  735:      { return reverse_iterator(end()); }
<         -:  736:
<         -:  737:      /**
<         -:  738:       *  Returns a read-only (constant) reverse iterator that points
<         -:  739:       *  to the last element in the %vector.  Iteration is done in
<         -:  740:       *  reverse element order.
<         -:  741:       */
<         -:  742:      const_reverse_iterator
<         -:  743:      rbegin() const _GLIBCXX_NOEXCEPT
<         -:  744:      { return const_reverse_iterator(end()); }
<         -:  745:
<         -:  746:      /**
<         -:  747:       *  Returns a read/write reverse iterator that points to one
<         -:  748:       *  before the first element in the %vector.  Iteration is done
<         -:  749:       *  in reverse element order.
<         -:  750:       */
<         -:  751:      reverse_iterator
<         -:  752:      rend() _GLIBCXX_NOEXCEPT
<         -:  753:      { return reverse_iterator(begin()); }
<         -:  754:
<         -:  755:      /**
<         -:  756:       *  Returns a read-only (constant) reverse iterator that points
<         -:  757:       *  to one before the first element in the %vector.  Iteration
<         -:  758:       *  is done in reverse element order.
<         -:  759:       */
<         -:  760:      const_reverse_iterator
<         -:  761:      rend() const _GLIBCXX_NOEXCEPT
<         -:  762:      { return const_reverse_iterator(begin()); }
<         -:  763:
<         -:  764:#if __cplusplus >= 201103L
<         -:  765:      /**
<         -:  766:       *  Returns a read-only (constant) iterator that points to the
<         -:  767:       *  first element in the %vector.  Iteration is done in ordinary
<         -:  768:       *  element order.
<         -:  769:       */
<         -:  770:      const_iterator
<        94:  771:      cbegin() const noexcept
<        94:  772:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE6cbeginEv:
<         1:  771:      cbegin() const noexcept
<         1:  772:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE6cbeginEv:
<        89:  771:      cbegin() const noexcept
<        89:  772:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE6cbeginEv:
<         4:  771:      cbegin() const noexcept
<         4:  772:      { return const_iterator(this->_M_impl._M_start); }
< ------------------
<         -:  773:
<         -:  774:      /**
<         -:  775:       *  Returns a read-only (constant) iterator that points one past
<         -:  776:       *  the last element in the %vector.  Iteration is done in
<         -:  777:       *  ordinary element order.
---
>         -:  640:       *  Returns a read-only (constant) iterator that points one past
>         -:  641:       *  the last element in the %vector.  Iteration is done in
>         -:  642:       *  ordinary element order.
>         -:  643:       */
>         -:  644:      const_iterator
>         -:  645:      cend() const noexcept
>         -:  646:      { return const_iterator(this->_M_impl._M_finish); }
>         -:  647:
>         -:  648:      /**
>         -:  649:       *  Returns a read-only (constant) reverse iterator that points
>         -:  650:       *  to the last element in the %vector.  Iteration is done in
>         -:  651:       *  reverse element order.
>         -:  652:       */
>         -:  653:      const_reverse_iterator
>         -:  654:      crbegin() const noexcept
>         -:  655:      { return const_reverse_iterator(end()); }
>         -:  656:
>         -:  657:      /**
>         -:  658:       *  Returns a read-only (constant) reverse iterator that points
>         -:  659:       *  to one before the first element in the %vector.  Iteration
>         -:  660:       *  is done in reverse element order.
>         -:  661:       */
>         -:  662:      const_reverse_iterator
>         -:  663:      crend() const noexcept
>         -:  664:      { return const_reverse_iterator(begin()); }
>         -:  665:#endif
>         -:  666:
>         -:  667:      // [23.2.4.2] capacity
>         -:  668:      /**  Returns the number of elements in the %vector.  */
>         -:  669:      size_type
>     #####:  670:      size() const _GLIBCXX_NOEXCEPT
>     #####:  671:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
>         -:  672:
>         -:  673:      /**  Returns the size() of the largest possible %vector.  */
>         -:  674:      size_type
>     #####:  675:      max_size() const _GLIBCXX_NOEXCEPT
>     #####:  676:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
>         -:  677:
>         -:  678:#if __cplusplus >= 201103L
>         -:  679:      /**
>         -:  680:       *  @brief  Resizes the %vector to the specified number of elements.
>         -:  681:       *  @param  __new_size  Number of elements the %vector should contain.
>         -:  682:       *
>         -:  683:       *  This function will %resize the %vector to the specified
>         -:  684:       *  number of elements.  If the number is smaller than the
>         -:  685:       *  %vector's current size the %vector is truncated, otherwise
>         -:  686:       *  default constructed elements are appended.
>         -:  687:       */
>         -:  688:      void
>         -:  689:      resize(size_type __new_size)
>         -:  690:      {
>         -:  691:	if (__new_size > size())
>         -:  692:	  _M_default_append(__new_size - size());
>         -:  693:	else if (__new_size < size())
>         -:  694:	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
>         -:  695:      }
>         -:  696:
>         -:  697:      /**
>         -:  698:       *  @brief  Resizes the %vector to the specified number of elements.
>         -:  699:       *  @param  __new_size  Number of elements the %vector should contain.
>         -:  700:       *  @param  __x  Data with which new elements should be populated.
>         -:  701:       *
>         -:  702:       *  This function will %resize the %vector to the specified
>         -:  703:       *  number of elements.  If the number is smaller than the
>         -:  704:       *  %vector's current size the %vector is truncated, otherwise
>         -:  705:       *  the %vector is extended and new elements are populated with
>         -:  706:       *  given data.
>         -:  707:       */
>         -:  708:      void
>         -:  709:      resize(size_type __new_size, const value_type& __x)
>         -:  710:      {
>         -:  711:	if (__new_size > size())
>         -:  712:	  _M_fill_insert(end(), __new_size - size(), __x);
>         -:  713:	else if (__new_size < size())
>         -:  714:	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
>         -:  715:      }
>         -:  716:#else
>         -:  717:      /**
>         -:  718:       *  @brief  Resizes the %vector to the specified number of elements.
>         -:  719:       *  @param  __new_size  Number of elements the %vector should contain.
>         -:  720:       *  @param  __x  Data with which new elements should be populated.
>         -:  721:       *
>         -:  722:       *  This function will %resize the %vector to the specified
>         -:  723:       *  number of elements.  If the number is smaller than the
>         -:  724:       *  %vector's current size the %vector is truncated, otherwise
>         -:  725:       *  the %vector is extended and new elements are populated with
>         -:  726:       *  given data.
>         -:  727:       */
>         -:  728:      void
>         -:  729:      resize(size_type __new_size, value_type __x = value_type())
>         -:  730:      {
>         -:  731:	if (__new_size > size())
>         -:  732:	  _M_fill_insert(end(), __new_size - size(), __x);
>         -:  733:	else if (__new_size < size())
>         -:  734:	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
>         -:  735:      }
>         -:  736:#endif
>         -:  737:
>         -:  738:#if __cplusplus >= 201103L
>         -:  739:      /**  A non-binding request to reduce capacity() to size().  */
>         -:  740:      void
>         -:  741:      shrink_to_fit()
>         -:  742:      { _M_shrink_to_fit(); }
>         -:  743:#endif
>         -:  744:
>         -:  745:      /**
>         -:  746:       *  Returns the total number of elements that the %vector can
>         -:  747:       *  hold before needing to allocate more memory.
>         -:  748:       */
>         -:  749:      size_type
>         -:  750:      capacity() const _GLIBCXX_NOEXCEPT
>         -:  751:      { return size_type(this->_M_impl._M_end_of_storage
>         -:  752:			 - this->_M_impl._M_start); }
>         -:  753:
>         -:  754:      /**
>         -:  755:       *  Returns true if the %vector is empty.  (Thus begin() would
>         -:  756:       *  equal end().)
>         -:  757:       */
>         -:  758:      bool
>         -:  759:      empty() const _GLIBCXX_NOEXCEPT
>         -:  760:      { return begin() == end(); }
>         -:  761:
>         -:  762:      /**
>         -:  763:       *  @brief  Attempt to preallocate enough memory for specified number of
>         -:  764:       *          elements.
>         -:  765:       *  @param  __n  Number of elements required.
>         -:  766:       *  @throw  std::length_error  If @a n exceeds @c max_size().
>         -:  767:       *
>         -:  768:       *  This function attempts to reserve enough memory for the
>         -:  769:       *  %vector to hold the specified number of elements.  If the
>         -:  770:       *  number requested is more than max_size(), length_error is
>         -:  771:       *  thrown.
>         -:  772:       *
>         -:  773:       *  The advantage of this function is that if optimal code is a
>         -:  774:       *  necessity and the user can determine the number of elements
>         -:  775:       *  that will be required, the user can reserve the memory in
>         -:  776:       *  %advance, and thus prevent a possible reallocation of memory
>         -:  777:       *  and copying of %vector data.
1452,1455c781,784
<         -:  779:      const_iterator
<         -:  780:      cend() const noexcept
<         -:  781:      { return const_iterator(this->_M_impl._M_finish); }
<         -:  782:
---
>         -:  779:      void
>         -:  780:      reserve(size_type __n);
>         -:  781:
>         -:  782:      // element access
1457,1594c786,833
<         -:  784:       *  Returns a read-only (constant) reverse iterator that points
<         -:  785:       *  to the last element in the %vector.  Iteration is done in
<         -:  786:       *  reverse element order.
<         -:  787:       */
<         -:  788:      const_reverse_iterator
<         -:  789:      crbegin() const noexcept
<         -:  790:      { return const_reverse_iterator(end()); }
<         -:  791:
<         -:  792:      /**
<         -:  793:       *  Returns a read-only (constant) reverse iterator that points
<         -:  794:       *  to one before the first element in the %vector.  Iteration
<         -:  795:       *  is done in reverse element order.
<         -:  796:       */
<         -:  797:      const_reverse_iterator
<         -:  798:      crend() const noexcept
<         -:  799:      { return const_reverse_iterator(begin()); }
<         -:  800:#endif
<         -:  801:
<         -:  802:      // [23.2.4.2] capacity
<         -:  803:      /**  Returns the number of elements in the %vector.  */
<         -:  804:      size_type
<      991*:  805:      size() const _GLIBCXX_NOEXCEPT
<      991*:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE4sizeEv:
<         8:  805:      size() const _GLIBCXX_NOEXCEPT
<         8:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorI13ACE_INET_AddrSaIS0_EE4sizeEv:
<     #####:  805:      size() const _GLIBCXX_NOEXCEPT
<     #####:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE4sizeEv:
<        24:  805:      size() const _GLIBCXX_NOEXCEPT
<        24:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE4sizeEv:
<       294:  805:      size() const _GLIBCXX_NOEXCEPT
<       294:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE4sizeEv:
<     #####:  805:      size() const _GLIBCXX_NOEXCEPT
<     #####:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE4sizeEv:
<       173:  805:      size() const _GLIBCXX_NOEXCEPT
<       173:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE4sizeEv:
<     #####:  805:      size() const _GLIBCXX_NOEXCEPT
<     #####:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE4sizeEv:
<       370:  805:      size() const _GLIBCXX_NOEXCEPT
<       370:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE4sizeEv:
<     #####:  805:      size() const _GLIBCXX_NOEXCEPT
<     #####:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE4sizeEv:
<     #####:  805:      size() const _GLIBCXX_NOEXCEPT
<     #####:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS14SequenceNumberES3_ESaIS4_EE4sizeEv:
<     #####:  805:      size() const _GLIBCXX_NOEXCEPT
<     #####:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE4sizeEv:
<       122:  805:      size() const _GLIBCXX_NOEXCEPT
<       122:  806:      { return size_type(this->_M_impl._M_finish - this->_M_impl._M_start); }
< ------------------
<         -:  807:
<         -:  808:      /**  Returns the size() of the largest possible %vector.  */
<         -:  809:      size_type
<      347*:  810:      max_size() const _GLIBCXX_NOEXCEPT
<      347*:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE8max_sizeEv:
<         4:  810:      max_size() const _GLIBCXX_NOEXCEPT
<         4:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorI13ACE_INET_AddrSaIS0_EE8max_sizeEv:
<     #####:  810:      max_size() const _GLIBCXX_NOEXCEPT
<     #####:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE8max_sizeEv:
<        12:  810:      max_size() const _GLIBCXX_NOEXCEPT
<        12:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE8max_sizeEv:
<        84:  810:      max_size() const _GLIBCXX_NOEXCEPT
<        84:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE8max_sizeEv:
<        55:  810:      max_size() const _GLIBCXX_NOEXCEPT
<        55:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE8max_sizeEv:
<     #####:  810:      max_size() const _GLIBCXX_NOEXCEPT
<     #####:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE8max_sizeEv:
<       178:  810:      max_size() const _GLIBCXX_NOEXCEPT
<       178:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE8max_sizeEv:
<     #####:  810:      max_size() const _GLIBCXX_NOEXCEPT
<     #####:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE8max_sizeEv:
<     #####:  810:      max_size() const _GLIBCXX_NOEXCEPT
<     #####:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
< _ZNKSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE8max_sizeEv:
<        14:  810:      max_size() const _GLIBCXX_NOEXCEPT
<        14:  811:      { return _Alloc_traits::max_size(_M_get_Tp_allocator()); }
< ------------------
<         -:  812:
<         -:  813:#if __cplusplus >= 201103L
<         -:  814:      /**
<         -:  815:       *  @brief  Resizes the %vector to the specified number of elements.
<         -:  816:       *  @param  __new_size  Number of elements the %vector should contain.
<         -:  817:       *
<         -:  818:       *  This function will %resize the %vector to the specified
<         -:  819:       *  number of elements.  If the number is smaller than the
<         -:  820:       *  %vector's current size the %vector is truncated, otherwise
<         -:  821:       *  default constructed elements are appended.
<         -:  822:       */
<         -:  823:      void
<         -:  824:      resize(size_type __new_size)
<         -:  825:      {
<         -:  826:	if (__new_size > size())
<         -:  827:	  _M_default_append(__new_size - size());
<         -:  828:	else if (__new_size < size())
<         -:  829:	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
<         -:  830:      }
<         -:  831:
---
>         -:  784:       *  @brief  Subscript access to the data contained in the %vector.
>         -:  785:       *  @param __n The index of the element for which data should be
>         -:  786:       *  accessed.
>         -:  787:       *  @return  Read/write reference to data.
>         -:  788:       *
>         -:  789:       *  This operator allows for easy, array-style, data access.
>         -:  790:       *  Note that data access with this operator is unchecked and
>         -:  791:       *  out_of_range lookups are not defined. (For checked lookups
>         -:  792:       *  see at().)
>         -:  793:       */
>         -:  794:      reference
>         -:  795:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
>         -:  796:      {
>         -:  797:	__glibcxx_requires_subscript(__n);
>         -:  798:	return *(this->_M_impl._M_start + __n);
>         -:  799:      }
>         -:  800:
>         -:  801:      /**
>         -:  802:       *  @brief  Subscript access to the data contained in the %vector.
>         -:  803:       *  @param __n The index of the element for which data should be
>         -:  804:       *  accessed.
>         -:  805:       *  @return  Read-only (constant) reference to data.
>         -:  806:       *
>         -:  807:       *  This operator allows for easy, array-style, data access.
>         -:  808:       *  Note that data access with this operator is unchecked and
>         -:  809:       *  out_of_range lookups are not defined. (For checked lookups
>         -:  810:       *  see at().)
>         -:  811:       */
>         -:  812:      const_reference
>         -:  813:      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
>         -:  814:      {
>         -:  815:	__glibcxx_requires_subscript(__n);
>         -:  816:	return *(this->_M_impl._M_start + __n);
>         -:  817:      }
>         -:  818:
>         -:  819:    protected:
>         -:  820:      /// Safety check used only from at().
>         -:  821:      void
>         -:  822:      _M_range_check(size_type __n) const
>         -:  823:      {
>         -:  824:	if (__n >= this->size())
>         -:  825:	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
>         -:  826:				       "(which is %zu) >= this->size() "
>         -:  827:				       "(which is %zu)"),
>         -:  828:				   __n, this->size());
>         -:  829:      }
>         -:  830:
>         -:  831:    public:
1596,1604c835,843
<         -:  833:       *  @brief  Resizes the %vector to the specified number of elements.
<         -:  834:       *  @param  __new_size  Number of elements the %vector should contain.
<         -:  835:       *  @param  __x  Data with which new elements should be populated.
<         -:  836:       *
<         -:  837:       *  This function will %resize the %vector to the specified
<         -:  838:       *  number of elements.  If the number is smaller than the
<         -:  839:       *  %vector's current size the %vector is truncated, otherwise
<         -:  840:       *  the %vector is extended and new elements are populated with
<         -:  841:       *  given data.
---
>         -:  833:       *  @brief  Provides access to the data contained in the %vector.
>         -:  834:       *  @param __n The index of the element for which data should be
>         -:  835:       *  accessed.
>         -:  836:       *  @return  Read/write reference to data.
>         -:  837:       *  @throw  std::out_of_range  If @a __n is an invalid index.
>         -:  838:       *
>         -:  839:       *  This function provides for safer data access.  The parameter
>         -:  840:       *  is first checked that it is in the range of the vector.  The
>         -:  841:       *  function throws out_of_range if the check fails.
1606,1607c845,846
<         -:  843:      void
<         -:  844:      resize(size_type __new_size, const value_type& __x)
---
>         -:  843:      reference
>         -:  844:      at(size_type __n)
1609,1618c848,857
<         -:  846:	if (__new_size > size())
<         -:  847:	  _M_fill_insert(end(), __new_size - size(), __x);
<         -:  848:	else if (__new_size < size())
<         -:  849:	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
<         -:  850:      }
<         -:  851:#else
<         -:  852:      /**
<         -:  853:       *  @brief  Resizes the %vector to the specified number of elements.
<         -:  854:       *  @param  __new_size  Number of elements the %vector should contain.
<         -:  855:       *  @param  __x  Data with which new elements should be populated.
---
>         -:  846:	_M_range_check(__n);
>         -:  847:	return (*this)[__n];
>         -:  848:      }
>         -:  849:
>         -:  850:      /**
>         -:  851:       *  @brief  Provides access to the data contained in the %vector.
>         -:  852:       *  @param __n The index of the element for which data should be
>         -:  853:       *  accessed.
>         -:  854:       *  @return  Read-only (constant) reference to data.
>         -:  855:       *  @throw  std::out_of_range  If @a __n is an invalid index.
1620,1855c859,1015
<         -:  857:       *  This function will %resize the %vector to the specified
<         -:  858:       *  number of elements.  If the number is smaller than the
<         -:  859:       *  %vector's current size the %vector is truncated, otherwise
<         -:  860:       *  the %vector is extended and new elements are populated with
<         -:  861:       *  given data.
<         -:  862:       */
<         -:  863:      void
<         -:  864:      resize(size_type __new_size, value_type __x = value_type())
<         -:  865:      {
<         -:  866:	if (__new_size > size())
<         -:  867:	  _M_fill_insert(end(), __new_size - size(), __x);
<         -:  868:	else if (__new_size < size())
<         -:  869:	  _M_erase_at_end(this->_M_impl._M_start + __new_size);
<         -:  870:      }
<         -:  871:#endif
<         -:  872:
<         -:  873:#if __cplusplus >= 201103L
<         -:  874:      /**  A non-binding request to reduce capacity() to size().  */
<         -:  875:      void
<         -:  876:      shrink_to_fit()
<         -:  877:      { _M_shrink_to_fit(); }
<         -:  878:#endif
<         -:  879:
<         -:  880:      /**
<         -:  881:       *  Returns the total number of elements that the %vector can
<         -:  882:       *  hold before needing to allocate more memory.
<         -:  883:       */
<         -:  884:      size_type
<        15:  885:      capacity() const _GLIBCXX_NOEXCEPT
<        15:  886:      { return size_type(this->_M_impl._M_end_of_storage
<        15:  887:			 - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE8capacityEv:
<         9:  885:      capacity() const _GLIBCXX_NOEXCEPT
<         9:  886:      { return size_type(this->_M_impl._M_end_of_storage
<         9:  887:			 - this->_M_impl._M_start); }
< ------------------
< _ZNKSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE8capacityEv:
<         6:  885:      capacity() const _GLIBCXX_NOEXCEPT
<         6:  886:      { return size_type(this->_M_impl._M_end_of_storage
<         6:  887:			 - this->_M_impl._M_start); }
< ------------------
<         -:  888:
<         -:  889:      /**
<         -:  890:       *  Returns true if the %vector is empty.  (Thus begin() would
<         -:  891:       *  equal end().)
<         -:  892:       */
<         -:  893:      bool
<       57*:  894:      empty() const _GLIBCXX_NOEXCEPT
<       57*:  895:      { return begin() == end(); }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE5emptyEv:
<        14:  894:      empty() const _GLIBCXX_NOEXCEPT
<        14:  895:      { return begin() == end(); }
< ------------------
< _ZNKSt6vectorI13ACE_INET_AddrSaIS0_EE5emptyEv:
<     #####:  894:      empty() const _GLIBCXX_NOEXCEPT
<     #####:  895:      { return begin() == end(); }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE5emptyEv:
<        41:  894:      empty() const _GLIBCXX_NOEXCEPT
<        41:  895:      { return begin() == end(); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5emptyEv:
<     #####:  894:      empty() const _GLIBCXX_NOEXCEPT
<     #####:  895:      { return begin() == end(); }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE5emptyEv:
<         2:  894:      empty() const _GLIBCXX_NOEXCEPT
<         2:  895:      { return begin() == end(); }
< ------------------
< _ZNKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE5emptyEv:
<     #####:  894:      empty() const _GLIBCXX_NOEXCEPT
<     #####:  895:      { return begin() == end(); }
< ------------------
<         -:  896:
<         -:  897:      /**
<         -:  898:       *  @brief  Attempt to preallocate enough memory for specified number of
<         -:  899:       *          elements.
<         -:  900:       *  @param  __n  Number of elements required.
<         -:  901:       *  @throw  std::length_error  If @a n exceeds @c max_size().
<         -:  902:       *
<         -:  903:       *  This function attempts to reserve enough memory for the
<         -:  904:       *  %vector to hold the specified number of elements.  If the
<         -:  905:       *  number requested is more than max_size(), length_error is
<         -:  906:       *  thrown.
<         -:  907:       *
<         -:  908:       *  The advantage of this function is that if optimal code is a
<         -:  909:       *  necessity and the user can determine the number of elements
<         -:  910:       *  that will be required, the user can reserve the memory in
<         -:  911:       *  %advance, and thus prevent a possible reallocation of memory
<         -:  912:       *  and copying of %vector data.
<         -:  913:       */
<         -:  914:      void
<         -:  915:      reserve(size_type __n);
<         -:  916:
<         -:  917:      // element access
<         -:  918:      /**
<         -:  919:       *  @brief  Subscript access to the data contained in the %vector.
<         -:  920:       *  @param __n The index of the element for which data should be
<         -:  921:       *  accessed.
<         -:  922:       *  @return  Read/write reference to data.
<         -:  923:       *
<         -:  924:       *  This operator allows for easy, array-style, data access.
<         -:  925:       *  Note that data access with this operator is unchecked and
<         -:  926:       *  out_of_range lookups are not defined. (For checked lookups
<         -:  927:       *  see at().)
<         -:  928:       */
<         -:  929:      reference
<      200*:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<      200*:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EEixEm:
<        42:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<        42:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EEixEm:
<        14:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<        14:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EEixEm:
<        54:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<        54:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EEixEm:
<     #####:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<     #####:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EEixEm:
<     #####:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<     #####:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EEixEm:
<        90:  930:      operator[](size_type __n) _GLIBCXX_NOEXCEPT
<         -:  931:      {
<         -:  932:	__glibcxx_requires_subscript(__n);
<        90:  933:	return *(this->_M_impl._M_start + __n);
<         -:  934:      }
< ------------------
<         -:  935:
<         -:  936:      /**
<         -:  937:       *  @brief  Subscript access to the data contained in the %vector.
<         -:  938:       *  @param __n The index of the element for which data should be
<         -:  939:       *  accessed.
<         -:  940:       *  @return  Read-only (constant) reference to data.
<         -:  941:       *
<         -:  942:       *  This operator allows for easy, array-style, data access.
<         -:  943:       *  Note that data access with this operator is unchecked and
<         -:  944:       *  out_of_range lookups are not defined. (For checked lookups
<         -:  945:       *  see at().)
<         -:  946:       */
<         -:  947:      const_reference
<     #####:  948:      operator[](size_type __n) const _GLIBCXX_NOEXCEPT
<         -:  949:      {
<         -:  950:	__glibcxx_requires_subscript(__n);
<     #####:  951:	return *(this->_M_impl._M_start + __n);
<         -:  952:      }
<         -:  953:
<         -:  954:    protected:
<         -:  955:      /// Safety check used only from at().
<         -:  956:      void
<        18:  957:      _M_range_check(size_type __n) const
<         -:  958:      {
<        18:  959:	if (__n >= this->size())
<     #####:  960:	  __throw_out_of_range_fmt(__N("vector::_M_range_check: __n "
<         -:  961:				       "(which is %zu) >= this->size() "
<         -:  962:				       "(which is %zu)"),
<         -:  963:				   __n, this->size());
<        18:  964:      }
<         -:  965:
<         -:  966:    public:
<         -:  967:      /**
<         -:  968:       *  @brief  Provides access to the data contained in the %vector.
<         -:  969:       *  @param __n The index of the element for which data should be
<         -:  970:       *  accessed.
<         -:  971:       *  @return  Read/write reference to data.
<         -:  972:       *  @throw  std::out_of_range  If @a __n is an invalid index.
<         -:  973:       *
<         -:  974:       *  This function provides for safer data access.  The parameter
<         -:  975:       *  is first checked that it is in the range of the vector.  The
<         -:  976:       *  function throws out_of_range if the check fails.
<         -:  977:       */
<         -:  978:      reference
<        18:  979:      at(size_type __n)
<         -:  980:      {
<        18:  981:	_M_range_check(__n);
<        18:  982:	return (*this)[__n];
<         -:  983:      }
<         -:  984:
<         -:  985:      /**
<         -:  986:       *  @brief  Provides access to the data contained in the %vector.
<         -:  987:       *  @param __n The index of the element for which data should be
<         -:  988:       *  accessed.
<         -:  989:       *  @return  Read-only (constant) reference to data.
<         -:  990:       *  @throw  std::out_of_range  If @a __n is an invalid index.
<         -:  991:       *
<         -:  992:       *  This function provides for safer data access.  The parameter
<         -:  993:       *  is first checked that it is in the range of the vector.  The
<         -:  994:       *  function throws out_of_range if the check fails.
<         -:  995:       */
<         -:  996:      const_reference
<         -:  997:      at(size_type __n) const
<         -:  998:      {
<         -:  999:	_M_range_check(__n);
<         -: 1000:	return (*this)[__n];
<         -: 1001:      }
<         -: 1002:
<         -: 1003:      /**
<         -: 1004:       *  Returns a read/write reference to the data at the first
<         -: 1005:       *  element of the %vector.
<         -: 1006:       */
<         -: 1007:      reference
<         -: 1008:      front() _GLIBCXX_NOEXCEPT
<         -: 1009:      {
<         -: 1010:	__glibcxx_requires_nonempty();
<         -: 1011:	return *begin();
<         -: 1012:      }
<         -: 1013:
---
>         -:  857:       *  This function provides for safer data access.  The parameter
>         -:  858:       *  is first checked that it is in the range of the vector.  The
>         -:  859:       *  function throws out_of_range if the check fails.
>         -:  860:       */
>         -:  861:      const_reference
>         -:  862:      at(size_type __n) const
>         -:  863:      {
>         -:  864:	_M_range_check(__n);
>         -:  865:	return (*this)[__n];
>         -:  866:      }
>         -:  867:
>         -:  868:      /**
>         -:  869:       *  Returns a read/write reference to the data at the first
>         -:  870:       *  element of the %vector.
>         -:  871:       */
>         -:  872:      reference
>         -:  873:      front() _GLIBCXX_NOEXCEPT
>         -:  874:      {
>         -:  875:	__glibcxx_requires_nonempty();
>         -:  876:	return *begin();
>         -:  877:      }
>         -:  878:
>         -:  879:      /**
>         -:  880:       *  Returns a read-only (constant) reference to the data at the first
>         -:  881:       *  element of the %vector.
>         -:  882:       */
>         -:  883:      const_reference
>         -:  884:      front() const _GLIBCXX_NOEXCEPT
>         -:  885:      {
>         -:  886:	__glibcxx_requires_nonempty();
>         -:  887:	return *begin();
>         -:  888:      }
>         -:  889:
>         -:  890:      /**
>         -:  891:       *  Returns a read/write reference to the data at the last
>         -:  892:       *  element of the %vector.
>         -:  893:       */
>         -:  894:      reference
>         -:  895:      back() _GLIBCXX_NOEXCEPT
>         -:  896:      {
>         -:  897:	__glibcxx_requires_nonempty();
>         -:  898:	return *(end() - 1);
>         -:  899:      }
>         -:  900:
>         -:  901:      /**
>         -:  902:       *  Returns a read-only (constant) reference to the data at the
>         -:  903:       *  last element of the %vector.
>         -:  904:       */
>         -:  905:      const_reference
>         -:  906:      back() const _GLIBCXX_NOEXCEPT
>         -:  907:      {
>         -:  908:	__glibcxx_requires_nonempty();
>         -:  909:	return *(end() - 1);
>         -:  910:      }
>         -:  911:
>         -:  912:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  913:      // DR 464. Suggestion for new member functions in standard containers.
>         -:  914:      // data access
>         -:  915:      /**
>         -:  916:       *   Returns a pointer such that [data(), data() + size()) is a valid
>         -:  917:       *   range.  For a non-empty %vector, data() == &front().
>         -:  918:       */
>         -:  919:      _Tp*
>         -:  920:      data() _GLIBCXX_NOEXCEPT
>         -:  921:      { return _M_data_ptr(this->_M_impl._M_start); }
>         -:  922:
>         -:  923:      const _Tp*
>         -:  924:      data() const _GLIBCXX_NOEXCEPT
>         -:  925:      { return _M_data_ptr(this->_M_impl._M_start); }
>         -:  926:
>         -:  927:      // [23.2.4.3] modifiers
>         -:  928:      /**
>         -:  929:       *  @brief  Add data to the end of the %vector.
>         -:  930:       *  @param  __x  Data to be added.
>         -:  931:       *
>         -:  932:       *  This is a typical stack operation.  The function creates an
>         -:  933:       *  element at the end of the %vector and assigns the given data
>         -:  934:       *  to it.  Due to the nature of a %vector this operation can be
>         -:  935:       *  done in constant time if the %vector has preallocated space
>         -:  936:       *  available.
>         -:  937:       */
>         -:  938:      void
>         -:  939:      push_back(const value_type& __x)
>         -:  940:      {
>         -:  941:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
>         -:  942:	  {
>         -:  943:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
>         -:  944:				     __x);
>         -:  945:	    ++this->_M_impl._M_finish;
>         -:  946:	  }
>         -:  947:	else
>         -:  948:	  _M_realloc_insert(end(), __x);
>         -:  949:      }
>         -:  950:
>         -:  951:#if __cplusplus >= 201103L
>         -:  952:      void
>     #####:  953:      push_back(value_type&& __x)
>     #####:  954:      { emplace_back(std::move(__x)); }
>         -:  955:
>         -:  956:      template<typename... _Args>
>         -:  957:#if __cplusplus > 201402L
>         -:  958:	reference
>         -:  959:#else
>         -:  960:	void
>         -:  961:#endif
>         -:  962:	emplace_back(_Args&&... __args);
>         -:  963:#endif
>         -:  964:
>         -:  965:      /**
>         -:  966:       *  @brief  Removes last element.
>         -:  967:       *
>         -:  968:       *  This is a typical stack operation. It shrinks the %vector by one.
>         -:  969:       *
>         -:  970:       *  Note that no data is returned, and if the last element's
>         -:  971:       *  data is needed, it should be retrieved before pop_back() is
>         -:  972:       *  called.
>         -:  973:       */
>         -:  974:      void
>         -:  975:      pop_back() _GLIBCXX_NOEXCEPT
>         -:  976:      {
>         -:  977:	__glibcxx_requires_nonempty();
>         -:  978:	--this->_M_impl._M_finish;
>         -:  979:	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
>         -:  980:      }
>         -:  981:
>         -:  982:#if __cplusplus >= 201103L
>         -:  983:      /**
>         -:  984:       *  @brief  Inserts an object in %vector before specified iterator.
>         -:  985:       *  @param  __position  A const_iterator into the %vector.
>         -:  986:       *  @param  __args  Arguments.
>         -:  987:       *  @return  An iterator that points to the inserted data.
>         -:  988:       *
>         -:  989:       *  This function will insert an object of type T constructed
>         -:  990:       *  with T(std::forward<Args>(args)...) before the specified location.
>         -:  991:       *  Note that this kind of operation could be expensive for a %vector
>         -:  992:       *  and if it is frequently used the user should consider using
>         -:  993:       *  std::list.
>         -:  994:       */
>         -:  995:      template<typename... _Args>
>         -:  996:	iterator
>         -:  997:	emplace(const_iterator __position, _Args&&... __args)
>         -:  998:	{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
>         -:  999:
>         -: 1000:      /**
>         -: 1001:       *  @brief  Inserts given value into %vector before specified iterator.
>         -: 1002:       *  @param  __position  A const_iterator into the %vector.
>         -: 1003:       *  @param  __x  Data to be inserted.
>         -: 1004:       *  @return  An iterator that points to the inserted data.
>         -: 1005:       *
>         -: 1006:       *  This function will insert a copy of the given value before
>         -: 1007:       *  the specified location.  Note that this kind of operation
>         -: 1008:       *  could be expensive for a %vector and if it is frequently
>         -: 1009:       *  used the user should consider using std::list.
>         -: 1010:       */
>         -: 1011:      iterator
>         -: 1012:      insert(const_iterator __position, const value_type& __x);
>         -: 1013:#else
1857,2405c1017,1388
<         -: 1015:       *  Returns a read-only (constant) reference to the data at the first
<         -: 1016:       *  element of the %vector.
<         -: 1017:       */
<         -: 1018:      const_reference
<         -: 1019:      front() const _GLIBCXX_NOEXCEPT
<         -: 1020:      {
<         -: 1021:	__glibcxx_requires_nonempty();
<         -: 1022:	return *begin();
<         -: 1023:      }
<         -: 1024:
<         -: 1025:      /**
<         -: 1026:       *  Returns a read/write reference to the data at the last
<         -: 1027:       *  element of the %vector.
<         -: 1028:       */
<         -: 1029:      reference
<        11: 1030:      back() _GLIBCXX_NOEXCEPT
<         -: 1031:      {
<         -: 1032:	__glibcxx_requires_nonempty();
<        11: 1033:	return *(end() - 1);
<         -: 1034:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE4backEv:
<         2: 1030:      back() _GLIBCXX_NOEXCEPT
<         -: 1031:      {
<         -: 1032:	__glibcxx_requires_nonempty();
<         2: 1033:	return *(end() - 1);
<         -: 1034:      }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE4backEv:
<         9: 1030:      back() _GLIBCXX_NOEXCEPT
<         -: 1031:      {
<         -: 1032:	__glibcxx_requires_nonempty();
<         9: 1033:	return *(end() - 1);
<         -: 1034:      }
< ------------------
<         -: 1035:
<         -: 1036:      /**
<         -: 1037:       *  Returns a read-only (constant) reference to the data at the
<         -: 1038:       *  last element of the %vector.
<         -: 1039:       */
<         -: 1040:      const_reference
<         -: 1041:      back() const _GLIBCXX_NOEXCEPT
<         -: 1042:      {
<         -: 1043:	__glibcxx_requires_nonempty();
<         -: 1044:	return *(end() - 1);
<         -: 1045:      }
<         -: 1046:
<         -: 1047:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 1048:      // DR 464. Suggestion for new member functions in standard containers.
<         -: 1049:      // data access
<         -: 1050:      /**
<         -: 1051:       *   Returns a pointer such that [data(), data() + size()) is a valid
<         -: 1052:       *   range.  For a non-empty %vector, data() == &front().
<         -: 1053:       */
<         -: 1054:      _Tp*
<         -: 1055:      data() _GLIBCXX_NOEXCEPT
<         -: 1056:      { return _M_data_ptr(this->_M_impl._M_start); }
<         -: 1057:
<         -: 1058:      const _Tp*
<         -: 1059:      data() const _GLIBCXX_NOEXCEPT
<         -: 1060:      { return _M_data_ptr(this->_M_impl._M_start); }
<         -: 1061:
<         -: 1062:      // [23.2.4.3] modifiers
<         -: 1063:      /**
<         -: 1064:       *  @brief  Add data to the end of the %vector.
<         -: 1065:       *  @param  __x  Data to be added.
<         -: 1066:       *
<         -: 1067:       *  This is a typical stack operation.  The function creates an
<         -: 1068:       *  element at the end of the %vector and assigns the given data
<         -: 1069:       *  to it.  Due to the nature of a %vector this operation can be
<         -: 1070:       *  done in constant time if the %vector has preallocated space
<         -: 1071:       *  available.
<         -: 1072:       */
<         -: 1073:      void
<       84*: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<       84*: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<        9*: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<        9*: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<       75*: 1085:	  _M_realloc_insert(end(), __x);
<       84*: 1086:      }
< ------------------
< _ZNSt6vectorI13ACE_INET_AddrSaIS0_EE9push_backERKS0_:
<     #####: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<     #####: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<     #####: 1085:	  _M_realloc_insert(end(), __x);
<     #####: 1086:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE9push_backERKS2_:
<         6: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<         6: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<         6: 1085:	  _M_realloc_insert(end(), __x);
<         6: 1086:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE9push_backERKS4_:
<        42: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<        42: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<        42: 1085:	  _M_realloc_insert(end(), __x);
<        42: 1086:      }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE9push_backERKS3_:
<        32: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<        32: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<         9: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<         9: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<        23: 1085:	  _M_realloc_insert(end(), __x);
<        32: 1086:      }
< ------------------
< _ZNSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE9push_backERKS4_:
<     #####: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<     #####: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<     #####: 1085:	  _M_realloc_insert(end(), __x);
<     #####: 1086:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE9push_backERKSE_:
<     #####: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<     #####: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<     #####: 1085:	  _M_realloc_insert(end(), __x);
<     #####: 1086:      }
< ------------------
< _ZNSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE9push_backERKS5_:
<     #####: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<     #####: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<     #####: 1085:	  _M_realloc_insert(end(), __x);
<     #####: 1086:      }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE9push_backERKS7_:
<         4: 1074:      push_back(const value_type& __x)
<         -: 1075:      {
<         4: 1076:	if (this->_M_impl._M_finish != this->_M_impl._M_end_of_storage)
<         -: 1077:	  {
<         -: 1078:	    _GLIBCXX_ASAN_ANNOTATE_GROW(1);
<     #####: 1079:	    _Alloc_traits::construct(this->_M_impl, this->_M_impl._M_finish,
<         -: 1080:				     __x);
<     #####: 1081:	    ++this->_M_impl._M_finish;
<         -: 1082:	    _GLIBCXX_ASAN_ANNOTATE_GREW(1);
<         -: 1083:	  }
<         -: 1084:	else
<         4: 1085:	  _M_realloc_insert(end(), __x);
<         4: 1086:      }
< ------------------
<         -: 1087:
<         -: 1088:#if __cplusplus >= 201103L
<         -: 1089:      void
<        47: 1090:      push_back(value_type&& __x)
<        47: 1091:      { emplace_back(std::move(__x)); }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE9push_backEOS7_:
<         2: 1090:      push_back(value_type&& __x)
<         2: 1091:      { emplace_back(std::move(__x)); }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE9push_backEOS7_:
<        45: 1090:      push_back(value_type&& __x)
<        45: 1091:      { emplace_back(std::move(__x)); }
< ------------------
<         -: 1092:
<         -: 1093:      template<typename... _Args>
<         -: 1094:#if __cplusplus > 201402L
<         -: 1095:	reference
<         -: 1096:#else
<         -: 1097:	void
<         -: 1098:#endif
<         -: 1099:	emplace_back(_Args&&... __args);
<         -: 1100:#endif
<         -: 1101:
<         -: 1102:      /**
<         -: 1103:       *  @brief  Removes last element.
<         -: 1104:       *
<         -: 1105:       *  This is a typical stack operation. It shrinks the %vector by one.
<         -: 1106:       *
<         -: 1107:       *  Note that no data is returned, and if the last element's
<         -: 1108:       *  data is needed, it should be retrieved before pop_back() is
<         -: 1109:       *  called.
<         -: 1110:       */
<         -: 1111:      void
<        2*: 1112:      pop_back() _GLIBCXX_NOEXCEPT
<         -: 1113:      {
<         -: 1114:	__glibcxx_requires_nonempty();
<        2*: 1115:	--this->_M_impl._M_finish;
<        2*: 1116:	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
<         -: 1117:	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
<        2*: 1118:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE8pop_backEv:
<         2: 1112:      pop_back() _GLIBCXX_NOEXCEPT
<         -: 1113:      {
<         -: 1114:	__glibcxx_requires_nonempty();
<         2: 1115:	--this->_M_impl._M_finish;
<         2: 1116:	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
<         -: 1117:	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
<         2: 1118:      }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE8pop_backEv:
<     #####: 1112:      pop_back() _GLIBCXX_NOEXCEPT
<         -: 1113:      {
<         -: 1114:	__glibcxx_requires_nonempty();
<     #####: 1115:	--this->_M_impl._M_finish;
<     #####: 1116:	_Alloc_traits::destroy(this->_M_impl, this->_M_impl._M_finish);
<         -: 1117:	_GLIBCXX_ASAN_ANNOTATE_SHRINK(1);
<     #####: 1118:      }
< ------------------
<         -: 1119:
<         -: 1120:#if __cplusplus >= 201103L
<         -: 1121:      /**
<         -: 1122:       *  @brief  Inserts an object in %vector before specified iterator.
<         -: 1123:       *  @param  __position  A const_iterator into the %vector.
<         -: 1124:       *  @param  __args  Arguments.
<         -: 1125:       *  @return  An iterator that points to the inserted data.
<         -: 1126:       *
<         -: 1127:       *  This function will insert an object of type T constructed
<         -: 1128:       *  with T(std::forward<Args>(args)...) before the specified location.
<         -: 1129:       *  Note that this kind of operation could be expensive for a %vector
<         -: 1130:       *  and if it is frequently used the user should consider using
<         -: 1131:       *  std::list.
<         -: 1132:       */
<         -: 1133:      template<typename... _Args>
<         -: 1134:	iterator
<         -: 1135:	emplace(const_iterator __position, _Args&&... __args)
<         -: 1136:	{ return _M_emplace_aux(__position, std::forward<_Args>(__args)...); }
<         -: 1137:
<         -: 1138:      /**
<         -: 1139:       *  @brief  Inserts given value into %vector before specified iterator.
<         -: 1140:       *  @param  __position  A const_iterator into the %vector.
<         -: 1141:       *  @param  __x  Data to be inserted.
<         -: 1142:       *  @return  An iterator that points to the inserted data.
<         -: 1143:       *
<         -: 1144:       *  This function will insert a copy of the given value before
<         -: 1145:       *  the specified location.  Note that this kind of operation
<         -: 1146:       *  could be expensive for a %vector and if it is frequently
<         -: 1147:       *  used the user should consider using std::list.
<         -: 1148:       */
<         -: 1149:      iterator
<         -: 1150:      insert(const_iterator __position, const value_type& __x);
<         -: 1151:#else
<         -: 1152:      /**
<         -: 1153:       *  @brief  Inserts given value into %vector before specified iterator.
<         -: 1154:       *  @param  __position  An iterator into the %vector.
<         -: 1155:       *  @param  __x  Data to be inserted.
<         -: 1156:       *  @return  An iterator that points to the inserted data.
<         -: 1157:       *
<         -: 1158:       *  This function will insert a copy of the given value before
<         -: 1159:       *  the specified location.  Note that this kind of operation
<         -: 1160:       *  could be expensive for a %vector and if it is frequently
<         -: 1161:       *  used the user should consider using std::list.
<         -: 1162:       */
<         -: 1163:      iterator
<         -: 1164:      insert(iterator __position, const value_type& __x);
<         -: 1165:#endif
<         -: 1166:
<         -: 1167:#if __cplusplus >= 201103L
<         -: 1168:      /**
<         -: 1169:       *  @brief  Inserts given rvalue into %vector before specified iterator.
<         -: 1170:       *  @param  __position  A const_iterator into the %vector.
<         -: 1171:       *  @param  __x  Data to be inserted.
<         -: 1172:       *  @return  An iterator that points to the inserted data.
<         -: 1173:       *
<         -: 1174:       *  This function will insert a copy of the given rvalue before
<         -: 1175:       *  the specified location.  Note that this kind of operation
<         -: 1176:       *  could be expensive for a %vector and if it is frequently
<         -: 1177:       *  used the user should consider using std::list.
<         -: 1178:       */
<         -: 1179:      iterator
<         -: 1180:      insert(const_iterator __position, value_type&& __x)
<         -: 1181:      { return _M_insert_rval(__position, std::move(__x)); }
<         -: 1182:
<         -: 1183:      /**
<         -: 1184:       *  @brief  Inserts an initializer_list into the %vector.
<         -: 1185:       *  @param  __position  An iterator into the %vector.
<         -: 1186:       *  @param  __l  An initializer_list.
<         -: 1187:       *
<         -: 1188:       *  This function will insert copies of the data in the
<         -: 1189:       *  initializer_list @a l into the %vector before the location
<         -: 1190:       *  specified by @a position.
<         -: 1191:       *
<         -: 1192:       *  Note that this kind of operation could be expensive for a
<         -: 1193:       *  %vector and if it is frequently used the user should
<         -: 1194:       *  consider using std::list.
<         -: 1195:       */
<         -: 1196:      iterator
<         -: 1197:      insert(const_iterator __position, initializer_list<value_type> __l)
<         -: 1198:      {
<         -: 1199:	auto __offset = __position - cbegin();
<         -: 1200:	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),
<         -: 1201:			std::random_access_iterator_tag());
<         -: 1202:	return begin() + __offset;
<         -: 1203:      }
<         -: 1204:#endif
<         -: 1205:
<         -: 1206:#if __cplusplus >= 201103L
<         -: 1207:      /**
<         -: 1208:       *  @brief  Inserts a number of copies of given data into the %vector.
<         -: 1209:       *  @param  __position  A const_iterator into the %vector.
<         -: 1210:       *  @param  __n  Number of elements to be inserted.
<         -: 1211:       *  @param  __x  Data to be inserted.
<         -: 1212:       *  @return  An iterator that points to the inserted data.
<         -: 1213:       *
<         -: 1214:       *  This function will insert a specified number of copies of
<         -: 1215:       *  the given data before the location specified by @a position.
<         -: 1216:       *
<         -: 1217:       *  Note that this kind of operation could be expensive for a
<         -: 1218:       *  %vector and if it is frequently used the user should
<         -: 1219:       *  consider using std::list.
<         -: 1220:       */
<         -: 1221:      iterator
<         -: 1222:      insert(const_iterator __position, size_type __n, const value_type& __x)
<         -: 1223:      {
<         -: 1224:	difference_type __offset = __position - cbegin();
<         -: 1225:	_M_fill_insert(begin() + __offset, __n, __x);
<         -: 1226:	return begin() + __offset;
<         -: 1227:      }
<         -: 1228:#else
<         -: 1229:      /**
<         -: 1230:       *  @brief  Inserts a number of copies of given data into the %vector.
<         -: 1231:       *  @param  __position  An iterator into the %vector.
<         -: 1232:       *  @param  __n  Number of elements to be inserted.
<         -: 1233:       *  @param  __x  Data to be inserted.
<         -: 1234:       *
<         -: 1235:       *  This function will insert a specified number of copies of
<         -: 1236:       *  the given data before the location specified by @a position.
<         -: 1237:       *
<         -: 1238:       *  Note that this kind of operation could be expensive for a
<         -: 1239:       *  %vector and if it is frequently used the user should
<         -: 1240:       *  consider using std::list.
<         -: 1241:       */
<         -: 1242:      void
<         -: 1243:      insert(iterator __position, size_type __n, const value_type& __x)
<         -: 1244:      { _M_fill_insert(__position, __n, __x); }
<         -: 1245:#endif
<         -: 1246:
<         -: 1247:#if __cplusplus >= 201103L
<         -: 1248:      /**
<         -: 1249:       *  @brief  Inserts a range into the %vector.
<         -: 1250:       *  @param  __position  A const_iterator into the %vector.
<         -: 1251:       *  @param  __first  An input iterator.
<         -: 1252:       *  @param  __last   An input iterator.
<         -: 1253:       *  @return  An iterator that points to the inserted data.
<         -: 1254:       *
<         -: 1255:       *  This function will insert copies of the data in the range
<         -: 1256:       *  [__first,__last) into the %vector before the location specified
<         -: 1257:       *  by @a pos.
<         -: 1258:       *
<         -: 1259:       *  Note that this kind of operation could be expensive for a
<         -: 1260:       *  %vector and if it is frequently used the user should
<         -: 1261:       *  consider using std::list.
<         -: 1262:       */
<         -: 1263:      template<typename _InputIterator,
<         -: 1264:	       typename = std::_RequireInputIter<_InputIterator>>
<         -: 1265:	iterator
<         -: 1266:	insert(const_iterator __position, _InputIterator __first,
<         -: 1267:	       _InputIterator __last)
<         -: 1268:	{
<         -: 1269:	  difference_type __offset = __position - cbegin();
<         -: 1270:	  _M_insert_dispatch(begin() + __offset,
<         -: 1271:			     __first, __last, __false_type());
<         -: 1272:	  return begin() + __offset;
<         -: 1273:	}
<         -: 1274:#else
<         -: 1275:      /**
<         -: 1276:       *  @brief  Inserts a range into the %vector.
<         -: 1277:       *  @param  __position  An iterator into the %vector.
<         -: 1278:       *  @param  __first  An input iterator.
<         -: 1279:       *  @param  __last   An input iterator.
<         -: 1280:       *
<         -: 1281:       *  This function will insert copies of the data in the range
<         -: 1282:       *  [__first,__last) into the %vector before the location specified
<         -: 1283:       *  by @a pos.
<         -: 1284:       *
<         -: 1285:       *  Note that this kind of operation could be expensive for a
<         -: 1286:       *  %vector and if it is frequently used the user should
<         -: 1287:       *  consider using std::list.
<         -: 1288:       */
<         -: 1289:      template<typename _InputIterator>
<         -: 1290:	void
<         -: 1291:	insert(iterator __position, _InputIterator __first,
<         -: 1292:	       _InputIterator __last)
<         -: 1293:	{
<         -: 1294:	  // Check whether it's an integral type.  If so, it's not an iterator.
<         -: 1295:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
<         -: 1296:	  _M_insert_dispatch(__position, __first, __last, _Integral());
<         -: 1297:	}
<         -: 1298:#endif
<         -: 1299:
<         -: 1300:      /**
<         -: 1301:       *  @brief  Remove element at given position.
<         -: 1302:       *  @param  __position  Iterator pointing to element to be erased.
<         -: 1303:       *  @return  An iterator pointing to the next element (or end()).
<         -: 1304:       *
<         -: 1305:       *  This function will erase the element at the given position and thus
<         -: 1306:       *  shorten the %vector by one.
<         -: 1307:       *
<         -: 1308:       *  Note This operation could be expensive and if it is
<         -: 1309:       *  frequently used the user should consider using std::list.
<         -: 1310:       *  The user is also cautioned that this function only erases
<         -: 1311:       *  the element, and that if the element is itself a pointer,
<         -: 1312:       *  the pointed-to memory is not touched in any way.  Managing
<         -: 1313:       *  the pointer is the user's responsibility.
<         -: 1314:       */
<         -: 1315:      iterator
<         -: 1316:#if __cplusplus >= 201103L
<         4: 1317:      erase(const_iterator __position)
<         4: 1318:      { return _M_erase(begin() + (__position - cbegin())); }
<         -: 1319:#else
<         -: 1320:      erase(iterator __position)
<         -: 1321:      { return _M_erase(__position); }
<         -: 1322:#endif
<         -: 1323:
<         -: 1324:      /**
<         -: 1325:       *  @brief  Remove a range of elements.
<         -: 1326:       *  @param  __first  Iterator pointing to the first element to be erased.
<         -: 1327:       *  @param  __last  Iterator pointing to one past the last element to be
<         -: 1328:       *                  erased.
<         -: 1329:       *  @return  An iterator pointing to the element pointed to by @a __last
<         -: 1330:       *           prior to erasing (or end()).
<         -: 1331:       *
<         -: 1332:       *  This function will erase the elements in the range
<         -: 1333:       *  [__first,__last) and shorten the %vector accordingly.
<         -: 1334:       *
<         -: 1335:       *  Note This operation could be expensive and if it is
<         -: 1336:       *  frequently used the user should consider using std::list.
<         -: 1337:       *  The user is also cautioned that this function only erases
<         -: 1338:       *  the elements, and that if the elements themselves are
<         -: 1339:       *  pointers, the pointed-to memory is not touched in any way.
<         -: 1340:       *  Managing the pointer is the user's responsibility.
<         -: 1341:       */
<         -: 1342:      iterator
<         -: 1343:#if __cplusplus >= 201103L
<         1: 1344:      erase(const_iterator __first, const_iterator __last)
<         -: 1345:      {
<         1: 1346:	const auto __beg = begin();
<         1: 1347:	const auto __cbeg = cbegin();
<         2: 1348:	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
<         -: 1349:      }
<         -: 1350:#else
<         -: 1351:      erase(iterator __first, iterator __last)
<         -: 1352:      { return _M_erase(__first, __last); }
<         -: 1353:#endif
<         -: 1354:
<         -: 1355:      /**
<         -: 1356:       *  @brief  Swaps data with another %vector.
<         -: 1357:       *  @param  __x  A %vector of the same element and allocator types.
<         -: 1358:       *
<         -: 1359:       *  This exchanges the elements between two vectors in constant time.
<         -: 1360:       *  (Three pointers, so it should be quite fast.)
<         -: 1361:       *  Note that the global std::swap() function is specialized such that
<         -: 1362:       *  std::swap(v1,v2) will feed to this function.
<         -: 1363:       *
<         -: 1364:       *  Whether the allocators are swapped depends on the allocator traits.
<         -: 1365:       */
<         -: 1366:      void
<         -: 1367:      swap(vector& __x) _GLIBCXX_NOEXCEPT
<         -: 1368:      {
<         -: 1369:#if __cplusplus >= 201103L
<         -: 1370:	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
<         -: 1371:			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
<         -: 1372:#endif
<         -: 1373:	this->_M_impl._M_swap_data(__x._M_impl);
<         -: 1374:	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
<         -: 1375:				  __x._M_get_Tp_allocator());
<         -: 1376:      }
<         -: 1377:
<         -: 1378:      /**
<         -: 1379:       *  Erases all the elements.  Note that this function only erases the
<         -: 1380:       *  elements, and that if the elements themselves are pointers, the
<         -: 1381:       *  pointed-to memory is not touched in any way.  Managing the pointer is
<         -: 1382:       *  the user's responsibility.
<         -: 1383:       */
<         -: 1384:      void
<       65*: 1385:      clear() _GLIBCXX_NOEXCEPT
<       65*: 1386:      { _M_erase_at_end(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE5clearEv:
<     #####: 1385:      clear() _GLIBCXX_NOEXCEPT
<     #####: 1386:      { _M_erase_at_end(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE5clearEv:
<        18: 1385:      clear() _GLIBCXX_NOEXCEPT
<        18: 1386:      { _M_erase_at_end(this->_M_impl._M_start); }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE5clearEv:
<        47: 1385:      clear() _GLIBCXX_NOEXCEPT
<        47: 1386:      { _M_erase_at_end(this->_M_impl._M_start); }
< ------------------
---
>         -: 1015:       *  @brief  Inserts given value into %vector before specified iterator.
>         -: 1016:       *  @param  __position  An iterator into the %vector.
>         -: 1017:       *  @param  __x  Data to be inserted.
>         -: 1018:       *  @return  An iterator that points to the inserted data.
>         -: 1019:       *
>         -: 1020:       *  This function will insert a copy of the given value before
>         -: 1021:       *  the specified location.  Note that this kind of operation
>         -: 1022:       *  could be expensive for a %vector and if it is frequently
>         -: 1023:       *  used the user should consider using std::list.
>         -: 1024:       */
>         -: 1025:      iterator
>         -: 1026:      insert(iterator __position, const value_type& __x);
>         -: 1027:#endif
>         -: 1028:
>         -: 1029:#if __cplusplus >= 201103L
>         -: 1030:      /**
>         -: 1031:       *  @brief  Inserts given rvalue into %vector before specified iterator.
>         -: 1032:       *  @param  __position  A const_iterator into the %vector.
>         -: 1033:       *  @param  __x  Data to be inserted.
>         -: 1034:       *  @return  An iterator that points to the inserted data.
>         -: 1035:       *
>         -: 1036:       *  This function will insert a copy of the given rvalue before
>         -: 1037:       *  the specified location.  Note that this kind of operation
>         -: 1038:       *  could be expensive for a %vector and if it is frequently
>         -: 1039:       *  used the user should consider using std::list.
>         -: 1040:       */
>         -: 1041:      iterator
>         -: 1042:      insert(const_iterator __position, value_type&& __x)
>         -: 1043:      { return _M_insert_rval(__position, std::move(__x)); }
>         -: 1044:
>         -: 1045:      /**
>         -: 1046:       *  @brief  Inserts an initializer_list into the %vector.
>         -: 1047:       *  @param  __position  An iterator into the %vector.
>         -: 1048:       *  @param  __l  An initializer_list.
>         -: 1049:       *
>         -: 1050:       *  This function will insert copies of the data in the
>         -: 1051:       *  initializer_list @a l into the %vector before the location
>         -: 1052:       *  specified by @a position.
>         -: 1053:       *
>         -: 1054:       *  Note that this kind of operation could be expensive for a
>         -: 1055:       *  %vector and if it is frequently used the user should
>         -: 1056:       *  consider using std::list.
>         -: 1057:       */
>         -: 1058:      iterator
>         -: 1059:      insert(const_iterator __position, initializer_list<value_type> __l)
>         -: 1060:      {
>         -: 1061:	auto __offset = __position - cbegin();
>         -: 1062:	_M_range_insert(begin() + __offset, __l.begin(), __l.end(),
>         -: 1063:			std::random_access_iterator_tag());
>         -: 1064:	return begin() + __offset;
>         -: 1065:      }
>         -: 1066:#endif
>         -: 1067:
>         -: 1068:#if __cplusplus >= 201103L
>         -: 1069:      /**
>         -: 1070:       *  @brief  Inserts a number of copies of given data into the %vector.
>         -: 1071:       *  @param  __position  A const_iterator into the %vector.
>         -: 1072:       *  @param  __n  Number of elements to be inserted.
>         -: 1073:       *  @param  __x  Data to be inserted.
>         -: 1074:       *  @return  An iterator that points to the inserted data.
>         -: 1075:       *
>         -: 1076:       *  This function will insert a specified number of copies of
>         -: 1077:       *  the given data before the location specified by @a position.
>         -: 1078:       *
>         -: 1079:       *  Note that this kind of operation could be expensive for a
>         -: 1080:       *  %vector and if it is frequently used the user should
>         -: 1081:       *  consider using std::list.
>         -: 1082:       */
>         -: 1083:      iterator
>         -: 1084:      insert(const_iterator __position, size_type __n, const value_type& __x)
>         -: 1085:      {
>         -: 1086:	difference_type __offset = __position - cbegin();
>         -: 1087:	_M_fill_insert(begin() + __offset, __n, __x);
>         -: 1088:	return begin() + __offset;
>         -: 1089:      }
>         -: 1090:#else
>         -: 1091:      /**
>         -: 1092:       *  @brief  Inserts a number of copies of given data into the %vector.
>         -: 1093:       *  @param  __position  An iterator into the %vector.
>         -: 1094:       *  @param  __n  Number of elements to be inserted.
>         -: 1095:       *  @param  __x  Data to be inserted.
>         -: 1096:       *
>         -: 1097:       *  This function will insert a specified number of copies of
>         -: 1098:       *  the given data before the location specified by @a position.
>         -: 1099:       *
>         -: 1100:       *  Note that this kind of operation could be expensive for a
>         -: 1101:       *  %vector and if it is frequently used the user should
>         -: 1102:       *  consider using std::list.
>         -: 1103:       */
>         -: 1104:      void
>         -: 1105:      insert(iterator __position, size_type __n, const value_type& __x)
>         -: 1106:      { _M_fill_insert(__position, __n, __x); }
>         -: 1107:#endif
>         -: 1108:
>         -: 1109:#if __cplusplus >= 201103L
>         -: 1110:      /**
>         -: 1111:       *  @brief  Inserts a range into the %vector.
>         -: 1112:       *  @param  __position  A const_iterator into the %vector.
>         -: 1113:       *  @param  __first  An input iterator.
>         -: 1114:       *  @param  __last   An input iterator.
>         -: 1115:       *  @return  An iterator that points to the inserted data.
>         -: 1116:       *
>         -: 1117:       *  This function will insert copies of the data in the range
>         -: 1118:       *  [__first,__last) into the %vector before the location specified
>         -: 1119:       *  by @a pos.
>         -: 1120:       *
>         -: 1121:       *  Note that this kind of operation could be expensive for a
>         -: 1122:       *  %vector and if it is frequently used the user should
>         -: 1123:       *  consider using std::list.
>         -: 1124:       */
>         -: 1125:      template<typename _InputIterator,
>         -: 1126:	       typename = std::_RequireInputIter<_InputIterator>>
>         -: 1127:	iterator
>         -: 1128:	insert(const_iterator __position, _InputIterator __first,
>         -: 1129:	       _InputIterator __last)
>         -: 1130:	{
>         -: 1131:	  difference_type __offset = __position - cbegin();
>         -: 1132:	  _M_insert_dispatch(begin() + __offset,
>         -: 1133:			     __first, __last, __false_type());
>         -: 1134:	  return begin() + __offset;
>         -: 1135:	}
>         -: 1136:#else
>         -: 1137:      /**
>         -: 1138:       *  @brief  Inserts a range into the %vector.
>         -: 1139:       *  @param  __position  An iterator into the %vector.
>         -: 1140:       *  @param  __first  An input iterator.
>         -: 1141:       *  @param  __last   An input iterator.
>         -: 1142:       *
>         -: 1143:       *  This function will insert copies of the data in the range
>         -: 1144:       *  [__first,__last) into the %vector before the location specified
>         -: 1145:       *  by @a pos.
>         -: 1146:       *
>         -: 1147:       *  Note that this kind of operation could be expensive for a
>         -: 1148:       *  %vector and if it is frequently used the user should
>         -: 1149:       *  consider using std::list.
>         -: 1150:       */
>         -: 1151:      template<typename _InputIterator>
>         -: 1152:	void
>         -: 1153:	insert(iterator __position, _InputIterator __first,
>         -: 1154:	       _InputIterator __last)
>         -: 1155:	{
>         -: 1156:	  // Check whether it's an integral type.  If so, it's not an iterator.
>         -: 1157:	  typedef typename std::__is_integer<_InputIterator>::__type _Integral;
>         -: 1158:	  _M_insert_dispatch(__position, __first, __last, _Integral());
>         -: 1159:	}
>         -: 1160:#endif
>         -: 1161:
>         -: 1162:      /**
>         -: 1163:       *  @brief  Remove element at given position.
>         -: 1164:       *  @param  __position  Iterator pointing to element to be erased.
>         -: 1165:       *  @return  An iterator pointing to the next element (or end()).
>         -: 1166:       *
>         -: 1167:       *  This function will erase the element at the given position and thus
>         -: 1168:       *  shorten the %vector by one.
>         -: 1169:       *
>         -: 1170:       *  Note This operation could be expensive and if it is
>         -: 1171:       *  frequently used the user should consider using std::list.
>         -: 1172:       *  The user is also cautioned that this function only erases
>         -: 1173:       *  the element, and that if the element is itself a pointer,
>         -: 1174:       *  the pointed-to memory is not touched in any way.  Managing
>         -: 1175:       *  the pointer is the user's responsibility.
>         -: 1176:       */
>         -: 1177:      iterator
>         -: 1178:#if __cplusplus >= 201103L
>         -: 1179:      erase(const_iterator __position)
>         -: 1180:      { return _M_erase(begin() + (__position - cbegin())); }
>         -: 1181:#else
>         -: 1182:      erase(iterator __position)
>         -: 1183:      { return _M_erase(__position); }
>         -: 1184:#endif
>         -: 1185:
>         -: 1186:      /**
>         -: 1187:       *  @brief  Remove a range of elements.
>         -: 1188:       *  @param  __first  Iterator pointing to the first element to be erased.
>         -: 1189:       *  @param  __last  Iterator pointing to one past the last element to be
>         -: 1190:       *                  erased.
>         -: 1191:       *  @return  An iterator pointing to the element pointed to by @a __last
>         -: 1192:       *           prior to erasing (or end()).
>         -: 1193:       *
>         -: 1194:       *  This function will erase the elements in the range
>         -: 1195:       *  [__first,__last) and shorten the %vector accordingly.
>         -: 1196:       *
>         -: 1197:       *  Note This operation could be expensive and if it is
>         -: 1198:       *  frequently used the user should consider using std::list.
>         -: 1199:       *  The user is also cautioned that this function only erases
>         -: 1200:       *  the elements, and that if the elements themselves are
>         -: 1201:       *  pointers, the pointed-to memory is not touched in any way.
>         -: 1202:       *  Managing the pointer is the user's responsibility.
>         -: 1203:       */
>         -: 1204:      iterator
>         -: 1205:#if __cplusplus >= 201103L
>         -: 1206:      erase(const_iterator __first, const_iterator __last)
>         -: 1207:      {
>         -: 1208:	const auto __beg = begin();
>         -: 1209:	const auto __cbeg = cbegin();
>         -: 1210:	return _M_erase(__beg + (__first - __cbeg), __beg + (__last - __cbeg));
>         -: 1211:      }
>         -: 1212:#else
>         -: 1213:      erase(iterator __first, iterator __last)
>         -: 1214:      { return _M_erase(__first, __last); }
>         -: 1215:#endif
>         -: 1216:
>         -: 1217:      /**
>         -: 1218:       *  @brief  Swaps data with another %vector.
>         -: 1219:       *  @param  __x  A %vector of the same element and allocator types.
>         -: 1220:       *
>         -: 1221:       *  This exchanges the elements between two vectors in constant time.
>         -: 1222:       *  (Three pointers, so it should be quite fast.)
>         -: 1223:       *  Note that the global std::swap() function is specialized such that
>         -: 1224:       *  std::swap(v1,v2) will feed to this function.
>         -: 1225:       *
>         -: 1226:       *  Whether the allocators are swapped depends on the allocator traits.
>         -: 1227:       */
>         -: 1228:      void
>         -: 1229:      swap(vector& __x) _GLIBCXX_NOEXCEPT
>         -: 1230:      {
>         -: 1231:#if __cplusplus >= 201103L
>         -: 1232:	__glibcxx_assert(_Alloc_traits::propagate_on_container_swap::value
>         -: 1233:			 || _M_get_Tp_allocator() == __x._M_get_Tp_allocator());
>         -: 1234:#endif
>         -: 1235:	this->_M_impl._M_swap_data(__x._M_impl);
>         -: 1236:	_Alloc_traits::_S_on_swap(_M_get_Tp_allocator(),
>         -: 1237:				  __x._M_get_Tp_allocator());
>         -: 1238:      }
>         -: 1239:
>         -: 1240:      /**
>         -: 1241:       *  Erases all the elements.  Note that this function only erases the
>         -: 1242:       *  elements, and that if the elements themselves are pointers, the
>         -: 1243:       *  pointed-to memory is not touched in any way.  Managing the pointer is
>         -: 1244:       *  the user's responsibility.
>         -: 1245:       */
>         -: 1246:      void
>         -: 1247:      clear() _GLIBCXX_NOEXCEPT
>         -: 1248:      { _M_erase_at_end(this->_M_impl._M_start); }
>         -: 1249:
>         -: 1250:    protected:
>         -: 1251:      /**
>         -: 1252:       *  Memory expansion handler.  Uses the member allocation function to
>         -: 1253:       *  obtain @a n bytes of memory, and then copies [first,last) into it.
>         -: 1254:       */
>         -: 1255:      template<typename _ForwardIterator>
>         -: 1256:	pointer
>         -: 1257:	_M_allocate_and_copy(size_type __n,
>         -: 1258:			     _ForwardIterator __first, _ForwardIterator __last)
>         -: 1259:	{
>         -: 1260:	  pointer __result = this->_M_allocate(__n);
>         -: 1261:	  __try
>         -: 1262:	    {
>         -: 1263:	      std::__uninitialized_copy_a(__first, __last, __result,
>         -: 1264:					  _M_get_Tp_allocator());
>         -: 1265:	      return __result;
>         -: 1266:	    }
>         -: 1267:	  __catch(...)
>         -: 1268:	    {
>         -: 1269:	      _M_deallocate(__result, __n);
>         -: 1270:	      __throw_exception_again;
>         -: 1271:	    }
>         -: 1272:	}
>         -: 1273:
>         -: 1274:
>         -: 1275:      // Internal constructor functions follow.
>         -: 1276:
>         -: 1277:      // Called by the range constructor to implement [23.1.1]/9
>         -: 1278:
>         -: 1279:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 1280:      // 438. Ambiguity in the "do the right thing" clause
>         -: 1281:      template<typename _Integer>
>         -: 1282:	void
>         -: 1283:	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
>         -: 1284:	{
>         -: 1285:	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
>         -: 1286:	  this->_M_impl._M_end_of_storage =
>         -: 1287:	    this->_M_impl._M_start + static_cast<size_type>(__n);
>         -: 1288:	  _M_fill_initialize(static_cast<size_type>(__n), __value);
>         -: 1289:	}
>         -: 1290:
>         -: 1291:      // Called by the range constructor to implement [23.1.1]/9
>         -: 1292:      template<typename _InputIterator>
>         -: 1293:	void
>         -: 1294:	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
>         -: 1295:			       __false_type)
>         -: 1296:	{
>         -: 1297:	  typedef typename std::iterator_traits<_InputIterator>::
>         -: 1298:	    iterator_category _IterCategory;
>         -: 1299:	  _M_range_initialize(__first, __last, _IterCategory());
>         -: 1300:	}
>         -: 1301:
>         -: 1302:      // Called by the second initialize_dispatch above
>         -: 1303:      template<typename _InputIterator>
>         -: 1304:	void
>         -: 1305:	_M_range_initialize(_InputIterator __first, _InputIterator __last,
>         -: 1306:			    std::input_iterator_tag)
>         -: 1307:	{
>         -: 1308:	  __try {
>         -: 1309:	    for (; __first != __last; ++__first)
>         -: 1310:#if __cplusplus >= 201103L
>         -: 1311:	      emplace_back(*__first);
>         -: 1312:#else
>         -: 1313:	      push_back(*__first);
>         -: 1314:#endif
>         -: 1315:	  } __catch(...) {
>         -: 1316:	    clear();
>         -: 1317:	    __throw_exception_again;
>         -: 1318:	  }
>         -: 1319:	}
>         -: 1320:
>         -: 1321:      // Called by the second initialize_dispatch above
>         -: 1322:      template<typename _ForwardIterator>
>         -: 1323:	void
>         -: 1324:	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
>         -: 1325:			    std::forward_iterator_tag)
>         -: 1326:	{
>         -: 1327:	  const size_type __n = std::distance(__first, __last);
>         -: 1328:	  this->_M_impl._M_start = this->_M_allocate(__n);
>         -: 1329:	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
>         -: 1330:	  this->_M_impl._M_finish =
>         -: 1331:	    std::__uninitialized_copy_a(__first, __last,
>         -: 1332:					this->_M_impl._M_start,
>         -: 1333:					_M_get_Tp_allocator());
>         -: 1334:	}
>         -: 1335:
>         -: 1336:      // Called by the first initialize_dispatch above and by the
>         -: 1337:      // vector(n,value,a) constructor.
>         -: 1338:      void
>         -: 1339:      _M_fill_initialize(size_type __n, const value_type& __value)
>         -: 1340:      {
>         -: 1341:	this->_M_impl._M_finish =
>         -: 1342:	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
>         -: 1343:					_M_get_Tp_allocator());
>         -: 1344:      }
>         -: 1345:
>         -: 1346:#if __cplusplus >= 201103L
>         -: 1347:      // Called by the vector(n) constructor.
>         -: 1348:      void
>         -: 1349:      _M_default_initialize(size_type __n)
>         -: 1350:      {
>         -: 1351:	this->_M_impl._M_finish =
>         -: 1352:	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
>         -: 1353:					   _M_get_Tp_allocator());
>         -: 1354:      }
>         -: 1355:#endif
>         -: 1356:
>         -: 1357:      // Internal assign functions follow.  The *_aux functions do the actual
>         -: 1358:      // assignment work for the range versions.
>         -: 1359:
>         -: 1360:      // Called by the range assign to implement [23.1.1]/9
>         -: 1361:
>         -: 1362:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 1363:      // 438. Ambiguity in the "do the right thing" clause
>         -: 1364:      template<typename _Integer>
>         -: 1365:	void
>         -: 1366:	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
>         -: 1367:	{ _M_fill_assign(__n, __val); }
>         -: 1368:
>         -: 1369:      // Called by the range assign to implement [23.1.1]/9
>         -: 1370:      template<typename _InputIterator>
>         -: 1371:	void
>         -: 1372:	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
>         -: 1373:			   __false_type)
>         -: 1374:	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
>         -: 1375:
>         -: 1376:      // Called by the second assign_dispatch above
>         -: 1377:      template<typename _InputIterator>
>         -: 1378:	void
>         -: 1379:	_M_assign_aux(_InputIterator __first, _InputIterator __last,
>         -: 1380:		      std::input_iterator_tag);
>         -: 1381:
>         -: 1382:      // Called by the second assign_dispatch above
>         -: 1383:      template<typename _ForwardIterator>
>         -: 1384:	void
>         -: 1385:	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
>         -: 1386:		      std::forward_iterator_tag);
2407,2469c1390,1415
<         -: 1388:    protected:
<         -: 1389:      /**
<         -: 1390:       *  Memory expansion handler.  Uses the member allocation function to
<         -: 1391:       *  obtain @a n bytes of memory, and then copies [first,last) into it.
<         -: 1392:       */
<         -: 1393:      template<typename _ForwardIterator>
<         -: 1394:	pointer
<        15: 1395:	_M_allocate_and_copy(size_type __n,
<         -: 1396:			     _ForwardIterator __first, _ForwardIterator __last)
<         -: 1397:	{
<        15: 1398:	  pointer __result = this->_M_allocate(__n);
<         -: 1399:	  __try
<         -: 1400:	    {
<        15: 1401:	      std::__uninitialized_copy_a(__first, __last, __result,
<        15: 1402:					  _M_get_Tp_allocator());
<        15: 1403:	      return __result;
<         -: 1404:	    }
<     =====: 1405:	  __catch(...)
<         -: 1406:	    {
<     =====: 1407:	      _M_deallocate(__result, __n);
<     =====: 1408:	      __throw_exception_again;
<         -: 1409:	    }
<         -: 1410:	}
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE20_M_allocate_and_copyISt13move_iteratorIPS3_EEES8_mT_SA_:
<         9: 1395:	_M_allocate_and_copy(size_type __n,
<         -: 1396:			     _ForwardIterator __first, _ForwardIterator __last)
<         -: 1397:	{
<         9: 1398:	  pointer __result = this->_M_allocate(__n);
<         -: 1399:	  __try
<         -: 1400:	    {
<         9: 1401:	      std::__uninitialized_copy_a(__first, __last, __result,
<         9: 1402:					  _M_get_Tp_allocator());
<         9: 1403:	      return __result;
<         -: 1404:	    }
<     =====: 1405:	  __catch(...)
<         -: 1406:	    {
<     =====: 1407:	      _M_deallocate(__result, __n);
<     =====: 1408:	      __throw_exception_again;
<         -: 1409:	    }
<         -: 1410:	}
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE20_M_allocate_and_copyISt13move_iteratorIPS7_EEESC_mT_SE_:
<         6: 1395:	_M_allocate_and_copy(size_type __n,
<         -: 1396:			     _ForwardIterator __first, _ForwardIterator __last)
<         -: 1397:	{
<         6: 1398:	  pointer __result = this->_M_allocate(__n);
<         -: 1399:	  __try
<         -: 1400:	    {
<         6: 1401:	      std::__uninitialized_copy_a(__first, __last, __result,
<         6: 1402:					  _M_get_Tp_allocator());
<         6: 1403:	      return __result;
<         -: 1404:	    }
<     =====: 1405:	  __catch(...)
<         -: 1406:	    {
<     =====: 1407:	      _M_deallocate(__result, __n);
<     =====: 1408:	      __throw_exception_again;
<         -: 1409:	    }
<         -: 1410:	}
< ------------------
<         -: 1411:
<         -: 1412:
<         -: 1413:      // Internal constructor functions follow.
---
>         -: 1388:      // Called by assign(n,t), and the range assign when it turns out
>         -: 1389:      // to be the same thing.
>         -: 1390:      void
>         -: 1391:      _M_fill_assign(size_type __n, const value_type& __val);
>         -: 1392:
>         -: 1393:      // Internal insert functions follow.
>         -: 1394:
>         -: 1395:      // Called by the range insert to implement [23.1.1]/9
>         -: 1396:
>         -: 1397:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -: 1398:      // 438. Ambiguity in the "do the right thing" clause
>         -: 1399:      template<typename _Integer>
>         -: 1400:	void
>         -: 1401:	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
>         -: 1402:			   __true_type)
>         -: 1403:	{ _M_fill_insert(__pos, __n, __val); }
>         -: 1404:
>         -: 1405:      // Called by the range insert to implement [23.1.1]/9
>         -: 1406:      template<typename _InputIterator>
>         -: 1407:	void
>         -: 1408:	_M_insert_dispatch(iterator __pos, _InputIterator __first,
>         -: 1409:			   _InputIterator __last, __false_type)
>         -: 1410:	{
>         -: 1411:	  _M_range_insert(__pos, __first, __last,
>         -: 1412:			  std::__iterator_category(__first));
>         -: 1413:	}
2471,2554c1417,1500
<         -: 1415:      // Called by the range constructor to implement [23.1.1]/9
<         -: 1416:
<         -: 1417:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 1418:      // 438. Ambiguity in the "do the right thing" clause
<         -: 1419:      template<typename _Integer>
<         -: 1420:	void
<         -: 1421:	_M_initialize_dispatch(_Integer __n, _Integer __value, __true_type)
<         -: 1422:	{
<         -: 1423:	  this->_M_impl._M_start = _M_allocate(static_cast<size_type>(__n));
<         -: 1424:	  this->_M_impl._M_end_of_storage =
<         -: 1425:	    this->_M_impl._M_start + static_cast<size_type>(__n);
<         -: 1426:	  _M_fill_initialize(static_cast<size_type>(__n), __value);
<         -: 1427:	}
<         -: 1428:
<         -: 1429:      // Called by the range constructor to implement [23.1.1]/9
<         -: 1430:      template<typename _InputIterator>
<         -: 1431:	void
<         -: 1432:	_M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
<         -: 1433:			       __false_type)
<         -: 1434:	{
<         -: 1435:	  typedef typename std::iterator_traits<_InputIterator>::
<         -: 1436:	    iterator_category _IterCategory;
<         -: 1437:	  _M_range_initialize(__first, __last, _IterCategory());
<         -: 1438:	}
<         -: 1439:
<         -: 1440:      // Called by the second initialize_dispatch above
<         -: 1441:      template<typename _InputIterator>
<         -: 1442:	void
<         -: 1443:	_M_range_initialize(_InputIterator __first, _InputIterator __last,
<         -: 1444:			    std::input_iterator_tag)
<         -: 1445:	{
<         -: 1446:	  __try {
<         -: 1447:	    for (; __first != __last; ++__first)
<         -: 1448:#if __cplusplus >= 201103L
<         -: 1449:	      emplace_back(*__first);
<         -: 1450:#else
<         -: 1451:	      push_back(*__first);
<         -: 1452:#endif
<         -: 1453:	  } __catch(...) {
<         -: 1454:	    clear();
<         -: 1455:	    __throw_exception_again;
<         -: 1456:	  }
<         -: 1457:	}
<         -: 1458:
<         -: 1459:      // Called by the second initialize_dispatch above
<         -: 1460:      template<typename _ForwardIterator>
<         -: 1461:	void
<         -: 1462:	_M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,
<         -: 1463:			    std::forward_iterator_tag)
<         -: 1464:	{
<         -: 1465:	  const size_type __n = std::distance(__first, __last);
<         -: 1466:	  this->_M_impl._M_start = this->_M_allocate(__n);
<         -: 1467:	  this->_M_impl._M_end_of_storage = this->_M_impl._M_start + __n;
<         -: 1468:	  this->_M_impl._M_finish =
<         -: 1469:	    std::__uninitialized_copy_a(__first, __last,
<         -: 1470:					this->_M_impl._M_start,
<         -: 1471:					_M_get_Tp_allocator());
<         -: 1472:	}
<         -: 1473:
<         -: 1474:      // Called by the first initialize_dispatch above and by the
<         -: 1475:      // vector(n,value,a) constructor.
<         -: 1476:      void
<         -: 1477:      _M_fill_initialize(size_type __n, const value_type& __value)
<         -: 1478:      {
<         -: 1479:	this->_M_impl._M_finish =
<         -: 1480:	  std::__uninitialized_fill_n_a(this->_M_impl._M_start, __n, __value,
<         -: 1481:					_M_get_Tp_allocator());
<         -: 1482:      }
<         -: 1483:
<         -: 1484:#if __cplusplus >= 201103L
<         -: 1485:      // Called by the vector(n) constructor.
<         -: 1486:      void
<         -: 1487:      _M_default_initialize(size_type __n)
<         -: 1488:      {
<         -: 1489:	this->_M_impl._M_finish =
<         -: 1490:	  std::__uninitialized_default_n_a(this->_M_impl._M_start, __n,
<         -: 1491:					   _M_get_Tp_allocator());
<         -: 1492:      }
<         -: 1493:#endif
<         -: 1494:
<         -: 1495:      // Internal assign functions follow.  The *_aux functions do the actual
<         -: 1496:      // assignment work for the range versions.
<         -: 1497:
<         -: 1498:      // Called by the range assign to implement [23.1.1]/9
---
>         -: 1415:      // Called by the second insert_dispatch above
>         -: 1416:      template<typename _InputIterator>
>         -: 1417:	void
>         -: 1418:	_M_range_insert(iterator __pos, _InputIterator __first,
>         -: 1419:			_InputIterator __last, std::input_iterator_tag);
>         -: 1420:
>         -: 1421:      // Called by the second insert_dispatch above
>         -: 1422:      template<typename _ForwardIterator>
>         -: 1423:	void
>         -: 1424:	_M_range_insert(iterator __pos, _ForwardIterator __first,
>         -: 1425:			_ForwardIterator __last, std::forward_iterator_tag);
>         -: 1426:
>         -: 1427:      // Called by insert(p,n,x), and the range insert when it turns out to be
>         -: 1428:      // the same thing.
>         -: 1429:      void
>         -: 1430:      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
>         -: 1431:
>         -: 1432:#if __cplusplus >= 201103L
>         -: 1433:      // Called by resize(n).
>         -: 1434:      void
>         -: 1435:      _M_default_append(size_type __n);
>         -: 1436:
>         -: 1437:      bool
>         -: 1438:      _M_shrink_to_fit();
>         -: 1439:#endif
>         -: 1440:
>         -: 1441:#if __cplusplus < 201103L
>         -: 1442:      // Called by insert(p,x)
>         -: 1443:      void
>         -: 1444:      _M_insert_aux(iterator __position, const value_type& __x);
>         -: 1445:
>         -: 1446:      void
>         -: 1447:      _M_realloc_insert(iterator __position, const value_type& __x);
>         -: 1448:#else
>         -: 1449:      // A value_type object constructed with _Alloc_traits::construct()
>         -: 1450:      // and destroyed with _Alloc_traits::destroy().
>         -: 1451:      struct _Temporary_value
>         -: 1452:      {
>         -: 1453:	template<typename... _Args>
>         -: 1454:	  explicit
>         -: 1455:	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
>         -: 1456:	  {
>         -: 1457:	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
>         -: 1458:				     std::forward<_Args>(__args)...);
>         -: 1459:	  }
>         -: 1460:
>         -: 1461:	~_Temporary_value()
>         -: 1462:	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
>         -: 1463:
>         -: 1464:	value_type&
>         -: 1465:	_M_val() { return *reinterpret_cast<_Tp*>(&__buf); }
>         -: 1466:
>         -: 1467:      private:
>         -: 1468:	pointer
>         -: 1469:	_M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }
>         -: 1470:
>         -: 1471:	vector* _M_this;
>         -: 1472:	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
>         -: 1473:      };
>         -: 1474:
>         -: 1475:      // Called by insert(p,x) and other functions when insertion needs to
>         -: 1476:      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
>         -: 1477:      template<typename _Arg>
>         -: 1478:	void
>         -: 1479:	_M_insert_aux(iterator __position, _Arg&& __arg);
>         -: 1480:
>         -: 1481:      template<typename... _Args>
>         -: 1482:	void
>         -: 1483:	_M_realloc_insert(iterator __position, _Args&&... __args);
>         -: 1484:
>         -: 1485:      // Either move-construct at the end, or forward to _M_insert_aux.
>         -: 1486:      iterator
>         -: 1487:      _M_insert_rval(const_iterator __position, value_type&& __v);
>         -: 1488:
>         -: 1489:      // Try to emplace at the end, otherwise forward to _M_insert_aux.
>         -: 1490:      template<typename... _Args>
>         -: 1491:	iterator
>         -: 1492:	_M_emplace_aux(const_iterator __position, _Args&&... __args);
>         -: 1493:
>         -: 1494:      // Emplacing an rvalue of the correct type can use _M_insert_rval.
>         -: 1495:      iterator
>         -: 1496:      _M_emplace_aux(const_iterator __position, value_type&& __v)
>         -: 1497:      { return _M_insert_rval(__position, std::move(__v)); }
>         -: 1498:#endif
2556,2561c1502,1507
<         -: 1500:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 1501:      // 438. Ambiguity in the "do the right thing" clause
<         -: 1502:      template<typename _Integer>
<         -: 1503:	void
<         -: 1504:	_M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
<         -: 1505:	{ _M_fill_assign(__n, __val); }
---
>         -: 1500:      // Called by _M_fill_insert, _M_insert_aux etc.
>         -: 1501:      size_type
>     #####: 1502:      _M_check_len(size_type __n, const char* __s) const
>         -: 1503:      {
>     #####: 1504:	if (max_size() - size() < __n)
>     #####: 1505:	  __throw_length_error(__N(__s));
2563,2619c1509,1565
<         -: 1507:      // Called by the range assign to implement [23.1.1]/9
<         -: 1508:      template<typename _InputIterator>
<         -: 1509:	void
<         -: 1510:	_M_assign_dispatch(_InputIterator __first, _InputIterator __last,
<         -: 1511:			   __false_type)
<         -: 1512:	{ _M_assign_aux(__first, __last, std::__iterator_category(__first)); }
<         -: 1513:
<         -: 1514:      // Called by the second assign_dispatch above
<         -: 1515:      template<typename _InputIterator>
<         -: 1516:	void
<         -: 1517:	_M_assign_aux(_InputIterator __first, _InputIterator __last,
<         -: 1518:		      std::input_iterator_tag);
<         -: 1519:
<         -: 1520:      // Called by the second assign_dispatch above
<         -: 1521:      template<typename _ForwardIterator>
<         -: 1522:	void
<         -: 1523:	_M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,
<         -: 1524:		      std::forward_iterator_tag);
<         -: 1525:
<         -: 1526:      // Called by assign(n,t), and the range assign when it turns out
<         -: 1527:      // to be the same thing.
<         -: 1528:      void
<         -: 1529:      _M_fill_assign(size_type __n, const value_type& __val);
<         -: 1530:
<         -: 1531:      // Internal insert functions follow.
<         -: 1532:
<         -: 1533:      // Called by the range insert to implement [23.1.1]/9
<         -: 1534:
<         -: 1535:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -: 1536:      // 438. Ambiguity in the "do the right thing" clause
<         -: 1537:      template<typename _Integer>
<         -: 1538:	void
<         -: 1539:	_M_insert_dispatch(iterator __pos, _Integer __n, _Integer __val,
<         -: 1540:			   __true_type)
<         -: 1541:	{ _M_fill_insert(__pos, __n, __val); }
<         -: 1542:
<         -: 1543:      // Called by the range insert to implement [23.1.1]/9
<         -: 1544:      template<typename _InputIterator>
<         -: 1545:	void
<         -: 1546:	_M_insert_dispatch(iterator __pos, _InputIterator __first,
<         -: 1547:			   _InputIterator __last, __false_type)
<         -: 1548:	{
<         -: 1549:	  _M_range_insert(__pos, __first, __last,
<         -: 1550:			  std::__iterator_category(__first));
<         -: 1551:	}
<         -: 1552:
<         -: 1553:      // Called by the second insert_dispatch above
<         -: 1554:      template<typename _InputIterator>
<         -: 1555:	void
<         -: 1556:	_M_range_insert(iterator __pos, _InputIterator __first,
<         -: 1557:			_InputIterator __last, std::input_iterator_tag);
<         -: 1558:
<         -: 1559:      // Called by the second insert_dispatch above
<         -: 1560:      template<typename _ForwardIterator>
<         -: 1561:	void
<         -: 1562:	_M_range_insert(iterator __pos, _ForwardIterator __first,
<         -: 1563:			_ForwardIterator __last, std::forward_iterator_tag);
---
>     #####: 1507:	const size_type __len = size() + std::max(size(), __n);
>     #####: 1508:	return (__len < size() || __len > max_size()) ? max_size() : __len;
>         -: 1509:      }
>         -: 1510:
>         -: 1511:      // Internal erase functions follow.
>         -: 1512:
>         -: 1513:      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
>         -: 1514:      // _M_assign_aux.
>         -: 1515:      void
>         -: 1516:      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
>         -: 1517:      {
>         -: 1518:	std::_Destroy(__pos, this->_M_impl._M_finish, _M_get_Tp_allocator());
>         -: 1519:	this->_M_impl._M_finish = __pos;
>         -: 1520:      }
>         -: 1521:
>         -: 1522:      iterator
>         -: 1523:      _M_erase(iterator __position);
>         -: 1524:
>         -: 1525:      iterator
>         -: 1526:      _M_erase(iterator __first, iterator __last);
>         -: 1527:
>         -: 1528:#if __cplusplus >= 201103L
>         -: 1529:    private:
>         -: 1530:      // Constant-time move assignment when source object's memory can be
>         -: 1531:      // moved, either because the source's allocator will move too
>         -: 1532:      // or because the allocators are equal.
>         -: 1533:      void
>         -: 1534:      _M_move_assign(vector&& __x, std::true_type) noexcept
>         -: 1535:      {
>         -: 1536:	vector __tmp(get_allocator());
>         -: 1537:	this->_M_impl._M_swap_data(__tmp._M_impl);
>         -: 1538:	this->_M_impl._M_swap_data(__x._M_impl);
>         -: 1539:	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
>         -: 1540:      }
>         -: 1541:
>         -: 1542:      // Do move assignment when it might not be possible to move source
>         -: 1543:      // object's memory, resulting in a linear-time operation.
>         -: 1544:      void
>         -: 1545:      _M_move_assign(vector&& __x, std::false_type)
>         -: 1546:      {
>         -: 1547:	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
>         -: 1548:	  _M_move_assign(std::move(__x), std::true_type());
>         -: 1549:	else
>         -: 1550:	  {
>         -: 1551:	    // The rvalue's allocator cannot be moved and is not equal,
>         -: 1552:	    // so we need to individually move each element.
>         -: 1553:	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
>         -: 1554:			 std::__make_move_if_noexcept_iterator(__x.end()));
>         -: 1555:	    __x.clear();
>         -: 1556:	  }
>         -: 1557:      }
>         -: 1558:#endif
>         -: 1559:
>         -: 1560:      template<typename _Up>
>         -: 1561:	_Up*
>         -: 1562:	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
>         -: 1563:	{ return __ptr; }
2621,2659c1567,1605
<         -: 1565:      // Called by insert(p,n,x), and the range insert when it turns out to be
<         -: 1566:      // the same thing.
<         -: 1567:      void
<         -: 1568:      _M_fill_insert(iterator __pos, size_type __n, const value_type& __x);
<         -: 1569:
<         -: 1570:#if __cplusplus >= 201103L
<         -: 1571:      // Called by resize(n).
<         -: 1572:      void
<         -: 1573:      _M_default_append(size_type __n);
<         -: 1574:
<         -: 1575:      bool
<         -: 1576:      _M_shrink_to_fit();
<         -: 1577:#endif
<         -: 1578:
<         -: 1579:#if __cplusplus < 201103L
<         -: 1580:      // Called by insert(p,x)
<         -: 1581:      void
<         -: 1582:      _M_insert_aux(iterator __position, const value_type& __x);
<         -: 1583:
<         -: 1584:      void
<         -: 1585:      _M_realloc_insert(iterator __position, const value_type& __x);
<         -: 1586:#else
<         -: 1587:      // A value_type object constructed with _Alloc_traits::construct()
<         -: 1588:      // and destroyed with _Alloc_traits::destroy().
<         -: 1589:      struct _Temporary_value
<         -: 1590:      {
<         -: 1591:	template<typename... _Args>
<         -: 1592:	  explicit
<     #####: 1593:	  _Temporary_value(vector* __vec, _Args&&... __args) : _M_this(__vec)
<         -: 1594:	  {
<     #####: 1595:	    _Alloc_traits::construct(_M_this->_M_impl, _M_ptr(),
<         -: 1596:				     std::forward<_Args>(__args)...);
<     #####: 1597:	  }
<         -: 1598:
<     #####: 1599:	~_Temporary_value()
<     #####: 1600:	{ _Alloc_traits::destroy(_M_this->_M_impl, _M_ptr()); }
<         -: 1601:
<         -: 1602:	value_type&
<     #####: 1603:	_M_val() { return *reinterpret_cast<_Tp*>(&__buf); }
---
>         -: 1565:#if __cplusplus >= 201103L
>         -: 1566:      template<typename _Ptr>
>         -: 1567:	typename std::pointer_traits<_Ptr>::element_type*
>         -: 1568:	_M_data_ptr(_Ptr __ptr) const
>         -: 1569:	{ return empty() ? nullptr : std::__addressof(*__ptr); }
>         -: 1570:#else
>         -: 1571:      template<typename _Up>
>         -: 1572:	_Up*
>         -: 1573:	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT
>         -: 1574:	{ return __ptr; }
>         -: 1575:
>         -: 1576:      template<typename _Ptr>
>         -: 1577:	value_type*
>         -: 1578:	_M_data_ptr(_Ptr __ptr)
>         -: 1579:	{ return __ptr.operator->(); }
>         -: 1580:
>         -: 1581:      template<typename _Ptr>
>         -: 1582:	const value_type*
>         -: 1583:	_M_data_ptr(_Ptr __ptr) const
>         -: 1584:	{ return __ptr.operator->(); }
>         -: 1585:#endif
>         -: 1586:    };
>         -: 1587:
>         -: 1588:
>         -: 1589:  /**
>         -: 1590:   *  @brief  Vector equality comparison.
>         -: 1591:   *  @param  __x  A %vector.
>         -: 1592:   *  @param  __y  A %vector of the same type as @a __x.
>         -: 1593:   *  @return  True iff the size and elements of the vectors are equal.
>         -: 1594:   *
>         -: 1595:   *  This is an equivalence relation.  It is linear in the size of the
>         -: 1596:   *  vectors.  Vectors are considered equivalent if their sizes are equal,
>         -: 1597:   *  and if corresponding elements compare equal.
>         -: 1598:  */
>         -: 1599:  template<typename _Tp, typename _Alloc>
>         -: 1600:    inline bool
>         -: 1601:    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
>         -: 1602:    { return (__x.size() == __y.size()
>         -: 1603:	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
2661,3015c1607,1658
<         -: 1605:      private:
<         -: 1606:	pointer
<     #####: 1607:	_M_ptr() { return pointer_traits<pointer>::pointer_to(_M_val()); }
<         -: 1608:
<         -: 1609:	vector* _M_this;
<         -: 1610:	typename aligned_storage<sizeof(_Tp), alignof(_Tp)>::type __buf;
<         -: 1611:      };
<         -: 1612:
<         -: 1613:      // Called by insert(p,x) and other functions when insertion needs to
<         -: 1614:      // reallocate or move existing elements. _Arg is either _Tp& or _Tp.
<         -: 1615:      template<typename _Arg>
<         -: 1616:	void
<         -: 1617:	_M_insert_aux(iterator __position, _Arg&& __arg);
<         -: 1618:
<         -: 1619:      template<typename... _Args>
<         -: 1620:	void
<         -: 1621:	_M_realloc_insert(iterator __position, _Args&&... __args);
<         -: 1622:
<         -: 1623:      // Either move-construct at the end, or forward to _M_insert_aux.
<         -: 1624:      iterator
<         -: 1625:      _M_insert_rval(const_iterator __position, value_type&& __v);
<         -: 1626:
<         -: 1627:      // Try to emplace at the end, otherwise forward to _M_insert_aux.
<         -: 1628:      template<typename... _Args>
<         -: 1629:	iterator
<         -: 1630:	_M_emplace_aux(const_iterator __position, _Args&&... __args);
<         -: 1631:
<         -: 1632:      // Emplacing an rvalue of the correct type can use _M_insert_rval.
<         -: 1633:      iterator
<         -: 1634:      _M_emplace_aux(const_iterator __position, value_type&& __v)
<         -: 1635:      { return _M_insert_rval(__position, std::move(__v)); }
<         -: 1636:#endif
<         -: 1637:
<         -: 1638:      // Called by _M_fill_insert, _M_insert_aux etc.
<         -: 1639:      size_type
<      166*: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<      166*: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<      166*: 1645:	const size_type __len = size() + std::max(size(), __n);
<      166*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE12_M_check_lenEmPKc:
<         2: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<         2: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<         2: 1645:	const size_type __len = size() + std::max(size(), __n);
<        2*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorI13ACE_INET_AddrSaIS0_EE12_M_check_lenEmPKc:
<     #####: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<     #####: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<     #####: 1645:	const size_type __len = size() + std::max(size(), __n);
<     #####: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS12HostnameInfoESaIS2_EE12_M_check_lenEmPKc:
<         6: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<         6: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<         6: 1645:	const size_type __len = size() + std::max(size(), __n);
<        6*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS12WeakRcHandleINS1_24TransportReceiveListenerEEESaIS4_EE12_M_check_lenEmPKc:
<        42: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<        42: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<        42: 1645:	const size_type __len = size() + std::max(size(), __n);
<       42*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE12_M_check_lenEmPKc:
<        23: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<        23: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<        23: 1645:	const size_type __len = size() + std::max(size(), __n);
<       23*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE12_M_check_lenEmPKc:
<     #####: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<     #####: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<     #####: 1645:	const size_type __len = size() + std::max(size(), __n);
<     #####: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorIN7OpenDDS4DCPS8RcHandleINS1_13TransportInstEEESaIS4_EE12_M_check_lenEmPKc:
<        89: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<        89: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<        89: 1645:	const size_type __len = size() + std::max(size(), __n);
<       89*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorISt4pairIN7OpenDDS4DCPS8RcHandleINS2_15TransportConfigEEES_INSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaISB_EEESaISE_EE12_M_check_lenEmPKc:
<     #####: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<     #####: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<     #####: 1645:	const size_type __len = size() + std::max(size(), __n);
<     #####: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorINSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEESaIS5_EE12_M_check_lenEmPKc:
<     #####: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<     #####: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<     #####: 1645:	const size_type __len = size() + std::max(size(), __n);
<     #####: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
< _ZNKSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE12_M_check_lenEmPKc:
<         4: 1640:      _M_check_len(size_type __n, const char* __s) const
<         -: 1641:      {
<         4: 1642:	if (max_size() - size() < __n)
<     #####: 1643:	  __throw_length_error(__N(__s));
<         -: 1644:
<         4: 1645:	const size_type __len = size() + std::max(size(), __n);
<        4*: 1646:	return (__len < size() || __len > max_size()) ? max_size() : __len;
<         -: 1647:      }
< ------------------
<         -: 1648:
<         -: 1649:      // Internal erase functions follow.
<         -: 1650:
<         -: 1651:      // Called by erase(q1,q2), clear(), resize(), _M_fill_assign,
<         -: 1652:      // _M_assign_aux.
<         -: 1653:      void
<       65*: 1654:      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
<         -: 1655:      {
<       65*: 1656:	if (size_type __n = this->_M_impl._M_finish - __pos)
<         -: 1657:	  {
<       41*: 1658:	    std::_Destroy(__pos, this->_M_impl._M_finish,
<       41*: 1659:			  _M_get_Tp_allocator());
<       41*: 1660:	    this->_M_impl._M_finish = __pos;
<         -: 1661:	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
<         -: 1662:	  }
<       65*: 1663:      }
< ------------------
< _ZNSt6vectorISt4pairIN7OpenDDS4DCPS12WeakRcHandleINS2_15TransportClientEEENS2_6GUID_tEESaIS7_EE15_M_erase_at_endEPS7_:
<     #####: 1654:      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
<         -: 1655:      {
<     #####: 1656:	if (size_type __n = this->_M_impl._M_finish - __pos)
<         -: 1657:	  {
<     #####: 1658:	    std::_Destroy(__pos, this->_M_impl._M_finish,
<     #####: 1659:			  _M_get_Tp_allocator());
<     #####: 1660:	    this->_M_impl._M_finish = __pos;
<         -: 1661:	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
<         -: 1662:	  }
<     #####: 1663:      }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE15_M_erase_at_endEPS7_:
<     #####: 1654:      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
<         -: 1655:      {
<     #####: 1656:	if (size_type __n = this->_M_impl._M_finish - __pos)
<         -: 1657:	  {
<     #####: 1658:	    std::_Destroy(__pos, this->_M_impl._M_finish,
<     #####: 1659:			  _M_get_Tp_allocator());
<     #####: 1660:	    this->_M_impl._M_finish = __pos;
<         -: 1661:	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
<         -: 1662:	  }
<     #####: 1663:      }
< ------------------
< _ZNSt6vectorIPN7OpenDDS4DCPS13TransportImplESaIS3_EE15_M_erase_at_endEPS3_:
<        18: 1654:      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
<         -: 1655:      {
<        18: 1656:	if (size_type __n = this->_M_impl._M_finish - __pos)
<         -: 1657:	  {
<     #####: 1658:	    std::_Destroy(__pos, this->_M_impl._M_finish,
<     #####: 1659:			  _M_get_Tp_allocator());
<     #####: 1660:	    this->_M_impl._M_finish = __pos;
<         -: 1661:	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
<         -: 1662:	  }
<        18: 1663:      }
< ------------------
< _ZNSt6vectorISt4pairIPN7OpenDDS4DCPS21TransportQueueElementENS2_21TransportSendStrategy8SendModeEESaIS7_EE15_M_erase_at_endEPS7_:
<        47: 1654:      _M_erase_at_end(pointer __pos) _GLIBCXX_NOEXCEPT
<         -: 1655:      {
<        47: 1656:	if (size_type __n = this->_M_impl._M_finish - __pos)
<         -: 1657:	  {
<        41: 1658:	    std::_Destroy(__pos, this->_M_impl._M_finish,
<        41: 1659:			  _M_get_Tp_allocator());
<        41: 1660:	    this->_M_impl._M_finish = __pos;
<         -: 1661:	    _GLIBCXX_ASAN_ANNOTATE_SHRINK(__n);
<         -: 1662:	  }
<        47: 1663:      }
< ------------------
<         -: 1664:
<         -: 1665:      iterator
<         -: 1666:      _M_erase(iterator __position);
<         -: 1667:
<         -: 1668:      iterator
<         -: 1669:      _M_erase(iterator __first, iterator __last);
<         -: 1670:
<         -: 1671:#if __cplusplus >= 201103L
<         -: 1672:    private:
<         -: 1673:      // Constant-time move assignment when source object's memory can be
<         -: 1674:      // moved, either because the source's allocator will move too
<         -: 1675:      // or because the allocators are equal.
<         -: 1676:      void
<         -: 1677:      _M_move_assign(vector&& __x, std::true_type) noexcept
<         -: 1678:      {
<         -: 1679:	vector __tmp(get_allocator());
<         -: 1680:	this->_M_impl._M_swap_data(__tmp._M_impl);
<         -: 1681:	this->_M_impl._M_swap_data(__x._M_impl);
<         -: 1682:	std::__alloc_on_move(_M_get_Tp_allocator(), __x._M_get_Tp_allocator());
<         -: 1683:      }
<         -: 1684:
<         -: 1685:      // Do move assignment when it might not be possible to move source
<         -: 1686:      // object's memory, resulting in a linear-time operation.
<         -: 1687:      void
<         -: 1688:      _M_move_assign(vector&& __x, std::false_type)
<         -: 1689:      {
<         -: 1690:	if (__x._M_get_Tp_allocator() == this->_M_get_Tp_allocator())
<         -: 1691:	  _M_move_assign(std::move(__x), std::true_type());
<         -: 1692:	else
<         -: 1693:	  {
<         -: 1694:	    // The rvalue's allocator cannot be moved and is not equal,
<         -: 1695:	    // so we need to individually move each element.
<         -: 1696:	    this->assign(std::__make_move_if_noexcept_iterator(__x.begin()),
<         -: 1697:			 std::__make_move_if_noexcept_iterator(__x.end()));
<         -: 1698:	    __x.clear();
<         -: 1699:	  }
<         -: 1700:      }
<         -: 1701:#endif
<         -: 1702:
<         -: 1703:      template<typename _Up>
<         -: 1704:	_Up*
<         -: 1705:	_M_data_ptr(_Up* __ptr) const _GLIBCXX_NOEXCEPT
<         -: 1706:	{ return __ptr; }
<         -: 1707:
<         -: 1708:#if __cplusplus >= 201103L
<         -: 1709:      template<typename _Ptr>
<         -: 1710:	typename std::pointer_traits<_Ptr>::element_type*
<         -: 1711:	_M_data_ptr(_Ptr __ptr) const
<         -: 1712:	{ return empty() ? nullptr : std::__to_address(__ptr); }
<         -: 1713:#else
<         -: 1714:      template<typename _Up>
<         -: 1715:	_Up*
<         -: 1716:	_M_data_ptr(_Up* __ptr) _GLIBCXX_NOEXCEPT
<         -: 1717:	{ return __ptr; }
<         -: 1718:
<         -: 1719:      template<typename _Ptr>
<         -: 1720:	value_type*
<         -: 1721:	_M_data_ptr(_Ptr __ptr)
<         -: 1722:	{ return empty() ? (value_type*)0 : __ptr.operator->(); }
<         -: 1723:
<         -: 1724:      template<typename _Ptr>
<         -: 1725:	const value_type*
<         -: 1726:	_M_data_ptr(_Ptr __ptr) const
<         -: 1727:	{ return empty() ? (const value_type*)0 : __ptr.operator->(); }
<         -: 1728:#endif
<         -: 1729:    };
<         -: 1730:
<         -: 1731:#if __cpp_deduction_guides >= 201606
<         -: 1732:  template<typename _InputIterator, typename _ValT
<         -: 1733:	     = typename iterator_traits<_InputIterator>::value_type,
<         -: 1734:	   typename _Allocator = allocator<_ValT>,
<         -: 1735:	   typename = _RequireInputIter<_InputIterator>,
<         -: 1736:	   typename = _RequireAllocator<_Allocator>>
<         -: 1737:    vector(_InputIterator, _InputIterator, _Allocator = _Allocator())
<         -: 1738:      -> vector<_ValT, _Allocator>;
<         -: 1739:#endif
<         -: 1740:
<         -: 1741:  /**
<         -: 1742:   *  @brief  Vector equality comparison.
<         -: 1743:   *  @param  __x  A %vector.
<         -: 1744:   *  @param  __y  A %vector of the same type as @a __x.
<         -: 1745:   *  @return  True iff the size and elements of the vectors are equal.
<         -: 1746:   *
<         -: 1747:   *  This is an equivalence relation.  It is linear in the size of the
<         -: 1748:   *  vectors.  Vectors are considered equivalent if their sizes are equal,
<         -: 1749:   *  and if corresponding elements compare equal.
<         -: 1750:  */
<         -: 1751:  template<typename _Tp, typename _Alloc>
<         -: 1752:    inline bool
<         -: 1753:    operator==(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
<         -: 1754:    { return (__x.size() == __y.size()
<         -: 1755:	      && std::equal(__x.begin(), __x.end(), __y.begin())); }
<         -: 1756:
<         -: 1757:  /**
<         -: 1758:   *  @brief  Vector ordering relation.
<         -: 1759:   *  @param  __x  A %vector.
<         -: 1760:   *  @param  __y  A %vector of the same type as @a __x.
<         -: 1761:   *  @return  True iff @a __x is lexicographically less than @a __y.
<         -: 1762:   *
<         -: 1763:   *  This is a total ordering relation.  It is linear in the size of the
<         -: 1764:   *  vectors.  The elements must be comparable with @c <.
<         -: 1765:   *
<         -: 1766:   *  See std::lexicographical_compare() for how the determination is made.
<         -: 1767:  */
<         -: 1768:  template<typename _Tp, typename _Alloc>
<         -: 1769:    inline bool
<         -: 1770:    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
<         -: 1771:    { return std::lexicographical_compare(__x.begin(), __x.end(),
<         -: 1772:					  __y.begin(), __y.end()); }
<         -: 1773:
<         -: 1774:  /// Based on operator==
<         -: 1775:  template<typename _Tp, typename _Alloc>
<         -: 1776:    inline bool
<         -: 1777:    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
<         -: 1778:    { return !(__x == __y); }
<         -: 1779:
<         -: 1780:  /// Based on operator<
<         -: 1781:  template<typename _Tp, typename _Alloc>
<         -: 1782:    inline bool
<         -: 1783:    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
<         -: 1784:    { return __y < __x; }
<         -: 1785:
<         -: 1786:  /// Based on operator<
<         -: 1787:  template<typename _Tp, typename _Alloc>
<         -: 1788:    inline bool
<         -: 1789:    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
<         -: 1790:    { return !(__y < __x); }
<         -: 1791:
<         -: 1792:  /// Based on operator<
<         -: 1793:  template<typename _Tp, typename _Alloc>
<         -: 1794:    inline bool
<         -: 1795:    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
<         -: 1796:    { return !(__x < __y); }
<         -: 1797:
<         -: 1798:  /// See std::vector::swap().
<         -: 1799:  template<typename _Tp, typename _Alloc>
<         -: 1800:    inline void
<         -: 1801:    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
<         -: 1802:    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
<         -: 1803:    { __x.swap(__y); }
<         -: 1804:
<         -: 1805:_GLIBCXX_END_NAMESPACE_CONTAINER
<         -: 1806:_GLIBCXX_END_NAMESPACE_VERSION
<         -: 1807:} // namespace std
<         -: 1808:
<         -: 1809:#endif /* _STL_VECTOR_H */
---
>         -: 1605:  /**
>         -: 1606:   *  @brief  Vector ordering relation.
>         -: 1607:   *  @param  __x  A %vector.
>         -: 1608:   *  @param  __y  A %vector of the same type as @a __x.
>         -: 1609:   *  @return  True iff @a __x is lexicographically less than @a __y.
>         -: 1610:   *
>         -: 1611:   *  This is a total ordering relation.  It is linear in the size of the
>         -: 1612:   *  vectors.  The elements must be comparable with @c <.
>         -: 1613:   *
>         -: 1614:   *  See std::lexicographical_compare() for how the determination is made.
>         -: 1615:  */
>         -: 1616:  template<typename _Tp, typename _Alloc>
>         -: 1617:    inline bool
>         -: 1618:    operator<(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
>         -: 1619:    { return std::lexicographical_compare(__x.begin(), __x.end(),
>         -: 1620:					  __y.begin(), __y.end()); }
>         -: 1621:
>         -: 1622:  /// Based on operator==
>         -: 1623:  template<typename _Tp, typename _Alloc>
>         -: 1624:    inline bool
>         -: 1625:    operator!=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
>         -: 1626:    { return !(__x == __y); }
>         -: 1627:
>         -: 1628:  /// Based on operator<
>         -: 1629:  template<typename _Tp, typename _Alloc>
>         -: 1630:    inline bool
>         -: 1631:    operator>(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
>         -: 1632:    { return __y < __x; }
>         -: 1633:
>         -: 1634:  /// Based on operator<
>         -: 1635:  template<typename _Tp, typename _Alloc>
>         -: 1636:    inline bool
>         -: 1637:    operator<=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
>         -: 1638:    { return !(__y < __x); }
>         -: 1639:
>         -: 1640:  /// Based on operator<
>         -: 1641:  template<typename _Tp, typename _Alloc>
>         -: 1642:    inline bool
>         -: 1643:    operator>=(const vector<_Tp, _Alloc>& __x, const vector<_Tp, _Alloc>& __y)
>         -: 1644:    { return !(__x < __y); }
>         -: 1645:
>         -: 1646:  /// See std::vector::swap().
>         -: 1647:  template<typename _Tp, typename _Alloc>
>         -: 1648:    inline void
>         -: 1649:    swap(vector<_Tp, _Alloc>& __x, vector<_Tp, _Alloc>& __y)
>         -: 1650:    _GLIBCXX_NOEXCEPT_IF(noexcept(__x.swap(__y)))
>         -: 1651:    { __x.swap(__y); }
>         -: 1652:
>         -: 1653:_GLIBCXX_END_NAMESPACE_CONTAINER
>         -: 1654:} // namespace std
>         -: 1655:
>         -: 1656:#endif /* _STL_VECTOR_H */
