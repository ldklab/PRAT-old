1c1
<         -:    0:Source:/usr/include/c++/8/bits/stl_queue.h
---
>         -:    0:Source:/usr/include/c++/7/bits/stl_queue.h
5c5
<         -:    3:// Copyright (C) 2001-2018 Free Software Foundation, Inc.
---
>         -:    3:// Copyright (C) 2001-2017 Free Software Foundation, Inc.
307,347c307,347
<         -:  305:#if __cpp_deduction_guides >= 201606
<         -:  306:  template<typename _Container,
<         -:  307:	   typename = enable_if_t<!__is_allocator<_Container>::value>>
<         -:  308:    queue(_Container) -> queue<typename _Container::value_type, _Container>;
<         -:  309:
<         -:  310:  template<typename _Container, typename _Allocator,
<         -:  311:	   typename = enable_if_t<!__is_allocator<_Container>::value>,
<         -:  312:	   typename = enable_if_t<__is_allocator<_Allocator>::value>>
<         -:  313:    queue(_Container, _Allocator)
<         -:  314:    -> queue<typename _Container::value_type, _Container>;
<         -:  315:#endif
<         -:  316:
<         -:  317:  /**
<         -:  318:   *  @brief  Queue equality comparison.
<         -:  319:   *  @param  __x  A %queue.
<         -:  320:   *  @param  __y  A %queue of the same type as @a __x.
<         -:  321:   *  @return  True iff the size and elements of the queues are equal.
<         -:  322:   *
<         -:  323:   *  This is an equivalence relation.  Complexity and semantics depend on the
<         -:  324:   *  underlying sequence type, but the expected rules are:  this relation is
<         -:  325:   *  linear in the size of the sequences, and queues are considered equivalent
<         -:  326:   *  if their sequences compare equal.
<         -:  327:  */
<         -:  328:  template<typename _Tp, typename _Seq>
<         -:  329:    inline bool
<         -:  330:    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
<         -:  331:    { return __x.c == __y.c; }
<         -:  332:
<         -:  333:  /**
<         -:  334:   *  @brief  Queue ordering relation.
<         -:  335:   *  @param  __x  A %queue.
<         -:  336:   *  @param  __y  A %queue of the same type as @a x.
<         -:  337:   *  @return  True iff @a __x is lexicographically less than @a __y.
<         -:  338:   *
<         -:  339:   *  This is an total ordering relation.  Complexity and semantics
<         -:  340:   *  depend on the underlying sequence type, but the expected rules
<         -:  341:   *  are: this relation is linear in the size of the sequences, the
<         -:  342:   *  elements must be comparable with @c <, and
<         -:  343:   *  std::lexicographical_compare() is usually used to make the
<         -:  344:   *  determination.
<         -:  345:  */
---
>         -:  305:  /**
>         -:  306:   *  @brief  Queue equality comparison.
>         -:  307:   *  @param  __x  A %queue.
>         -:  308:   *  @param  __y  A %queue of the same type as @a __x.
>         -:  309:   *  @return  True iff the size and elements of the queues are equal.
>         -:  310:   *
>         -:  311:   *  This is an equivalence relation.  Complexity and semantics depend on the
>         -:  312:   *  underlying sequence type, but the expected rules are:  this relation is
>         -:  313:   *  linear in the size of the sequences, and queues are considered equivalent
>         -:  314:   *  if their sequences compare equal.
>         -:  315:  */
>         -:  316:  template<typename _Tp, typename _Seq>
>         -:  317:    inline bool
>         -:  318:    operator==(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
>         -:  319:    { return __x.c == __y.c; }
>         -:  320:
>         -:  321:  /**
>         -:  322:   *  @brief  Queue ordering relation.
>         -:  323:   *  @param  __x  A %queue.
>         -:  324:   *  @param  __y  A %queue of the same type as @a x.
>         -:  325:   *  @return  True iff @a __x is lexicographically less than @a __y.
>         -:  326:   *
>         -:  327:   *  This is an total ordering relation.  Complexity and semantics
>         -:  328:   *  depend on the underlying sequence type, but the expected rules
>         -:  329:   *  are: this relation is linear in the size of the sequences, the
>         -:  330:   *  elements must be comparable with @c <, and
>         -:  331:   *  std::lexicographical_compare() is usually used to make the
>         -:  332:   *  determination.
>         -:  333:  */
>         -:  334:  template<typename _Tp, typename _Seq>
>         -:  335:    inline bool
>         -:  336:    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
>         -:  337:    { return __x.c < __y.c; }
>         -:  338:
>         -:  339:  /// Based on operator==
>         -:  340:  template<typename _Tp, typename _Seq>
>         -:  341:    inline bool
>         -:  342:    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
>         -:  343:    { return !(__x == __y); }
>         -:  344:
>         -:  345:  /// Based on operator<
350,351c350,351
<         -:  348:    operator<(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
<         -:  349:    { return __x.c < __y.c; }
---
>         -:  348:    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
>         -:  349:    { return __y < __x; }
353c353
<         -:  351:  /// Based on operator==
---
>         -:  351:  /// Based on operator<
356,357c356,357
<         -:  354:    operator!=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
<         -:  355:    { return !(__x == __y); }
---
>         -:  354:    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
>         -:  355:    { return !(__y < __x); }
362,363c362,363
<         -:  360:    operator>(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
<         -:  361:    { return __y < __x; }
---
>         -:  360:    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
>         -:  361:    { return !(__x < __y); }
365c365
<         -:  363:  /// Based on operator<
---
>         -:  363:#if __cplusplus >= 201103L
367,403c367,403
<         -:  365:    inline bool
<         -:  366:    operator<=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
<         -:  367:    { return !(__y < __x); }
<         -:  368:
<         -:  369:  /// Based on operator<
<         -:  370:  template<typename _Tp, typename _Seq>
<         -:  371:    inline bool
<         -:  372:    operator>=(const queue<_Tp, _Seq>& __x, const queue<_Tp, _Seq>& __y)
<         -:  373:    { return !(__x < __y); }
<         -:  374:
<         -:  375:#if __cplusplus >= 201103L
<         -:  376:  template<typename _Tp, typename _Seq>
<         -:  377:    inline
<         -:  378:#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
<         -:  379:    // Constrained free swap overload, see p0185r1
<         -:  380:    typename enable_if<__is_swappable<_Seq>::value>::type
<         -:  381:#else
<         -:  382:    void
<         -:  383:#endif
<         -:  384:    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
<         -:  385:    noexcept(noexcept(__x.swap(__y)))
<         -:  386:    { __x.swap(__y); }
<         -:  387:
<         -:  388:  template<typename _Tp, typename _Seq, typename _Alloc>
<         -:  389:    struct uses_allocator<queue<_Tp, _Seq>, _Alloc>
<         -:  390:    : public uses_allocator<_Seq, _Alloc>::type { };
<         -:  391:#endif // __cplusplus >= 201103L
<         -:  392:
<         -:  393:  /**
<         -:  394:   *  @brief  A standard container automatically sorting its contents.
<         -:  395:   *
<         -:  396:   *  @ingroup sequences
<         -:  397:   *
<         -:  398:   *  @tparam _Tp  Type of element.
<         -:  399:   *  @tparam _Sequence  Type of underlying sequence, defaults to vector<_Tp>.
<         -:  400:   *  @tparam _Compare  Comparison function object type, defaults to
<         -:  401:   *                    less<_Sequence::value_type>.
---
>         -:  365:    inline
>         -:  366:#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
>         -:  367:    // Constrained free swap overload, see p0185r1
>         -:  368:    typename enable_if<__is_swappable<_Seq>::value>::type
>         -:  369:#else
>         -:  370:    void
>         -:  371:#endif
>         -:  372:    swap(queue<_Tp, _Seq>& __x, queue<_Tp, _Seq>& __y)
>         -:  373:    noexcept(noexcept(__x.swap(__y)))
>         -:  374:    { __x.swap(__y); }
>         -:  375:
>         -:  376:  template<typename _Tp, typename _Seq, typename _Alloc>
>         -:  377:    struct uses_allocator<queue<_Tp, _Seq>, _Alloc>
>         -:  378:    : public uses_allocator<_Seq, _Alloc>::type { };
>         -:  379:#endif // __cplusplus >= 201103L
>         -:  380:
>         -:  381:  /**
>         -:  382:   *  @brief  A standard container automatically sorting its contents.
>         -:  383:   *
>         -:  384:   *  @ingroup sequences
>         -:  385:   *
>         -:  386:   *  @tparam _Tp  Type of element.
>         -:  387:   *  @tparam _Sequence  Type of underlying sequence, defaults to vector<_Tp>.
>         -:  388:   *  @tparam _Compare  Comparison function object type, defaults to
>         -:  389:   *                    less<_Sequence::value_type>.
>         -:  390:   *
>         -:  391:   *  This is not a true container, but an @e adaptor.  It holds
>         -:  392:   *  another container, and provides a wrapper interface to that
>         -:  393:   *  container.  The wrapper is what enforces priority-based sorting
>         -:  394:   *  and %queue behavior.  Very few of the standard container/sequence
>         -:  395:   *  interface requirements are met (e.g., iterators).
>         -:  396:   *
>         -:  397:   *  The second template parameter defines the type of the underlying
>         -:  398:   *  sequence/container.  It defaults to std::vector, but it can be
>         -:  399:   *  any type that supports @c front(), @c push_back, @c pop_back,
>         -:  400:   *  and random-access iterators, such as std::deque or an
>         -:  401:   *  appropriate user-defined type.
405,477c405,477
<         -:  403:   *  This is not a true container, but an @e adaptor.  It holds
<         -:  404:   *  another container, and provides a wrapper interface to that
<         -:  405:   *  container.  The wrapper is what enforces priority-based sorting
<         -:  406:   *  and %queue behavior.  Very few of the standard container/sequence
<         -:  407:   *  interface requirements are met (e.g., iterators).
<         -:  408:   *
<         -:  409:   *  The second template parameter defines the type of the underlying
<         -:  410:   *  sequence/container.  It defaults to std::vector, but it can be
<         -:  411:   *  any type that supports @c front(), @c push_back, @c pop_back,
<         -:  412:   *  and random-access iterators, such as std::deque or an
<         -:  413:   *  appropriate user-defined type.
<         -:  414:   *
<         -:  415:   *  The third template parameter supplies the means of making
<         -:  416:   *  priority comparisons.  It defaults to @c less<value_type> but
<         -:  417:   *  can be anything defining a strict weak ordering.
<         -:  418:   *
<         -:  419:   *  Members not found in @a normal containers are @c container_type,
<         -:  420:   *  which is a typedef for the second Sequence parameter, and @c
<         -:  421:   *  push, @c pop, and @c top, which are standard %queue operations.
<         -:  422:   *
<         -:  423:   *  @note No equality/comparison operators are provided for
<         -:  424:   *  %priority_queue.
<         -:  425:   *
<         -:  426:   *  @note Sorting of the elements takes place as they are added to,
<         -:  427:   *  and removed from, the %priority_queue using the
<         -:  428:   *  %priority_queue's member functions.  If you access the elements
<         -:  429:   *  by other means, and change their data such that the sorting
<         -:  430:   *  order would be different, the %priority_queue will not re-sort
<         -:  431:   *  the elements for you.  (How could it know to do so?)
<         -:  432:  */
<         -:  433:  template<typename _Tp, typename _Sequence = vector<_Tp>,
<         -:  434:	   typename _Compare  = less<typename _Sequence::value_type> >
<         -:  435:    class priority_queue
<         -:  436:    {
<         -:  437:#ifdef _GLIBCXX_CONCEPT_CHECKS
<         -:  438:      // concept requirements
<         -:  439:      typedef typename _Sequence::value_type _Sequence_value_type;
<         -:  440:# if __cplusplus < 201103L
<         -:  441:      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
<         -:  442:# endif
<         -:  443:      __glibcxx_class_requires(_Sequence, _SequenceConcept)
<         -:  444:      __glibcxx_class_requires(_Sequence, _RandomAccessContainerConcept)
<         -:  445:      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)
<         -:  446:      __glibcxx_class_requires4(_Compare, bool, _Tp, _Tp,
<         -:  447:				_BinaryFunctionConcept)
<         -:  448:#endif
<         -:  449:
<         -:  450:#if __cplusplus >= 201103L
<         -:  451:      template<typename _Alloc>
<         -:  452:	using _Uses = typename
<         -:  453:	  enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;
<         -:  454:#endif
<         -:  455:
<         -:  456:    public:
<         -:  457:      typedef typename	_Sequence::value_type		value_type;
<         -:  458:      typedef typename	_Sequence::reference		 reference;
<         -:  459:      typedef typename	_Sequence::const_reference	   const_reference;
<         -:  460:      typedef typename	_Sequence::size_type		 size_type;
<         -:  461:      typedef		_Sequence			    container_type;
<         -:  462:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
<         -:  463:      // DR 2684. priority_queue lacking comparator typedef
<         -:  464:      typedef	       _Compare				    value_compare;
<         -:  465:
<         -:  466:    protected:
<         -:  467:      //  See queue::c for notes on these names.
<         -:  468:      _Sequence  c;
<         -:  469:      _Compare   comp;
<         -:  470:
<         -:  471:    public:
<         -:  472:      /**
<         -:  473:       *  @brief  Default constructor creates no elements.
<         -:  474:       */
<         -:  475:#if __cplusplus < 201103L
---
>         -:  403:   *  The third template parameter supplies the means of making
>         -:  404:   *  priority comparisons.  It defaults to @c less<value_type> but
>         -:  405:   *  can be anything defining a strict weak ordering.
>         -:  406:   *
>         -:  407:   *  Members not found in @a normal containers are @c container_type,
>         -:  408:   *  which is a typedef for the second Sequence parameter, and @c
>         -:  409:   *  push, @c pop, and @c top, which are standard %queue operations.
>         -:  410:   *
>         -:  411:   *  @note No equality/comparison operators are provided for
>         -:  412:   *  %priority_queue.
>         -:  413:   *
>         -:  414:   *  @note Sorting of the elements takes place as they are added to,
>         -:  415:   *  and removed from, the %priority_queue using the
>         -:  416:   *  %priority_queue's member functions.  If you access the elements
>         -:  417:   *  by other means, and change their data such that the sorting
>         -:  418:   *  order would be different, the %priority_queue will not re-sort
>         -:  419:   *  the elements for you.  (How could it know to do so?)
>         -:  420:  */
>         -:  421:  template<typename _Tp, typename _Sequence = vector<_Tp>,
>         -:  422:	   typename _Compare  = less<typename _Sequence::value_type> >
>         -:  423:    class priority_queue
>         -:  424:    {
>         -:  425:#ifdef _GLIBCXX_CONCEPT_CHECKS
>         -:  426:      // concept requirements
>         -:  427:      typedef typename _Sequence::value_type _Sequence_value_type;
>         -:  428:# if __cplusplus < 201103L
>         -:  429:      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)
>         -:  430:# endif
>         -:  431:      __glibcxx_class_requires(_Sequence, _SequenceConcept)
>         -:  432:      __glibcxx_class_requires(_Sequence, _RandomAccessContainerConcept)
>         -:  433:      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)
>         -:  434:      __glibcxx_class_requires4(_Compare, bool, _Tp, _Tp,
>         -:  435:				_BinaryFunctionConcept)
>         -:  436:#endif
>         -:  437:
>         -:  438:#if __cplusplus >= 201103L
>         -:  439:      template<typename _Alloc>
>         -:  440:	using _Uses = typename
>         -:  441:	  enable_if<uses_allocator<_Sequence, _Alloc>::value>::type;
>         -:  442:#endif
>         -:  443:
>         -:  444:    public:
>         -:  445:      typedef typename	_Sequence::value_type		value_type;
>         -:  446:      typedef typename	_Sequence::reference		 reference;
>         -:  447:      typedef typename	_Sequence::const_reference	   const_reference;
>         -:  448:      typedef typename	_Sequence::size_type		 size_type;
>         -:  449:      typedef		_Sequence			    container_type;
>         -:  450:      // _GLIBCXX_RESOLVE_LIB_DEFECTS
>         -:  451:      // DR 2684. priority_queue lacking comparator typedef
>         -:  452:      typedef	       _Compare				    value_compare;
>         -:  453:
>         -:  454:    protected:
>         -:  455:      //  See queue::c for notes on these names.
>         -:  456:      _Sequence  c;
>         -:  457:      _Compare   comp;
>         -:  458:
>         -:  459:    public:
>         -:  460:      /**
>         -:  461:       *  @brief  Default constructor creates no elements.
>         -:  462:       */
>         -:  463:#if __cplusplus < 201103L
>         -:  464:      explicit
>         -:  465:      priority_queue(const _Compare& __x = _Compare(),
>         -:  466:		     const _Sequence& __s = _Sequence())
>         -:  467:      : c(__s), comp(__x)
>         -:  468:      { std::make_heap(c.begin(), c.end(), comp); }
>         -:  469:#else
>         -:  470:      template<typename _Seq = _Sequence, typename _Requires = typename
>         -:  471:	       enable_if<__and_<is_default_constructible<_Compare>,
>         -:  472:				is_default_constructible<_Seq>>::value>::type>
>         -:  473:	priority_queue()
>         -:  474:	: c(), comp() { }
>         -:  475:
479,563c479,563
<         -:  477:      priority_queue(const _Compare& __x = _Compare(),
<         -:  478:		     const _Sequence& __s = _Sequence())
<         -:  479:      : c(__s), comp(__x)
<         -:  480:      { std::make_heap(c.begin(), c.end(), comp); }
<         -:  481:#else
<         -:  482:      template<typename _Seq = _Sequence, typename _Requires = typename
<         -:  483:	       enable_if<__and_<is_default_constructible<_Compare>,
<         -:  484:				is_default_constructible<_Seq>>::value>::type>
<         -:  485:	priority_queue()
<         -:  486:	: c(), comp() { }
<         -:  487:
<         -:  488:      explicit
<         -:  489:      priority_queue(const _Compare& __x, const _Sequence& __s)
<         -:  490:      : c(__s), comp(__x)
<         -:  491:      { std::make_heap(c.begin(), c.end(), comp); }
<         -:  492:
<         -:  493:      explicit
<         -:  494:      priority_queue(const _Compare& __x, _Sequence&& __s = _Sequence())
<         -:  495:      : c(std::move(__s)), comp(__x)
<         -:  496:      { std::make_heap(c.begin(), c.end(), comp); }
<         -:  497:
<         -:  498:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
<         -:  499:	explicit
<         -:  500:	priority_queue(const _Alloc& __a)
<         -:  501:	: c(__a), comp() { }
<         -:  502:
<         -:  503:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
<         -:  504:	priority_queue(const _Compare& __x, const _Alloc& __a)
<         -:  505:	: c(__a), comp(__x) { }
<         -:  506:
<         -:  507:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
<         -:  508:	priority_queue(const _Compare& __x, const _Sequence& __c,
<         -:  509:		       const _Alloc& __a)
<         -:  510:	: c(__c, __a), comp(__x) { }
<         -:  511:
<         -:  512:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
<         -:  513:	priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
<         -:  514:	: c(std::move(__c), __a), comp(__x) { }
<         -:  515:
<         -:  516:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
<         -:  517:	priority_queue(const priority_queue& __q, const _Alloc& __a)
<         -:  518:	: c(__q.c, __a), comp(__q.comp) { }
<         -:  519:
<         -:  520:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
<         -:  521:	priority_queue(priority_queue&& __q, const _Alloc& __a)
<         -:  522:	: c(std::move(__q.c), __a), comp(std::move(__q.comp)) { }
<         -:  523:#endif
<         -:  524:
<         -:  525:      /**
<         -:  526:       *  @brief  Builds a %queue from a range.
<         -:  527:       *  @param  __first  An input iterator.
<         -:  528:       *  @param  __last  An input iterator.
<         -:  529:       *  @param  __x  A comparison functor describing a strict weak ordering.
<         -:  530:       *  @param  __s  An initial sequence with which to start.
<         -:  531:       *
<         -:  532:       *  Begins by copying @a __s, inserting a copy of the elements
<         -:  533:       *  from @a [first,last) into the copy of @a __s, then ordering
<         -:  534:       *  the copy according to @a __x.
<         -:  535:       *
<         -:  536:       *  For more information on function objects, see the
<         -:  537:       *  documentation on @link functors functor base
<         -:  538:       *  classes@endlink.
<         -:  539:       */
<         -:  540:#if __cplusplus < 201103L
<         -:  541:      template<typename _InputIterator>
<         -:  542:	priority_queue(_InputIterator __first, _InputIterator __last,
<         -:  543:		       const _Compare& __x = _Compare(),
<         -:  544:		       const _Sequence& __s = _Sequence())
<         -:  545:	: c(__s), comp(__x)
<         -:  546:	{
<         -:  547:	  __glibcxx_requires_valid_range(__first, __last);
<         -:  548:	  c.insert(c.end(), __first, __last);
<         -:  549:	  std::make_heap(c.begin(), c.end(), comp);
<         -:  550:	}
<         -:  551:#else
<         -:  552:      template<typename _InputIterator>
<         -:  553:	priority_queue(_InputIterator __first, _InputIterator __last,
<         -:  554:		       const _Compare& __x,
<         -:  555:		       const _Sequence& __s)
<         -:  556:	: c(__s), comp(__x)
<         -:  557:	{
<         -:  558:	  __glibcxx_requires_valid_range(__first, __last);
<         -:  559:	  c.insert(c.end(), __first, __last);
<         -:  560:	  std::make_heap(c.begin(), c.end(), comp);
<         -:  561:	}
---
>         -:  477:      priority_queue(const _Compare& __x, const _Sequence& __s)
>         -:  478:      : c(__s), comp(__x)
>         -:  479:      { std::make_heap(c.begin(), c.end(), comp); }
>         -:  480:
>         -:  481:      explicit
>         -:  482:      priority_queue(const _Compare& __x, _Sequence&& __s = _Sequence())
>         -:  483:      : c(std::move(__s)), comp(__x)
>         -:  484:      { std::make_heap(c.begin(), c.end(), comp); }
>         -:  485:
>         -:  486:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
>         -:  487:	explicit
>         -:  488:	priority_queue(const _Alloc& __a)
>         -:  489:	: c(__a), comp() { }
>         -:  490:
>         -:  491:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
>         -:  492:	priority_queue(const _Compare& __x, const _Alloc& __a)
>         -:  493:	: c(__a), comp(__x) { }
>         -:  494:
>         -:  495:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
>         -:  496:	priority_queue(const _Compare& __x, const _Sequence& __c,
>         -:  497:		       const _Alloc& __a)
>         -:  498:	: c(__c, __a), comp(__x) { }
>         -:  499:
>         -:  500:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
>         -:  501:	priority_queue(const _Compare& __x, _Sequence&& __c, const _Alloc& __a)
>         -:  502:	: c(std::move(__c), __a), comp(__x) { }
>         -:  503:
>         -:  504:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
>         -:  505:	priority_queue(const priority_queue& __q, const _Alloc& __a)
>         -:  506:	: c(__q.c, __a), comp(__q.comp) { }
>         -:  507:
>         -:  508:      template<typename _Alloc, typename _Requires = _Uses<_Alloc>>
>         -:  509:	priority_queue(priority_queue&& __q, const _Alloc& __a)
>         -:  510:	: c(std::move(__q.c), __a), comp(std::move(__q.comp)) { }
>         -:  511:#endif
>         -:  512:
>         -:  513:      /**
>         -:  514:       *  @brief  Builds a %queue from a range.
>         -:  515:       *  @param  __first  An input iterator.
>         -:  516:       *  @param  __last  An input iterator.
>         -:  517:       *  @param  __x  A comparison functor describing a strict weak ordering.
>         -:  518:       *  @param  __s  An initial sequence with which to start.
>         -:  519:       *
>         -:  520:       *  Begins by copying @a __s, inserting a copy of the elements
>         -:  521:       *  from @a [first,last) into the copy of @a __s, then ordering
>         -:  522:       *  the copy according to @a __x.
>         -:  523:       *
>         -:  524:       *  For more information on function objects, see the
>         -:  525:       *  documentation on @link functors functor base
>         -:  526:       *  classes@endlink.
>         -:  527:       */
>         -:  528:#if __cplusplus < 201103L
>         -:  529:      template<typename _InputIterator>
>         -:  530:	priority_queue(_InputIterator __first, _InputIterator __last,
>         -:  531:		       const _Compare& __x = _Compare(),
>         -:  532:		       const _Sequence& __s = _Sequence())
>         -:  533:	: c(__s), comp(__x)
>         -:  534:	{
>         -:  535:	  __glibcxx_requires_valid_range(__first, __last);
>         -:  536:	  c.insert(c.end(), __first, __last);
>         -:  537:	  std::make_heap(c.begin(), c.end(), comp);
>         -:  538:	}
>         -:  539:#else
>         -:  540:      template<typename _InputIterator>
>         -:  541:	priority_queue(_InputIterator __first, _InputIterator __last,
>         -:  542:		       const _Compare& __x,
>         -:  543:		       const _Sequence& __s)
>         -:  544:	: c(__s), comp(__x)
>         -:  545:	{
>         -:  546:	  __glibcxx_requires_valid_range(__first, __last);
>         -:  547:	  c.insert(c.end(), __first, __last);
>         -:  548:	  std::make_heap(c.begin(), c.end(), comp);
>         -:  549:	}
>         -:  550:
>         -:  551:      template<typename _InputIterator>
>         -:  552:	priority_queue(_InputIterator __first, _InputIterator __last,
>         -:  553:		       const _Compare& __x = _Compare(),
>         -:  554:		       _Sequence&& __s = _Sequence())
>         -:  555:	: c(std::move(__s)), comp(__x)
>         -:  556:	{
>         -:  557:	  __glibcxx_requires_valid_range(__first, __last);
>         -:  558:	  c.insert(c.end(), __first, __last);
>         -:  559:	  std::make_heap(c.begin(), c.end(), comp);
>         -:  560:	}
>         -:  561:#endif
565,575c565,575
<         -:  563:      template<typename _InputIterator>
<         -:  564:	priority_queue(_InputIterator __first, _InputIterator __last,
<         -:  565:		       const _Compare& __x = _Compare(),
<         -:  566:		       _Sequence&& __s = _Sequence())
<         -:  567:	: c(std::move(__s)), comp(__x)
<         -:  568:	{
<         -:  569:	  __glibcxx_requires_valid_range(__first, __last);
<         -:  570:	  c.insert(c.end(), __first, __last);
<         -:  571:	  std::make_heap(c.begin(), c.end(), comp);
<         -:  572:	}
<         -:  573:#endif
---
>         -:  563:      /**
>         -:  564:       *  Returns true if the %queue is empty.
>         -:  565:       */
>         -:  566:      bool
>         -:  567:      empty() const
>         -:  568:      { return c.empty(); }
>         -:  569:
>         -:  570:      /**  Returns the number of elements in the %queue.  */
>         -:  571:      size_type
>         -:  572:      size() const
>         -:  573:      { return c.size(); }
578,722c578,684
<         -:  576:       *  Returns true if the %queue is empty.
<         -:  577:       */
<         -:  578:      bool
<         -:  579:      empty() const
<         -:  580:      { return c.empty(); }
<         -:  581:
<         -:  582:      /**  Returns the number of elements in the %queue.  */
<         -:  583:      size_type
<         -:  584:      size() const
<         -:  585:      { return c.size(); }
<         -:  586:
<         -:  587:      /**
<         -:  588:       *  Returns a read-only (constant) reference to the data at the first
<         -:  589:       *  element of the %queue.
<         -:  590:       */
<         -:  591:      const_reference
<         -:  592:      top() const
<         -:  593:      {
<         -:  594:	__glibcxx_requires_nonempty();
<         -:  595:	return c.front();
<         -:  596:      }
<         -:  597:
<         -:  598:      /**
<         -:  599:       *  @brief  Add data to the %queue.
<         -:  600:       *  @param  __x  Data to be added.
<         -:  601:       *
<         -:  602:       *  This is a typical %queue operation.
<         -:  603:       *  The time complexity of the operation depends on the underlying
<         -:  604:       *  sequence.
<         -:  605:       */
<         -:  606:      void
<         -:  607:      push(const value_type& __x)
<         -:  608:      {
<         -:  609:	c.push_back(__x);
<         -:  610:	std::push_heap(c.begin(), c.end(), comp);
<         -:  611:      }
<         -:  612:
<         -:  613:#if __cplusplus >= 201103L
<         -:  614:      void
<         -:  615:      push(value_type&& __x)
<         -:  616:      {
<         -:  617:	c.push_back(std::move(__x));
<         -:  618:	std::push_heap(c.begin(), c.end(), comp);
<         -:  619:      }
<         -:  620:
<         -:  621:      template<typename... _Args>
<         -:  622:	void
<         -:  623:	emplace(_Args&&... __args)
<         -:  624:	{
<         -:  625:	  c.emplace_back(std::forward<_Args>(__args)...);
<         -:  626:	  std::push_heap(c.begin(), c.end(), comp);
<         -:  627:	}
<         -:  628:#endif
<         -:  629:
<         -:  630:      /**
<         -:  631:       *  @brief  Removes first element.
<         -:  632:       *
<         -:  633:       *  This is a typical %queue operation.  It shrinks the %queue
<         -:  634:       *  by one.  The time complexity of the operation depends on the
<         -:  635:       *  underlying sequence.
<         -:  636:       *
<         -:  637:       *  Note that no data is returned, and if the first element's
<         -:  638:       *  data is needed, it should be retrieved before pop() is
<         -:  639:       *  called.
<         -:  640:       */
<         -:  641:      void
<         -:  642:      pop()
<         -:  643:      {
<         -:  644:	__glibcxx_requires_nonempty();
<         -:  645:	std::pop_heap(c.begin(), c.end(), comp);
<         -:  646:	c.pop_back();
<         -:  647:      }
<         -:  648:
<         -:  649:#if __cplusplus >= 201103L
<         -:  650:      void
<         -:  651:      swap(priority_queue& __pq)
<         -:  652:      noexcept(__and_<
<         -:  653:#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
<         -:  654:		 __is_nothrow_swappable<_Sequence>,
<         -:  655:#else
<         -:  656:		 __is_nothrow_swappable<_Tp>,
<         -:  657:#endif
<         -:  658:		 __is_nothrow_swappable<_Compare>
<         -:  659:	       >::value)
<         -:  660:      {
<         -:  661:	using std::swap;
<         -:  662:	swap(c, __pq.c);
<         -:  663:	swap(comp, __pq.comp);
<         -:  664:      }
<         -:  665:#endif // __cplusplus >= 201103L
<         -:  666:    };
<         -:  667:
<         -:  668:#if __cpp_deduction_guides >= 201606
<         -:  669:  template<typename _Compare, typename _Container,
<         -:  670:	   typename = enable_if_t<!__is_allocator<_Compare>::value>,
<         -:  671:	   typename = enable_if_t<!__is_allocator<_Container>::value>>
<         -:  672:    priority_queue(_Compare, _Container)
<         -:  673:    -> priority_queue<typename _Container::value_type, _Container, _Compare>;
<         -:  674:
<         -:  675:  template<typename _InputIterator, typename _ValT
<         -:  676:	   = typename iterator_traits<_InputIterator>::value_type,
<         -:  677:	   typename _Compare = less<_ValT>,
<         -:  678:	   typename _Container = vector<_ValT>,
<         -:  679:	   typename = _RequireInputIter<_InputIterator>,
<         -:  680:	   typename = enable_if_t<!__is_allocator<_Compare>::value>,
<         -:  681:	   typename = enable_if_t<!__is_allocator<_Container>::value>>
<         -:  682:    priority_queue(_InputIterator, _InputIterator, _Compare = _Compare(),
<         -:  683:		   _Container = _Container())
<         -:  684:    -> priority_queue<_ValT, _Container, _Compare>;
<         -:  685:
<         -:  686:  template<typename _Compare, typename _Container, typename _Allocator,
<         -:  687:	   typename = enable_if_t<!__is_allocator<_Compare>::value>,
<         -:  688:	   typename = enable_if_t<!__is_allocator<_Container>::value>,
<         -:  689:	   typename = enable_if_t<__is_allocator<_Allocator>::value>>
<         -:  690:    priority_queue(_Compare, _Container, _Allocator)
<         -:  691:    -> priority_queue<typename _Container::value_type, _Container, _Compare>;
<         -:  692:#endif
<         -:  693:
<         -:  694:  // No equality/comparison operators are provided for priority_queue.
<         -:  695:
<         -:  696:#if __cplusplus >= 201103L
<         -:  697:  template<typename _Tp, typename _Sequence, typename _Compare>
<         -:  698:    inline
<         -:  699:#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
<         -:  700:    // Constrained free swap overload, see p0185r1
<         -:  701:    typename enable_if<__and_<__is_swappable<_Sequence>,
<         -:  702:			      __is_swappable<_Compare>>::value>::type
<         -:  703:#else
<         -:  704:    void
<         -:  705:#endif
<         -:  706:    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
<         -:  707:	 priority_queue<_Tp, _Sequence, _Compare>& __y)
<         -:  708:    noexcept(noexcept(__x.swap(__y)))
<         -:  709:    { __x.swap(__y); }
<         -:  710:
<         -:  711:  template<typename _Tp, typename _Sequence, typename _Compare,
<         -:  712:	   typename _Alloc>
<         -:  713:    struct uses_allocator<priority_queue<_Tp, _Sequence, _Compare>, _Alloc>
<         -:  714:    : public uses_allocator<_Sequence, _Alloc>::type { };
<         -:  715:#endif // __cplusplus >= 201103L
<         -:  716:
<         -:  717:_GLIBCXX_END_NAMESPACE_VERSION
<         -:  718:} // namespace
<         -:  719:
<         -:  720:#endif /* _STL_QUEUE_H */
---
>         -:  576:       *  Returns a read-only (constant) reference to the data at the first
>         -:  577:       *  element of the %queue.
>         -:  578:       */
>         -:  579:      const_reference
>         -:  580:      top() const
>         -:  581:      {
>         -:  582:	__glibcxx_requires_nonempty();
>         -:  583:	return c.front();
>         -:  584:      }
>         -:  585:
>         -:  586:      /**
>         -:  587:       *  @brief  Add data to the %queue.
>         -:  588:       *  @param  __x  Data to be added.
>         -:  589:       *
>         -:  590:       *  This is a typical %queue operation.
>         -:  591:       *  The time complexity of the operation depends on the underlying
>         -:  592:       *  sequence.
>         -:  593:       */
>         -:  594:      void
>         -:  595:      push(const value_type& __x)
>         -:  596:      {
>         -:  597:	c.push_back(__x);
>         -:  598:	std::push_heap(c.begin(), c.end(), comp);
>         -:  599:      }
>         -:  600:
>         -:  601:#if __cplusplus >= 201103L
>         -:  602:      void
>         -:  603:      push(value_type&& __x)
>         -:  604:      {
>         -:  605:	c.push_back(std::move(__x));
>         -:  606:	std::push_heap(c.begin(), c.end(), comp);
>         -:  607:      }
>         -:  608:
>         -:  609:      template<typename... _Args>
>         -:  610:	void
>         -:  611:	emplace(_Args&&... __args)
>         -:  612:	{
>         -:  613:	  c.emplace_back(std::forward<_Args>(__args)...);
>         -:  614:	  std::push_heap(c.begin(), c.end(), comp);
>         -:  615:	}
>         -:  616:#endif
>         -:  617:
>         -:  618:      /**
>         -:  619:       *  @brief  Removes first element.
>         -:  620:       *
>         -:  621:       *  This is a typical %queue operation.  It shrinks the %queue
>         -:  622:       *  by one.  The time complexity of the operation depends on the
>         -:  623:       *  underlying sequence.
>         -:  624:       *
>         -:  625:       *  Note that no data is returned, and if the first element's
>         -:  626:       *  data is needed, it should be retrieved before pop() is
>         -:  627:       *  called.
>         -:  628:       */
>         -:  629:      void
>         -:  630:      pop()
>         -:  631:      {
>         -:  632:	__glibcxx_requires_nonempty();
>         -:  633:	std::pop_heap(c.begin(), c.end(), comp);
>         -:  634:	c.pop_back();
>         -:  635:      }
>         -:  636:
>         -:  637:#if __cplusplus >= 201103L
>         -:  638:      void
>         -:  639:      swap(priority_queue& __pq)
>         -:  640:      noexcept(__and_<
>         -:  641:#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
>         -:  642:		 __is_nothrow_swappable<_Sequence>,
>         -:  643:#else
>         -:  644:		 __is_nothrow_swappable<_Tp>,
>         -:  645:#endif
>         -:  646:		 __is_nothrow_swappable<_Compare>
>         -:  647:	       >::value)
>         -:  648:      {
>         -:  649:	using std::swap;
>         -:  650:	swap(c, __pq.c);
>         -:  651:	swap(comp, __pq.comp);
>         -:  652:      }
>         -:  653:#endif // __cplusplus >= 201103L
>         -:  654:    };
>         -:  655:
>         -:  656:  // No equality/comparison operators are provided for priority_queue.
>         -:  657:
>         -:  658:#if __cplusplus >= 201103L
>         -:  659:  template<typename _Tp, typename _Sequence, typename _Compare>
>         -:  660:    inline
>         -:  661:#if __cplusplus > 201402L || !defined(__STRICT_ANSI__) // c++1z or gnu++11
>         -:  662:    // Constrained free swap overload, see p0185r1
>         -:  663:    typename enable_if<__and_<__is_swappable<_Sequence>,
>         -:  664:			      __is_swappable<_Compare>>::value>::type
>         -:  665:#else
>         -:  666:    void
>         -:  667:#endif
>         -:  668:    swap(priority_queue<_Tp, _Sequence, _Compare>& __x,
>         -:  669:	 priority_queue<_Tp, _Sequence, _Compare>& __y)
>         -:  670:    noexcept(noexcept(__x.swap(__y)))
>         -:  671:    { __x.swap(__y); }
>         -:  672:
>         -:  673:  template<typename _Tp, typename _Sequence, typename _Compare,
>         -:  674:	   typename _Alloc>
>         -:  675:    struct uses_allocator<priority_queue<_Tp, _Sequence, _Compare>, _Alloc>
>         -:  676:    : public uses_allocator<_Sequence, _Alloc>::type { };
>         -:  677:#endif // __cplusplus >= 201103L
>         -:  678:
>         -:  679:_GLIBCXX_END_NAMESPACE_VERSION
>         -:  680:} // namespace
>         -:  681:
>         -:  682:#endif /* _STL_QUEUE_H */
