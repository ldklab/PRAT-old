        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/deps/azure-c-shared-utility/src/http_proxy_io.c
        -:    0:Programs:80
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <stdio.h>
        -:    6:#include <stdbool.h>
        -:    7:#include <stdint.h>
        -:    8:#include <limits.h>
        -:    9:#include "azure_c_shared_utility/gballoc.h"
        -:   10:#include "azure_c_shared_utility/xio.h"
        -:   11:#include "azure_c_shared_utility/socketio.h"
        -:   12:#include "azure_c_shared_utility/crt_abstractions.h"
        -:   13:#include "azure_c_shared_utility/http_proxy_io.h"
        -:   14:#include "azure_c_shared_utility/azure_base64.h"
        -:   15:
        -:   16:typedef enum HTTP_PROXY_IO_STATE_TAG
        -:   17:{
        -:   18:    HTTP_PROXY_IO_STATE_CLOSED,
        -:   19:    HTTP_PROXY_IO_STATE_OPENING_UNDERLYING_IO,
        -:   20:    HTTP_PROXY_IO_STATE_WAITING_FOR_CONNECT_RESPONSE,
        -:   21:    HTTP_PROXY_IO_STATE_OPEN,
        -:   22:    HTTP_PROXY_IO_STATE_CLOSING,
        -:   23:    HTTP_PROXY_IO_STATE_ERROR
        -:   24:} HTTP_PROXY_IO_STATE;
        -:   25:
        -:   26:typedef struct HTTP_PROXY_IO_INSTANCE_TAG
        -:   27:{
        -:   28:    HTTP_PROXY_IO_STATE http_proxy_io_state;
        -:   29:    ON_BYTES_RECEIVED on_bytes_received;
        -:   30:    void* on_bytes_received_context;
        -:   31:    ON_IO_ERROR on_io_error;
        -:   32:    void* on_io_error_context;
        -:   33:    ON_IO_OPEN_COMPLETE on_io_open_complete;
        -:   34:    void* on_io_open_complete_context;
        -:   35:    ON_IO_CLOSE_COMPLETE on_io_close_complete;
        -:   36:    void* on_io_close_complete_context;
        -:   37:    char* hostname;
        -:   38:    int port;
        -:   39:    char* proxy_hostname;
        -:   40:    int proxy_port;
        -:   41:    char* username;
        -:   42:    char* password;
        -:   43:    XIO_HANDLE underlying_io;
        -:   44:    unsigned char* receive_buffer;
        -:   45:    size_t receive_buffer_size;
        -:   46:} HTTP_PROXY_IO_INSTANCE;
        -:   47:
    #####:   48:static CONCRETE_IO_HANDLE http_proxy_io_create(void* io_create_parameters)
        -:   49:{
        -:   50:    HTTP_PROXY_IO_INSTANCE* result;
        -:   51:
    #####:   52:    if (io_create_parameters == NULL)
        -:   53:    {
        -:   54:        /* Codes_SRS_HTTP_PROXY_IO_01_002: [ If io_create_parameters is NULL, http_proxy_io_create shall fail and return NULL. ]*/
    #####:   55:        result = NULL;
    #####:   56:        LogError("NULL io_create_parameters.");
        -:   57:    }
        -:   58:    else
        -:   59:    {
        -:   60:        /* Codes_SRS_HTTP_PROXY_IO_01_003: [ io_create_parameters shall be used as an HTTP_PROXY_IO_CONFIG*. ]*/
    #####:   61:        HTTP_PROXY_IO_CONFIG* http_proxy_io_config = (HTTP_PROXY_IO_CONFIG*)io_create_parameters;
    #####:   62:        if ((http_proxy_io_config->hostname == NULL) ||
    #####:   63:            (http_proxy_io_config->proxy_hostname == NULL))
        -:   64:        {
        -:   65:            /* Codes_SRS_HTTP_PROXY_IO_01_004: [ If the hostname or proxy_hostname member is NULL, then http_proxy_io_create shall fail and return NULL. ]*/
    #####:   66:            result = NULL;
    #####:   67:            LogError("Bad arguments: hostname = %p, proxy_hostname = %p",
        -:   68:                http_proxy_io_config->hostname, http_proxy_io_config->proxy_hostname);
        -:   69:        }
        -:   70:        /* Codes_SRS_HTTP_PROXY_IO_01_095: [ If one of the fields username and password is non-NULL, then the other has to be also non-NULL, otherwise http_proxy_io_create shall fail and return NULL. ]*/
    #####:   71:        else if (((http_proxy_io_config->username == NULL) && (http_proxy_io_config->password != NULL)) ||
    #####:   72:            ((http_proxy_io_config->username != NULL) && (http_proxy_io_config->password == NULL)))
        -:   73:        {
    #####:   74:            result = NULL;
    #####:   75:            LogError("Bad arguments: username = %p, password = %p",
        -:   76:                http_proxy_io_config->username, http_proxy_io_config->password);
        -:   77:        }
        -:   78:        else
        -:   79:        {
        -:   80:            /* Codes_SRS_HTTP_PROXY_IO_01_001: [ http_proxy_io_create shall create a new instance of the HTTP proxy IO. ]*/
    #####:   81:            result = (HTTP_PROXY_IO_INSTANCE*)malloc(sizeof(HTTP_PROXY_IO_INSTANCE));
    #####:   82:            if (result == NULL)
        -:   83:            {
        -:   84:                /* Codes_SRS_HTTP_PROXY_IO_01_051: [ If allocating memory for the new instance fails, http_proxy_io_create shall fail and return NULL. ]*/
    #####:   85:                LogError("Failed allocating HTTP proxy IO instance.");
        -:   86:            }
        -:   87:            else
        -:   88:            {
        -:   89:                /* Codes_SRS_HTTP_PROXY_IO_01_005: [ http_proxy_io_create shall copy the hostname, port, username and password values for later use when the actual CONNECT is performed. ]*/
        -:   90:                /* Codes_SRS_HTTP_PROXY_IO_01_006: [ hostname and proxy_hostname, username and password shall be copied by calling mallocAndStrcpy_s. ]*/
    #####:   91:                if (mallocAndStrcpy_s(&result->hostname, http_proxy_io_config->hostname) != 0)
        -:   92:                {
        -:   93:                    /* Codes_SRS_HTTP_PROXY_IO_01_007: [ If mallocAndStrcpy_s fails then http_proxy_io_create shall fail and return NULL. ]*/
    #####:   94:                    LogError("Failed to copy the hostname.");
        -:   95:                    /* Codes_SRS_HTTP_PROXY_IO_01_008: [ When http_proxy_io_create fails, all allocated resources up to that point shall be freed. ]*/
    #####:   96:                    free(result);
    #####:   97:                    result = NULL;
        -:   98:                }
        -:   99:                else
        -:  100:                {
        -:  101:                    /* Codes_SRS_HTTP_PROXY_IO_01_006: [ hostname and proxy_hostname, username and password shall be copied by calling mallocAndStrcpy_s. ]*/
    #####:  102:                    if (mallocAndStrcpy_s(&result->proxy_hostname, http_proxy_io_config->proxy_hostname) != 0)
        -:  103:                    {
        -:  104:                        /* Codes_SRS_HTTP_PROXY_IO_01_007: [ If mallocAndStrcpy_s fails then http_proxy_io_create shall fail and return NULL. ]*/
    #####:  105:                        LogError("Failed to copy the proxy_hostname.");
        -:  106:                        /* Codes_SRS_HTTP_PROXY_IO_01_008: [ When http_proxy_io_create fails, all allocated resources up to that point shall be freed. ]*/
    #####:  107:                        free(result->hostname);
    #####:  108:                        free(result);
    #####:  109:                        result = NULL;
        -:  110:                    }
        -:  111:                    else
        -:  112:                    {
    #####:  113:                        result->username = NULL;
    #####:  114:                        result->password = NULL;
        -:  115:
        -:  116:                        /* Codes_SRS_HTTP_PROXY_IO_01_006: [ hostname and proxy_hostname, username and password shall be copied by calling mallocAndStrcpy_s. ]*/
        -:  117:                        /* Codes_SRS_HTTP_PROXY_IO_01_094: [ username and password shall be optional. ]*/
    #####:  118:                        if ((http_proxy_io_config->username != NULL) && (mallocAndStrcpy_s(&result->username, http_proxy_io_config->username) != 0))
        -:  119:                        {
        -:  120:                            /* Codes_SRS_HTTP_PROXY_IO_01_007: [ If mallocAndStrcpy_s fails then http_proxy_io_create shall fail and return NULL. ]*/
    #####:  121:                            LogError("Failed to copy the username.");
        -:  122:                            /* Codes_SRS_HTTP_PROXY_IO_01_008: [ When http_proxy_io_create fails, all allocated resources up to that point shall be freed. ]*/
    #####:  123:                            free(result->proxy_hostname);
    #####:  124:                            free(result->hostname);
    #####:  125:                            free(result);
    #####:  126:                            result = NULL;
        -:  127:                        }
        -:  128:                        else
        -:  129:                        {
        -:  130:                            /* Codes_SRS_HTTP_PROXY_IO_01_006: [ hostname and proxy_hostname, username and password shall be copied by calling mallocAndStrcpy_s. ]*/
        -:  131:                            /* Codes_SRS_HTTP_PROXY_IO_01_094: [ username and password shall be optional. ]*/
    #####:  132:                            if ((http_proxy_io_config->password != NULL) && (mallocAndStrcpy_s(&result->password, http_proxy_io_config->password) != 0))
        -:  133:                            {
        -:  134:                                /* Codes_SRS_HTTP_PROXY_IO_01_007: [ If mallocAndStrcpy_s fails then http_proxy_io_create shall fail and return NULL. ]*/
    #####:  135:                                LogError("Failed to copy the passowrd.");
        -:  136:                                /* Codes_SRS_HTTP_PROXY_IO_01_008: [ When http_proxy_io_create fails, all allocated resources up to that point shall be freed. ]*/
    #####:  137:                                free(result->username);
    #####:  138:                                free(result->proxy_hostname);
    #####:  139:                                free(result->hostname);
    #####:  140:                                free(result);
    #####:  141:                                result = NULL;
        -:  142:                            }
        -:  143:                            else
        -:  144:                            {
        -:  145:                                /* Codes_SRS_HTTP_PROXY_IO_01_010: [ - io_interface_description shall be set to the result of socketio_get_interface_description. ]*/
    #####:  146:                                const IO_INTERFACE_DESCRIPTION* underlying_io_interface = socketio_get_interface_description();
    #####:  147:                                if (underlying_io_interface == NULL)
        -:  148:                                {
        -:  149:                                    /* Codes_SRS_HTTP_PROXY_IO_01_050: [ If socketio_get_interface_description fails, http_proxy_io_create shall fail and return NULL. ]*/
    #####:  150:                                    LogError("Unable to get the socket IO interface description.");
        -:  151:                                    /* Codes_SRS_HTTP_PROXY_IO_01_008: [ When http_proxy_io_create fails, all allocated resources up to that point shall be freed. ]*/
    #####:  152:                                    free(result->password);
    #####:  153:                                    free(result->username);
    #####:  154:                                    free(result->proxy_hostname);
    #####:  155:                                    free(result->hostname);
    #####:  156:                                    free(result);
    #####:  157:                                    result = NULL;
        -:  158:                                }
        -:  159:                                else
        -:  160:                                {
        -:  161:                                    SOCKETIO_CONFIG socket_io_config;
        -:  162:
        -:  163:                                    /* Codes_SRS_HTTP_PROXY_IO_01_011: [ - xio_create_parameters shall be set to a SOCKETIO_CONFIG* where hostname is set to the proxy_hostname member of io_create_parameters and port is set to the proxy_port member of io_create_parameters. ]*/
    #####:  164:                                    socket_io_config.hostname = http_proxy_io_config->proxy_hostname;
    #####:  165:                                    socket_io_config.port = http_proxy_io_config->proxy_port;
    #####:  166:                                    socket_io_config.accepted_socket = NULL;
        -:  167:
        -:  168:                                    /* Codes_SRS_HTTP_PROXY_IO_01_009: [ http_proxy_io_create shall create a new socket IO by calling xio_create with the arguments: ]*/
    #####:  169:                                    result->underlying_io = xio_create(underlying_io_interface, &socket_io_config);
    #####:  170:                                    if (result->underlying_io == NULL)
        -:  171:                                    {
        -:  172:                                        /* Codes_SRS_HTTP_PROXY_IO_01_012: [ If xio_create fails, http_proxy_io_create shall fail and return NULL. ]*/
    #####:  173:                                        LogError("Unable to create the underlying IO.");
        -:  174:                                        /* Codes_SRS_HTTP_PROXY_IO_01_008: [ When http_proxy_io_create fails, all allocated resources up to that point shall be freed. ]*/
    #####:  175:                                        free(result->password);
    #####:  176:                                        free(result->username);
    #####:  177:                                        free(result->proxy_hostname);
    #####:  178:                                        free(result->hostname);
    #####:  179:                                        free(result);
    #####:  180:                                        result = NULL;
        -:  181:                                    }
        -:  182:                                    else
        -:  183:                                    {
    #####:  184:                                        result->port = http_proxy_io_config->port;
    #####:  185:                                        result->proxy_port = http_proxy_io_config->proxy_port;
    #####:  186:                                        result->receive_buffer = NULL;
    #####:  187:                                        result->receive_buffer_size = 0;
    #####:  188:                                        result->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSED;
        -:  189:                                    }
        -:  190:                                }
        -:  191:                            }
        -:  192:                        }
        -:  193:                    }
        -:  194:                }
        -:  195:            }
        -:  196:        }
        -:  197:    }
        -:  198:
    #####:  199:    return result;
        -:  200:}
        -:  201:
    #####:  202:static void http_proxy_io_destroy(CONCRETE_IO_HANDLE http_proxy_io)
        -:  203:{
    #####:  204:    if (http_proxy_io == NULL)
        -:  205:    {
        -:  206:        /* Codes_SRS_HTTP_PROXY_IO_01_014: [ If http_proxy_io is NULL, http_proxy_io_destroy shall do nothing. ]*/
    #####:  207:        LogError("NULL http_proxy_io.");
        -:  208:    }
        -:  209:    else
        -:  210:    {
    #####:  211:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  212:
        -:  213:        /* Codes_SRS_HTTP_PROXY_IO_01_013: [ http_proxy_io_destroy shall free the HTTP proxy IO instance indicated by http_proxy_io. ]*/
    #####:  214:        if (http_proxy_io_instance->receive_buffer != NULL)
        -:  215:        {
    #####:  216:            free(http_proxy_io_instance->receive_buffer);
        -:  217:        }
        -:  218:
        -:  219:        /* Codes_SRS_HTTP_PROXY_IO_01_016: [ http_proxy_io_destroy shall destroy the underlying IO created in http_proxy_io_create by calling xio_destroy. ]*/
    #####:  220:        xio_destroy(http_proxy_io_instance->underlying_io);
    #####:  221:        free(http_proxy_io_instance->hostname);
    #####:  222:        free(http_proxy_io_instance->proxy_hostname);
    #####:  223:        free(http_proxy_io_instance->username);
    #####:  224:        free(http_proxy_io_instance->password);
    #####:  225:        free(http_proxy_io_instance);
        -:  226:    }
    #####:  227:}
        -:  228:
    #####:  229:static void indicate_open_complete_error_and_close(HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance)
        -:  230:{
    #####:  231:    http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSED;
    #####:  232:    (void)xio_close(http_proxy_io_instance->underlying_io, NULL, NULL);
    #####:  233:    http_proxy_io_instance->on_io_open_complete(http_proxy_io_instance->on_io_open_complete_context, IO_OPEN_ERROR);
    #####:  234:}
        -:  235:
        -:  236:// This callback usage needs to be either verified and commented or integrated into
        -:  237:// the state machine.
    #####:  238:static void unchecked_on_send_complete(void* context, IO_SEND_RESULT send_result)
        -:  239:{
        -:  240:    (void)context;
        -:  241:    (void)send_result;
    #####:  242:}
        -:  243:
    #####:  244:static void on_underlying_io_open_complete(void* context, IO_OPEN_RESULT open_result)
        -:  245:{
    #####:  246:    if (context == NULL)
        -:  247:    {
        -:  248:        /* Codes_SRS_HTTP_PROXY_IO_01_081: [ on_underlying_io_open_complete called with NULL context shall do nothing. ]*/
    #####:  249:        LogError("NULL context in on_underlying_io_open_complete");
        -:  250:    }
        -:  251:    else
        -:  252:    {
    #####:  253:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)context;
    #####:  254:        switch (http_proxy_io_instance->http_proxy_io_state)
        -:  255:        {
    #####:  256:        default:
    #####:  257:            LogError("on_underlying_io_open_complete called in an unexpected state.");
    #####:  258:            break;
        -:  259:
    #####:  260:        case HTTP_PROXY_IO_STATE_CLOSING:
        -:  261:        case HTTP_PROXY_IO_STATE_OPEN:
        -:  262:            /* Codes_SRS_HTTP_PROXY_IO_01_077: [ When on_underlying_io_open_complete is called in after OPEN has completed, the on_io_error callback shall be triggered passing the on_io_error_context argument as context. ]*/
    #####:  263:            http_proxy_io_instance->on_io_error(http_proxy_io_instance->on_io_error_context);
    #####:  264:            break;
        -:  265:
    #####:  266:        case HTTP_PROXY_IO_STATE_WAITING_FOR_CONNECT_RESPONSE:
        -:  267:            /* Codes_SRS_HTTP_PROXY_IO_01_076: [ When on_underlying_io_open_complete is called while waiting for the CONNECT reply, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  268:            LogError("Open complete called again by underlying IO.");
    #####:  269:            indicate_open_complete_error_and_close(http_proxy_io_instance);
    #####:  270:            break;
        -:  271:
    #####:  272:        case HTTP_PROXY_IO_STATE_OPENING_UNDERLYING_IO:
        -:  273:            switch (open_result)
        -:  274:            {
    #####:  275:            default:
        -:  276:            case IO_OPEN_ERROR:
        -:  277:                /* Codes_SRS_HTTP_PROXY_IO_01_078: [ When on_underlying_io_open_complete is called with IO_OPEN_ERROR, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  278:                LogError("Underlying IO open failed");
    #####:  279:                indicate_open_complete_error_and_close(http_proxy_io_instance);
    #####:  280:                break;
        -:  281:
    #####:  282:            case IO_OPEN_CANCELLED:
        -:  283:                /* Codes_SRS_HTTP_PROXY_IO_01_079: [ When on_underlying_io_open_complete is called with IO_OPEN_CANCELLED, the on_open_complete callback shall be triggered with IO_OPEN_CANCELLED, passing also the on_open_complete_context argument as context. ]*/
    #####:  284:                LogError("Underlying IO open failed");
    #####:  285:                http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSED;
    #####:  286:                (void)xio_close(http_proxy_io_instance->underlying_io, NULL, NULL);
    #####:  287:                http_proxy_io_instance->on_io_open_complete(http_proxy_io_instance->on_io_open_complete_context, IO_OPEN_CANCELLED);
    #####:  288:                break;
        -:  289:
    #####:  290:            case IO_OPEN_OK:
        -:  291:            {
        -:  292:                STRING_HANDLE encoded_auth_string;
        -:  293:
        -:  294:                /* Codes_SRS_HTTP_PROXY_IO_01_057: [ When on_underlying_io_open_complete is called, the http_proxy_io shall send the CONNECT request constructed per RFC 2817: ]*/
    #####:  295:                http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_WAITING_FOR_CONNECT_RESPONSE;
        -:  296:
    #####:  297:                if (http_proxy_io_instance->username != NULL)
        -:  298:                {
        -:  299:                    char* plain_auth_string_bytes;
        -:  300:
        -:  301:                    /* Codes_SRS_HTTP_PROXY_IO_01_060: [ - The value of Proxy-Authorization shall be the constructed according to RFC 2617. ]*/
    #####:  302:                    int plain_auth_string_length = (int)(strlen(http_proxy_io_instance->username)+1);
    #####:  303:                    if (http_proxy_io_instance->password != NULL)
        -:  304:                    {
    #####:  305:                        plain_auth_string_length += (int)strlen(http_proxy_io_instance->password);
        -:  306:                    }
        -:  307:
    #####:  308:                    if (plain_auth_string_length < 0)
        -:  309:                    {
        -:  310:                        /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  311:                        encoded_auth_string = NULL;
    #####:  312:                        indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  313:                    }
        -:  314:                    else
        -:  315:                    {
    #####:  316:                        plain_auth_string_bytes = (char*)malloc(plain_auth_string_length + 1);
    #####:  317:                        if (plain_auth_string_bytes == NULL)
        -:  318:                        {
        -:  319:                            /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  320:                            encoded_auth_string = NULL;
    #####:  321:                            indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  322:                        }
        -:  323:                        else
        -:  324:                        {
        -:  325:                            /* Codes_SRS_HTTP_PROXY_IO_01_091: [ To receive authorization, the client sends the userid and password, separated by a single colon (":") character, within a base64 [7] encoded string in the credentials. ]*/
        -:  326:                            /* Codes_SRS_HTTP_PROXY_IO_01_092: [ A client MAY preemptively send the corresponding Authorization header with requests for resources in that space without receipt of another challenge from the server. ]*/
        -:  327:                            /* Codes_SRS_HTTP_PROXY_IO_01_093: [ Userids might be case sensitive. ]*/
    #####:  328:                            if (sprintf(plain_auth_string_bytes, "%s:%s", http_proxy_io_instance->username, (http_proxy_io_instance->password == NULL) ? "" : http_proxy_io_instance->password) < 0)
        -:  329:                            {
        -:  330:                                /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  331:                                encoded_auth_string = NULL;
    #####:  332:                                indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  333:                            }
        -:  334:                            else
        -:  335:                            {
        -:  336:                                /* Codes_SRS_HTTP_PROXY_IO_01_061: [ Encoding to Base64 shall be done by calling Azure_Base64_Encode_Bytes. ]*/
    #####:  337:                                encoded_auth_string = Azure_Base64_Encode_Bytes((const unsigned char*)plain_auth_string_bytes, plain_auth_string_length);
    #####:  338:                                if (encoded_auth_string == NULL)
        -:  339:                                {
        -:  340:                                    /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  341:                                    LogError("Cannot Base64 encode auth string");
    #####:  342:                                    indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  343:                                }
        -:  344:                            }
        -:  345:
    #####:  346:                            free(plain_auth_string_bytes);
        -:  347:                        }
        -:  348:                    }
        -:  349:                }
        -:  350:                else
        -:  351:                {
    #####:  352:                    encoded_auth_string = NULL;
        -:  353:                }
        -:  354:
    #####:  355:                if ((http_proxy_io_instance->username != NULL) &&
        -:  356:                    (encoded_auth_string == NULL))
        -:  357:                {
    #####:  358:                    LogError("Cannot create authorization header");
        -:  359:                }
        -:  360:                else
        -:  361:                {
        -:  362:                    int connect_request_length;
        -:  363:                    const char* auth_string_payload;
        -:  364:                    /* Codes_SRS_HTTP_PROXY_IO_01_075: [ The Request-URI portion of the Request-Line is always an 'authority' as defined by URI Generic Syntax [2], which is to say the host name and port number destination of the requested connection separated by a colon: ]*/
    #####:  365:                    const char request_format[] = "CONNECT %s:%d HTTP/1.1\r\nHost:%s:%d%s%s\r\n\r\n";
    #####:  366:                    const char proxy_basic[] = "\r\nProxy-authorization: Basic ";
    #####:  367:                    if (http_proxy_io_instance->username != NULL)
        -:  368:                    {
    #####:  369:                        auth_string_payload = STRING_c_str(encoded_auth_string);
        -:  370:                    }
        -:  371:                    else
        -:  372:                    {
    #####:  373:                        auth_string_payload = "";
        -:  374:                    }
        -:  375:
        -:  376:                    /* Codes_SRS_HTTP_PROXY_IO_01_059: [ - If username and password have been specified in the arguments passed to http_proxy_io_create, then the header Proxy-Authorization shall be added to the request. ]*/
        -:  377:
    #####:  378:                    connect_request_length = (int)(strlen(request_format)+(strlen(http_proxy_io_instance->hostname)*2)+strlen(auth_string_payload)+10);
    #####:  379:                    if (http_proxy_io_instance->username != NULL)
        -:  380:                    {
    #####:  381:                        connect_request_length += (int)strlen(proxy_basic);
        -:  382:                    }
        -:  383:
    #####:  384:                    if (connect_request_length < 0)
        -:  385:                    {
        -:  386:                        /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  387:                        LogError("Cannot encode the CONNECT request");
    #####:  388:                        indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  389:                    }
        -:  390:                    else
        -:  391:                    {
    #####:  392:                        char* connect_request = (char*)malloc(connect_request_length + 1);
    #####:  393:                        if (connect_request == NULL)
        -:  394:                        {
        -:  395:                            /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  396:                            LogError("Cannot allocate memory for CONNECT request");
    #####:  397:                            indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  398:                        }
        -:  399:                        else
        -:  400:                        {
        -:  401:                            /* Codes_SRS_HTTP_PROXY_IO_01_059: [ - If username and password have been specified in the arguments passed to http_proxy_io_create, then the header Proxy-Authorization shall be added to the request. ]*/
    #####:  402:                            connect_request_length = sprintf(connect_request, request_format,
        -:  403:                                http_proxy_io_instance->hostname,
        -:  404:                                http_proxy_io_instance->port,
        -:  405:                                http_proxy_io_instance->hostname,
        -:  406:                                http_proxy_io_instance->port,
    #####:  407:                                (http_proxy_io_instance->username != NULL) ? proxy_basic : "",
        -:  408:                                auth_string_payload);
        -:  409:
    #####:  410:                            if (connect_request_length < 0)
        -:  411:                            {
        -:  412:                                /* Codes_SRS_HTTP_PROXY_IO_01_062: [ If any failure is encountered while constructing the request, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  413:                                LogError("Cannot encode the CONNECT request");
    #####:  414:                                indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  415:                            }
        -:  416:                            else
        -:  417:                            {
        -:  418:                                /* Codes_SRS_HTTP_PROXY_IO_01_063: [ The request shall be sent by calling xio_send and passing NULL as on_send_complete callback. ]*/
    #####:  419:                                if (xio_send(http_proxy_io_instance->underlying_io, connect_request, connect_request_length, unchecked_on_send_complete, NULL) != 0)
        -:  420:                                {
        -:  421:                                    /* Codes_SRS_HTTP_PROXY_IO_01_064: [ If xio_send fails, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  422:                                    LogError("Could not send CONNECT request");
    #####:  423:                                    indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  424:                                }
        -:  425:                            }
        -:  426:
    #####:  427:                            free(connect_request);
        -:  428:                        }
        -:  429:                    }
        -:  430:                }
        -:  431:
    #####:  432:                if (encoded_auth_string != NULL)
        -:  433:                {
    #####:  434:                    STRING_delete(encoded_auth_string);
        -:  435:                }
        -:  436:
    #####:  437:                break;
        -:  438:            }
        -:  439:            }
        -:  440:
    #####:  441:            break;
        -:  442:        }
        -:  443:    }
    #####:  444:}
        -:  445:
    #####:  446:static void on_underlying_io_error(void* context)
        -:  447:{
    #####:  448:    if (context == NULL)
        -:  449:    {
        -:  450:        /* Codes_SRS_HTTP_PROXY_IO_01_088: [ on_underlying_io_error called with NULL context shall do nothing. ]*/
    #####:  451:        LogError("NULL context in on_underlying_io_error");
        -:  452:    }
        -:  453:    else
        -:  454:    {
    #####:  455:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)context;
        -:  456:
    #####:  457:        switch (http_proxy_io_instance->http_proxy_io_state)
        -:  458:        {
    #####:  459:        default:
    #####:  460:            LogError("on_underlying_io_error in invalid state");
    #####:  461:            break;
        -:  462:
    #####:  463:        case HTTP_PROXY_IO_STATE_OPENING_UNDERLYING_IO:
        -:  464:        case HTTP_PROXY_IO_STATE_WAITING_FOR_CONNECT_RESPONSE:
        -:  465:            /* Codes_SRS_HTTP_PROXY_IO_01_087: [ If the on_underlying_io_error callback is called while OPENING, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  466:            indicate_open_complete_error_and_close(http_proxy_io_instance);
    #####:  467:            break;
        -:  468:
    #####:  469:        case HTTP_PROXY_IO_STATE_OPEN:
        -:  470:            /* Codes_SRS_HTTP_PROXY_IO_01_089: [ If the on_underlying_io_error callback is called while the IO is OPEN, the on_io_error callback shall be called with the on_io_error_context argument as context. ]*/
    #####:  471:            http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_ERROR;
    #####:  472:            http_proxy_io_instance->on_io_error(http_proxy_io_instance->on_io_error_context);
    #####:  473:            break;
        -:  474:        }
        -:  475:    }
    #####:  476:}
        -:  477:
    #####:  478:static void on_underlying_io_close_complete(void* context)
        -:  479:{
    #####:  480:    if (context == NULL)
        -:  481:    {
        -:  482:        /* Cdoes_SRS_HTTP_PROXY_IO_01_084: [ on_underlying_io_close_complete called with NULL context shall do nothing. ]*/
    #####:  483:        LogError("NULL context in on_underlying_io_open_complete");
        -:  484:    }
        -:  485:    else
        -:  486:    {
    #####:  487:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)context;
        -:  488:
    #####:  489:        switch (http_proxy_io_instance->http_proxy_io_state)
        -:  490:        {
    #####:  491:        default:
    #####:  492:            LogError("on_underlying_io_close_complete called in an invalid state");
    #####:  493:            break;
        -:  494:
    #####:  495:        case HTTP_PROXY_IO_STATE_CLOSING:
    #####:  496:            http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSED;
        -:  497:
        -:  498:            /* Codes_SRS_HTTP_PROXY_IO_01_086: [ If the on_io_close_complete callback passed to http_proxy_io_close was NULL, no callback shall be triggered. ]*/
    #####:  499:            if (http_proxy_io_instance->on_io_close_complete != NULL)
        -:  500:            {
        -:  501:                /* Codes_SRS_HTTP_PROXY_IO_01_083: [ on_underlying_io_close_complete while CLOSING shall call the on_io_close_complete callback, passing to it the on_io_close_complete_context as context argument. ]*/
    #####:  502:                http_proxy_io_instance->on_io_close_complete(http_proxy_io_instance->on_io_close_complete_context);
        -:  503:            }
        -:  504:
    #####:  505:            break;
        -:  506:        }
        -:  507:    }
    #####:  508:}
        -:  509:
        -:  510:/*the following function does the same as sscanf(pos2, "%d", &sec)*/
        -:  511:/*this function only exists because some of platforms do not have sscanf. */
    #####:  512:static int ParseStringToDecimal(const char *src, int* dst)
        -:  513:{
        -:  514:    int result;
        -:  515:    char* next;
        -:  516:
    #####:  517:    (*dst) = (int)strtol(src, &next, 0);
    #####:  518:    if ((src == next) || ((((*dst) == INT_MAX) || ((*dst) == INT_MIN)) && (errno != 0)))
        -:  519:    {
    #####:  520:        result = __LINE__;
        -:  521:    }
        -:  522:    else
        -:  523:    {
    #####:  524:        result = 0;
        -:  525:    }
        -:  526:
    #####:  527:    return result;
        -:  528:}
        -:  529:
        -:  530:/*the following function does the same as sscanf(buf, "HTTP/%*d.%*d %d %*[^\r\n]", &ret) */
        -:  531:/*this function only exists because some of platforms do not have sscanf. This is not a full implementation; it only works with well-defined HTTP response. */
    #####:  532:static int ParseHttpResponse(const char* src, int* dst)
        -:  533:{
        -:  534:    int result;
        -:  535:    static const char HTTPPrefix[] = "HTTP/";
        -:  536:    bool fail;
        -:  537:    const char* runPrefix;
        -:  538:
    #####:  539:    if ((src == NULL) || (dst == NULL))
        -:  540:    {
    #####:  541:        result = __LINE__;
        -:  542:    }
        -:  543:    else
        -:  544:    {
    #####:  545:        fail = false;
    #####:  546:        runPrefix = HTTPPrefix;
        -:  547:
    #####:  548:        while ((*runPrefix) != '\0')
        -:  549:        {
    #####:  550:            if ((*runPrefix) != (*src))
        -:  551:            {
    #####:  552:                fail = true;
    #####:  553:                break;
        -:  554:            }
    #####:  555:            src++;
    #####:  556:            runPrefix++;
        -:  557:        }
        -:  558:
    #####:  559:        if (!fail)
        -:  560:        {
    #####:  561:            while ((*src) != '.')
        -:  562:            {
    #####:  563:                if ((*src) == '\0')
        -:  564:                {
    #####:  565:                    fail = true;
    #####:  566:                    break;
        -:  567:                }
    #####:  568:                src++;
        -:  569:            }
        -:  570:        }
        -:  571:
    #####:  572:        if (!fail)
        -:  573:        {
    #####:  574:            while ((*src) != ' ')
        -:  575:            {
    #####:  576:                if ((*src) == '\0')
        -:  577:                {
    #####:  578:                    fail = true;
    #####:  579:                    break;
        -:  580:                }
    #####:  581:                src++;
        -:  582:            }
        -:  583:        }
        -:  584:
    #####:  585:        if (fail)
        -:  586:        {
    #####:  587:            result = __LINE__;
        -:  588:        }
        -:  589:        else
        -:  590:        {
    #####:  591:            if (ParseStringToDecimal(src, dst) != 0)
        -:  592:            {
    #####:  593:                result = __LINE__;
        -:  594:            }
        -:  595:            else
        -:  596:            {
    #####:  597:                result = 0;
        -:  598:            }
        -:  599:        }
        -:  600:    }
        -:  601:
    #####:  602:    return result;
        -:  603:}
        -:  604:
    #####:  605:static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)
        -:  606:{
    #####:  607:    if (context == NULL)
        -:  608:    {
        -:  609:        /* Codes_SRS_HTTP_PROXY_IO_01_082: [ on_underlying_io_bytes_received called with NULL context shall do nothing. ]*/
    #####:  610:        LogError("NULL context in on_underlying_io_bytes_received");
        -:  611:    }
        -:  612:    else
        -:  613:    {
    #####:  614:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)context;
        -:  615:
    #####:  616:        switch (http_proxy_io_instance->http_proxy_io_state)
        -:  617:        {
    #####:  618:        default:
        -:  619:        case HTTP_PROXY_IO_STATE_CLOSING:
    #####:  620:            LogError("Bytes received in invalid state");
    #####:  621:            break;
        -:  622:
    #####:  623:        case HTTP_PROXY_IO_STATE_OPENING_UNDERLYING_IO:
        -:  624:            /* Codes_SRS_HTTP_PROXY_IO_01_080: [ If on_underlying_io_bytes_received is called while the underlying IO is being opened, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  625:            LogError("Bytes received while opening underlying IO");
    #####:  626:            indicate_open_complete_error_and_close(http_proxy_io_instance);
    #####:  627:            break;
        -:  628:
    #####:  629:        case HTTP_PROXY_IO_STATE_WAITING_FOR_CONNECT_RESPONSE:
        -:  630:        {
        -:  631:            /* Codes_SRS_HTTP_PROXY_IO_01_065: [ When bytes are received and the response to the CONNECT request was not yet received, the bytes shall be accumulated until a double new-line is detected. ]*/
    #####:  632:            unsigned char* new_receive_buffer = (unsigned char*)realloc(http_proxy_io_instance->receive_buffer, http_proxy_io_instance->receive_buffer_size + size + 1);
    #####:  633:            if (new_receive_buffer == NULL)
        -:  634:            {
        -:  635:                /* Codes_SRS_HTTP_PROXY_IO_01_067: [ If allocating memory for the buffered bytes fails, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  636:                LogError("Cannot allocate memory for received data");
    #####:  637:                indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  638:            }
        -:  639:            else
        -:  640:            {
    #####:  641:                http_proxy_io_instance->receive_buffer = new_receive_buffer;
    #####:  642:                memcpy(http_proxy_io_instance->receive_buffer + http_proxy_io_instance->receive_buffer_size, buffer, size);
    #####:  643:                http_proxy_io_instance->receive_buffer_size += size;
        -:  644:            }
        -:  645:
    #####:  646:            if (http_proxy_io_instance->receive_buffer_size >= 4)
        -:  647:            {
        -:  648:                const char* request_end_ptr;
        -:  649:
    #####:  650:                http_proxy_io_instance->receive_buffer[http_proxy_io_instance->receive_buffer_size] = 0;
        -:  651:
        -:  652:                /* Codes_SRS_HTTP_PROXY_IO_01_066: [ When a double new-line is detected the response shall be parsed in order to extract the status code. ]*/
    #####:  653:                if ((http_proxy_io_instance->receive_buffer_size >= 4) &&
    #####:  654:                    ((request_end_ptr = strstr((const char*)http_proxy_io_instance->receive_buffer, "\r\n\r\n")) != NULL))
        -:  655:                {
        -:  656:                    int status_code;
        -:  657:
        -:  658:                    /* This part should really be done with the HTTPAPI, but that has to be done as a separate step
        -:  659:                    as the HTTPAPI has to expose somehow the underlying IO and currently this would be a too big of a change. */
        -:  660:
    #####:  661:                    if (ParseHttpResponse((const char*)http_proxy_io_instance->receive_buffer, &status_code) != 0)
        -:  662:                    {
        -:  663:                        /* Codes_SRS_HTTP_PROXY_IO_01_068: [ If parsing the CONNECT response fails, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  664:                        LogError("Cannot decode HTTP response");
    #####:  665:                        indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  666:                    }
        -:  667:                    /* Codes_SRS_HTTP_PROXY_IO_01_069: [ Any successful (2xx) response to a CONNECT request indicates that the proxy has established a connection to the requested host and port, and has switched to tunneling the current connection to that server connection. ]*/
        -:  668:                    /* Codes_SRS_HTTP_PROXY_IO_01_090: [ Any successful (2xx) response to a CONNECT request indicates that the proxy has established a connection to the requested host and port, and has switched to tunneling the current connection to that server connection. ]*/
    #####:  669:                    else if ((status_code < 200) || (status_code > 299))
        -:  670:                    {
        -:  671:                        /* Codes_SRS_HTTP_PROXY_IO_01_071: [ If the status code is not successful, the on_open_complete callback shall be triggered with IO_OPEN_ERROR, passing also the on_open_complete_context argument as context. ]*/
    #####:  672:                        LogError("Bad status (%d) received in CONNECT response", status_code);
    #####:  673:                        indicate_open_complete_error_and_close(http_proxy_io_instance);
        -:  674:                    }
        -:  675:                    else
        -:  676:                    {
    #####:  677:                        size_t length_remaining = http_proxy_io_instance->receive_buffer + http_proxy_io_instance->receive_buffer_size - ((const unsigned char *)request_end_ptr + 4);
        -:  678:
        -:  679:                        /* Codes_SRS_HTTP_PROXY_IO_01_073: [ Once a success status code was parsed, the IO shall be OPEN. ]*/
    #####:  680:                        http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_OPEN;
        -:  681:                        /* Codes_SRS_HTTP_PROXY_IO_01_070: [ When a success status code is parsed, the on_open_complete callback shall be triggered with IO_OPEN_OK, passing also the on_open_complete_context argument as context. ]*/
    #####:  682:                        http_proxy_io_instance->on_io_open_complete(http_proxy_io_instance->on_io_open_complete_context, IO_OPEN_OK);
        -:  683:
    #####:  684:                        if (length_remaining > 0)
        -:  685:                        {
        -:  686:                            /* Codes_SRS_HTTP_PROXY_IO_01_072: [ Any bytes that are extra (not consumed by the CONNECT response), shall be indicated as received by calling the on_bytes_received callback and passing the on_bytes_received_context as context argument. ]*/
    #####:  687:                            http_proxy_io_instance->on_bytes_received(http_proxy_io_instance->on_bytes_received_context, (const unsigned char*)request_end_ptr + 4, length_remaining);
        -:  688:                        }
        -:  689:                    }
        -:  690:                }
        -:  691:            }
    #####:  692:            break;
        -:  693:        }
    #####:  694:        case HTTP_PROXY_IO_STATE_OPEN:
        -:  695:            /* Codes_SRS_HTTP_PROXY_IO_01_074: [ If on_underlying_io_bytes_received is called while OPEN, all bytes shall be indicated as received by calling the on_bytes_received callback and passing the on_bytes_received_context as context argument. ]*/
    #####:  696:            http_proxy_io_instance->on_bytes_received(http_proxy_io_instance->on_bytes_received_context, buffer, size);
    #####:  697:            break;
        -:  698:        }
        -:  699:    }
    #####:  700:}
        -:  701:
    #####:  702:static int http_proxy_io_open(CONCRETE_IO_HANDLE http_proxy_io, ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context, ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context, ON_IO_ERROR on_io_error, void* on_io_error_context)
        -:  703:{
        -:  704:    int result;
        -:  705:
        -:  706:    /* Codes_SRS_HTTP_PROXY_IO_01_051: [ The arguments on_io_open_complete_context, on_bytes_received_context and on_io_error_context shall be allowed to be NULL. ]*/
        -:  707:    /* Codes_SRS_HTTP_PROXY_IO_01_018: [ If any of the arguments http_proxy_io, on_io_open_complete, on_bytes_received or on_io_error are NULL then http_proxy_io_open shall return a non-zero value. ]*/
    #####:  708:    if ((http_proxy_io == NULL) ||
    #####:  709:        (on_io_open_complete == NULL) ||
    #####:  710:        (on_bytes_received == NULL) ||
        -:  711:        (on_io_error == NULL))
        -:  712:    {
    #####:  713:        LogError("Bad arguments: http_proxy_io = %p, on_io_open_complete = %p, on_bytes_received = %p, on_io_error_context = %p.",
        -:  714:            http_proxy_io,
        -:  715:            on_io_open_complete,
        -:  716:            on_bytes_received,
        -:  717:            on_io_error);
    #####:  718:        result = __LINE__;
        -:  719:    }
        -:  720:    else
        -:  721:    {
    #####:  722:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  723:
    #####:  724:        if (http_proxy_io_instance->http_proxy_io_state != HTTP_PROXY_IO_STATE_CLOSED)
        -:  725:        {
    #####:  726:            LogError("Invalid tlsio_state. Expected state is HTTP_PROXY_IO_STATE_CLOSED.");
    #####:  727:            result = __LINE__;
        -:  728:        }
        -:  729:        else
        -:  730:        {
    #####:  731:            http_proxy_io_instance->on_bytes_received = on_bytes_received;
    #####:  732:            http_proxy_io_instance->on_bytes_received_context = on_bytes_received_context;
        -:  733:
    #####:  734:            http_proxy_io_instance->on_io_error = on_io_error;
    #####:  735:            http_proxy_io_instance->on_io_error_context = on_io_error_context;
        -:  736:
    #####:  737:            http_proxy_io_instance->on_io_open_complete = on_io_open_complete;
    #####:  738:            http_proxy_io_instance->on_io_open_complete_context = on_io_open_complete_context;
        -:  739:
    #####:  740:            http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_OPENING_UNDERLYING_IO;
        -:  741:
        -:  742:            /* Codes_SRS_HTTP_PROXY_IO_01_019: [ http_proxy_io_open shall open the underlying IO by calling xio_open on the underlying IO handle created in http_proxy_io_create, while passing to it the callbacks on_underlying_io_open_complete, on_underlying_io_bytes_received and on_underlying_io_error. ]*/
    #####:  743:            if (xio_open(http_proxy_io_instance->underlying_io, on_underlying_io_open_complete, http_proxy_io_instance, on_underlying_io_bytes_received, http_proxy_io_instance, on_underlying_io_error, http_proxy_io_instance) != 0)
        -:  744:            {
        -:  745:                /* Codes_SRS_HTTP_PROXY_IO_01_020: [ If xio_open fails, then http_proxy_io_open shall return a non-zero value. ]*/
    #####:  746:                http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSED;
    #####:  747:                LogError("Cannot open the underlying IO.");
    #####:  748:                result = __LINE__;
        -:  749:            }
        -:  750:            else
        -:  751:            {
        -:  752:                /* Codes_SRS_HTTP_PROXY_IO_01_017: [ http_proxy_io_open shall open the HTTP proxy IO and on success it shall return 0. ]*/
    #####:  753:                result = 0;
        -:  754:            }
        -:  755:        }
        -:  756:    }
        -:  757:
    #####:  758:    return result;
        -:  759:}
        -:  760:
    #####:  761:static int http_proxy_io_close(CONCRETE_IO_HANDLE http_proxy_io, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* on_io_close_complete_context)
        -:  762:{
    #####:  763:    int result = 0;
        -:  764:
        -:  765:    /* Codes_SRS_HTTP_PROXY_IO_01_052: [ on_io_close_complete_context shall be allowed to be NULL. ]*/
        -:  766:    /* Codes_SRS_HTTP_PROXY_IO_01_028: [ on_io_close_complete shall be allowed to be NULL. ]*/
    #####:  767:    if (http_proxy_io == NULL)
        -:  768:    {
        -:  769:        /* Codes_SRS_HTTP_PROXY_IO_01_023: [ If the argument http_proxy_io is NULL, http_proxy_io_close shall fail and return a non-zero value. ]*/
    #####:  770:        result = __LINE__;
    #####:  771:        LogError("NULL http_proxy_io.");
        -:  772:    }
        -:  773:    else
        -:  774:    {
    #####:  775:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  776:
        -:  777:        /* Codes_SRS_HTTP_PROXY_IO_01_027: [ If http_proxy_io_close is called when not open, http_proxy_io_close shall fail and return a non-zero value. ]*/
    #####:  778:        if ((http_proxy_io_instance->http_proxy_io_state == HTTP_PROXY_IO_STATE_CLOSED) ||
        -:  779:            /* Codes_SRS_HTTP_PROXY_IO_01_054: [ http_proxy_io_close while OPENING shall fail and return a non-zero value. ]*/
    #####:  780:            (http_proxy_io_instance->http_proxy_io_state == HTTP_PROXY_IO_STATE_CLOSING))
        -:  781:        {
    #####:  782:            result = __LINE__;
    #####:  783:            LogError("Invalid tlsio_state. Expected state is HTTP_PROXY_IO_STATE_OPEN.");
        -:  784:        }
    #####:  785:        else if ((http_proxy_io_instance->http_proxy_io_state == HTTP_PROXY_IO_STATE_OPENING_UNDERLYING_IO) ||
    #####:  786:            (http_proxy_io_instance->http_proxy_io_state == HTTP_PROXY_IO_STATE_WAITING_FOR_CONNECT_RESPONSE))
        -:  787:        {
        -:  788:            /* Codes_SRS_HTTP_PROXY_IO_01_053: [ http_proxy_io_close while OPENING shall trigger the on_io_open_complete callback with IO_OPEN_CANCELLED. ]*/
    #####:  789:            http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSED;
    #####:  790:            (void)xio_close(http_proxy_io_instance->underlying_io, NULL, NULL);
    #####:  791:            http_proxy_io_instance->on_io_open_complete(http_proxy_io_instance->on_io_open_complete_context, IO_OPEN_CANCELLED);
        -:  792:
        -:  793:            /* Codes_SRS_HTTP_PROXY_IO_01_022: [ http_proxy_io_close shall close the HTTP proxy IO and on success it shall return 0. ]*/
    #####:  794:            result = 0;
        -:  795:        }
        -:  796:        else
        -:  797:        {
    #####:  798:            HTTP_PROXY_IO_STATE previous_state = http_proxy_io_instance->http_proxy_io_state;
        -:  799:
    #####:  800:            http_proxy_io_instance->http_proxy_io_state = HTTP_PROXY_IO_STATE_CLOSING;
        -:  801:
        -:  802:            /* Codes_SRS_HTTP_PROXY_IO_01_026: [ The on_io_close_complete and on_io_close_complete_context arguments shall be saved for later use. ]*/
    #####:  803:            http_proxy_io_instance->on_io_close_complete = on_io_close_complete;
    #####:  804:            http_proxy_io_instance->on_io_close_complete_context = on_io_close_complete_context;
        -:  805:
        -:  806:            /* Codes_SRS_HTTP_PROXY_IO_01_024: [ http_proxy_io_close shall close the underlying IO by calling xio_close on the IO handle create in http_proxy_io_create, while passing to it the on_underlying_io_close_complete callback. ]*/
    #####:  807:            if (xio_close(http_proxy_io_instance->underlying_io, on_underlying_io_close_complete, http_proxy_io_instance) != 0)
        -:  808:            {
        -:  809:                /* Codes_SRS_HTTP_PROXY_IO_01_025: [ If xio_close fails, http_proxy_io_close shall fail and return a non-zero value. ]*/
    #####:  810:                result = __LINE__;
    #####:  811:                http_proxy_io_instance->http_proxy_io_state = previous_state;
    #####:  812:                LogError("Cannot close underlying IO.");
        -:  813:            }
        -:  814:            else
        -:  815:            {
        -:  816:                /* Codes_SRS_HTTP_PROXY_IO_01_022: [ http_proxy_io_close shall close the HTTP proxy IO and on success it shall return 0. ]*/
    #####:  817:                result = 0;
        -:  818:            }
        -:  819:        }
        -:  820:    }
        -:  821:
    #####:  822:    return result;
        -:  823:}
        -:  824:
    #####:  825:static int http_proxy_io_send(CONCRETE_IO_HANDLE http_proxy_io, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* on_send_complete_context)
        -:  826:{
        -:  827:    int result;
        -:  828:
        -:  829:    /* Codes_SRS_HTTP_PROXY_IO_01_032: [ on_send_complete shall be allowed to be NULL. ]*/
        -:  830:    /* Codes_SRS_HTTP_PROXY_IO_01_030: [ If any of the arguments http_proxy_io or buffer is NULL, http_proxy_io_send shall fail and return a non-zero value. ]*/
    #####:  831:    if ((http_proxy_io == NULL) ||
    #####:  832:        (buffer == NULL) ||
        -:  833:        /* Codes_SRS_HTTP_PROXY_IO_01_031: [ If size is 0, http_proxy_io_send shall fail and return a non-zero value. ]*/
        -:  834:        (size == 0))
        -:  835:    {
    #####:  836:        result = __LINE__;
    #####:  837:        LogError("Bad arguments: http_proxy_io = %p, buffer = %p.",
        -:  838:            http_proxy_io, buffer);
        -:  839:    }
        -:  840:    else
        -:  841:    {
    #####:  842:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  843:
        -:  844:        /* Codes_SRS_HTTP_PROXY_IO_01_034: [ If http_proxy_io_send is called when the IO is not open, http_proxy_io_send shall fail and return a non-zero value. ]*/
        -:  845:        /* Codes_SRS_HTTP_PROXY_IO_01_035: [ If the IO is in an error state (an error was reported through the on_io_error callback), http_proxy_io_send shall fail and return a non-zero value. ]*/
    #####:  846:        if (http_proxy_io_instance->http_proxy_io_state != HTTP_PROXY_IO_STATE_OPEN)
        -:  847:        {
    #####:  848:            result = __LINE__;
    #####:  849:            LogError("Invalid HTTP proxy IO state. Expected state is HTTP_PROXY_IO_STATE_OPEN.");
        -:  850:        }
        -:  851:        else
        -:  852:        {
        -:  853:            /* Codes_SRS_HTTP_PROXY_IO_01_033: [ http_proxy_io_send shall send the bytes by calling xio_send on the underlying IO created in http_proxy_io_create and passing buffer and size as arguments. ]*/
    #####:  854:            if (xio_send(http_proxy_io_instance->underlying_io, buffer, size, on_send_complete, on_send_complete_context) != 0)
        -:  855:            {
        -:  856:                /* Codes_SRS_HTTP_PROXY_IO_01_055: [ If xio_send fails, http_proxy_io_send shall fail and return a non-zero value. ]*/
    #####:  857:                result = __LINE__;
    #####:  858:                LogError("Underlying xio_send failed.");
        -:  859:            }
        -:  860:            else
        -:  861:            {
        -:  862:                /* Codes_SRS_HTTP_PROXY_IO_01_029: [ http_proxy_io_send shall send the size bytes pointed to by buffer and on success it shall return 0. ]*/
    #####:  863:                result = 0;
        -:  864:            }
        -:  865:        }
        -:  866:    }
        -:  867:
    #####:  868:    return result;
        -:  869:}
        -:  870:
    #####:  871:static void http_proxy_io_dowork(CONCRETE_IO_HANDLE http_proxy_io)
        -:  872:{
    #####:  873:    if (http_proxy_io == NULL)
        -:  874:    {
        -:  875:        /* Codes_SRS_HTTP_PROXY_IO_01_038: [ If the http_proxy_io argument is NULL, http_proxy_io_dowork shall do nothing. ]*/
    #####:  876:        LogError("NULL http_proxy_io.");
        -:  877:    }
        -:  878:    else
        -:  879:    {
    #####:  880:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  881:
    #####:  882:        if (http_proxy_io_instance->http_proxy_io_state != HTTP_PROXY_IO_STATE_CLOSED)
        -:  883:        {
        -:  884:            /* Codes_SRS_HTTP_PROXY_IO_01_037: [ http_proxy_io_dowork shall call xio_dowork on the underlying IO created in http_proxy_io_create. ]*/
    #####:  885:            xio_dowork(http_proxy_io_instance->underlying_io);
        -:  886:        }
        -:  887:    }
    #####:  888:}
        -:  889:
    #####:  890:static int http_proxy_io_set_option(CONCRETE_IO_HANDLE http_proxy_io, const char* option_name, const void* value)
        -:  891:{
        -:  892:    int result;
        -:  893:
    #####:  894:    if ((http_proxy_io == NULL) || (option_name == NULL))
        -:  895:    {
        -:  896:        /* Codes_SRS_HTTP_PROXY_IO_01_040: [ If any of the arguments http_proxy_io or option_name is NULL, http_proxy_io_set_option shall return a non-zero value. ]*/
    #####:  897:        LogError("Bad arguments: http_proxy_io = %p, option_name = %p",
        -:  898:            http_proxy_io, option_name);
    #####:  899:        result = __LINE__;
        -:  900:    }
        -:  901:    else
        -:  902:    {
    #####:  903:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  904:
        -:  905:        /* Codes_SRS_HTTP_PROXY_IO_01_045: [ None. ]*/
        -:  906:
        -:  907:        /* Codes_SRS_HTTP_PROXY_IO_01_043: [ If the option_name argument indicates an option that is not handled by http_proxy_io_set_option, then xio_setoption shall be called on the underlying IO created in http_proxy_io_create, passing the option name and value to it. ]*/
        -:  908:        /* Codes_SRS_HTTP_PROXY_IO_01_056: [ The value argument shall be allowed to be NULL. ]*/
    #####:  909:        if (xio_setoption(http_proxy_io_instance->underlying_io, option_name, value) != 0)
        -:  910:        {
        -:  911:            /* Codes_SRS_HTTP_PROXY_IO_01_044: [ if xio_setoption fails, http_proxy_io_set_option shall return a non-zero value. ]*/
    #####:  912:            LogError("Unrecognized option");
    #####:  913:            result = __LINE__;
        -:  914:        }
        -:  915:        else
        -:  916:        {
        -:  917:            /* Codes_SRS_HTTP_PROXY_IO_01_042: [ If the option was handled by http_proxy_io_set_option or the underlying IO, then http_proxy_io_set_option shall return 0. ]*/
    #####:  918:            result = 0;
        -:  919:        }
        -:  920:    }
        -:  921:
    #####:  922:    return result;
        -:  923:}
        -:  924:
    #####:  925:static OPTIONHANDLER_HANDLE http_proxy_io_retrieve_options(CONCRETE_IO_HANDLE http_proxy_io)
        -:  926:{
        -:  927:    OPTIONHANDLER_HANDLE result;
        -:  928:
    #####:  929:    if (http_proxy_io == NULL)
        -:  930:    {
        -:  931:        /* Codes_SRS_HTTP_PROXY_IO_01_047: [ If the parameter http_proxy_io is NULL then http_proxy_io_retrieve_options shall fail and return NULL. ]*/
    #####:  932:        LogError("invalid parameter detected: CONCRETE_IO_HANDLE handle=%p", http_proxy_io);
    #####:  933:        result = NULL;
        -:  934:    }
        -:  935:    else
        -:  936:    {
    #####:  937:        HTTP_PROXY_IO_INSTANCE* http_proxy_io_instance = (HTTP_PROXY_IO_INSTANCE*)http_proxy_io;
        -:  938:
        -:  939:        /* Codes_SRS_HTTP_PROXY_IO_01_046: [ http_proxy_io_retrieve_options shall return an OPTIONHANDLER_HANDLE obtained by calling xio_retrieveoptions on the underlying IO created in http_proxy_io_create. ]*/
    #####:  940:        result = xio_retrieveoptions(http_proxy_io_instance->underlying_io);
    #####:  941:        if (result == NULL)
        -:  942:        {
        -:  943:            /* Codes_SRS_HTTP_PROXY_IO_01_048: [ If xio_retrieveoptions fails, http_proxy_io_retrieve_options shall return NULL. ]*/
    #####:  944:            LogError("unable to create option handler");
        -:  945:        }
        -:  946:    }
    #####:  947:    return result;
        -:  948:}
        -:  949:
        -:  950:static const IO_INTERFACE_DESCRIPTION http_proxy_io_interface_description =
        -:  951:{
        -:  952:    http_proxy_io_retrieve_options,
        -:  953:    http_proxy_io_create,
        -:  954:    http_proxy_io_destroy,
        -:  955:    http_proxy_io_open,
        -:  956:    http_proxy_io_close,
        -:  957:    http_proxy_io_send,
        -:  958:    http_proxy_io_dowork,
        -:  959:    http_proxy_io_set_option
        -:  960:};
        -:  961:
    #####:  962:const IO_INTERFACE_DESCRIPTION* http_proxy_io_get_interface_description(void)
        -:  963:{
        -:  964:    /* Codes_SRS_HTTP_PROXY_IO_01_049: [ http_proxy_io_get_interface_description shall return a pointer to an IO_INTERFACE_DESCRIPTION structure that contains pointers to the functions: http_proxy_io_retrieve_options, http_proxy_io_retrieve_create, http_proxy_io_destroy, http_proxy_io_open, http_proxy_io_close, http_proxy_io_send and http_proxy_io_dowork. ]*/
    #####:  965:    return &http_proxy_io_interface_description;
        -:  966:}
