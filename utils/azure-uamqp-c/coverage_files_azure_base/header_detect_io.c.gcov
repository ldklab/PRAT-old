        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/src/header_detect_io.c
        -:    0:Programs:101
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <stddef.h>
        -:    6:#include <stdbool.h>
        -:    7:#include "azure_macro_utils/macro_utils.h"
        -:    8:#include "azure_c_shared_utility/gballoc.h"
        -:    9:#include "azure_c_shared_utility/xlogging.h"
        -:   10:#include "azure_c_shared_utility/singlylinkedlist.h"
        -:   11:#include "azure_uamqp_c/header_detect_io.h"
        -:   12:#include "azure_uamqp_c/server_protocol_io.h"
        -:   13:
        -:   14:static const unsigned char amqp_header_bytes[] = { 'A', 'M', 'Q', 'P', 0, 1, 0, 0 };
        -:   15:static const unsigned char sasl_amqp_header_bytes[] = { 'A', 'M', 'Q', 'P', 3, 1, 0, 0 };
        -:   16:
        -:   17:typedef enum IO_STATE_TAG
        -:   18:{
        -:   19:    IO_STATE_NOT_OPEN,
        -:   20:    IO_STATE_OPENING_UNDERLYING_IO,
        -:   21:    IO_STATE_WAIT_FOR_HEADER,
        -:   22:    IO_STATE_OPENING_DETECTED_IO,
        -:   23:    IO_STATE_OPEN,
        -:   24:    IO_STATE_CLOSING,
        -:   25:    IO_STATE_ERROR
        -:   26:} IO_STATE;
        -:   27:
        -:   28:typedef struct INTERNAL_HEADER_DETECT_ENTRY_TAG
        -:   29:{
        -:   30:    unsigned char* header_bytes;
        -:   31:    size_t header_size;
        -:   32:    const IO_INTERFACE_DESCRIPTION* io_interface_description;
        -:   33:} INTERNAL_HEADER_DETECT_ENTRY;
        -:   34:
        -:   35:typedef struct CHAINED_IO_TAG
        -:   36:{
        -:   37:    XIO_HANDLE detected_io;
        -:   38:    ON_BYTES_RECEIVED on_bytes_received;
        -:   39:    void* on_bytes_received_context;
        -:   40:} CHAINED_IO;
        -:   41:
        -:   42:typedef struct HEADER_DETECT_IO_INSTANCE_TAG
        -:   43:{
        -:   44:    XIO_HANDLE underlying_io;
        -:   45:    IO_STATE io_state;
        -:   46:    size_t header_pos;
        -:   47:    ON_IO_OPEN_COMPLETE on_io_open_complete;
        -:   48:    ON_IO_CLOSE_COMPLETE on_io_close_complete;
        -:   49:    ON_IO_ERROR on_io_error;
        -:   50:    ON_BYTES_RECEIVED on_bytes_received;
        -:   51:    void* on_io_open_complete_context;
        -:   52:    void* on_io_close_complete_context;
        -:   53:    void* on_io_error_context;
        -:   54:    void* on_bytes_received_context;
        -:   55:    INTERNAL_HEADER_DETECT_ENTRY* header_detect_entries;
        -:   56:    size_t header_detect_entry_count;
        -:   57:    SINGLYLINKEDLIST_HANDLE chained_io_list;
        -:   58:    XIO_HANDLE* last_io;
        -:   59:} HEADER_DETECT_IO_INSTANCE;
        -:   60:
    #####:   61:static void destroy_io_chain(HEADER_DETECT_IO_INSTANCE* header_detect_io)
        -:   62:{
    #####:   63:    LIST_ITEM_HANDLE list_item = singlylinkedlist_get_head_item(header_detect_io->chained_io_list);
    #####:   64:    while (list_item != NULL)
        -:   65:    {
    #####:   66:        CHAINED_IO* chained_io = (CHAINED_IO*)singlylinkedlist_item_get_value(list_item);
        -:   67:
    #####:   68:        if (singlylinkedlist_remove(header_detect_io->chained_io_list, list_item) != 0)
        -:   69:        {
    #####:   70:            LogError("Cannot remove detected IO from list");
        -:   71:        }
        -:   72:
    #####:   73:        xio_destroy(chained_io->detected_io);
    #####:   74:        free(chained_io);
        -:   75:
    #####:   76:        list_item = singlylinkedlist_get_head_item(header_detect_io->chained_io_list);
        -:   77:    }
        -:   78:
    #####:   79:    header_detect_io->last_io = &header_detect_io->underlying_io;
    #####:   80:}
        -:   81:
    #####:   82:static void internal_close(HEADER_DETECT_IO_INSTANCE* header_detect_io)
        -:   83:{
        -:   84:    // close the last underlying IO (the one that we're talking to)
    #####:   85:    if (xio_close(*header_detect_io->last_io, NULL, NULL) != 0)
        -:   86:    {
    #####:   87:        LogError("Cannot close underlying IO");
        -:   88:    }
        -:   89:
    #####:   90:    destroy_io_chain(header_detect_io);
        -:   91:
    #####:   92:    header_detect_io->io_state = IO_STATE_NOT_OPEN;
    #####:   93:}
        -:   94:
        -:   95:static void on_underlying_io_open_complete(void* context, IO_OPEN_RESULT open_result);
        -:   96:static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size);
        -:   97:static void on_underlying_io_error(void* context);
        -:   98:
    #####:   99:static void indicate_error(HEADER_DETECT_IO_INSTANCE* header_detect_io_instance)
        -:  100:{
    #####:  101:    if (header_detect_io_instance->on_io_error != NULL)
        -:  102:    {
    #####:  103:        header_detect_io_instance->on_io_error(header_detect_io_instance->on_io_error_context);
        -:  104:    }
    #####:  105:}
        -:  106:
    #####:  107:static void indicate_open_complete(HEADER_DETECT_IO_INSTANCE* header_detect_io_instance, IO_OPEN_RESULT open_result)
        -:  108:{
    #####:  109:    if (header_detect_io_instance->on_io_open_complete != NULL)
        -:  110:    {
    #####:  111:        header_detect_io_instance->on_io_open_complete(header_detect_io_instance->on_io_open_complete_context, open_result);
        -:  112:    }
    #####:  113:}
        -:  114:
    #####:  115:static void indicate_close_complete(HEADER_DETECT_IO_INSTANCE* header_detect_io_instance)
        -:  116:{
    #####:  117:    if (header_detect_io_instance->on_io_close_complete != NULL)
        -:  118:    {
    #####:  119:        header_detect_io_instance->on_io_close_complete(header_detect_io_instance->on_io_close_complete_context);
        -:  120:    }
    #####:  121:}
        -:  122:
    #####:  123:static void on_send_complete(void* context, IO_SEND_RESULT send_result)
        -:  124:{
        -:  125:    // able to send the header
    #####:  126:    HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)context;
        -:  127:
    #####:  128:    if (send_result != IO_SEND_OK)
        -:  129:    {
        -:  130:        // signal error
    #####:  131:        indicate_error(header_detect_io_instance);
        -:  132:    }
    #####:  133:}
        -:  134:
        -:  135:// This callback usage needs to be either verified and commented or integrated into
        -:  136:// the state machine.
    #####:  137:static void unchecked_on_send_complete(void* context, IO_SEND_RESULT send_result)
        -:  138:{
        -:  139:    (void)context;
        -:  140:    (void)send_result;
    #####:  141:}
        -:  142:
    #####:  143:static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)
        -:  144:{
    #####:  145:    if (context == NULL)
        -:  146:    {
        -:  147:        /* Codes_SRS_HEADER_DETECT_IO_01_050: [ If `context` is NULL, `on_underlying_io_bytes_received` shall do nothing. ]*/
    #####:  148:        LogError("NULL context");
        -:  149:    }
        -:  150:    else
        -:  151:    {
    #####:  152:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)context;
        -:  153:
    #####:  154:        if ((buffer == NULL) ||
        -:  155:            (size == 0))
        -:  156:        {
    #####:  157:            switch (header_detect_io_instance->io_state)
        -:  158:            {
    #####:  159:            default:
    #####:  160:                break;
        -:  161:
    #####:  162:            case IO_STATE_OPEN:
        -:  163:                /* Codes_SRS_HEADER_DETECT_IO_01_051: [ If `buffer` is NULL or `size` is 0 while the IO is OPEN an error shall be indicated by calling `on_io_error`. ]*/
    #####:  164:                indicate_error(header_detect_io_instance);
    #####:  165:                break;
        -:  166:            }
        -:  167:        }
        -:  168:        else
        -:  169:        {
    #####:  170:            while (size > 0)
        -:  171:            {
    #####:  172:                switch (header_detect_io_instance->io_state)
        -:  173:                {
    #####:  174:                default:
    #####:  175:                    break;
        -:  176:
    #####:  177:                case IO_STATE_OPENING_UNDERLYING_IO:
        -:  178:                    /* Codes_SRS_HEADER_DETECT_IO_01_049: [ When `on_underlying_io_bytes_received` is called while opening the underlying IO (before the underlying open complete is received), an error shall be indicated by calling `on_io_open_complete` with `IO_OPEN_ERROR`. ]*/
    #####:  179:                    indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
    #####:  180:                    size = 0;
    #####:  181:                    break;
        -:  182:
    #####:  183:                case IO_STATE_OPENING_DETECTED_IO:
        -:  184:                {
        -:  185:                    /* Codes_SRS_HEADER_DETECT_IO_01_087: [ If `on_underlying_io_bytes_received` is called while waiting for the detected IO to complete its open, the bytes shall be given to the last created IO by calling its `on_bytes_received` callback that was filled into the `on_bytes_received` member of `SERVER_PROTOCOL_IO_CONFIG`. ]*/
    #####:  186:                    CHAINED_IO* chained_io = (CHAINED_IO*)(((unsigned char*)header_detect_io_instance->last_io) - offsetof(CHAINED_IO, detected_io));
    #####:  187:                    (chained_io->on_bytes_received)(chained_io->on_bytes_received_context, buffer, size);
    #####:  188:                    size = 0;
    #####:  189:                    break;
        -:  190:                }
        -:  191:
    #####:  192:                case IO_STATE_WAIT_FOR_HEADER:
        -:  193:                {
        -:  194:                    size_t i;
    #####:  195:                    bool has_one_match = false;
        -:  196:
        -:  197:                    /* check if any of the headers matches */
    #####:  198:                    for (i = 0; i < header_detect_io_instance->header_detect_entry_count; i++)
        -:  199:                    {
        -:  200:                        /* Codes_SRS_HEADER_DETECT_IO_01_067: [ When `on_underlying_io_bytes_received` is called while waiting for header bytes (after the underlying IO was open), the bytes shall be matched against the entries provided in the configuration passed to `header_detect_io_create`. ]*/
        -:  201:                        /* Codes_SRS_HEADER_DETECT_IO_01_068: [ Header bytes shall be accepted in multiple `on_underlying_io_bytes_received` calls. ]*/
    #####:  202:                        if ((header_detect_io_instance->header_pos < header_detect_io_instance->header_detect_entries[i].header_size) &&
    #####:  203:                            (header_detect_io_instance->header_detect_entries[i].header_bytes[header_detect_io_instance->header_pos] == buffer[0]))
        -:  204:                        {
    #####:  205:                            has_one_match = true;
        -:  206:
    #####:  207:                            if (header_detect_io_instance->header_pos + 1 == header_detect_io_instance->header_detect_entries[i].header_size)
        -:  208:                            {
        -:  209:                                /* recognized one header */
    #####:  210:                                if (xio_send(*header_detect_io_instance->last_io, header_detect_io_instance->header_detect_entries[i].header_bytes, header_detect_io_instance->header_detect_entries[i].header_size, on_send_complete, header_detect_io_instance) != 0)
        -:  211:                                {
    #####:  212:                                    LogError("Failed sending header");
    #####:  213:                                    header_detect_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  214:                                    indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
        -:  215:                                }
        -:  216:                                else
        -:  217:                                {
        -:  218:                                    // wait for send complete and then start the detected IO open
    #####:  219:                                    if (header_detect_io_instance->header_detect_entries[i].io_interface_description == NULL)
        -:  220:                                    {
    #####:  221:                                        header_detect_io_instance->io_state = IO_STATE_OPEN;
    #####:  222:                                        indicate_open_complete(header_detect_io_instance, IO_OPEN_OK);
        -:  223:                                    }
        -:  224:                                    else
        -:  225:                                    {
        -:  226:                                        SERVER_PROTOCOL_IO_CONFIG server_protocol_io_config;
    #####:  227:                                        CHAINED_IO* chained_io = (CHAINED_IO*)malloc(sizeof(CHAINED_IO));
    #####:  228:                                        if (chained_io == NULL)
        -:  229:                                        {
    #####:  230:                                            LogError("Cannot allocate memory for chained IO");
    #####:  231:                                            internal_close(header_detect_io_instance);
    #####:  232:                                            indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
        -:  233:                                        }
        -:  234:                                        else
        -:  235:                                        {
        -:  236:                                            /* Codes_SRS_HEADER_DETECT_IO_01_076: [ If no detected IO was created then the underlying IO in the `SERVER_PROTOCOL_IO_CONFIG` structure shall be set to the `underlying_io` passed in the create arguments. ]*/
        -:  237:                                            /* Codes_SRS_HEADER_DETECT_IO_01_075: [ The underlying IO in the `SERVER_PROTOCOL_IO_CONFIG` structure shall be set to the last detected IO that was created if any. ]*/
    #####:  238:                                            server_protocol_io_config.underlying_io = *header_detect_io_instance->last_io;
    #####:  239:                                            server_protocol_io_config.on_bytes_received = &chained_io->on_bytes_received;
    #####:  240:                                            server_protocol_io_config.on_bytes_received_context = &chained_io->on_bytes_received_context;
        -:  241:
        -:  242:                                            /* Codes_SRS_HEADER_DETECT_IO_01_069: [ If a header match was detected on an entry with a non-NULL io handle, a new IO associated shall be created by calling `xio_create`. ]*/
        -:  243:                                            /* Codes_SRS_HEADER_DETECT_IO_01_073: [ The interface description passed to `xio_create` shall be the interface description associated with the detected header. ]*/
        -:  244:                                            /* Codes_SRS_HEADER_DETECT_IO_01_074: [ The IO create parameters shall be a `SERVER_PROTOCOL_IO_CONFIG` structure. ]*/
    #####:  245:                                            chained_io->detected_io = xio_create(header_detect_io_instance->header_detect_entries[i].io_interface_description, &server_protocol_io_config);
    #####:  246:                                            if (chained_io->detected_io == NULL)
        -:  247:                                            {
        -:  248:                                                /* Codes_SRS_HEADER_DETECT_IO_01_077: [ If `xio_create` fails the header detect IO shall be closed and an error shall be indicated by calling `on_io_open_complete` with `IO_OPEN_ERROR`. ]*/
    #####:  249:                                                LogError("Creating detected IO failed");
    #####:  250:                                                free(chained_io);
    #####:  251:                                                internal_close(header_detect_io_instance);
    #####:  252:                                                indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
        -:  253:                                            }
        -:  254:                                            else
        -:  255:                                            {
        -:  256:                                                /* Codes_SRS_HEADER_DETECT_IO_01_086: [ The newly created IO shall be added to the chain of IOs by calling `singlylinkedlist_add`. ]*/
    #####:  257:                                                LIST_ITEM_HANDLE new_list_item = singlylinkedlist_add(header_detect_io_instance->chained_io_list, chained_io);
    #####:  258:                                                if (new_list_item == NULL)
        -:  259:                                                {
        -:  260:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_084: [ If `singlylinkedlist_add` fails the newly created IO shall be destroyed and an error shall be indicated by calling `on_io_open_complete` with `IO_OPEN_ERROR`. ]*/
    #####:  261:                                                    LogError("Cannot add detected IO to list");
    #####:  262:                                                    xio_destroy(chained_io->detected_io);
    #####:  263:                                                    free(chained_io);
    #####:  264:                                                    internal_close(header_detect_io_instance);
    #####:  265:                                                    indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
        -:  266:                                                }
        -:  267:                                                else
        -:  268:                                                {
        -:  269:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_063: [ `header_detect_io_close_async` shall close the last detected IO that was created as a result of matching a header. ]*/
    #####:  270:                                                    XIO_HANDLE* previous_last_io = header_detect_io_instance->last_io;
    #####:  271:                                                    header_detect_io_instance->last_io = &chained_io->detected_io;
        -:  272:
        -:  273:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_083: [ The header detect IO shall wait for opening of the detected IO (signaled by the `on_underlying_io_open_complete`). ]*/
    #####:  274:                                                    header_detect_io_instance->io_state = IO_STATE_OPENING_DETECTED_IO;
        -:  275:
        -:  276:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_078: [ The newly create IO shall be open by calling `xio_open`. ]*/
        -:  277:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_079: [ The `on_io_open_complete` callback passed to `xio_open` shall be `on_underlying_io_open_complete`. ]*/
        -:  278:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_080: [ The `on_bytes_received` callback passed to `xio_open` shall be `on_underlying_io_bytes_received`. ]*/
        -:  279:                                                    /* Codes_SRS_HEADER_DETECT_IO_01_081: [ The `on_io_error` callback passed to `xio_open` shall be `on_underlying_io_error`. ]*/
    #####:  280:                                                    if (xio_open(chained_io->detected_io, on_underlying_io_open_complete, header_detect_io_instance, on_underlying_io_bytes_received, header_detect_io_instance, on_underlying_io_error, header_detect_io_instance) != 0)
        -:  281:                                                    {
        -:  282:                                                        /* Codes_SRS_HEADER_DETECT_IO_01_082: [ If `xio_open` fails the header detect IO shall be closed and an error shall be indicated by calling `on_io_open_complete` with `IO_OPEN_ERROR`. ]*/
    #####:  283:                                                        LogError("Opening detected IO failed");
    #####:  284:                                                        if (singlylinkedlist_remove(header_detect_io_instance->chained_io_list, new_list_item) != 0)
        -:  285:                                                        {
    #####:  286:                                                            LogError("Cannot remove chained IO from list");
        -:  287:                                                        }
        -:  288:
    #####:  289:                                                        xio_destroy(chained_io->detected_io);
    #####:  290:                                                        free(chained_io);
    #####:  291:                                                        header_detect_io_instance->last_io = previous_last_io;
    #####:  292:                                                        internal_close(header_detect_io_instance);
    #####:  293:                                                        indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
        -:  294:                                                    }
        -:  295:                                                    else
        -:  296:                                                    {
        -:  297:                                                        // all OK
        -:  298:                                                    }
        -:  299:                                                }
        -:  300:                                            }
        -:  301:                                        }
        -:  302:                                    }
        -:  303:                                }
        -:  304:
    #####:  305:                                break;
        -:  306:                            }
        -:  307:                        }
        -:  308:                    }
        -:  309:
    #####:  310:                    if (has_one_match)
        -:  311:                    {
    #####:  312:                        if (header_detect_io_instance->io_state == IO_STATE_OPENING_DETECTED_IO)
        -:  313:                        {
    #####:  314:                            header_detect_io_instance->header_pos = 0;
        -:  315:                        }
        -:  316:                        else
        -:  317:                        {
    #####:  318:                            header_detect_io_instance->header_pos++;
        -:  319:                        }
        -:  320:
    #####:  321:                        size--;
    #####:  322:                        buffer++;
        -:  323:                    }
        -:  324:                    else
        -:  325:                    {
        -:  326:                        /* all header matches failed, we can't proceed, send back to the peer the first header we know of, */
        -:  327:                        /* then close as per spec.  We do not care if we fail sending */
    #####:  328:                        if (xio_send(header_detect_io_instance->underlying_io, header_detect_io_instance->header_detect_entries[0].header_bytes, header_detect_io_instance->header_detect_entries[0].header_size, unchecked_on_send_complete, NULL) != 0)
        -:  329:                        {
    #####:  330:                            LogError("Failed sending header");
        -:  331:                        }
        -:  332:
    #####:  333:                        internal_close(header_detect_io_instance);
    #####:  334:                        indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
    #####:  335:                        size = 0;
        -:  336:                    }
        -:  337:
    #####:  338:                    break;
        -:  339:                }
        -:  340:
    #####:  341:                case IO_STATE_OPEN:
        -:  342:                    /* Codes_SRS_HEADER_DETECT_IO_01_089: [ If `on_underlying_io_bytes_received` is called while header detect IO is OPEN the bytes shall be given to the user via the `on_bytes_received` callback that was the `on_bytes_received` callback passed to `header_detect_io_open_async`. ]*/
        -:  343:                    /* Codes_SRS_HEADER_DETECT_IO_01_090: [ If no detected IOs were created and `on_underlying_io_bytes_received` is called while header detect IO is OPEN, the `on_bytes_received` callback passed to `header_detect_io_open_async` shall be called to indicate the bytes as received. ]*/
    #####:  344:                    header_detect_io_instance->on_bytes_received(header_detect_io_instance->on_bytes_received_context, buffer, size);
    #####:  345:                    size = 0;
    #####:  346:                    break;
        -:  347:                }
        -:  348:            }
        -:  349:        }
        -:  350:    }
    #####:  351:}
        -:  352:
    #####:  353:static void on_underlying_io_close_complete(void* context)
        -:  354:{
    #####:  355:    HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)context;
        -:  356:
    #####:  357:    switch (header_detect_io_instance->io_state)
        -:  358:    {
    #####:  359:    default:
    #####:  360:        break;
        -:  361:
    #####:  362:    case IO_STATE_CLOSING:
        -:  363:        /* Codes_SRS_HEADER_DETECT_IO_01_095: [ When `on_underlying_io_open_complete` is called when the IO is closing, it shall destroy all the detected IOs that were created. ]*/
    #####:  364:        destroy_io_chain(header_detect_io_instance);
        -:  365:
    #####:  366:        header_detect_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  367:        indicate_close_complete(header_detect_io_instance);
    #####:  368:        break;
        -:  369:
    #####:  370:    case IO_STATE_WAIT_FOR_HEADER:
        -:  371:    case IO_STATE_OPENING_DETECTED_IO:
        -:  372:    case IO_STATE_OPENING_UNDERLYING_IO:
    #####:  373:        header_detect_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  374:        indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
    #####:  375:        break;
        -:  376:    }
    #####:  377:}
        -:  378:
    #####:  379:static void on_underlying_io_open_complete(void* context, IO_OPEN_RESULT open_result)
        -:  380:{
    #####:  381:    if (context == NULL)
        -:  382:    {
        -:  383:        /* Codes_SRS_HEADER_DETECT_IO_01_048: [ If `context` is NULL, `on_underlying_io_open_complete` shall do nothing. ]*/
    #####:  384:        LogError("NULL context");
        -:  385:    }
        -:  386:    else
        -:  387:    {
    #####:  388:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)context;
        -:  389:
    #####:  390:        if (open_result == IO_OPEN_OK)
        -:  391:        {
    #####:  392:            switch (header_detect_io_instance->io_state)
        -:  393:            {
    #####:  394:            default:
    #####:  395:                LogError("on_io_open_complete called in unexpected state: %d", (int)header_detect_io_instance->io_state);
    #####:  396:                break;
        -:  397:
    #####:  398:            case IO_STATE_OPENING_DETECTED_IO:
        -:  399:            case IO_STATE_OPENING_UNDERLYING_IO:
        -:  400:                /* Codes_SRS_HEADER_DETECT_IO_01_046: [ When `on_underlying_io_open_complete` is called with `open_result` being `IO_OPEN_OK` while OPENING, the IO shall start monitoring received bytes in order to detect headers. ]*/
    #####:  401:                header_detect_io_instance->io_state = IO_STATE_WAIT_FOR_HEADER;
    #####:  402:                break;
        -:  403:            }
        -:  404:        }
        -:  405:        else
        -:  406:        {
    #####:  407:            switch (header_detect_io_instance->io_state)
        -:  408:            {
    #####:  409:            default:
    #####:  410:                LogError("on_io_open_complete called in unexpected state: %d", (int)header_detect_io_instance->io_state);
    #####:  411:                break;
        -:  412:
    #####:  413:            case IO_STATE_OPENING_DETECTED_IO:
        -:  414:            case IO_STATE_OPENING_UNDERLYING_IO:
        -:  415:                /* Codes_SRS_HEADER_DETECT_IO_01_047: [ When `on_underlying_io_open_complete` is called with `open_result` being `IO_OPEN_ERROR` while OPENING, the `on_io_open_complete` callback passed to `header_detect_io_open` shall be called with `IO_OPEN_ERROR`. ]*/
    #####:  416:                internal_close(header_detect_io_instance);
        -:  417:
    #####:  418:                header_detect_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  419:                indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
    #####:  420:                break;
        -:  421:            }
        -:  422:        }
        -:  423:    }
    #####:  424:}
        -:  425:
    #####:  426:static void on_underlying_io_error(void* context)
        -:  427:{
    #####:  428:    if (context == NULL)
        -:  429:    {
        -:  430:        /* Codes_SRS_HEADER_DETECT_IO_01_058: [ If `context` is NULL, `on_underlying_io_error` shall do nothing. ]*/
    #####:  431:        LogError("NULL context");
        -:  432:    }
        -:  433:    else
        -:  434:    {
    #####:  435:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)context;
        -:  436:
    #####:  437:        switch (header_detect_io_instance->io_state)
        -:  438:        {
    #####:  439:        default:
    #####:  440:            break;
        -:  441:
    #####:  442:        case IO_STATE_WAIT_FOR_HEADER:
        -:  443:        case IO_STATE_OPENING_DETECTED_IO:
        -:  444:        case IO_STATE_OPENING_UNDERLYING_IO:
        -:  445:            /* Tests_SRS_HEADER_DETECT_IO_01_057: [ When `on_underlying_io_error` is called while OPENING, the IO shall indicate an error by calling `on_io_open_complete` with `IO_OPEN_ERROR` and it shall close the underlying IOs. ]*/
    #####:  446:            internal_close(header_detect_io_instance);
    #####:  447:            indicate_open_complete(header_detect_io_instance, IO_OPEN_ERROR);
    #####:  448:            break;
        -:  449:
    #####:  450:        case IO_STATE_OPEN:
        -:  451:            /* Codes_SRS_HEADER_DETECT_IO_01_059: [ When `on_underlying_io_error` is called while OPEN, the error should be indicated to the consumer by calling `on_io_error` and passing the `on_io_error_context` to it. ]*/
    #####:  452:            header_detect_io_instance->io_state = IO_STATE_ERROR;
    #####:  453:            indicate_error(header_detect_io_instance);
    #####:  454:            break;
        -:  455:        }
        -:  456:    }
    #####:  457:}
        -:  458:
    #####:  459:static CONCRETE_IO_HANDLE header_detect_io_create(void* io_create_parameters)
        -:  460:{
        -:  461:    HEADER_DETECT_IO_INSTANCE* result;
        -:  462:
    #####:  463:    if (io_create_parameters == NULL)
        -:  464:    {
        -:  465:        /* Codes_SRS_HEADER_DETECT_IO_01_003: [ If `io_create_parameters` is NULL, `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  466:        LogError("NULL io_create_parameters");
    #####:  467:        result = NULL;
        -:  468:    }
        -:  469:    else
        -:  470:    {
        -:  471:        /* Codes_SRS_HEADER_DETECT_IO_01_004: [ `io_create_parameters` shall be used as `HEADER_DETECT_IO_CONFIG*`. ]*/
    #####:  472:        HEADER_DETECT_IO_CONFIG* header_detect_io_config = (HEADER_DETECT_IO_CONFIG*)io_create_parameters;
        -:  473:
        -:  474:        /* Codes_SRS_HEADER_DETECT_IO_01_005: [ If the member `header_detect_entry_count` of `HEADER_DETECT_IO_CONFIG` is 0 then `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  475:        if ((header_detect_io_config->header_detect_entry_count == 0) ||
        -:  476:            /* Codes_SRS_HEADER_DETECT_IO_01_006: [ If the member `header_detect_entries` is NULL then `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  477:            (header_detect_io_config->header_detect_entries == NULL) ||
        -:  478:            /* Codes_SRS_HEADER_DETECT_IO_01_007: [ If the member `underlying_io` is NULL then `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  479:            (header_detect_io_config->underlying_io == NULL))
        -:  480:        {
    #####:  481:            LogError("Bad create parameters: header_detect_entry_count = %lu, header_detect_entries = %p, underlying_io = %p",
        -:  482:                (unsigned long)header_detect_io_config->header_detect_entry_count,
        -:  483:                header_detect_io_config->header_detect_entries,
        -:  484:                header_detect_io_config->underlying_io);
    #####:  485:            result = NULL;
        -:  486:        }
        -:  487:        else
        -:  488:        {
        -:  489:            size_t i;
    #####:  490:            bool null_io_found = false;
        -:  491:
    #####:  492:            for (i = 0; i < header_detect_io_config->header_detect_entry_count; i++)
        -:  493:            {
        -:  494:                /* Codes_SRS_HEADER_DETECT_IO_01_052: [ The `io` member in the in each of the `header_detect_entries` shall be allowed to be NULL. ]*/
    #####:  495:                if (header_detect_io_config->header_detect_entries[i].header.header_bytes == NULL)
        -:  496:                {
    #####:  497:                    LogError("header detect entry %u is invalid", (unsigned int)i);
    #####:  498:                    break;
        -:  499:                }
        -:  500:
    #####:  501:                if (header_detect_io_config->header_detect_entries[i].io_interface_description == NULL)
        -:  502:                {
    #####:  503:                    null_io_found = true;
        -:  504:                }
        -:  505:            }
        -:  506:
    #####:  507:            if (i < header_detect_io_config->header_detect_entry_count)
        -:  508:            {
    #####:  509:                result = NULL;
        -:  510:            }
    #####:  511:            else if (!null_io_found)
        -:  512:            {
        -:  513:                /* Codes_SRS_HEADER_DETECT_IO_01_054: [ At least one entry in `header_detect_entries` shall have IO set to NULL, otherwise `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  514:                LogError("No default header found");
    #####:  515:                result = NULL;
        -:  516:            }
        -:  517:            else
        -:  518:            {
        -:  519:                /* Codes_SRS_HEADER_DETECT_IO_01_001: [ `header_detect_io_create` shall create a new header detect IO instance and on success it shall return a non-NULL handle to the newly created instance. ] */
    #####:  520:                result = (HEADER_DETECT_IO_INSTANCE*)malloc(sizeof(HEADER_DETECT_IO_INSTANCE));
    #####:  521:                if (result == NULL)
        -:  522:                {
        -:  523:                    /* Codes_SRS_HEADER_DETECT_IO_01_002: [ If allocating memory for the header detect IO instance fails, `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  524:                    LogError("Cannot allocate memory for header detect IO");
        -:  525:                }
        -:  526:                else
        -:  527:                {
        -:  528:                    /* Codes_SRS_HEADER_DETECT_IO_01_009: [ The `header_detect_entries` array shall be copied so that it can be later used when detecting which header was received. ]*/
    #####:  529:                    result->header_detect_entries = (INTERNAL_HEADER_DETECT_ENTRY*)malloc(header_detect_io_config->header_detect_entry_count * sizeof(INTERNAL_HEADER_DETECT_ENTRY));
    #####:  530:                    if (result->header_detect_entries == NULL)
        -:  531:                    {
    #####:  532:                        free(result);
    #####:  533:                        result = NULL;
        -:  534:                    }
        -:  535:                    else
        -:  536:                    {
    #####:  537:                        result->header_detect_entry_count = header_detect_io_config->header_detect_entry_count;
        -:  538:
        -:  539:                        /* Codes_SRS_HEADER_DETECT_IO_01_009: [ The `header_detect_entries` array shall be copied so that it can be later used when detecting which header was received. ]*/
    #####:  540:                        for (i = 0; i < header_detect_io_config->header_detect_entry_count; i++)
        -:  541:                        {
    #####:  542:                            result->header_detect_entries[i].header_size = header_detect_io_config->header_detect_entries[i].header.header_size;
    #####:  543:                            result->header_detect_entries[i].header_bytes = (unsigned char*)malloc(result->header_detect_entries[i].header_size);
    #####:  544:                            if (result->header_detect_entries[i].header_bytes == NULL)
        -:  545:                            {
        -:  546:                                /* Codes_SRS_HEADER_DETECT_IO_01_010: [ If allocating memory for the `header_detect_entries` or its constituents fails then `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  547:                                break;
        -:  548:                            }
        -:  549:                            else
        -:  550:                            {
        -:  551:                                /* Codes_SRS_HEADER_DETECT_IO_01_014: [ For each entry in `header_detect_entries` the `header` field shall also be copied. ]*/
    #####:  552:                                (void)memcpy(result->header_detect_entries[i].header_bytes, header_detect_io_config->header_detect_entries[i].header.header_bytes, result->header_detect_entries[i].header_size);
    #####:  553:                                result->header_detect_entries[i].io_interface_description = header_detect_io_config->header_detect_entries[i].io_interface_description;
        -:  554:                            }
        -:  555:                        }
        -:  556:
    #####:  557:                        if (i < header_detect_io_config->header_detect_entry_count)
        -:  558:                        {
        -:  559:                            size_t j;
        -:  560:
    #####:  561:                            LogError("Failed copying header detect configuration");
    #####:  562:                            for (j = 0; j < i; j++)
        -:  563:                            {
    #####:  564:                                free(result->header_detect_entries[j].header_bytes);
        -:  565:                            }
        -:  566:
    #####:  567:                            free(result->header_detect_entries);
    #####:  568:                            free(result);
    #####:  569:                            result = NULL;
        -:  570:                        }
        -:  571:                        else
        -:  572:                        {
        -:  573:                            /* Codes_SRS_HEADER_DETECT_IO_01_060: [ `header_detect_io_create` shall create a singly linked list by calling `singlylinkedlist_create` where the chained detected IOs shall be stored. ]*/
    #####:  574:                            result->chained_io_list = singlylinkedlist_create();
    #####:  575:                            if (result->chained_io_list == NULL)
        -:  576:                            {
        -:  577:                                /* Codes_SRS_HEADER_DETECT_IO_01_065: [ If `singlylinkedlist_create` fails then `header_detect_io_create` shall fail and return NULL. ]*/
    #####:  578:                                LogError("Failed copying header detect configuration");
    #####:  579:                                for (i = 0; i < result->header_detect_entry_count; i++)
        -:  580:                                {
    #####:  581:                                    free(result->header_detect_entries[i].header_bytes);
        -:  582:                                }
        -:  583:
    #####:  584:                                free(result->header_detect_entries);
    #####:  585:                                free(result);
    #####:  586:                                result = NULL;
        -:  587:                            }
        -:  588:                            else
        -:  589:                            {
    #####:  590:                                result->underlying_io = header_detect_io_config->underlying_io;
    #####:  591:                                result->on_io_open_complete = NULL;
    #####:  592:                                result->on_io_close_complete = NULL;
    #####:  593:                                result->on_io_error = NULL;
    #####:  594:                                result->on_bytes_received = NULL;
    #####:  595:                                result->on_io_open_complete_context = NULL;
    #####:  596:                                result->on_io_close_complete_context = NULL;
    #####:  597:                                result->on_io_error_context = NULL;
    #####:  598:                                result->on_bytes_received_context = NULL;
        -:  599:
        -:  600:                                /* Codes_SRS_HEADER_DETECT_IO_01_070: [ If no detected IO was created then `header_detect_io_close_async` shall close the `underlying_io` passed in `header_detect_io_create`. ]*/
    #####:  601:                                result->last_io = &result->underlying_io;
        -:  602:
    #####:  603:                                result->io_state = IO_STATE_NOT_OPEN;
        -:  604:                            }
        -:  605:                        }
        -:  606:                    }
        -:  607:                }
        -:  608:            }
        -:  609:        }
        -:  610:    }
        -:  611:
    #####:  612:    return result;
        -:  613:}
        -:  614:
    #####:  615:static void header_detect_io_destroy(CONCRETE_IO_HANDLE header_detect_io)
        -:  616:{
    #####:  617:    if (header_detect_io == NULL)
        -:  618:    {
        -:  619:        /* Codes_SRS_HEADER_DETECT_IO_01_012: [ If `header_detect_io` is NULL, `header_detect_io_destroy` shall do nothing. ]*/
    #####:  620:        LogError("NULL header_detect_io");
        -:  621:    }
        -:  622:    else
        -:  623:    {
        -:  624:        size_t i;
    #####:  625:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)header_detect_io;
        -:  626:
    #####:  627:        if (header_detect_io_instance->io_state != IO_STATE_NOT_OPEN)
        -:  628:        {
        -:  629:            /* Codes_SRS_HEADER_DETECT_IO_01_062: [ If the IO is still open when `header_detect_io_destroy` is called, all actions normally executed when closing the IO shall also be executed. ]*/
    #####:  630:            internal_close(header_detect_io_instance);
        -:  631:        }
        -:  632:
        -:  633:        /* Codes_SRS_HEADER_DETECT_IO_01_061: [ `header_detect_io_destroy` shall destroy the chained IO list by calling `singlylinkedlist_destroy`. ]*/
    #####:  634:        singlylinkedlist_destroy(header_detect_io_instance->chained_io_list);
        -:  635:
        -:  636:        /* Codes_SRS_HEADER_DETECT_IO_01_011: [ `header_detect_io_destroy` shall free all resources associated with the `header_detect_io` handle. ]*/
    #####:  637:        for (i = 0; i < header_detect_io_instance->header_detect_entry_count; i++)
        -:  638:        {
        -:  639:            /* Codes_SRS_HEADER_DETECT_IO_01_013: [ `header_detect_io_destroy` shall free the memory allocated for the `header_detect_entries`. ]*/
    #####:  640:            free(header_detect_io_instance->header_detect_entries[i].header_bytes);
        -:  641:        }
        -:  642:
    #####:  643:        free(header_detect_io_instance->header_detect_entries);
        -:  644:
    #####:  645:        free(header_detect_io);
        -:  646:    }
    #####:  647:}
        -:  648:
    #####:  649:static int header_detect_io_open_async(CONCRETE_IO_HANDLE header_detect_io, ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context, ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context, ON_IO_ERROR on_io_error, void* on_io_error_context)
        -:  650:{
        -:  651:    int result;
        -:  652:
    #####:  653:    if ((header_detect_io == NULL) ||
    #####:  654:        (on_io_open_complete == NULL) ||
    #####:  655:        (on_bytes_received == NULL) ||
        -:  656:        (on_io_error == NULL))
        -:  657:    {
        -:  658:        /* Codes_SRS_HEADER_DETECT_IO_01_021: [ If `header_detect_io`, `on_io_open_complete`, `on_bytes_received` or `on_io_error` is NULL, `header_detect_io_open_async` shall fail and return a non-zero value. ]*/
    #####:  659:        LogError("Bad arguments: header_detect_io = %p, on_io_open_complete = %p, on_bytes_received = %p, on_io_error = %p",
        -:  660:            header_detect_io, on_io_open_complete, on_bytes_received, on_io_error);
    #####:  661:        result = MU_FAILURE;
        -:  662:    }
        -:  663:    else
        -:  664:    {
    #####:  665:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)header_detect_io;
        -:  666:
    #####:  667:        if (header_detect_io_instance->io_state != IO_STATE_NOT_OPEN)
        -:  668:        {
        -:  669:            /* Codes_SRS_HEADER_DETECT_IO_01_020: [ If the IO is already OPEN or OPENING then `header_detect_io_open_async` shall fail and return a non-zero value. ]*/
    #####:  670:            LogError("Already OPEN");
    #####:  671:            result = MU_FAILURE;
        -:  672:        }
        -:  673:        else
        -:  674:        {
    #####:  675:            header_detect_io_instance->on_bytes_received = on_bytes_received;
    #####:  676:            header_detect_io_instance->on_io_open_complete = on_io_open_complete;
    #####:  677:            header_detect_io_instance->on_io_error = on_io_error;
    #####:  678:            header_detect_io_instance->on_bytes_received_context = on_bytes_received_context;
    #####:  679:            header_detect_io_instance->on_io_open_complete_context = on_io_open_complete_context;
    #####:  680:            header_detect_io_instance->on_io_error_context = on_io_error_context;
        -:  681:
    #####:  682:            header_detect_io_instance->io_state = IO_STATE_OPENING_UNDERLYING_IO;
    #####:  683:            header_detect_io_instance->header_pos = 0;
        -:  684:
        -:  685:            /* Codes_SRS_HEADER_DETECT_IO_01_015: [ `header_detect_io_open_async` shall open the underlying IO by calling `xio_open` and passing to it: ]*/
        -:  686:            /* Codes_SRS_HEADER_DETECT_IO_01_016: [ - `xio` shall be the `underlying_io` member of the `io_create_parameters` passed to `header_detect_io_create`. ]*/
        -:  687:            /* Codes_SRS_HEADER_DETECT_IO_01_017: [ - `on_io_open_complete`, `on_io_open_complete_context`, `on_bytes_received`, `on_bytes_received_context`, `on_error` and `on_error_context` shall be set to implementation specific values of `header_detect_io`. ]*/
    #####:  688:            if (xio_open(header_detect_io_instance->underlying_io, on_underlying_io_open_complete, header_detect_io_instance, on_underlying_io_bytes_received, header_detect_io_instance, on_underlying_io_error, header_detect_io_instance) != 0)
        -:  689:            {
        -:  690:                /* Codes_SRS_HEADER_DETECT_IO_01_019: [ If `xio_open` fails, `header_detect_io_open_async` shall fail and return a non-zero value. ]*/
    #####:  691:                LogError("xio_open failed");
    #####:  692:                result = MU_FAILURE;
        -:  693:            }
        -:  694:            else
        -:  695:            {
        -:  696:                /* Codes_SRS_HEADER_DETECT_IO_01_018: [ On success `header_detect_io_open_async` shall return 0. ]*/
    #####:  697:                result = 0;
        -:  698:            }
        -:  699:        }
        -:  700:    }
        -:  701:
    #####:  702:    return result;
        -:  703:}
        -:  704:
    #####:  705:static int header_detect_io_close_async(CONCRETE_IO_HANDLE header_detect_io, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* callback_context)
        -:  706:{
        -:  707:    int result;
        -:  708:
    #####:  709:    if (header_detect_io == NULL)
        -:  710:    {
        -:  711:        /* Codes_SRS_HEADER_DETECT_IO_01_026: [ If `header_detect_io` is NULL, `header_detect_io_close_async` shall fail and return a non-zero value. ]*/
    #####:  712:        LogError("NULL header_detect_io");
    #####:  713:        result = MU_FAILURE;
        -:  714:    }
        -:  715:    else
        -:  716:    {
    #####:  717:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)header_detect_io;
        -:  718:
        -:  719:        /* Codes_SRS_HEADER_DETECT_IO_01_027: [ If the IO is not OPEN (open has not been called or close has been completely carried out) `header_detect_io_close_async` shall fail and return a non-zero value. ]*/
    #####:  720:        if ((header_detect_io_instance->io_state == IO_STATE_OPENING_UNDERLYING_IO) ||
    #####:  721:            (header_detect_io_instance->io_state == IO_STATE_OPENING_DETECTED_IO) ||
    #####:  722:            (header_detect_io_instance->io_state == IO_STATE_WAIT_FOR_HEADER))
        -:  723:        {
        -:  724:            /* Codes_SRS_HEADER_DETECT_IO_01_028: [ If the IO is OPENING (`header_detect_io_open_async` has been called, but no header has been detected yet), `header_detect_io_close_async` shall close the underlying IO and call `on_io_open_complete` with `IO_OPEN_CANCELLED`. ]*/
    #####:  725:            (void)internal_close(header_detect_io_instance);
    #####:  726:            header_detect_io_instance->on_io_open_complete(header_detect_io_instance->on_io_open_complete_context, IO_OPEN_CANCELLED);
    #####:  727:            result = 0;
        -:  728:        }
    #####:  729:        else if ((header_detect_io_instance->io_state == IO_STATE_NOT_OPEN) ||
        -:  730:            /* Codes_SRS_HEADER_DETECT_IO_01_053: [ If the IO is CLOSING then `header_detect_io_close_async` shall fail and return a non-zero value. ]*/
    #####:  731:            (header_detect_io_instance->io_state == IO_STATE_CLOSING))
        -:  732:        {
    #####:  733:            LogError("Not open");
    #####:  734:            result = MU_FAILURE;
        -:  735:        }
        -:  736:        else
        -:  737:        {
    #####:  738:            header_detect_io_instance->io_state = IO_STATE_CLOSING;
    #####:  739:            header_detect_io_instance->on_io_close_complete = on_io_close_complete;
    #####:  740:            header_detect_io_instance->on_io_close_complete_context = callback_context;
        -:  741:
        -:  742:            /* Codes_SRS_HEADER_DETECT_IO_01_022: [ `header_detect_io_close_async` shall close the underlying IO by calling `xio_close` and passing to it: ]*/
        -:  743:            /* Codes_SRS_HEADER_DETECT_IO_01_023: [ - `xio` shall be the `underlying_io` member of the `io_create_parameters` passed to `header_detect_io_create`. ]*/
        -:  744:            /* Codes_SRS_HEADER_DETECT_IO_01_024: [ - `on_io_close_complete` shall be set to implementation specific values of `header_detect_io`. ]*/
    #####:  745:            if (xio_close(*header_detect_io_instance->last_io, on_underlying_io_close_complete, header_detect_io_instance) != 0)
        -:  746:            {
        -:  747:                /* Codes_SRS_HEADER_DETECT_IO_01_092: [ If `xio_close` fails `header_detect_io_close_async` shall fail and return a non-zero value. ]*/
    #####:  748:                LogError("xio_close failed");
    #####:  749:                result = MU_FAILURE;
        -:  750:            }
        -:  751:            else
        -:  752:            {
        -:  753:                /* Codes_SRS_HEADER_DETECT_IO_01_025: [ On success `header_detect_io_close_async` shall return 0. ]*/
    #####:  754:                result = 0;
        -:  755:            }
        -:  756:        }
        -:  757:    }
        -:  758:
    #####:  759:    return result;
        -:  760:}
        -:  761:
    #####:  762:static int header_detect_io_send_async(CONCRETE_IO_HANDLE header_detect_io, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
        -:  763:{
        -:  764:    int result;
        -:  765:
        -:  766:    /* Codes_SRS_HEADER_DETECT_IO_01_055: [ `on_send_complete` and `callback_context` shall be allowed to be NULL. ]*/
    #####:  767:    if ((header_detect_io == NULL) ||
    #####:  768:        (buffer == NULL) ||
        -:  769:        /* Codes_SRS_HEADER_DETECT_IO_01_034: [ If `size` is 0, `header_detect_io_send_async` shall fail and return a non-zero value. ]*/
        -:  770:        (size == 0))
        -:  771:    {
        -:  772:        /* Codes_SRS_HEADER_DETECT_IO_01_033: [ If `header_detect_io` or `buffer` is NULL, `header_detect_io_send_async` shall fail and return a non-zero value. ]*/
    #####:  773:        LogError("Bad arguments: header_detect_io = %p, buffer = %p, size = %u",
        -:  774:            header_detect_io, buffer, (unsigned int)size);
    #####:  775:        result = MU_FAILURE;
        -:  776:    }
        -:  777:    else
        -:  778:    {
    #####:  779:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)header_detect_io;
        -:  780:
    #####:  781:        if (header_detect_io_instance->io_state != IO_STATE_OPEN)
        -:  782:        {
        -:  783:            /* Codes_SRS_HEADER_DETECT_IO_01_093: [ `header_detect_io_send_async` when the IO is not open shall fail and return a non-zero value. ]*/
    #####:  784:            LogError("header_detect_io not OPEN");
    #####:  785:            result = MU_FAILURE;
        -:  786:        }
        -:  787:        else
        -:  788:        {
        -:  789:            /* Codes_SRS_HEADER_DETECT_IO_01_029: [ If no detected IO was created, `header_detect_io_send_async` shall send the bytes to the underlying IO passed via `header_detect_io_create`. ]*/
        -:  790:            /* Codes_SRS_HEADER_DETECT_IO_01_030: [ The `buffer`, `size`, `on_send_complete` and `callback_context` shall be passed as is to `xio_send`. ]*/
        -:  791:            /* Codes_SRS_HEADER_DETECT_IO_01_071: [ If the header IO is open `header_detect_io_send_async` shall send the bytes to the last detected IO by calling `xio_send` that was created as result of matching a header. ]*/
    #####:  792:            if (xio_send(*header_detect_io_instance->last_io, buffer, size, on_send_complete, callback_context) != 0)
        -:  793:            {
    #####:  794:                LogError("xio_send failed");
    #####:  795:                result = MU_FAILURE;
        -:  796:            }
        -:  797:            else
        -:  798:            {
        -:  799:                /* Codes_SRS_HEADER_DETECT_IO_01_031: [ On success `header_detect_io_send_async` shall return 0. ]*/
    #####:  800:                result = 0;
        -:  801:            }
        -:  802:        }
        -:  803:    }
        -:  804:
    #####:  805:    return result;
        -:  806:}
        -:  807:
    #####:  808:static void header_detect_io_dowork(CONCRETE_IO_HANDLE header_detect_io)
        -:  809:{
    #####:  810:    if (header_detect_io == NULL)
        -:  811:    {
        -:  812:        /* Codes_SRS_HEADER_DETECT_IO_01_036: [ If `header_detect_io` is NULL, `header_detect_io_dowork` shall do nothing. ]*/
    #####:  813:        LogError("NULL header_detect_io");
        -:  814:    }
        -:  815:    else
        -:  816:    {
    #####:  817:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)header_detect_io;
        -:  818:
        -:  819:        /* Codes_SRS_HEADER_DETECT_IO_01_037: [ No work shall be scheduled if `header_detect_io` is not OPEN or in ERROR (an error has been indicated to the user). ]*/
    #####:  820:        if ((header_detect_io_instance->io_state != IO_STATE_NOT_OPEN) &&
    #####:  821:            (header_detect_io_instance->io_state != IO_STATE_ERROR))
        -:  822:        {
        -:  823:            /* Codes_SRS_HEADER_DETECT_IO_01_056: [ `header_detect_io_dowork` shall call `xio_dowork` for all detected IOs created as a result of matching headers. ]*/
    #####:  824:            LIST_ITEM_HANDLE list_item = singlylinkedlist_get_head_item(header_detect_io_instance->chained_io_list);
    #####:  825:            while (list_item != NULL)
        -:  826:            {
    #####:  827:                CHAINED_IO* chained_io = (CHAINED_IO*)singlylinkedlist_item_get_value(list_item);
    #####:  828:                xio_dowork(chained_io->detected_io);
        -:  829:
    #####:  830:                list_item = singlylinkedlist_get_next_item(list_item);
        -:  831:            }
        -:  832:
        -:  833:            /* Codes_SRS_HEADER_DETECT_IO_01_035: [ `header_detect_io_dowork` shall schedule work for the underlying IO associated with `header_detect_io` by calling `xio_dowork` and passing as argument the `underlying_io` member of the `io_create_parameters` passed to `header_detect_io_create`. ]*/
    #####:  834:            xio_dowork(header_detect_io_instance->underlying_io);
        -:  835:        }
        -:  836:    }
    #####:  837:}
        -:  838:
    #####:  839:static int header_detect_io_set_option(CONCRETE_IO_HANDLE header_detect_io, const char* option_name, const void* value)
        -:  840:{
        -:  841:    int result;
        -:  842:
    #####:  843:    if ((header_detect_io == NULL) ||
        -:  844:        (option_name == NULL))
        -:  845:    {
        -:  846:        /* Codes_SRS_HEADER_DETECT_IO_01_044: [ If `header_detect_io` or `optionName` is NULL, `header_detect_io_set_option` shall fail and return a non-zero value. ]*/
    #####:  847:        LogError("NULL header_detect_io");
    #####:  848:        result = MU_FAILURE;
        -:  849:    }
        -:  850:    else
        -:  851:    {
    #####:  852:        HEADER_DETECT_IO_INSTANCE* header_detect_io_instance = (HEADER_DETECT_IO_INSTANCE*)header_detect_io;
        -:  853:
        -:  854:        /* Codes_SRS_HEADER_DETECT_IO_01_042: [ If no detected IO was created `header_detect_io_set_option` shall pass any option to the underlying IO by calling `xio_setoption` and passing as IO handle the `underlying_io` member of the `io_create_parameters` passed to `header_detect_io_create`. ]*/
        -:  855:        /* Codes_SRS_HEADER_DETECT_IO_01_072: [ If any detected IO was created, `header_detect_io_set_option` shall pass any option to the last detected IO by calling `xio_setoption` and passing as IO handle the `underlying_io` member of the `io_create_parameters` passed to `header_detect_io_create`. ]*/
    #####:  856:        if (xio_setoption(*header_detect_io_instance->last_io, option_name, value) != 0)
        -:  857:        {
        -:  858:            /* Codes_SRS_HEADER_DETECT_IO_01_045: [ If `xio_setoption` fails, `header_detect_io_set_option` shall fail and return a non-zero value. ]*/
    #####:  859:            LogError("Setting the option on the underlying IO failed");
    #####:  860:            result = MU_FAILURE;
        -:  861:        }
        -:  862:        else
        -:  863:        {
        -:  864:            /* Codes_SRS_HEADER_DETECT_IO_01_043: [ On success, `header_detect_io_set_option` shall return 0. ]*/
    #####:  865:            result = 0;
        -:  866:        }
        -:  867:    }
        -:  868:
    #####:  869:    return result;
        -:  870:}
        -:  871:
        -:  872:/*this function will clone an option given by name and value*/
    #####:  873:static void* header_detect_io_clone_option(const char* name, const void* value)
        -:  874:{
        -:  875:    (void)name;
        -:  876:    (void)value;
    #####:  877:    return NULL;
        -:  878:}
        -:  879:
        -:  880:/*this function destroys an option previously created*/
    #####:  881:static void header_detect_io_destroy_option(const char* name, const void* value)
        -:  882:{
        -:  883:    (void)name;
        -:  884:    (void)value;
    #####:  885:}
        -:  886:
    #####:  887:static OPTIONHANDLER_HANDLE header_detect_io_retrieve_options(CONCRETE_IO_HANDLE header_detect_io)
        -:  888:{
        -:  889:    OPTIONHANDLER_HANDLE result;
        -:  890:
    #####:  891:    if (header_detect_io == NULL)
        -:  892:    {
        -:  893:        /* Codes_SRS_HEADER_DETECT_IO_01_041: [ If `header_detect_io` is NULL, `header_detect_io_retrieve_options` shall return NULL. ]*/
    #####:  894:        LogError("NULL header_detect_io");
    #####:  895:        result = NULL;
        -:  896:    }
        -:  897:    else
        -:  898:    {
        -:  899:        /* Codes_SRS_HEADER_DETECT_IO_01_038: [ `header_detect_io_retrieve_options` shall create a new `OPTIONHANDLER_HANDLE` by calling `OptionHandler_Create` and on success it shall return a non-NULL handle to the newly created option handler. ]*/
    #####:  900:        result = OptionHandler_Create(header_detect_io_clone_option, header_detect_io_destroy_option, header_detect_io_set_option);
    #####:  901:        if (result == NULL)
        -:  902:        {
        -:  903:            /* Codes_SRS_HEADER_DETECT_IO_01_040: [ If `OptionHandler_Create` fails, `header_detect_io_retrieve_options` shall return NULL. ]*/
    #####:  904:            LogError("unable to OptionHandler_Create");
        -:  905:            /*return as is*/
        -:  906:        }
        -:  907:        else
        -:  908:        {
        -:  909:            /*insert here work to add the options to "result" handle*/
        -:  910:            /* Codes_SRS_HEADER_DETECT_IO_01_039: [ No options shall be added to the newly created option handler. ]*/
        -:  911:        }
        -:  912:    }
    #####:  913:    return result;
        -:  914:}
        -:  915:
        -:  916:static const IO_INTERFACE_DESCRIPTION header_detect_io_interface_description =
        -:  917:{
        -:  918:    header_detect_io_retrieve_options,
        -:  919:    header_detect_io_create,
        -:  920:    header_detect_io_destroy,
        -:  921:    header_detect_io_open_async,
        -:  922:    header_detect_io_close_async,
        -:  923:    header_detect_io_send_async,
        -:  924:    header_detect_io_dowork,
        -:  925:    header_detect_io_set_option
        -:  926:};
        -:  927:
    #####:  928:const IO_INTERFACE_DESCRIPTION* header_detect_io_get_interface_description(void)
        -:  929:{
    #####:  930:    return &header_detect_io_interface_description;
        -:  931:}
        -:  932:
        -:  933:static const AMQP_HEADER amqp_header =
        -:  934:{
        -:  935:    amqp_header_bytes,
        -:  936:    sizeof(amqp_header_bytes)
        -:  937:};
        -:  938:
        -:  939:static const AMQP_HEADER sasl_amqp_header =
        -:  940:{
        -:  941:    sasl_amqp_header_bytes,
        -:  942:    sizeof(sasl_amqp_header_bytes)
        -:  943:};
        -:  944:
    #####:  945:AMQP_HEADER header_detect_io_get_amqp_header(void)
        -:  946:{
        -:  947:    /* Codes_SRS_HEADER_DETECT_IO_01_091: [ `header_detect_io_get_amqp_header` shall return a structure that should point to a buffer that contains the bytes { 'A', 'M', 'Q', 'P', 0, 1, 0, 0 }. ]*/
    #####:  948:    return amqp_header;
        -:  949:}
        -:  950:
    #####:  951:AMQP_HEADER header_detect_io_get_sasl_amqp_header(void)
        -:  952:{
        -:  953:    /* Codes_SRS_HEADER_DETECT_IO_01_091: [ `header_detect_io_get_sasl_amqp_header` shall return a structure that should point to a buffer that contains the bytes { 'A', 'M', 'Q', 'P', 3, 1, 0, 0 }. ]*/
    #####:  954:    return sasl_amqp_header;
        -:  955:}
