        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/deps/azure-c-shared-utility/src/string_tokenizer.c
        -:    0:Programs:80
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <stdbool.h>
        -:    6:#include "azure_c_shared_utility/gballoc.h"
        -:    7:#include "azure_c_shared_utility/string_tokenizer.h"
        -:    8:#include "azure_c_shared_utility/optimize_size.h"
        -:    9:#include "azure_c_shared_utility/xlogging.h"
        -:   10:#include "azure_c_shared_utility/crt_abstractions.h"
        -:   11:
        -:   12:typedef struct STRING_TOKEN_TAG
        -:   13:{
        -:   14:    const char* inputString;
        -:   15:    const char* currentPos;
        -:   16:    size_t sizeOfinputString;
        -:   17:} STRING_TOKEN;
        -:   18:
    #####:   19:STRING_TOKENIZER_HANDLE STRING_TOKENIZER_create(STRING_HANDLE handle)
        -:   20:{
        -:   21:    STRING_TOKENIZER_HANDLE result;
        -:   22:
        -:   23:    /* Codes_SRS_STRING_04_001: [STRING_TOKENIZER_create shall return an NULL STRING_TOKENIZER_HANDLE if parameter handle is NULL] */
    #####:   24:    if (handle == NULL)
        -:   25:    {
    #####:   26:        LogError("Invalid Argument. Handle cannot be NULL.");
    #####:   27:        result = NULL;
        -:   28:    }
        -:   29:    else
        -:   30:    {
        -:   31:        /* Codes_SRS_STRING_04_002: [STRING_TOKENIZER_create shall allocate a new STRING_TOKENIZER_HANDLE having the content of the STRING_HANDLE copied and current position pointing at the beginning of the string] */
    #####:   32:        result = STRING_TOKENIZER_create_from_char(STRING_c_str(handle));
        -:   33:    }
        -:   34:
    #####:   35:    return result;
        -:   36:}
        -:   37:
    #####:   38:extern STRING_TOKENIZER_HANDLE STRING_TOKENIZER_create_from_char(const char* input)
        -:   39:{
        -:   40:    STRING_TOKEN *result;
        -:   41:    char* inputStringToMalloc;
        -:   42:
        -:   43:    /* Codes_SRS_STRING_07_001: [STRING_TOKENIZER_create shall return an NULL STRING_TOKENIZER_HANDLE if parameter input is NULL] */
    #####:   44:    if (input == NULL)
        -:   45:    {
    #####:   46:        LogError("Invalid Argument. Handle cannot be NULL.");
    #####:   47:        result = NULL;
        -:   48:    }
        -:   49:    /* Codes_SRS_STRING_07_002: [STRING_TOKENIZER_create shall allocate a new STRING_TOKENIZER_HANDLE having the content of the STRING_HANDLE copied and current position pointing at the beginning of the string] */
    #####:   50:    else if ((result = (STRING_TOKEN*)malloc(sizeof(STRING_TOKEN))) == NULL)
        -:   51:    {
    #####:   52:        LogError("Memory Allocation failed. Cannot allocate STRING_TOKENIZER.");
        -:   53:    }
    #####:   54:    else if ((mallocAndStrcpy_s(&inputStringToMalloc, input)) != 0)
        -:   55:    {
    #####:   56:        LogError("Memory Allocation Failed. Cannot allocate and copy string Content.");
    #####:   57:        free(result);
    #####:   58:        result = NULL;
        -:   59:    }
        -:   60:    else
        -:   61:    {
    #####:   62:        result->inputString = inputStringToMalloc;
    #####:   63:        result->currentPos = result->inputString; //Current Pos will point to the initial position of Token.
    #####:   64:        result->sizeOfinputString = strlen(result->inputString); //Calculate Size of Current String
        -:   65:    }
    #####:   66:    return (STRING_TOKENIZER_HANDLE)result;
        -:   67:}
        -:   68:
    #####:   69:int STRING_TOKENIZER_get_next_token(STRING_TOKENIZER_HANDLE tokenizer, STRING_HANDLE output, const char* delimiters)
        -:   70:{
        -:   71:    int result;
        -:   72:    /* Codes_SRS_STRING_04_004: [STRING_TOKENIZER_get_next_token shall return a nonzero value if any of the 3 parameters is NULL] */
    #####:   73:    if (tokenizer == NULL || output == NULL || delimiters == NULL)
        -:   74:    {
    #####:   75:        result = MU_FAILURE;
        -:   76:    }
        -:   77:    else
        -:   78:    {
    #####:   79:        STRING_TOKEN* token = (STRING_TOKEN*)tokenizer;
        -:   80:        /* Codes_SRS_STRING_04_011: [Each subsequent call to STRING_TOKENIZER_get_next_token starts searching from the saved position on t and behaves as described above.] */
    #####:   81:        size_t remainingInputStringSize = token->sizeOfinputString - (token->currentPos - token->inputString);
    #####:   82:        size_t delimitterSize = strlen(delimiters);
        -:   83:
        -:   84:        /* First Check if we reached the end of the string*/
        -:   85:        /* Codes_SRS_STRING_TOKENIZER_04_014: [STRING_TOKENIZER_get_next_token shall return nonzero value if t contains an empty string.] */
    #####:   86:        if (remainingInputStringSize == 0)
        -:   87:        {
    #####:   88:            result = MU_FAILURE;
        -:   89:        }
    #####:   90:        else if (delimitterSize == 0)
        -:   91:        {
    #####:   92:            LogError("Empty delimiters parameter.");
    #####:   93:            result = MU_FAILURE;
        -:   94:        }
        -:   95:        else
        -:   96:        {
        -:   97:            size_t i;
        -:   98:            /* Codes_SRS_STRING_04_005: [STRING_TOKENIZER_get_next_token searches the string inside STRING_TOKENIZER_HANDLE for the first character that is NOT contained in the current delimiter] */
    #####:   99:            for (i = 0; i < remainingInputStringSize; i++)
        -:  100:            {
        -:  101:                size_t j;
        -:  102:
    #####:  103:                bool foundDelimitter = false;
    #####:  104:                for (j = 0; j < delimitterSize; j++)
        -:  105:                {
    #####:  106:                    if (token->currentPos[i] == delimiters[j])
        -:  107:                    {
    #####:  108:                        foundDelimitter = true;
    #####:  109:                        break;
        -:  110:                    }
        -:  111:                }
        -:  112:
        -:  113:                /* Codes_SRS_STRING_04_007: [If such a character is found, STRING_TOKENIZER_get_next_token consider it as the start of a token.] */
    #####:  114:                if (!foundDelimitter)
        -:  115:                {
    #####:  116:                    break;
        -:  117:                }
        -:  118:            }
        -:  119:
        -:  120:            /* Codes_SRS_STRING_04_006: [If no such character is found, then STRING_TOKENIZER_get_next_token shall return a nonzero Value (You've reach the end of the string or the string consists with only delimiters).] */
        -:  121:            //At this point update Current Pos to the character of the last token found or end of String.
    #####:  122:            token->currentPos += i;
        -:  123:
        -:  124:            //Update the remainingInputStringSize
    #####:  125:            remainingInputStringSize -= i;
        -:  126:
        -:  127:            /* Codes_SRS_STRING_04_006: [If no such character is found, then STRING_TOKENIZER_get_next_token shall return a nonzero Value (You've reach the end of the string or the string consists with only delimiters).] */
    #####:  128:            if (remainingInputStringSize == 0)
        -:  129:            {
    #####:  130:                result = MU_FAILURE;
        -:  131:            }
        -:  132:            else
        -:  133:            {
    #####:  134:                bool foundDelimitter = false;
    #####:  135:                const char* endOfTokenPosition=NULL;
        -:  136:                size_t amountOfCharactersToCopy;
        -:  137:                size_t j;
        -:  138:                //At this point the Current Pos is pointing to a character that is point to a nonDelimiter. So, now search for a Delimiter, till the end of the String.
        -:  139:                /*Codes_SRS_STRING_04_008: [STRING_TOKENIZER_get_next_token than searches from the start of a token for a character that is contained in the delimiters string.] */
        -:  140:                /* Codes_SRS_STRING_04_009: [If no such character is found, STRING_TOKENIZER_get_next_token extends the current token to the end of the string inside t, copies the token to output and returns 0.] */
        -:  141:                /* Codes_SRS_STRING_04_010: [If such a character is found, STRING_TOKENIZER_get_next_token consider it the end of the token and copy it's content to output, updates the current position inside t to the next character and returns 0.] */
    #####:  142:                for (j = 0; j < delimitterSize; j++)
        -:  143:                {
    #####:  144:                    if ((endOfTokenPosition = strchr(token->currentPos, delimiters[j])) != NULL)
        -:  145:                    {
    #####:  146:                        foundDelimitter = true;
    #####:  147:                        break;
        -:  148:                    }
        -:  149:                }
        -:  150:
        -:  151:                //If token not found, than update the EndOfToken to the end of the inputString;
    #####:  152:                if (endOfTokenPosition == NULL)
        -:  153:                {
    #####:  154:                    amountOfCharactersToCopy = remainingInputStringSize;
        -:  155:                }
        -:  156:                else
        -:  157:                {
    #####:  158:                    amountOfCharactersToCopy = endOfTokenPosition - token->currentPos;
        -:  159:                }
        -:  160:
        -:  161:                //copy here the string to output.
    #####:  162:                if (STRING_copy_n(output, token->currentPos, amountOfCharactersToCopy) != 0)
        -:  163:                {
    #####:  164:                    LogError("Problem copying token to output String.");
    #####:  165:                    result = MU_FAILURE;
        -:  166:                }
        -:  167:                else
        -:  168:                {
        -:  169:                    //Update the Current position.
        -:  170:                    //Check if end of String reached so, currentPos points to the end of String.
    #####:  171:                    if (foundDelimitter)
        -:  172:                    {
    #####:  173:                        token->currentPos += amountOfCharactersToCopy + 1;
        -:  174:                    }
        -:  175:                    else
        -:  176:                    {
    #####:  177:                        token->currentPos += amountOfCharactersToCopy;
        -:  178:                    }
        -:  179:
    #####:  180:                    result = 0; //Result will be on the output.
        -:  181:                }
        -:  182:            }
        -:  183:        }
        -:  184:    }
        -:  185:
    #####:  186:    return result;
        -:  187:}
        -:  188:
        -:  189:
        -:  190:/* Codes_SRS_STRING_TOKENIZER_04_012: [STRING_TOKENIZER_destroy shall free the memory allocated by the STRING_TOKENIZER_create ] */
    #####:  191:void STRING_TOKENIZER_destroy(STRING_TOKENIZER_HANDLE t)
        -:  192:{
        -:  193:    /* Codes_SRS_STRING_TOKENIZER_04_013: [When the t argument is NULL, then STRING_TOKENIZER_destroy shall not attempt to free] */
    #####:  194:    if (t != NULL)
        -:  195:    {
    #####:  196:        STRING_TOKEN* value = (STRING_TOKEN*)t;
    #####:  197:        free((char*)value->inputString);
    #####:  198:        value->inputString = NULL;
    #####:  199:        free(value);
        -:  200:    }
    #####:  201:}
        -:  202:
