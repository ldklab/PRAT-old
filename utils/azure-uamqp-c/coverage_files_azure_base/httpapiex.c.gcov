        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/deps/azure-c-shared-utility/src/httpapiex.c
        -:    0:Programs:80
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include "azure_c_shared_utility/gballoc.h"
        -:    6:#include "azure_c_shared_utility/httpapiex.h"
        -:    7:#include "azure_c_shared_utility/optimize_size.h"
        -:    8:#include "azure_c_shared_utility/xlogging.h"
        -:    9:#include "azure_c_shared_utility/strings.h"
        -:   10:#include "azure_c_shared_utility/crt_abstractions.h"
        -:   11:#include "azure_c_shared_utility/vector.h"
        -:   12:
        -:   13:typedef struct HTTPAPIEX_SAVED_OPTION_TAG
        -:   14:{
        -:   15:    const char* optionName;
        -:   16:    const void* value;
        -:   17:}HTTPAPIEX_SAVED_OPTION;
        -:   18:
        -:   19:typedef struct HTTPAPIEX_HANDLE_DATA_TAG
        -:   20:{
        -:   21:    STRING_HANDLE hostName;
        -:   22:    int k;
        -:   23:    HTTP_HANDLE httpHandle;
        -:   24:    VECTOR_HANDLE savedOptions;
        -:   25:}HTTPAPIEX_HANDLE_DATA;
        -:   26:
    #####:   27:MU_DEFINE_ENUM_STRINGS(HTTPAPIEX_RESULT, HTTPAPIEX_RESULT_VALUES);
------------------
HTTPAPIEX_RESULT_FromString:
    #####:   27:MU_DEFINE_ENUM_STRINGS(HTTPAPIEX_RESULT, HTTPAPIEX_RESULT_VALUES);
------------------
HTTPAPIEX_RESULTStrings:
    #####:   27:MU_DEFINE_ENUM_STRINGS(HTTPAPIEX_RESULT, HTTPAPIEX_RESULT_VALUES);
------------------
        -:   28:
        -:   29:#define LOG_HTTAPIEX_ERROR() LogError("error code = %s", MU_ENUM_TO_STRING(HTTPAPIEX_RESULT, result))
        -:   30:
    #####:   31:HTTPAPIEX_HANDLE HTTPAPIEX_Create(const char* hostName)
        -:   32:{
        -:   33:    HTTPAPIEX_HANDLE result;
        -:   34:    /*Codes_SRS_HTTPAPIEX_02_001: [If parameter hostName is NULL then HTTPAPIEX_Create shall return NULL.]*/
    #####:   35:    if (hostName == NULL)
        -:   36:    {
    #####:   37:        LogError("invalid (NULL) parameter");
    #####:   38:        result = NULL;
        -:   39:    }
        -:   40:    else
        -:   41:    {
        -:   42:        /*Codes_SRS_HTTPAPIEX_02_005: [If creating the handle fails for any reason, then HTTAPIEX_Create shall return NULL.] */
    #####:   43:        HTTPAPIEX_HANDLE_DATA* handleData = (HTTPAPIEX_HANDLE_DATA*)malloc(sizeof(HTTPAPIEX_HANDLE_DATA));
    #####:   44:        if (handleData == NULL)
        -:   45:        {
    #####:   46:            LogError("malloc failed.");
    #####:   47:            result = NULL;
        -:   48:        }
        -:   49:        else
        -:   50:        {
        -:   51:            /*Codes_SRS_HTTPAPIEX_02_002: [Parameter hostName shall be saved.]*/
    #####:   52:            handleData->hostName = STRING_construct(hostName);
    #####:   53:            if (handleData->hostName == NULL)
        -:   54:            {
    #####:   55:                free(handleData);
    #####:   56:                LogError("unable to STRING_construct");
    #####:   57:                result = NULL;
        -:   58:            }
        -:   59:            else
        -:   60:            {
        -:   61:                /*Codes_SRS_HTTPAPIEX_02_004: [Otherwise, HTTPAPIEX_Create shall return a HTTAPIEX_HANDLE suitable for further calls to the module.] */
    #####:   62:                handleData->savedOptions = VECTOR_create(sizeof(HTTPAPIEX_SAVED_OPTION));
    #####:   63:                if (handleData->savedOptions == NULL)
        -:   64:                {
    #####:   65:                    STRING_delete(handleData->hostName);
    #####:   66:                    free(handleData);
    #####:   67:                    result = NULL;
        -:   68:                }
        -:   69:                else
        -:   70:                {
    #####:   71:                    handleData->k = -1;
    #####:   72:                    handleData->httpHandle = NULL;
    #####:   73:                    result = handleData;
        -:   74:                }
        -:   75:            }
        -:   76:        }
        -:   77:    }
    #####:   78:    return result;
        -:   79:}
        -:   80:
        -:   81:/*this function builds the default request http headers if none are specified*/
        -:   82:/*returns 0 if no error*/
        -:   83:/*any other code is error*/
    #####:   84:static int buildRequestHttpHeadersHandle(HTTPAPIEX_HANDLE_DATA *handleData, BUFFER_HANDLE requestContent, HTTP_HEADERS_HANDLE originalRequestHttpHeadersHandle, bool* isOriginalRequestHttpHeadersHandle, HTTP_HEADERS_HANDLE* toBeUsedRequestHttpHeadersHandle)
        -:   85:{
        -:   86:    int result;
        -:   87:
        -:   88:
    #####:   89:    if (originalRequestHttpHeadersHandle != NULL)
        -:   90:    {
    #####:   91:        *toBeUsedRequestHttpHeadersHandle = originalRequestHttpHeadersHandle;
    #####:   92:        *isOriginalRequestHttpHeadersHandle = true;
        -:   93:
        -:   94:    }
        -:   95:    else
        -:   96:    {
        -:   97:        /*Codes_SRS_HTTPAPIEX_02_009: [If parameter requestHttpHeadersHandle is NULL then HTTPAPIEX_ExecuteRequest shall allocate a temporary internal instance of HTTPHEADERS, shall add to that instance the following headers
        -:   98:        Host:{hostname} - as it was indicated by the call to HTTPAPIEX_Create API call
        -:   99:        Content-Length:the size of the requestContent parameter, and use this instance to all the subsequent calls to HTTPAPI_ExecuteRequest as parameter httpHeadersHandle.]
        -:  100:        */
    #####:  101:        *isOriginalRequestHttpHeadersHandle = false;
    #####:  102:        *toBeUsedRequestHttpHeadersHandle = HTTPHeaders_Alloc();
        -:  103:    }
        -:  104:
    #####:  105:    if (*toBeUsedRequestHttpHeadersHandle == NULL)
        -:  106:    {
    #####:  107:        result = MU_FAILURE;
    #####:  108:        LogError("unable to HTTPHeaders_Alloc");
        -:  109:    }
        -:  110:    else
        -:  111:    {
    #####:  112:        char temp[22] = { 0 };
    #####:  113:        (void)size_tToString(temp, 22, BUFFER_length(requestContent)); /*cannot fail, MAX_uint64 has 19 digits*/
        -:  114:        /*Codes_SRS_HTTPAPIEX_02_011: [If parameter requestHttpHeadersHandle is not NULL then HTTPAPIEX_ExecuteRequest shall create or update the following headers of the request:
        -:  115:        Host:{hostname}
        -:  116:        Content-Length:the size of the requestContent parameter, and shall use the so constructed HTTPHEADERS object to all calls to HTTPAPI_ExecuteRequest as parameter httpHeadersHandle.]
        -:  117:        */
        -:  118:        /*Codes_SRS_HTTPAPIEX_02_009: [If parameter requestHttpHeadersHandle is NULL then HTTPAPIEX_ExecuteRequest shall allocate a temporary internal instance of HTTPHEADERS, shall add to that instance the following headers
        -:  119:        Host:{hostname} - as it was indicated by the call to HTTPAPIEX_Create API call
        -:  120:        Content-Length:the size of the requestContent parameter, and use this instance to all the subsequent calls to HTTPAPI_ExecuteRequest as parameter httpHeadersHandle.]
        -:  121:        */
    #####:  122:        if (!(
    #####:  123:            (HTTPHeaders_ReplaceHeaderNameValuePair(*toBeUsedRequestHttpHeadersHandle, "Host", STRING_c_str(handleData->hostName)) == HTTP_HEADERS_OK) &&
    #####:  124:            (HTTPHeaders_ReplaceHeaderNameValuePair(*toBeUsedRequestHttpHeadersHandle, "Content-Length", temp) == HTTP_HEADERS_OK)
        -:  125:            ))
        -:  126:        {
    #####:  127:            if (! *isOriginalRequestHttpHeadersHandle)
        -:  128:            {
    #####:  129:                HTTPHeaders_Free(*toBeUsedRequestHttpHeadersHandle);
        -:  130:            }
    #####:  131:            *toBeUsedRequestHttpHeadersHandle = NULL;
    #####:  132:            result = MU_FAILURE;
        -:  133:        }
        -:  134:        else
        -:  135:        {
    #####:  136:            result = 0;
        -:  137:        }
        -:  138:    }
    #####:  139:    return result;
        -:  140:}
        -:  141:
    #####:  142:static int buildResponseHttpHeadersHandle(HTTP_HEADERS_HANDLE originalResponsetHttpHeadersHandle, bool* isOriginalResponseHttpHeadersHandle, HTTP_HEADERS_HANDLE* toBeUsedResponsetHttpHeadersHandle)
        -:  143:{
        -:  144:    int result;
    #####:  145:    if (originalResponsetHttpHeadersHandle == NULL)
        -:  146:    {
    #####:  147:        if ((*toBeUsedResponsetHttpHeadersHandle = HTTPHeaders_Alloc()) == NULL)
        -:  148:        {
    #####:  149:            result = MU_FAILURE;
        -:  150:        }
        -:  151:        else
        -:  152:        {
    #####:  153:            *isOriginalResponseHttpHeadersHandle = false;
    #####:  154:            result = 0;
        -:  155:        }
        -:  156:    }
        -:  157:    else
        -:  158:    {
    #####:  159:        *isOriginalResponseHttpHeadersHandle = true;
    #####:  160:        *toBeUsedResponsetHttpHeadersHandle = originalResponsetHttpHeadersHandle;
    #####:  161:        result = 0;
        -:  162:    }
    #####:  163:    return result;
        -:  164:}
        -:  165:
        -:  166:
    #####:  167:static int buildBufferIfNotExist(BUFFER_HANDLE originalRequestContent, bool* isOriginalRequestContent, BUFFER_HANDLE* toBeUsedRequestContent)
        -:  168:{
        -:  169:    int result;
    #####:  170:    if (originalRequestContent == NULL)
        -:  171:    {
    #####:  172:        *toBeUsedRequestContent = BUFFER_new();
    #####:  173:        if (*toBeUsedRequestContent == NULL)
        -:  174:        {
    #####:  175:            result = MU_FAILURE;
        -:  176:        }
        -:  177:        else
        -:  178:        {
    #####:  179:            *isOriginalRequestContent = false;
    #####:  180:            result = 0;
        -:  181:        }
        -:  182:    }
        -:  183:    else
        -:  184:    {
    #####:  185:        *isOriginalRequestContent = true;
    #####:  186:        *toBeUsedRequestContent = originalRequestContent;
    #####:  187:        result = 0;
        -:  188:    }
    #####:  189:    return result;
        -:  190:}
        -:  191:
        -:  192:static unsigned int dummyStatusCode;
        -:  193:
    #####:  194:static int buildAllRequests(HTTPAPIEX_HANDLE_DATA* handle, HTTPAPI_REQUEST_TYPE requestType, const char* relativePath,
        -:  195:    HTTP_HEADERS_HANDLE requestHttpHeadersHandle, BUFFER_HANDLE requestContent, unsigned int* statusCode,
        -:  196:    HTTP_HEADERS_HANDLE responseHttpHeadersHandle, BUFFER_HANDLE responseContent,
        -:  197:
        -:  198:    const char** toBeUsedRelativePath,
        -:  199:    HTTP_HEADERS_HANDLE *toBeUsedRequestHttpHeadersHandle, bool *isOriginalRequestHttpHeadersHandle,
        -:  200:    BUFFER_HANDLE *toBeUsedRequestContent, bool *isOriginalRequestContent,
        -:  201:    unsigned int** toBeUsedStatusCode,
        -:  202:    HTTP_HEADERS_HANDLE *toBeUsedResponseHttpHeadersHandle, bool *isOriginalResponseHttpHeadersHandle,
        -:  203:    BUFFER_HANDLE *toBeUsedResponseContent, bool *isOriginalResponseContent)
        -:  204:{
        -:  205:    int result;
        -:  206:    (void)requestType;
        -:  207:    /*Codes_SRS_HTTPAPIEX_02_013: [If requestContent is NULL then HTTPAPIEX_ExecuteRequest shall behave as if a buffer of zero size would have been used, that is, it shall call HTTPAPI_ExecuteRequest with parameter content = NULL and contentLength = 0.]*/
        -:  208:    /*Codes_SRS_HTTPAPIEX_02_014: [If requestContent is not NULL then its content and its size shall be used for parameters content and contentLength of HTTPAPI_ExecuteRequest.] */
    #####:  209:    if (buildBufferIfNotExist(requestContent, isOriginalRequestContent, toBeUsedRequestContent) != 0)
        -:  210:    {
    #####:  211:        LogError("unable to build the request content");
    #####:  212:        result = MU_FAILURE;
        -:  213:    }
        -:  214:    else
        -:  215:    {
    #####:  216:        if (buildRequestHttpHeadersHandle(handle, *toBeUsedRequestContent, requestHttpHeadersHandle, isOriginalRequestHttpHeadersHandle, toBeUsedRequestHttpHeadersHandle) != 0)
        -:  217:        {
        -:  218:            /*Codes_SRS_HTTPAPIEX_02_010: [If any of the operations in SRS_HTTAPIEX_02_009 fails, then HTTPAPIEX_ExecuteRequest shall return HTTPAPIEX_ERROR.] */
    #####:  219:            if (*isOriginalRequestContent == false)
        -:  220:            {
    #####:  221:                BUFFER_delete(*toBeUsedRequestContent);
        -:  222:            }
    #####:  223:            LogError("unable to build the request http headers handle");
    #####:  224:            result = MU_FAILURE;
        -:  225:        }
        -:  226:        else
        -:  227:        {
        -:  228:            /*Codes_SRS_HTTPAPIEX_02_008: [If parameter relativePath is NULL then HTTPAPIEX_INVALID_ARG shall not assume a relative path - that is, it will assume an empty path ("").] */
    #####:  229:            if (relativePath == NULL)
        -:  230:            {
    #####:  231:                *toBeUsedRelativePath = "";
        -:  232:            }
        -:  233:            else
        -:  234:            {
    #####:  235:                *toBeUsedRelativePath = relativePath;
        -:  236:            }
        -:  237:
        -:  238:            /*Codes_SRS_HTTPAPIEX_02_015: [If statusCode is NULL then HTTPAPIEX_ExecuteRequest shall not write in statusCode the HTTP status code, and it will use a temporary internal int for parameter statusCode to the calls of HTTPAPI_ExecuteRequest.] */
    #####:  239:            if (statusCode == NULL)
        -:  240:            {
        -:  241:                /*Codes_SRS_HTTPAPIEX_02_016: [If statusCode is not NULL then If statusCode is NULL then HTTPAPIEX_ExecuteRequest shall use it for parameter statusCode to the calls of HTTPAPI_ExecuteRequest.] */
    #####:  242:                *toBeUsedStatusCode = &dummyStatusCode;
        -:  243:            }
        -:  244:            else
        -:  245:            {
    #####:  246:                *toBeUsedStatusCode = statusCode;
        -:  247:            }
        -:  248:
        -:  249:            /*Codes_SRS_HTTPAPIEX_02_017: [If responseHeaders handle is NULL then HTTPAPIEX_ExecuteRequest shall create a temporary internal instance of HTTPHEADERS object and use that for responseHeaders parameter of HTTPAPI_ExecuteRequest call.] */
        -:  250:            /*Codes_SRS_HTTPAPIEX_02_019: [If responseHeaders is not NULL, then then HTTPAPIEX_ExecuteRequest shall use that object as parameter responseHeaders of HTTPAPI_ExecuteRequest call.] */
    #####:  251:            if (buildResponseHttpHeadersHandle(responseHttpHeadersHandle, isOriginalResponseHttpHeadersHandle, toBeUsedResponseHttpHeadersHandle) != 0)
        -:  252:            {
        -:  253:                /*Codes_SRS_HTTPAPIEX_02_018: [If creating the temporary http headers in SRS_HTTPAPIEX_02_017 fails then HTTPAPIEX_ExecuteRequest shall return HTTPAPIEX_ERROR.] */
    #####:  254:                if (*isOriginalRequestContent == false)
        -:  255:                {
    #####:  256:                    BUFFER_delete(*toBeUsedRequestContent);
        -:  257:                }
    #####:  258:                if (*isOriginalRequestHttpHeadersHandle == false)
        -:  259:                {
    #####:  260:                    HTTPHeaders_Free(*toBeUsedRequestHttpHeadersHandle);
        -:  261:                }
    #####:  262:                LogError("unable to build response content");
    #####:  263:                result = MU_FAILURE;
        -:  264:            }
        -:  265:            else
        -:  266:            {
        -:  267:                /*Codes_SRS_HTTPAPIEX_02_020: [If responseContent is NULL then HTTPAPIEX_ExecuteRequest shall create a temporary internal BUFFER object and use that as parameter responseContent of HTTPAPI_ExecuteRequest call.] */
        -:  268:                /*Codes_SRS_HTTPAPIEX_02_022: [If responseContent is not NULL then HTTPAPIEX_ExecuteRequest use that as parameter responseContent of HTTPAPI_ExecuteRequest call.] */
    #####:  269:                if (buildBufferIfNotExist(responseContent, isOriginalResponseContent, toBeUsedResponseContent) != 0)
        -:  270:                {
        -:  271:                    /*Codes_SRS_HTTPAPIEX_02_021: [If creating the BUFFER_HANDLE in SRS_HTTPAPIEX_02_020 fails, then HTTPAPIEX_ExecuteRequest shall return HTTPAPIEX_ERROR.] */
    #####:  272:                    if (*isOriginalRequestContent == false)
        -:  273:                    {
    #####:  274:                        BUFFER_delete(*toBeUsedRequestContent);
        -:  275:                    }
    #####:  276:                    if (*isOriginalRequestHttpHeadersHandle == false)
        -:  277:                    {
    #####:  278:                        HTTPHeaders_Free(*toBeUsedRequestHttpHeadersHandle);
        -:  279:                    }
    #####:  280:                    if (*isOriginalResponseHttpHeadersHandle == false)
        -:  281:                    {
    #####:  282:                        HTTPHeaders_Free(*toBeUsedResponseHttpHeadersHandle);
        -:  283:                    }
    #####:  284:                    LogError("unable to build response content");
    #####:  285:                    result = MU_FAILURE;
        -:  286:                }
        -:  287:                else
        -:  288:                {
    #####:  289:                    result = 0;
        -:  290:                }
        -:  291:            }
        -:  292:        }
        -:  293:    }
    #####:  294:    return result;
        -:  295:}
        -:  296:
    #####:  297:HTTPAPIEX_RESULT HTTPAPIEX_ExecuteRequest(HTTPAPIEX_HANDLE handle, HTTPAPI_REQUEST_TYPE requestType, const char* relativePath,
        -:  298:    HTTP_HEADERS_HANDLE requestHttpHeadersHandle, BUFFER_HANDLE requestContent, unsigned int* statusCode,
        -:  299:    HTTP_HEADERS_HANDLE responseHttpHeadersHandle, BUFFER_HANDLE responseContent)
        -:  300:{
        -:  301:    HTTPAPIEX_RESULT result;
        -:  302:    /*Codes_SRS_HTTPAPIEX_02_006: [If parameter handle is NULL then HTTPAPIEX_ExecuteRequest shall fail and return HTTPAPIEX_INVALID_ARG.]*/
    #####:  303:    if (handle == NULL)
        -:  304:    {
    #####:  305:        result = HTTPAPIEX_INVALID_ARG;
    #####:  306:        LOG_HTTAPIEX_ERROR();
        -:  307:    }
        -:  308:    else
        -:  309:    {
        -:  310:        /*Codes_SRS_HTTPAPIEX_02_007: [If parameter requestType does not indicate a valid request, HTTPAPIEX_ExecuteRequest shall fail and return HTTPAPIEX_INVALID_ARG.] */
    #####:  311:        if (requestType >= MU_COUNT_ARG(HTTPAPI_REQUEST_TYPE_VALUES))
        -:  312:        {
    #####:  313:            result = HTTPAPIEX_INVALID_ARG;
    #####:  314:            LOG_HTTAPIEX_ERROR();
        -:  315:        }
        -:  316:        else
        -:  317:        {
    #####:  318:            HTTPAPIEX_HANDLE_DATA *handleData = (HTTPAPIEX_HANDLE_DATA *)handle;
        -:  319:
        -:  320:            /*call to buildAll*/
        -:  321:            const char* toBeUsedRelativePath;
        -:  322:            HTTP_HEADERS_HANDLE toBeUsedRequestHttpHeadersHandle; bool isOriginalRequestHttpHeadersHandle;
        -:  323:            BUFFER_HANDLE toBeUsedRequestContent; bool isOriginalRequestContent;
        -:  324:            unsigned int* toBeUsedStatusCode;
        -:  325:            HTTP_HEADERS_HANDLE toBeUsedResponseHttpHeadersHandle; bool isOriginalResponseHttpHeadersHandle;
        -:  326:            BUFFER_HANDLE toBeUsedResponseContent;  bool isOriginalResponseContent;
        -:  327:
    #####:  328:            if (buildAllRequests(handleData, requestType, relativePath, requestHttpHeadersHandle, requestContent, statusCode, responseHttpHeadersHandle, responseContent,
        -:  329:                &toBeUsedRelativePath,
        -:  330:                &toBeUsedRequestHttpHeadersHandle, &isOriginalRequestHttpHeadersHandle,
        -:  331:                &toBeUsedRequestContent, &isOriginalRequestContent,
        -:  332:                &toBeUsedStatusCode,
        -:  333:                &toBeUsedResponseHttpHeadersHandle, &isOriginalResponseHttpHeadersHandle,
        -:  334:                &toBeUsedResponseContent, &isOriginalResponseContent) != 0)
        -:  335:            {
    #####:  336:                result = HTTPAPIEX_ERROR;
    #####:  337:                LOG_HTTAPIEX_ERROR();
        -:  338:            }
        -:  339:            else
        -:  340:            {
        -:  341:
        -:  342:                /*Codes_SRS_HTTPAPIEX_02_023: [HTTPAPIEX_ExecuteRequest shall try to execute the HTTP call by ensuring the following API call sequence is respected:]*/
        -:  343:                /*Codes_SRS_HTTPAPIEX_02_024: [If any point in the sequence fails, HTTPAPIEX_ExecuteRequest shall attempt to recover by going back to the previous step and retrying that step.]*/
        -:  344:                /*Codes_SRS_HTTPAPIEX_02_025: [If the first step fails, then the sequence fails.]*/
        -:  345:                /*Codes_SRS_HTTPAPIEX_02_026: [A step shall be retried at most once.]*/
        -:  346:                /*Codes_SRS_HTTPAPIEX_02_027: [If a step has been retried then all subsequent steps shall be retried too.]*/
    #####:  347:                bool st[3] = { false, false, false }; /*the three levels of possible failure in resilient send: HTTAPI_Init, HTTPAPI_CreateConnection, HTTPAPI_ExecuteRequest*/
    #####:  348:                if (handleData->k == -1)
        -:  349:                {
    #####:  350:                    handleData->k = 0;
        -:  351:                }
        -:  352:
        -:  353:                do
        -:  354:                {
        -:  355:                    bool goOn;
        -:  356:
    #####:  357:                    if (handleData->k > 2)
        -:  358:                    {
        -:  359:                        /* error */
    #####:  360:                        break;
        -:  361:                    }
        -:  362:
    #####:  363:                    if (st[handleData->k] == true) /*already been tried*/
        -:  364:                    {
    #####:  365:                        goOn = false;
        -:  366:                    }
        -:  367:                    else
        -:  368:                    {
    #####:  369:                        switch (handleData->k)
        -:  370:                        {
    #####:  371:                        case 0:
        -:  372:                        {
    #####:  373:                            if (HTTPAPI_Init() != HTTPAPI_OK)
        -:  374:                            {
    #####:  375:                                goOn = false;
        -:  376:                            }
        -:  377:                            else
        -:  378:                            {
    #####:  379:                                goOn = true;
        -:  380:                            }
    #####:  381:                            break;
        -:  382:                        }
    #####:  383:                        case 1:
        -:  384:                        {
    #####:  385:                            if ((handleData->httpHandle = HTTPAPI_CreateConnection(STRING_c_str(handleData->hostName))) == NULL)
        -:  386:                            {
    #####:  387:                                goOn = false;
        -:  388:                            }
        -:  389:                            else
        -:  390:                            {
        -:  391:                                size_t i;
    #####:  392:                                size_t vectorSize = VECTOR_size(handleData->savedOptions);
    #####:  393:                                for (i = 0; i < vectorSize; i++)
        -:  394:                                {
        -:  395:                                    /*Codes_SRS_HTTPAPIEX_02_035: [HTTPAPIEX_ExecuteRequest shall pass all the saved options (see HTTPAPIEX_SetOption) to the newly create HTTPAPI_HANDLE in step 2 by calling HTTPAPI_SetOption.]*/
        -:  396:                                    /*Codes_SRS_HTTPAPIEX_02_036: [If setting the option fails, then the failure shall be ignored.] */
    #####:  397:                                    HTTPAPIEX_SAVED_OPTION* option = (HTTPAPIEX_SAVED_OPTION*)VECTOR_element(handleData->savedOptions, i);
    #####:  398:                                    if (HTTPAPI_SetOption(handleData->httpHandle, option->optionName, option->value) != HTTPAPI_OK)
        -:  399:                                    {
    #####:  400:                                        LogError("HTTPAPI_SetOption failed when called for option %s", option->optionName);
        -:  401:                                    }
        -:  402:                                }
    #####:  403:                                goOn = true;
        -:  404:                            }
    #####:  405:                            break;
        -:  406:                        }
    #####:  407:                        case 2:
        -:  408:                        {
    #####:  409:                            size_t length = BUFFER_length(toBeUsedRequestContent);
    #####:  410:                            unsigned char* buffer = BUFFER_u_char(toBeUsedRequestContent);
    #####:  411:                            if (HTTPAPI_ExecuteRequest(handleData->httpHandle, requestType, toBeUsedRelativePath, toBeUsedRequestHttpHeadersHandle, buffer, length, toBeUsedStatusCode, toBeUsedResponseHttpHeadersHandle, toBeUsedResponseContent) != HTTPAPI_OK)
        -:  412:                            {
    #####:  413:                                goOn = false;
        -:  414:                            }
        -:  415:                            else
        -:  416:                            {
    #####:  417:                                goOn = true;
        -:  418:                            }
    #####:  419:                            break;
        -:  420:                        }
    #####:  421:                        default:
        -:  422:                        {
        -:  423:                            /*serious error*/
    #####:  424:                            goOn = false;
    #####:  425:                            break;
        -:  426:                        }
        -:  427:                        }
        -:  428:                    }
        -:  429:
    #####:  430:                    if (goOn)
        -:  431:                    {
    #####:  432:                        if (handleData->k == 2)
        -:  433:                        {
        -:  434:                            /*Codes_SRS_HTTPAPIEX_02_028: [HTTPAPIEX_ExecuteRequest shall return HTTPAPIEX_OK when a call to HTTPAPI_ExecuteRequest has been completed successfully.]*/
    #####:  435:                            result = HTTPAPIEX_OK;
    #####:  436:                            goto out;
        -:  437:                        }
        -:  438:                        else
        -:  439:                        {
    #####:  440:                            st[handleData->k] = true;
    #####:  441:                            handleData->k++;
    #####:  442:                            st[handleData->k] = false;
        -:  443:                        }
        -:  444:                    }
        -:  445:                    else
        -:  446:                    {
    #####:  447:                        st[handleData->k] = false;
    #####:  448:                        handleData->k--;
    #####:  449:                        switch (handleData->k)
        -:  450:                        {
    #####:  451:                        case 0:
        -:  452:                        {
    #####:  453:                            HTTPAPI_Deinit();
    #####:  454:                            break;
        -:  455:                        }
    #####:  456:                        case 1:
        -:  457:                        {
    #####:  458:                            HTTPAPI_CloseConnection(handleData->httpHandle);
    #####:  459:                            handleData->httpHandle = NULL;
    #####:  460:                            break;
        -:  461:                        }
    #####:  462:                        case 2:
        -:  463:                        {
    #####:  464:                            break;
        -:  465:                        }
    #####:  466:                        default:
        -:  467:                        {
    #####:  468:                            break;
        -:  469:                        }
        -:  470:                        }
        -:  471:                    }
    #####:  472:                } while (handleData->k >= 0);
        -:  473:                /*Codes_SRS_HTTPAPIEX_02_029: [Otherwise, HTTAPIEX_ExecuteRequest shall return HTTPAPIEX_RECOVERYFAILED.] */
    #####:  474:                result = HTTPAPIEX_RECOVERYFAILED;
    #####:  475:                LogError("unable to recover sending to a working state");
    #####:  476:            out:;
        -:  477:                /*in all cases, unbuild the temporaries*/
    #####:  478:                if (isOriginalRequestContent == false)
        -:  479:                {
    #####:  480:                    BUFFER_delete(toBeUsedRequestContent);
        -:  481:                }
    #####:  482:                if (isOriginalRequestHttpHeadersHandle == false)
        -:  483:                {
    #####:  484:                    HTTPHeaders_Free(toBeUsedRequestHttpHeadersHandle);
        -:  485:                }
    #####:  486:                if (isOriginalResponseContent == false)
        -:  487:                {
    #####:  488:                    BUFFER_delete(toBeUsedResponseContent);
        -:  489:                }
    #####:  490:                if (isOriginalResponseHttpHeadersHandle == false)
        -:  491:                {
    #####:  492:                    HTTPHeaders_Free(toBeUsedResponseHttpHeadersHandle);
        -:  493:                }
        -:  494:            }
        -:  495:        }
        -:  496:    }
    #####:  497:    return result;
        -:  498:}
        -:  499:
        -:  500:
    #####:  501:void HTTPAPIEX_Destroy(HTTPAPIEX_HANDLE handle)
        -:  502:{
    #####:  503:    if (handle != NULL)
        -:  504:    {
        -:  505:        /*Codes_SRS_HTTPAPIEX_02_042: [HTTPAPIEX_Destroy shall free all the resources used by HTTAPIEX_HANDLE.]*/
        -:  506:        size_t i;
        -:  507:        size_t vectorSize;
    #####:  508:        HTTPAPIEX_HANDLE_DATA* handleData = (HTTPAPIEX_HANDLE_DATA*)handle;
        -:  509:
    #####:  510:        if (handleData->k == 2)
        -:  511:        {
    #####:  512:            HTTPAPI_CloseConnection(handleData->httpHandle);
    #####:  513:            HTTPAPI_Deinit();
        -:  514:        }
    #####:  515:        STRING_delete(handleData->hostName);
        -:  516:
    #####:  517:        vectorSize = VECTOR_size(handleData->savedOptions);
    #####:  518:        for (i = 0; i < vectorSize; i++)
        -:  519:        {
    #####:  520:            HTTPAPIEX_SAVED_OPTION* savedOption = (HTTPAPIEX_SAVED_OPTION*)VECTOR_element(handleData->savedOptions, i);
    #####:  521:            free((void*)savedOption->optionName);
    #####:  522:            free((void*)savedOption->value);
        -:  523:        }
    #####:  524:        VECTOR_destroy(handleData->savedOptions);
        -:  525:
    #####:  526:        free(handle);
        -:  527:    }
        -:  528:    else
        -:  529:    {
        -:  530:        /*Codes_SRS_HTTPAPIEX_02_043: [If parameter handle is NULL then HTTPAPIEX_Destroy shall take no action.] */
        -:  531:    }
    #####:  532:}
        -:  533:
    #####:  534:static bool sameName(const void* element, const void* value)
        -:  535:{
    #####:  536:    return (strcmp(((HTTPAPIEX_SAVED_OPTION*)element)->optionName, (const char*)value) == 0) ? true : false;
        -:  537:}
        -:  538:
        -:  539:/*return 0 on success, any other value is error*/
        -:  540:/*obs: value is already cloned at the time of calling this function */
    #####:  541:static int createOrUpdateOption(HTTPAPIEX_HANDLE_DATA* handleData, const char* optionName, const void* value)
        -:  542:{
        -:  543:    /*this function is called after the option value has been saved (cloned)*/
        -:  544:    int result;
        -:  545:
        -:  546:    /*decide bwtween update or create*/
    #####:  547:    HTTPAPIEX_SAVED_OPTION* whereIsIt = (HTTPAPIEX_SAVED_OPTION*)VECTOR_find_if(handleData->savedOptions, sameName, optionName);
    #####:  548:    if (whereIsIt != NULL)
        -:  549:    {
    #####:  550:        free((void*)(whereIsIt->value));
    #####:  551:        whereIsIt->value = value;
    #####:  552:        result = 0;
        -:  553:    }
        -:  554:    else
        -:  555:    {
        -:  556:        HTTPAPIEX_SAVED_OPTION newOption;
    #####:  557:        if (mallocAndStrcpy_s((char**)&(newOption.optionName), optionName) != 0)
        -:  558:        {
    #####:  559:            free((void*)value);
    #####:  560:            result = MU_FAILURE;
        -:  561:        }
        -:  562:        else
        -:  563:        {
    #####:  564:            newOption.value = value;
    #####:  565:            if (VECTOR_push_back(handleData->savedOptions, &newOption, 1) != 0)
        -:  566:            {
    #####:  567:                LogError("unable to VECTOR_push_back");
    #####:  568:                free((void*)newOption.optionName);
    #####:  569:                free((void*)value);
    #####:  570:                result = MU_FAILURE;
        -:  571:            }
        -:  572:            else
        -:  573:            {
    #####:  574:                result = 0;
        -:  575:            }
        -:  576:        }
        -:  577:    }
        -:  578:
    #####:  579:    return result;
        -:  580:}
        -:  581:
    #####:  582:HTTPAPIEX_RESULT HTTPAPIEX_SetOption(HTTPAPIEX_HANDLE handle, const char* optionName, const void* value)
        -:  583:{
        -:  584:    HTTPAPIEX_RESULT result;
        -:  585:    /*Codes_SRS_HTTPAPIEX_02_032: [If parameter handle is NULL then HTTPAPIEX_SetOption shall return HTTPAPIEX_INVALID_ARG.] */
        -:  586:    /*Codes_SRS_HTTPAPIEX_02_033: [If parameter optionName is NULL then HTTPAPIEX_SetOption shall return HTTPAPIEX_INVALID_ARG.] */
        -:  587:    /*Codes_SRS_HTTPAPIEX_02_034: [If parameter value is NULL then HTTPAPIEX_SetOption shall return HTTPAPIEX_INVALID_ARG.] */
    #####:  588:    if (
    #####:  589:        (handle == NULL) ||
    #####:  590:        (optionName == NULL) ||
        -:  591:        (value == NULL)
        -:  592:        )
        -:  593:    {
    #####:  594:        result = HTTPAPIEX_INVALID_ARG;
    #####:  595:        LOG_HTTAPIEX_ERROR();
        -:  596:    }
        -:  597:    else
        -:  598:    {
        -:  599:        const void* savedOption;
        -:  600:        HTTPAPI_RESULT saveOptionResult;
        -:  601:
        -:  602:        /*Codes_SRS_HTTPAPIEX_02_037: [HTTPAPIEX_SetOption shall attempt to save the value of the option by calling HTTPAPI_CloneOption passing optionName and value, irrespective of the existence of a HTTPAPI_HANDLE] */
    #####:  603:        saveOptionResult = HTTPAPI_CloneOption(optionName, value, &savedOption);
        -:  604:
    #####:  605:        if(saveOptionResult == HTTPAPI_INVALID_ARG)
        -:  606:        {
        -:  607:            /*Codes_SRS_HTTPAPIEX_02_038: [If HTTPAPI_CloneOption returns HTTPAPI_INVALID_ARG then HTTPAPIEX shall return HTTPAPIEX_INVALID_ARG.] */
    #####:  608:            result = HTTPAPIEX_INVALID_ARG;
    #####:  609:            LOG_HTTAPIEX_ERROR();
        -:  610:        }
    #####:  611:        else if (saveOptionResult != HTTPAPI_OK)
        -:  612:        {
        -:  613:            /*Codes_SRS_HTTPAPIEX_02_040: [For all other return values of HTTPAPI_SetOption, HTTPIAPIEX_SetOption shall return HTTPAPIEX_ERROR.] */
    #####:  614:            result = HTTPAPIEX_ERROR;
    #####:  615:            LOG_HTTAPIEX_ERROR();
        -:  616:        }
        -:  617:        else
        -:  618:        {
    #####:  619:            HTTPAPIEX_HANDLE_DATA* handleData = (HTTPAPIEX_HANDLE_DATA*)handle;
        -:  620:            /*Codes_SRS_HTTPAPIEX_02_039: [If HTTPAPI_CloneOption returns HTTPAPI_OK then HTTPAPIEX_SetOption shall create or update the pair optionName/value.]*/
    #####:  621:            if (createOrUpdateOption(handleData, optionName, savedOption) != 0)
        -:  622:            {
        -:  623:                /*Codes_SRS_HTTPAPIEX_02_041: [If creating or updating the pair optionName/value fails then shall return HTTPAPIEX_ERROR.] */
    #####:  624:                result = HTTPAPIEX_ERROR;
    #####:  625:                LOG_HTTAPIEX_ERROR();
        -:  626:
        -:  627:            }
        -:  628:            else
        -:  629:            {
        -:  630:                /*Codes_SRS_HTTPAPIEX_02_031: [If HTTPAPI_HANDLE exists then HTTPAPIEX_SetOption shall call HTTPAPI_SetOption passing the same optionName and value and shall return a value conforming to the below table:] */
    #####:  631:                if (handleData->httpHandle != NULL)
        -:  632:                {
    #####:  633:                    HTTPAPI_RESULT HTTPAPI_result = HTTPAPI_SetOption(handleData->httpHandle, optionName, value);
    #####:  634:                    if (HTTPAPI_result == HTTPAPI_OK)
        -:  635:                    {
    #####:  636:                        result = HTTPAPIEX_OK;
        -:  637:                    }
    #####:  638:                    else if (HTTPAPI_result == HTTPAPI_INVALID_ARG)
        -:  639:                    {
    #####:  640:                        result = HTTPAPIEX_INVALID_ARG;
    #####:  641:                        LOG_HTTAPIEX_ERROR();
        -:  642:                    }
        -:  643:                    else
        -:  644:                    {
    #####:  645:                        result = HTTPAPIEX_ERROR;
    #####:  646:                        LOG_HTTAPIEX_ERROR();
        -:  647:                    }
        -:  648:                }
        -:  649:                else
        -:  650:                {
    #####:  651:                    result = HTTPAPIEX_OK;
        -:  652:                }
        -:  653:            }
        -:  654:        }
        -:  655:    }
    #####:  656:    return result;
        -:  657:}
