        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/src/link.c
        -:    0:Programs:101
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include <stdint.h>
        -:    7:#include <stdbool.h>
        -:    8:#include "azure_c_shared_utility/gballoc.h"
        -:    9:#include "azure_macro_utils/macro_utils.h"
        -:   10:#include "azure_c_shared_utility/xlogging.h"
        -:   11:#include "azure_c_shared_utility/singlylinkedlist.h"
        -:   12:#include "azure_c_shared_utility/tickcounter.h"
        -:   13:#include "azure_uamqp_c/link.h"
        -:   14:#include "azure_uamqp_c/session.h"
        -:   15:#include "azure_uamqp_c/amqpvalue.h"
        -:   16:#include "azure_uamqp_c/amqp_definitions.h"
        -:   17:#include "azure_uamqp_c/amqp_frame_codec.h"
        -:   18:#include "azure_uamqp_c/async_operation.h"
        -:   19:
        -:   20:#define DEFAULT_LINK_CREDIT 10000
        -:   21:
        -:   22:typedef struct DELIVERY_INSTANCE_TAG
        -:   23:{
        -:   24:    delivery_number delivery_id;
        -:   25:    ON_DELIVERY_SETTLED on_delivery_settled;
        -:   26:    void* callback_context;
        -:   27:    void* link;
        -:   28:    tickcounter_ms_t start_tick;
        -:   29:    tickcounter_ms_t timeout;
        -:   30:} DELIVERY_INSTANCE;
        -:   31:
        -:   32:typedef struct ON_LINK_DETACH_EVENT_SUBSCRIPTION_TAG
        -:   33:{
        -:   34:    ON_LINK_DETACH_RECEIVED on_link_detach_received;
        -:   35:    void* context;
        -:   36:} ON_LINK_DETACH_EVENT_SUBSCRIPTION;
        -:   37:
        -:   38:typedef struct LINK_INSTANCE_TAG
        -:   39:{
        -:   40:    SESSION_HANDLE session;
        -:   41:    LINK_STATE link_state;
        -:   42:    LINK_STATE previous_link_state;
        -:   43:    AMQP_VALUE source;
        -:   44:    AMQP_VALUE target;
        -:   45:    handle handle;
        -:   46:    LINK_ENDPOINT_HANDLE link_endpoint;
        -:   47:    char* name;
        -:   48:    SINGLYLINKEDLIST_HANDLE pending_deliveries;
        -:   49:    sequence_no delivery_count;
        -:   50:    role role;
        -:   51:    ON_LINK_STATE_CHANGED on_link_state_changed;
        -:   52:    ON_LINK_FLOW_ON on_link_flow_on;
        -:   53:    ON_TRANSFER_RECEIVED on_transfer_received;
        -:   54:    void* callback_context;
        -:   55:    sender_settle_mode snd_settle_mode;
        -:   56:    receiver_settle_mode rcv_settle_mode;
        -:   57:    sequence_no initial_delivery_count;
        -:   58:    uint64_t max_message_size;
        -:   59:    uint64_t peer_max_message_size;
        -:   60:    uint32_t current_link_credit;
        -:   61:    uint32_t max_link_credit;
        -:   62:    uint32_t available;
        -:   63:    fields attach_properties;
        -:   64:    bool is_underlying_session_begun;
        -:   65:    bool is_closed;
        -:   66:    unsigned char* received_payload;
        -:   67:    uint32_t received_payload_size;
        -:   68:    delivery_number received_delivery_id;
        -:   69:    TICK_COUNTER_HANDLE tick_counter;
        -:   70:    ON_LINK_DETACH_EVENT_SUBSCRIPTION on_link_detach_received_event_subscription;
        -:   71:} LINK_INSTANCE;
        -:   72:
        -:   73:DEFINE_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE);
        -:   74:
       12:   75:static void set_link_state(LINK_INSTANCE* link_instance, LINK_STATE link_state)
        -:   76:{
       12:   77:    link_instance->previous_link_state = link_instance->link_state;
       12:   78:    link_instance->link_state = link_state;
        -:   79:
       12:   80:    if (link_instance->on_link_state_changed != NULL)
        -:   81:    {
    #####:   82:        link_instance->on_link_state_changed(link_instance->callback_context, link_state, link_instance->previous_link_state);
        -:   83:    }
       12:   84:}
        -:   85:
       12:   86:static void remove_all_pending_deliveries(LINK_INSTANCE* link, bool indicate_settled)
        -:   87:{
       12:   88:    if (link->pending_deliveries != NULL)
        -:   89:    {
       12:   90:        LIST_ITEM_HANDLE item = singlylinkedlist_get_head_item(link->pending_deliveries);
       12:   91:        while (item != NULL)
        -:   92:        {
    #####:   93:            LIST_ITEM_HANDLE next_item = singlylinkedlist_get_next_item(item);
    #####:   94:            ASYNC_OPERATION_HANDLE pending_delivery_operation = (ASYNC_OPERATION_HANDLE)singlylinkedlist_item_get_value(item);
    #####:   95:            if (pending_delivery_operation != NULL)
        -:   96:            {
    #####:   97:                DELIVERY_INSTANCE* delivery_instance = (DELIVERY_INSTANCE*)GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, pending_delivery_operation);
    #####:   98:                if (indicate_settled && (delivery_instance->on_delivery_settled != NULL))
        -:   99:                {
    #####:  100:                    delivery_instance->on_delivery_settled(delivery_instance->callback_context, delivery_instance->delivery_id, LINK_DELIVERY_SETTLE_REASON_NOT_DELIVERED, NULL);
        -:  101:                }
        -:  102:
    #####:  103:                async_operation_destroy(pending_delivery_operation);
        -:  104:            }
        -:  105:
    #####:  106:            item = next_item;
        -:  107:        }
        -:  108:
       12:  109:        singlylinkedlist_destroy(link->pending_deliveries);
       12:  110:        link->pending_deliveries = NULL;
        -:  111:    }
       12:  112:}
        -:  113:
    #####:  114:static int send_flow(LINK_INSTANCE* link)
        -:  115:{
        -:  116:    int result;
    #####:  117:    FLOW_HANDLE flow = flow_create(0, 0, 0);
        -:  118:
    #####:  119:    if (flow == NULL)
        -:  120:    {
    #####:  121:        LogError("NULL flow performative");
    #####:  122:        result = MU_FAILURE;
        -:  123:    }
        -:  124:    else
        -:  125:    {
    #####:  126:        if (flow_set_link_credit(flow, link->current_link_credit) != 0)
        -:  127:        {
    #####:  128:            LogError("Cannot set link credit on flow performative");
    #####:  129:            result = MU_FAILURE;
        -:  130:        }
    #####:  131:        else if (flow_set_handle(flow, link->handle) != 0)
        -:  132:        {
    #####:  133:            LogError("Cannot set handle on flow performative");
    #####:  134:            result = MU_FAILURE;
        -:  135:        }
    #####:  136:        else if (flow_set_delivery_count(flow, link->delivery_count) != 0)
        -:  137:        {
    #####:  138:            LogError("Cannot set delivery count on flow performative");
    #####:  139:            result = MU_FAILURE;
        -:  140:        }
        -:  141:        else
        -:  142:        {
    #####:  143:            if (session_send_flow(link->link_endpoint, flow) != 0)
        -:  144:            {
    #####:  145:                LogError("Sending flow frame failed in session send");
    #####:  146:                result = MU_FAILURE;
        -:  147:            }
        -:  148:            else
        -:  149:            {
    #####:  150:                result = 0;
        -:  151:            }
        -:  152:        }
        -:  153:
    #####:  154:        flow_destroy(flow);
        -:  155:    }
        -:  156:
    #####:  157:    return result;
        -:  158:}
        -:  159:
    #####:  160:static int send_disposition(LINK_INSTANCE* link_instance, delivery_number delivery_number, AMQP_VALUE delivery_state)
        -:  161:{
        -:  162:    int result;
        -:  163:
    #####:  164:    DISPOSITION_HANDLE disposition = disposition_create(link_instance->role, delivery_number);
    #####:  165:    if (disposition == NULL)
        -:  166:    {
    #####:  167:        LogError("NULL disposition performative");
    #####:  168:        result = MU_FAILURE;
        -:  169:    }
        -:  170:    else
        -:  171:    {
    #####:  172:        if (disposition_set_last(disposition, delivery_number) != 0)
        -:  173:        {
    #####:  174:            LogError("Failed setting last on disposition performative");
    #####:  175:            result = MU_FAILURE;
        -:  176:        }
    #####:  177:        else if (disposition_set_settled(disposition, true) != 0)
        -:  178:        {
    #####:  179:            LogError("Failed setting settled on disposition performative");
    #####:  180:            result = MU_FAILURE;
        -:  181:        }
    #####:  182:        else if ((delivery_state != NULL) && (disposition_set_state(disposition, delivery_state) != 0))
        -:  183:        {
    #####:  184:            LogError("Failed setting state on disposition performative");
    #####:  185:            result = MU_FAILURE;
        -:  186:        }
        -:  187:        else
        -:  188:        {
    #####:  189:            if (session_send_disposition(link_instance->link_endpoint, disposition) != 0)
        -:  190:            {
    #####:  191:                LogError("Sending disposition failed in session send");
    #####:  192:                result = MU_FAILURE;
        -:  193:            }
        -:  194:            else
        -:  195:            {
    #####:  196:                result = 0;
        -:  197:            }
        -:  198:        }
        -:  199:
    #####:  200:        disposition_destroy(disposition);
        -:  201:    }
        -:  202:
    #####:  203:    return result;
        -:  204:}
        -:  205:
    #####:  206:static int send_detach(LINK_INSTANCE* link_instance, bool close, ERROR_HANDLE error_handle)
        -:  207:{
        -:  208:    int result;
        -:  209:    DETACH_HANDLE detach_performative;
        -:  210:
    #####:  211:    detach_performative = detach_create(0);
    #####:  212:    if (detach_performative == NULL)
        -:  213:    {
    #####:  214:        LogError("NULL detach performative");
    #####:  215:        result = MU_FAILURE;
        -:  216:    }
        -:  217:    else
        -:  218:    {
    #####:  219:        if ((error_handle != NULL) &&
    #####:  220:            (detach_set_error(detach_performative, error_handle) != 0))
        -:  221:        {
    #####:  222:            LogError("Failed setting error on detach frame");
    #####:  223:            result = MU_FAILURE;
        -:  224:        }
    #####:  225:        else if (close &&
    #####:  226:            (detach_set_closed(detach_performative, true) != 0))
        -:  227:        {
    #####:  228:            LogError("Failed setting closed field on detach frame");
    #####:  229:            result = MU_FAILURE;
        -:  230:        }
        -:  231:        else
        -:  232:        {
    #####:  233:            if (session_send_detach(link_instance->link_endpoint, detach_performative) != 0)
        -:  234:            {
    #####:  235:                LogError("Sending detach frame failed in session send");
    #####:  236:                result = MU_FAILURE;
        -:  237:            }
        -:  238:            else
        -:  239:            {
    #####:  240:                if (close)
        -:  241:                {
        -:  242:                    /* Declare link to be closed */
    #####:  243:                    link_instance->is_closed = true;
        -:  244:                }
        -:  245:
    #####:  246:                result = 0;
        -:  247:            }
        -:  248:        }
        -:  249:
    #####:  250:        detach_destroy(detach_performative);
        -:  251:    }
        -:  252:
    #####:  253:    return result;
        -:  254:}
        -:  255:
    #####:  256:static int send_attach(LINK_INSTANCE* link, const char* name, handle handle, role role)
        -:  257:{
        -:  258:    int result;
    #####:  259:    ATTACH_HANDLE attach = attach_create(name, handle, role);
        -:  260:
    #####:  261:    if (attach == NULL)
        -:  262:    {
    #####:  263:        LogError("NULL attach performative");
    #####:  264:        result = MU_FAILURE;
        -:  265:    }
        -:  266:    else
        -:  267:    {
    #####:  268:        result = 0;
        -:  269:
    #####:  270:        link->delivery_count = link->initial_delivery_count;
        -:  271:
    #####:  272:        attach_set_snd_settle_mode(attach, link->snd_settle_mode);
    #####:  273:        attach_set_rcv_settle_mode(attach, link->rcv_settle_mode);
    #####:  274:        attach_set_role(attach, role);
    #####:  275:        attach_set_source(attach, link->source);
    #####:  276:        attach_set_target(attach, link->target);
    #####:  277:        if (link->attach_properties != NULL)
        -:  278:        {
    #####:  279:            (void)attach_set_properties(attach, link->attach_properties);
        -:  280:        }
        -:  281:
    #####:  282:        if (role == role_sender)
        -:  283:        {
    #####:  284:            if (attach_set_initial_delivery_count(attach, link->delivery_count) != 0)
        -:  285:            {
    #####:  286:                LogError("Cannot set attach initial delivery count");
    #####:  287:                result = MU_FAILURE;
        -:  288:            }
        -:  289:        }
        -:  290:
    #####:  291:        if (result == 0)
        -:  292:        {
    #####:  293:            if (attach_set_max_message_size(attach, link->max_message_size) != 0)
        -:  294:            {
    #####:  295:                LogError("Cannot set max message size");
    #####:  296:                result = MU_FAILURE;
        -:  297:            }
    #####:  298:            else if (session_send_attach(link->link_endpoint, attach) != 0)
        -:  299:            {
    #####:  300:                LogError("Sending attach failed in session send");
    #####:  301:                result = MU_FAILURE;
        -:  302:            }
        -:  303:            else
        -:  304:            {
    #####:  305:                result = 0;
        -:  306:            }
        -:  307:        }
        -:  308:
    #####:  309:        attach_destroy(attach);
        -:  310:    }
        -:  311:
    #####:  312:    return result;
        -:  313:}
        -:  314:
    #####:  315:static void link_frame_received(void* context, AMQP_VALUE performative, uint32_t payload_size, const unsigned char* payload_bytes)
        -:  316:{
    #####:  317:    LINK_INSTANCE* link_instance = (LINK_INSTANCE*)context;
    #####:  318:    AMQP_VALUE descriptor = amqpvalue_get_inplace_descriptor(performative);
        -:  319:
    #####:  320:    if (is_attach_type_by_descriptor(descriptor))
        -:  321:    {
        -:  322:        ATTACH_HANDLE attach_handle;
        -:  323:
    #####:  324:        if (amqpvalue_get_attach(performative, &attach_handle) != 0)
        -:  325:        {
    #####:  326:            LogError("Cannot get attach performative");
        -:  327:        }
        -:  328:        else
        -:  329:        {
    #####:  330:            if ((link_instance->role == role_receiver) &&
    #####:  331:                (attach_get_initial_delivery_count(attach_handle, &link_instance->delivery_count) != 0))
        -:  332:            {
    #####:  333:                LogError("Cannot get initial delivery count");
    #####:  334:                remove_all_pending_deliveries(link_instance, true);
    #####:  335:                set_link_state(link_instance, LINK_STATE_DETACHED);
        -:  336:            }
        -:  337:            else
        -:  338:            {
    #####:  339:                if (attach_get_max_message_size(attach_handle, &link_instance->peer_max_message_size) != 0)
        -:  340:                {
    #####:  341:                    LogError("Could not retrieve peer_max_message_size from attach frame");
        -:  342:                }
        -:  343:
    #####:  344:                if ((link_instance->link_state == LINK_STATE_DETACHED) ||
    #####:  345:                    (link_instance->link_state == LINK_STATE_HALF_ATTACHED_ATTACH_SENT))
        -:  346:                {
    #####:  347:                    if (link_instance->role == role_receiver)
        -:  348:                    {
    #####:  349:                        link_instance->current_link_credit = link_instance->max_link_credit;
    #####:  350:                        send_flow(link_instance);
        -:  351:                    }
        -:  352:                    else
        -:  353:                    {
    #####:  354:                        link_instance->current_link_credit = 0;
        -:  355:                    }
        -:  356:
    #####:  357:                    if (link_instance->link_state == LINK_STATE_DETACHED)
        -:  358:                    {
    #####:  359:                        set_link_state(link_instance, LINK_STATE_HALF_ATTACHED_ATTACH_RECEIVED);
        -:  360:                    }
        -:  361:                    else
        -:  362:                    {
    #####:  363:                        set_link_state(link_instance, LINK_STATE_ATTACHED);
        -:  364:                    }
        -:  365:                }
        -:  366:            }
        -:  367:
    #####:  368:            attach_destroy(attach_handle);
        -:  369:        }
        -:  370:    }
    #####:  371:    else if (is_flow_type_by_descriptor(descriptor))
        -:  372:    {
        -:  373:        FLOW_HANDLE flow_handle;
    #####:  374:        if (amqpvalue_get_flow(performative, &flow_handle) != 0)
        -:  375:        {
    #####:  376:            LogError("Cannot get flow performative");
        -:  377:        }
        -:  378:        else
        -:  379:        {
    #####:  380:            if (link_instance->role == role_sender)
        -:  381:            {
        -:  382:                delivery_number rcv_delivery_count;
        -:  383:                uint32_t rcv_link_credit;
        -:  384:
    #####:  385:                if (flow_get_link_credit(flow_handle, &rcv_link_credit) != 0)
        -:  386:                {
    #####:  387:                    LogError("Cannot get link credit");
    #####:  388:                    remove_all_pending_deliveries(link_instance, true);
    #####:  389:                    set_link_state(link_instance, LINK_STATE_DETACHED);
        -:  390:                }
    #####:  391:                else if (flow_get_delivery_count(flow_handle, &rcv_delivery_count) != 0)
        -:  392:                {
    #####:  393:                    LogError("Cannot get delivery count");
    #####:  394:                    remove_all_pending_deliveries(link_instance, true);
    #####:  395:                    set_link_state(link_instance, LINK_STATE_DETACHED);
        -:  396:                }
        -:  397:                else
        -:  398:                {
    #####:  399:                    link_instance->current_link_credit = rcv_delivery_count + rcv_link_credit - link_instance->delivery_count;
    #####:  400:                    if (link_instance->current_link_credit > 0)
        -:  401:                    {
    #####:  402:                        link_instance->on_link_flow_on(link_instance->callback_context);
        -:  403:                    }
        -:  404:                }
        -:  405:            }
        -:  406:        }
        -:  407:
    #####:  408:        flow_destroy(flow_handle);
        -:  409:    }
    #####:  410:    else if (is_transfer_type_by_descriptor(descriptor))
        -:  411:    {
    #####:  412:        if (link_instance->on_transfer_received != NULL)
        -:  413:        {
        -:  414:            TRANSFER_HANDLE transfer_handle;
    #####:  415:            if (amqpvalue_get_transfer(performative, &transfer_handle) != 0)
        -:  416:            {
    #####:  417:                LogError("Cannot get transfer performative");
        -:  418:            }
        -:  419:            else
        -:  420:            {
        -:  421:                AMQP_VALUE delivery_state;
        -:  422:                bool more;
        -:  423:                bool is_error;
        -:  424:
    #####:  425:                link_instance->current_link_credit--;
    #####:  426:                link_instance->delivery_count++;
    #####:  427:                if (link_instance->current_link_credit == 0)
        -:  428:                {
    #####:  429:                    link_instance->current_link_credit = link_instance->max_link_credit;
    #####:  430:                    send_flow(link_instance);
        -:  431:                }
        -:  432:
    #####:  433:                more = false;
        -:  434:                /* Attempt to get more flag, default to false */
    #####:  435:                (void)transfer_get_more(transfer_handle, &more);
    #####:  436:                is_error = false;
        -:  437:
    #####:  438:                if (transfer_get_delivery_id(transfer_handle, &link_instance->received_delivery_id) != 0)
        -:  439:                {
        -:  440:                    /* is this not a continuation transfer? */
    #####:  441:                    if (link_instance->received_payload_size == 0)
        -:  442:                    {
    #####:  443:                        LogError("Could not get the delivery Id from the transfer performative");
    #####:  444:                        is_error = true;
        -:  445:                    }
        -:  446:                }
        -:  447:
    #####:  448:                if (!is_error)
        -:  449:                {
        -:  450:                    /* If this is a continuation transfer or if this is the first chunk of a multi frame transfer */
    #####:  451:                    if ((link_instance->received_payload_size > 0) || more)
        -:  452:                    {
    #####:  453:                        unsigned char* new_received_payload = (unsigned char*)realloc(link_instance->received_payload, link_instance->received_payload_size + payload_size);
    #####:  454:                        if (new_received_payload == NULL)
        -:  455:                        {
    #####:  456:                            LogError("Could not allocate memory for the received payload");
        -:  457:                        }
        -:  458:                        else
        -:  459:                        {
    #####:  460:                            link_instance->received_payload = new_received_payload;
    #####:  461:                            (void)memcpy(link_instance->received_payload + link_instance->received_payload_size, payload_bytes, payload_size);
    #####:  462:                            link_instance->received_payload_size += payload_size;
        -:  463:                        }
        -:  464:                    }
        -:  465:
    #####:  466:                    if (!more)
        -:  467:                    {
        -:  468:                        const unsigned char* indicate_payload_bytes;
        -:  469:                        uint32_t indicate_payload_size;
        -:  470:
        -:  471:                        /* if no previously stored chunks then simply report the current payload */
    #####:  472:                        if (link_instance->received_payload_size > 0)
        -:  473:                        {
    #####:  474:                            indicate_payload_size = link_instance->received_payload_size;
    #####:  475:                            indicate_payload_bytes = link_instance->received_payload;
        -:  476:                        }
        -:  477:                        else
        -:  478:                        {
    #####:  479:                            indicate_payload_size = payload_size;
    #####:  480:                            indicate_payload_bytes = payload_bytes;
        -:  481:                        }
        -:  482:
    #####:  483:                        delivery_state = link_instance->on_transfer_received(link_instance->callback_context, transfer_handle, indicate_payload_size, indicate_payload_bytes);
        -:  484:
    #####:  485:                        if (link_instance->received_payload_size > 0)
        -:  486:                        {
    #####:  487:                            free(link_instance->received_payload);
    #####:  488:                            link_instance->received_payload = NULL;
    #####:  489:                            link_instance->received_payload_size = 0;
        -:  490:                        }
        -:  491:
    #####:  492:                        if (delivery_state != NULL)
        -:  493:                        {
    #####:  494:                            if (send_disposition(link_instance, link_instance->received_delivery_id, delivery_state) != 0)
        -:  495:                            {
    #####:  496:                                LogError("Cannot send disposition frame");
        -:  497:                            }
        -:  498:
    #####:  499:                            amqpvalue_destroy(delivery_state);
        -:  500:                        }
        -:  501:                    }
        -:  502:                }
        -:  503:
    #####:  504:                transfer_destroy(transfer_handle);
        -:  505:            }
        -:  506:        }
        -:  507:    }
    #####:  508:    else if (is_disposition_type_by_descriptor(descriptor))
        -:  509:    {
        -:  510:        DISPOSITION_HANDLE disposition;
    #####:  511:        if (amqpvalue_get_disposition(performative, &disposition) != 0)
        -:  512:        {
    #####:  513:            LogError("Cannot get disposition performative");
        -:  514:        }
        -:  515:        else
        -:  516:        {
        -:  517:            delivery_number first;
        -:  518:            delivery_number last;
        -:  519:
    #####:  520:            if (disposition_get_first(disposition, &first) != 0)
        -:  521:            {
    #####:  522:                LogError("Cannot get first field");
        -:  523:            }
        -:  524:            else
        -:  525:            {
        -:  526:                bool settled;
        -:  527:
    #####:  528:                if (disposition_get_last(disposition, &last) != 0)
        -:  529:                {
    #####:  530:                    last = first;
        -:  531:                }
        -:  532:
    #####:  533:                if (disposition_get_settled(disposition, &settled) != 0)
        -:  534:                {
    #####:  535:                    settled = false;
        -:  536:                }
        -:  537:
    #####:  538:                if (settled)
        -:  539:                {
    #####:  540:                    LIST_ITEM_HANDLE pending_delivery = singlylinkedlist_get_head_item(link_instance->pending_deliveries);
    #####:  541:                    while (pending_delivery != NULL)
        -:  542:                    {
    #####:  543:                        LIST_ITEM_HANDLE next_pending_delivery = singlylinkedlist_get_next_item(pending_delivery);
    #####:  544:                        ASYNC_OPERATION_HANDLE pending_delivery_operation = (ASYNC_OPERATION_HANDLE)singlylinkedlist_item_get_value(pending_delivery);
    #####:  545:                        if (pending_delivery_operation == NULL)
        -:  546:                        {
    #####:  547:                            LogError("Cannot obtain pending delivery");
    #####:  548:                            break;
        -:  549:                        }
        -:  550:                        else
        -:  551:                        {
    #####:  552:                            DELIVERY_INSTANCE* delivery_instance = (DELIVERY_INSTANCE*)GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, pending_delivery_operation);
        -:  553:
    #####:  554:                            if ((delivery_instance->delivery_id >= first) && (delivery_instance->delivery_id <= last))
    #####:  555:                            {
        -:  556:                                AMQP_VALUE delivery_state;
    #####:  557:                                if (disposition_get_state(disposition, &delivery_state) == 0)
        -:  558:                                {
    #####:  559:                                    delivery_instance->on_delivery_settled(delivery_instance->callback_context, delivery_instance->delivery_id, LINK_DELIVERY_SETTLE_REASON_DISPOSITION_RECEIVED, delivery_state);
    #####:  560:                                    async_operation_destroy(pending_delivery_operation);
    #####:  561:                                    if (singlylinkedlist_remove(link_instance->pending_deliveries, pending_delivery) != 0)
        -:  562:                                    {
    #####:  563:                                        LogError("Cannot remove pending delivery");
    #####:  564:                                        break;
        -:  565:                                    }
        -:  566:
    #####:  567:                                    pending_delivery = next_pending_delivery;
        -:  568:                                }
        -:  569:                            }
        -:  570:                            else
        -:  571:                            {
    #####:  572:                                pending_delivery = next_pending_delivery;
        -:  573:                            }
        -:  574:                        }
        -:  575:                    }
        -:  576:                }
        -:  577:            }
        -:  578:
    #####:  579:            disposition_destroy(disposition);
        -:  580:        }
        -:  581:    }
    #####:  582:    else if (is_detach_type_by_descriptor(descriptor))
        -:  583:    {
        -:  584:        DETACH_HANDLE detach;
        -:  585:
        -:  586:        /* Set link state appropriately based on whether we received detach condition */
    #####:  587:        if (amqpvalue_get_detach(performative, &detach) != 0)
        -:  588:        {
    #####:  589:            LogError("Cannot get detach performative");
        -:  590:        }
        -:  591:        else
        -:  592:        {
    #####:  593:            bool closed = false;
        -:  594:            ERROR_HANDLE error;
        -:  595:
    #####:  596:            (void)detach_get_closed(detach, &closed);
        -:  597:
        -:  598:            /* Received a detach while attached */
    #####:  599:            if (link_instance->link_state == LINK_STATE_ATTACHED)
        -:  600:            {
        -:  601:                /* Respond with ack */
    #####:  602:                if (send_detach(link_instance, closed, NULL) != 0)
        -:  603:                {
    #####:  604:                    LogError("Failed sending detach frame");
        -:  605:                }
        -:  606:            }
        -:  607:            /* Received a closing detach after we sent a non-closing detach. */
    #####:  608:            else if (closed &&
    #####:  609:                ((link_instance->link_state == LINK_STATE_HALF_ATTACHED_ATTACH_SENT) || (link_instance->link_state == LINK_STATE_HALF_ATTACHED_ATTACH_RECEIVED)) &&
    #####:  610:                !link_instance->is_closed)
        -:  611:            {
        -:  612:
        -:  613:                /* In this case, we MUST signal that we closed by reattaching and then sending a closing detach.*/
    #####:  614:                if (send_attach(link_instance, link_instance->name, 0, link_instance->role) != 0)
        -:  615:                {
    #####:  616:                    LogError("Failed sending attach frame");
        -:  617:                }
        -:  618:
    #####:  619:                if (send_detach(link_instance, true, NULL) != 0)
        -:  620:                {
    #####:  621:                    LogError("Failed sending detach frame");
        -:  622:                }
        -:  623:            }
        -:  624:
    #####:  625:            if (detach_get_error(detach, &error) != 0)
        -:  626:            {
    #####:  627:                error = NULL;
        -:  628:            }
    #####:  629:            remove_all_pending_deliveries(link_instance, true);
        -:  630:            // signal link detach received in order to handle cases like redirect
    #####:  631:            if (link_instance->on_link_detach_received_event_subscription.on_link_detach_received != NULL)
        -:  632:            {
    #####:  633:                link_instance->on_link_detach_received_event_subscription.on_link_detach_received(link_instance->on_link_detach_received_event_subscription.context, error);
        -:  634:            }
        -:  635:
    #####:  636:            if (error != NULL)
        -:  637:            {
    #####:  638:                set_link_state(link_instance, LINK_STATE_ERROR);
    #####:  639:                error_destroy(error);
        -:  640:            }
        -:  641:            else
        -:  642:            {
    #####:  643:                set_link_state(link_instance, LINK_STATE_DETACHED);
        -:  644:            }
        -:  645:
    #####:  646:            detach_destroy(detach);
        -:  647:        }
        -:  648:    }
    #####:  649:}
        -:  650:
    #####:  651:static void on_session_state_changed(void* context, SESSION_STATE new_session_state, SESSION_STATE previous_session_state)
        -:  652:{
    #####:  653:    LINK_INSTANCE* link_instance = (LINK_INSTANCE*)context;
        -:  654:    (void)previous_session_state;
        -:  655:
    #####:  656:    if (new_session_state == SESSION_STATE_MAPPED)
        -:  657:    {
    #####:  658:        if ((link_instance->link_state == LINK_STATE_DETACHED) && (!link_instance->is_closed))
        -:  659:        {
    #####:  660:            if (send_attach(link_instance, link_instance->name, 0, link_instance->role) == 0)
        -:  661:            {
    #####:  662:                set_link_state(link_instance, LINK_STATE_HALF_ATTACHED_ATTACH_SENT);
        -:  663:            }
        -:  664:        }
        -:  665:    }
    #####:  666:    else if (new_session_state == SESSION_STATE_DISCARDING)
        -:  667:    {
    #####:  668:        remove_all_pending_deliveries(link_instance, true);
    #####:  669:        set_link_state(link_instance, LINK_STATE_DETACHED);
        -:  670:    }
    #####:  671:    else if (new_session_state == SESSION_STATE_ERROR)
        -:  672:    {
    #####:  673:        remove_all_pending_deliveries(link_instance, true);
    #####:  674:        set_link_state(link_instance, LINK_STATE_ERROR);
        -:  675:    }
    #####:  676:}
        -:  677:
    #####:  678:static void on_session_flow_on(void* context)
        -:  679:{
    #####:  680:    LINK_INSTANCE* link_instance = (LINK_INSTANCE*)context;
    #####:  681:    if (link_instance->role == role_sender)
        -:  682:    {
    #####:  683:        link_instance->on_link_flow_on(link_instance->callback_context);
        -:  684:    }
    #####:  685:}
        -:  686:
    #####:  687:static void on_send_complete(void* context, IO_SEND_RESULT send_result)
        -:  688:{
    #####:  689:    LIST_ITEM_HANDLE delivery_instance_list_item = (LIST_ITEM_HANDLE)context;
    #####:  690:    ASYNC_OPERATION_HANDLE pending_delivery_operation = (ASYNC_OPERATION_HANDLE)singlylinkedlist_item_get_value(delivery_instance_list_item);
    #####:  691:    DELIVERY_INSTANCE* delivery_instance = (DELIVERY_INSTANCE*)GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, pending_delivery_operation);
    #####:  692:    LINK_HANDLE link = (LINK_HANDLE)delivery_instance->link;
        -:  693:    (void)send_result;
    #####:  694:    if (link->snd_settle_mode == sender_settle_mode_settled)
        -:  695:    {
    #####:  696:        delivery_instance->on_delivery_settled(delivery_instance->callback_context, delivery_instance->delivery_id, LINK_DELIVERY_SETTLE_REASON_SETTLED, NULL);
    #####:  697:        async_operation_destroy(pending_delivery_operation);
    #####:  698:        (void)singlylinkedlist_remove(link->pending_deliveries, delivery_instance_list_item);
        -:  699:    }
    #####:  700:}
        -:  701:
       12:  702:LINK_HANDLE link_create(SESSION_HANDLE session, const char* name, role role, AMQP_VALUE source, AMQP_VALUE target)
        -:  703:{
       12:  704:    LINK_INSTANCE* result = (LINK_INSTANCE*)malloc(sizeof(LINK_INSTANCE));
       12:  705:    if (result == NULL)
        -:  706:    {
    #####:  707:        LogError("Cannot create link");
        -:  708:    }
        -:  709:    else
        -:  710:    {
       12:  711:        result->link_state = LINK_STATE_DETACHED;
       12:  712:        result->previous_link_state = LINK_STATE_DETACHED;
       12:  713:        result->role = role;
       12:  714:        result->source = amqpvalue_clone(source);
       12:  715:        result->target = amqpvalue_clone(target);
       12:  716:        result->session = session;
       12:  717:        result->handle = 0;
       12:  718:        result->snd_settle_mode = sender_settle_mode_unsettled;
       12:  719:        result->rcv_settle_mode = receiver_settle_mode_first;
       12:  720:        result->delivery_count = 0;
       12:  721:        result->initial_delivery_count = 0;
       12:  722:        result->max_message_size = 0;
       12:  723:        result->max_link_credit = DEFAULT_LINK_CREDIT;
       12:  724:        result->peer_max_message_size = 0;
       12:  725:        result->is_underlying_session_begun = false;
       12:  726:        result->is_closed = false;
       12:  727:        result->attach_properties = NULL;
       12:  728:        result->received_payload = NULL;
       12:  729:        result->received_payload_size = 0;
       12:  730:        result->received_delivery_id = 0;
       12:  731:        result->on_link_detach_received_event_subscription.on_link_detach_received = NULL;
       12:  732:        result->on_link_detach_received_event_subscription.context = NULL;
        -:  733:
       12:  734:        result->tick_counter = tickcounter_create();
       12:  735:        if (result->tick_counter == NULL)
        -:  736:        {
    #####:  737:            LogError("Cannot create tick counter for link");
    #####:  738:            free(result);
    #####:  739:            result = NULL;
        -:  740:        }
        -:  741:        else
        -:  742:        {
       12:  743:            result->pending_deliveries = singlylinkedlist_create();
       12:  744:            if (result->pending_deliveries == NULL)
        -:  745:            {
    #####:  746:                LogError("Cannot create pending deliveries list");
    #####:  747:                tickcounter_destroy(result->tick_counter);
    #####:  748:                free(result);
    #####:  749:                result = NULL;
        -:  750:            }
        -:  751:            else
        -:  752:            {
       12:  753:                size_t name_length = strlen(name);
       12:  754:                result->name = (char*)malloc(name_length + 1);
       12:  755:                if (result->name == NULL)
        -:  756:                {
    #####:  757:                    LogError("Cannot allocate memory for link name");
    #####:  758:                    tickcounter_destroy(result->tick_counter);
    #####:  759:                    singlylinkedlist_destroy(result->pending_deliveries);
    #####:  760:                    free(result);
    #####:  761:                    result = NULL;
        -:  762:                }
        -:  763:                else
        -:  764:                {
       12:  765:                    result->on_link_state_changed = NULL;
       12:  766:                    result->callback_context = NULL;
       12:  767:                    set_link_state(result, LINK_STATE_DETACHED);
        -:  768:
       12:  769:                    (void)memcpy(result->name, name, name_length + 1);
       12:  770:                    result->link_endpoint = session_create_link_endpoint(session, name);
       12:  771:                    if (result->link_endpoint == NULL)
        -:  772:                    {
    #####:  773:                        LogError("Cannot create link endpoint");
    #####:  774:                        tickcounter_destroy(result->tick_counter);
    #####:  775:                        singlylinkedlist_destroy(result->pending_deliveries);
    #####:  776:                        free(result->name);
    #####:  777:                        free(result);
    #####:  778:                        result = NULL;
        -:  779:                    }
        -:  780:                }
        -:  781:            }
        -:  782:        }
        -:  783:    }
        -:  784:
       12:  785:    return result;
        -:  786:}
        -:  787:
    #####:  788:LINK_HANDLE link_create_from_endpoint(SESSION_HANDLE session, LINK_ENDPOINT_HANDLE link_endpoint, const char* name, role role, AMQP_VALUE source, AMQP_VALUE target)
        -:  789:{
    #####:  790:    LINK_INSTANCE* result = (LINK_INSTANCE*)malloc(sizeof(LINK_INSTANCE));
    #####:  791:    if (result == NULL)
        -:  792:    {
    #####:  793:        LogError("Cannot create link");
        -:  794:    }
        -:  795:    else
        -:  796:    {
    #####:  797:        result->link_state = LINK_STATE_DETACHED;
    #####:  798:        result->previous_link_state = LINK_STATE_DETACHED;
    #####:  799:        result->session = session;
    #####:  800:        result->handle = 0;
    #####:  801:        result->snd_settle_mode = sender_settle_mode_unsettled;
    #####:  802:        result->rcv_settle_mode = receiver_settle_mode_first;
    #####:  803:        result->delivery_count = 0;
    #####:  804:        result->initial_delivery_count = 0;
    #####:  805:        result->max_message_size = 0;
    #####:  806:        result->max_link_credit = DEFAULT_LINK_CREDIT;
    #####:  807:        result->peer_max_message_size = 0;
    #####:  808:        result->is_underlying_session_begun = false;
    #####:  809:        result->is_closed = false;
    #####:  810:        result->attach_properties = NULL;
    #####:  811:        result->received_payload = NULL;
    #####:  812:        result->received_payload_size = 0;
    #####:  813:        result->received_delivery_id = 0;
    #####:  814:        result->source = amqpvalue_clone(target);
    #####:  815:        result->target = amqpvalue_clone(source);
    #####:  816:        result->on_link_detach_received_event_subscription.on_link_detach_received = NULL;
    #####:  817:        result->on_link_detach_received_event_subscription.context = NULL;
        -:  818:
    #####:  819:        if (role == role_sender)
        -:  820:        {
    #####:  821:            result->role = role_receiver;
        -:  822:        }
        -:  823:        else
        -:  824:        {
    #####:  825:            result->role = role_sender;
        -:  826:        }
        -:  827:
    #####:  828:        result->tick_counter = tickcounter_create();
    #####:  829:        if (result->tick_counter == NULL)
        -:  830:        {
    #####:  831:            LogError("Cannot create tick counter for link");
    #####:  832:            free(result);
    #####:  833:            result = NULL;
        -:  834:        }
        -:  835:        else
        -:  836:        {
    #####:  837:            result->pending_deliveries = singlylinkedlist_create();
    #####:  838:            if (result->pending_deliveries == NULL)
        -:  839:            {
    #####:  840:                LogError("Cannot create pending deliveries list");
    #####:  841:                tickcounter_destroy(result->tick_counter);
    #####:  842:                free(result);
    #####:  843:                result = NULL;
        -:  844:            }
        -:  845:            else
        -:  846:            {
    #####:  847:                size_t name_length = strlen(name);
    #####:  848:                result->name = (char*)malloc(name_length + 1);
    #####:  849:                if (result->name == NULL)
        -:  850:                {
    #####:  851:                    LogError("Cannot allocate memory for link name");
    #####:  852:                    tickcounter_destroy(result->tick_counter);
    #####:  853:                    singlylinkedlist_destroy(result->pending_deliveries);
    #####:  854:                    free(result);
    #####:  855:                    result = NULL;
        -:  856:                }
        -:  857:                else
        -:  858:                {
    #####:  859:                    (void)memcpy(result->name, name, name_length + 1);
    #####:  860:                    result->on_link_state_changed = NULL;
    #####:  861:                    result->callback_context = NULL;
    #####:  862:                    result->link_endpoint = link_endpoint;
        -:  863:                }
        -:  864:            }
        -:  865:        }
        -:  866:    }
        -:  867:
    #####:  868:    return result;
        -:  869:}
        -:  870:
       12:  871:void link_destroy(LINK_HANDLE link)
        -:  872:{
       12:  873:    if (link == NULL)
        -:  874:    {
    #####:  875:        LogError("NULL link");
        -:  876:    }
        -:  877:    else
        -:  878:    {
       12:  879:        remove_all_pending_deliveries((LINK_INSTANCE*)link, false);
       12:  880:        tickcounter_destroy(link->tick_counter);
        -:  881:
       12:  882:        link->on_link_state_changed = NULL;
       12:  883:        (void)link_detach(link, true, NULL, NULL, NULL);
       12:  884:        session_destroy_link_endpoint(link->link_endpoint);
       12:  885:        amqpvalue_destroy(link->source);
       12:  886:        amqpvalue_destroy(link->target);
        -:  887:
       12:  888:        if (link->name != NULL)
        -:  889:        {
       12:  890:            free(link->name);
        -:  891:        }
        -:  892:
       12:  893:        if (link->attach_properties != NULL)
        -:  894:        {
        1:  895:            amqpvalue_destroy(link->attach_properties);
        -:  896:        }
        -:  897:
       12:  898:        if (link->received_payload != NULL)
        -:  899:        {
    #####:  900:            free(link->received_payload);
        -:  901:        }
        -:  902:
       12:  903:        free(link);
        -:  904:    }
       12:  905:}
        -:  906:
        3:  907:int link_set_snd_settle_mode(LINK_HANDLE link, sender_settle_mode snd_settle_mode)
        -:  908:{
        -:  909:    int result;
        -:  910:
        3:  911:    if (link == NULL)
        -:  912:    {
    #####:  913:        LogError("NULL link");
    #####:  914:        result = MU_FAILURE;
        -:  915:    }
        -:  916:    else
        -:  917:    {
        3:  918:        link->snd_settle_mode = snd_settle_mode;
        3:  919:        result = 0;
        -:  920:    }
        -:  921:
        3:  922:    return result;
        -:  923:}
        -:  924:
    #####:  925:int link_get_snd_settle_mode(LINK_HANDLE link, sender_settle_mode* snd_settle_mode)
        -:  926:{
        -:  927:    int result;
        -:  928:
    #####:  929:    if ((link == NULL) ||
        -:  930:        (snd_settle_mode == NULL))
        -:  931:    {
    #####:  932:        LogError("Bad arguments: link = %p, snd_settle_mode = %p",
        -:  933:            link, snd_settle_mode);
    #####:  934:        result = MU_FAILURE;
        -:  935:    }
        -:  936:    else
        -:  937:    {
    #####:  938:        *snd_settle_mode = link->snd_settle_mode;
        -:  939:
    #####:  940:        result = 0;
        -:  941:    }
        -:  942:
    #####:  943:    return result;
        -:  944:}
        -:  945:
        1:  946:int link_set_rcv_settle_mode(LINK_HANDLE link, receiver_settle_mode rcv_settle_mode)
        -:  947:{
        -:  948:    int result;
        -:  949:
        1:  950:    if (link == NULL)
        -:  951:    {
    #####:  952:        LogError("NULL link");
    #####:  953:        result = MU_FAILURE;
        -:  954:    }
        -:  955:    else
        -:  956:    {
        1:  957:        link->rcv_settle_mode = rcv_settle_mode;
        1:  958:        result = 0;
        -:  959:    }
        -:  960:
        1:  961:    return result;
        -:  962:}
        -:  963:
    #####:  964:int link_get_rcv_settle_mode(LINK_HANDLE link, receiver_settle_mode* rcv_settle_mode)
        -:  965:{
        -:  966:    int result;
        -:  967:
    #####:  968:    if ((link == NULL) ||
        -:  969:        (rcv_settle_mode == NULL))
        -:  970:    {
    #####:  971:        LogError("Bad arguments: link = %p, rcv_settle_mode = %p",
        -:  972:            link, rcv_settle_mode);
    #####:  973:        result = MU_FAILURE;
        -:  974:    }
        -:  975:    else
        -:  976:    {
    #####:  977:        *rcv_settle_mode = link->rcv_settle_mode;
    #####:  978:        result = 0;
        -:  979:    }
        -:  980:
    #####:  981:    return result;
        -:  982:}
        -:  983:
    #####:  984:int link_set_initial_delivery_count(LINK_HANDLE link, sequence_no initial_delivery_count)
        -:  985:{
        -:  986:    int result;
        -:  987:
    #####:  988:    if (link == NULL)
        -:  989:    {
    #####:  990:        LogError("NULL link");
    #####:  991:        result = MU_FAILURE;
        -:  992:    }
        -:  993:    else
        -:  994:    {
    #####:  995:        link->initial_delivery_count = initial_delivery_count;
    #####:  996:        result = 0;
        -:  997:    }
        -:  998:
    #####:  999:    return result;
        -: 1000:}
        -: 1001:
    #####: 1002:int link_get_initial_delivery_count(LINK_HANDLE link, sequence_no* initial_delivery_count)
        -: 1003:{
        -: 1004:    int result;
        -: 1005:
    #####: 1006:    if ((link == NULL) ||
        -: 1007:        (initial_delivery_count == NULL))
        -: 1008:    {
    #####: 1009:        LogError("Bad arguments: link = %p, initial_delivery_count = %p",
        -: 1010:            link, initial_delivery_count);
    #####: 1011:        result = MU_FAILURE;
        -: 1012:    }
        -: 1013:    else
        -: 1014:    {
    #####: 1015:        *initial_delivery_count = link->initial_delivery_count;
    #####: 1016:        result = 0;
        -: 1017:    }
        -: 1018:
    #####: 1019:    return result;
        -: 1020:}
        -: 1021:
        5: 1022:int link_set_max_message_size(LINK_HANDLE link, uint64_t max_message_size)
        -: 1023:{
        -: 1024:    int result;
        -: 1025:
        5: 1026:    if (link == NULL)
        -: 1027:    {
    #####: 1028:        LogError("NULL link");
    #####: 1029:        result = MU_FAILURE;
        -: 1030:    }
        -: 1031:    else
        -: 1032:    {
        5: 1033:        link->max_message_size = max_message_size;
        5: 1034:        result = 0;
        -: 1035:    }
        -: 1036:
        5: 1037:    return result;
        -: 1038:}
        -: 1039:
    #####: 1040:int link_get_max_message_size(LINK_HANDLE link, uint64_t* max_message_size)
        -: 1041:{
        -: 1042:    int result;
        -: 1043:
    #####: 1044:    if ((link == NULL) ||
        -: 1045:        (max_message_size == NULL))
        -: 1046:    {
    #####: 1047:        LogError("Bad arguments: link = %p, max_message_size = %p",
        -: 1048:            link, max_message_size);
    #####: 1049:        result = MU_FAILURE;
        -: 1050:    }
        -: 1051:    else
        -: 1052:    {
    #####: 1053:        *max_message_size = link->max_message_size;
    #####: 1054:        result = 0;
        -: 1055:    }
        -: 1056:
    #####: 1057:    return result;
        -: 1058:}
        -: 1059:
    #####: 1060:int link_get_peer_max_message_size(LINK_HANDLE link, uint64_t* peer_max_message_size)
        -: 1061:{
        -: 1062:    int result;
        -: 1063:
    #####: 1064:    if ((link == NULL) ||
        -: 1065:        (peer_max_message_size == NULL))
        -: 1066:    {
    #####: 1067:        LogError("Bad arguments: link = %p, peer_max_message_size = %p",
        -: 1068:            link, peer_max_message_size);
    #####: 1069:        result = MU_FAILURE;
        -: 1070:    }
    #####: 1071:    else if ((link->link_state != LINK_STATE_ATTACHED) &&
    #####: 1072:        (link->link_state != LINK_STATE_HALF_ATTACHED_ATTACH_RECEIVED))
        -: 1073:    {
    #####: 1074:        LogError("Attempting to read peer max message size before it was received");
    #####: 1075:        result = MU_FAILURE;
        -: 1076:    }
        -: 1077:    else
        -: 1078:    {
    #####: 1079:        *peer_max_message_size = link->peer_max_message_size;
    #####: 1080:        result = 0;
        -: 1081:    }
        -: 1082:
    #####: 1083:    return result;
        -: 1084:}
        -: 1085:
        1: 1086:int link_set_attach_properties(LINK_HANDLE link, fields attach_properties)
        -: 1087:{
        -: 1088:    int result;
        -: 1089:
        1: 1090:    if (link == NULL)
        -: 1091:    {
    #####: 1092:        LogError("NULL link");
    #####: 1093:        result = MU_FAILURE;
        -: 1094:    }
        -: 1095:    else
        -: 1096:    {
        1: 1097:        link->attach_properties = amqpvalue_clone(attach_properties);
        1: 1098:        if (link->attach_properties == NULL)
        -: 1099:        {
    #####: 1100:            LogError("Failed cloning attach properties");
    #####: 1101:            result = MU_FAILURE;
        -: 1102:        }
        -: 1103:        else
        -: 1104:        {
        1: 1105:            result = 0;
        -: 1106:        }
        -: 1107:    }
        -: 1108:
        1: 1109:    return result;
        -: 1110:}
        -: 1111:
    #####: 1112:int link_set_max_link_credit(LINK_HANDLE link, uint32_t max_link_credit)
        -: 1113:{
        -: 1114:    int result;
        -: 1115:
    #####: 1116:    if (link == NULL)
        -: 1117:    {
    #####: 1118:        result = MU_FAILURE;
        -: 1119:    }
        -: 1120:    else
        -: 1121:    {
    #####: 1122:        link->max_link_credit = max_link_credit;
    #####: 1123:        result = 0;
        -: 1124:    }
        -: 1125:
    #####: 1126:    return result;
        -: 1127:}
        -: 1128:
        9: 1129:int link_attach(LINK_HANDLE link, ON_TRANSFER_RECEIVED on_transfer_received, ON_LINK_STATE_CHANGED on_link_state_changed, ON_LINK_FLOW_ON on_link_flow_on, void* callback_context)
        -: 1130:{
        -: 1131:    int result;
        -: 1132:
        9: 1133:    if (link == NULL)
        -: 1134:    {
    #####: 1135:        LogError("NULL link");
    #####: 1136:        result = MU_FAILURE;
        -: 1137:    }
        9: 1138:    else if (link->is_closed)
        -: 1139:    {
    #####: 1140:        LogError("Already attached");
    #####: 1141:        result = MU_FAILURE;
        -: 1142:    }
        -: 1143:    else
        -: 1144:    {
        9: 1145:        if (!link->is_underlying_session_begun)
        -: 1146:        {
        9: 1147:            link->on_link_state_changed = on_link_state_changed;
        9: 1148:            link->on_transfer_received = on_transfer_received;
        9: 1149:            link->on_link_flow_on = on_link_flow_on;
        9: 1150:            link->callback_context = callback_context;
        -: 1151:
        9: 1152:            if (session_begin(link->session) != 0)
        -: 1153:            {
        9: 1154:                LogError("Begin session failed");
        9: 1155:                result = MU_FAILURE;
        -: 1156:            }
        -: 1157:            else
        -: 1158:            {
    #####: 1159:                link->is_underlying_session_begun = true;
        -: 1160:
    #####: 1161:                if (session_start_link_endpoint(link->link_endpoint, link_frame_received, on_session_state_changed, on_session_flow_on, link) != 0)
        -: 1162:                {
    #####: 1163:                    LogError("Binding link endpoint to session failed");
    #####: 1164:                    result = MU_FAILURE;
        -: 1165:                }
        -: 1166:                else
        -: 1167:                {
    #####: 1168:                    link->received_payload_size = 0;
        -: 1169:
    #####: 1170:                    result = 0;
        -: 1171:                }
        -: 1172:            }
        -: 1173:        }
        -: 1174:        else
        -: 1175:        {
    #####: 1176:            result = 0;
        -: 1177:        }
        -: 1178:    }
        -: 1179:
        9: 1180:    return result;
        -: 1181:}
        -: 1182:
       12: 1183:int link_detach(LINK_HANDLE link, bool close, const char* error_condition, const char* error_description, AMQP_VALUE info)
        -: 1184:{
        -: 1185:    int result;
        -: 1186:
        -: 1187:    (void)error_condition;
        -: 1188:    (void)error_description;
        -: 1189:    (void)info;
        -: 1190:
       12: 1191:    if (link == NULL)
        -: 1192:    {
    #####: 1193:        LogError("NULL link");
    #####: 1194:        result = MU_FAILURE;
        -: 1195:    }
       12: 1196:    else if (link->is_closed)
        -: 1197:    {
    #####: 1198:        result = 0;
        -: 1199:    }
        -: 1200:    else
        -: 1201:    {
        -: 1202:        ERROR_HANDLE error;
        -: 1203:
       12: 1204:        if (error_condition != NULL)
        -: 1205:        {
    #####: 1206:            error = error_create(error_condition);
    #####: 1207:            if (error == NULL)
        -: 1208:            {
    #####: 1209:                LogInfo("Cannot create error for detach, detaching without error anyhow");
        -: 1210:            }
        -: 1211:            else
        -: 1212:            {
    #####: 1213:                if (error_description != NULL)
        -: 1214:                {
    #####: 1215:                    if (error_set_description(error, error_description) != 0)
        -: 1216:                    {
    #####: 1217:                        LogInfo("Cannot set error description on detach error, detaching anyhow");
        -: 1218:                    }
        -: 1219:                }
        -: 1220:
    #####: 1221:                if (info != NULL)
        -: 1222:                {
    #####: 1223:                    if (error_set_info(error, info) != 0)
        -: 1224:                    {
    #####: 1225:                        LogInfo("Cannot set info map on detach error, detaching anyhow");
        -: 1226:                    }
        -: 1227:                }
        -: 1228:            }
        -: 1229:        }
        -: 1230:        else
        -: 1231:        {
       12: 1232:            error = NULL;
        -: 1233:        }
        -: 1234:
       12: 1235:        switch (link->link_state)
        -: 1236:        {
    #####: 1237:        case LINK_STATE_HALF_ATTACHED_ATTACH_SENT:
        -: 1238:        case LINK_STATE_HALF_ATTACHED_ATTACH_RECEIVED:
        -: 1239:            /* Sending detach when remote is not yet attached */
    #####: 1240:            if (send_detach(link, close, error) != 0)
        -: 1241:            {
    #####: 1242:                LogError("Sending detach frame failed");
    #####: 1243:                result = MU_FAILURE;
        -: 1244:            }
        -: 1245:            else
        -: 1246:            {
    #####: 1247:                set_link_state(link, LINK_STATE_DETACHED);
    #####: 1248:                result = 0;
        -: 1249:            }
    #####: 1250:            break;
        -: 1251:
    #####: 1252:        case LINK_STATE_ATTACHED:
        -: 1253:            /* Send detach and wait for remote to respond */
    #####: 1254:            if (send_detach(link, close, error) != 0)
        -: 1255:            {
    #####: 1256:                LogError("Sending detach frame failed");
    #####: 1257:                result = MU_FAILURE;
        -: 1258:            }
        -: 1259:            else
        -: 1260:            {
    #####: 1261:                set_link_state(link, LINK_STATE_HALF_ATTACHED_ATTACH_SENT);
    #####: 1262:                result = 0;
        -: 1263:            }
    #####: 1264:            break;
        -: 1265:
       12: 1266:        case LINK_STATE_DETACHED:
        -: 1267:            /* Already detached */
       12: 1268:            result = 0;
       12: 1269:            break;
        -: 1270:
    #####: 1271:        default:
        -: 1272:        case LINK_STATE_ERROR:
        -: 1273:            /* Already detached and in error state */
    #####: 1274:            result = MU_FAILURE;
    #####: 1275:            break;
        -: 1276:        }
        -: 1277:
       12: 1278:        if (error != NULL)
        -: 1279:        {
    #####: 1280:            error_destroy(error);
        -: 1281:        }
        -: 1282:    }
        -: 1283:
       12: 1284:    return result;
        -: 1285:}
        -: 1286:
    #####: 1287:static bool remove_pending_delivery_condition_function(const void* item, const void* match_context, bool* continue_processing)
        -: 1288:{
        -: 1289:    bool result;
        -: 1290:
    #####: 1291:    if (item == match_context)
        -: 1292:    {
    #####: 1293:        result = true;
    #####: 1294:        *continue_processing = false;
        -: 1295:    }
        -: 1296:    else
        -: 1297:    {
    #####: 1298:        result = false;
    #####: 1299:        *continue_processing = true;
        -: 1300:    }
        -: 1301:
    #####: 1302:    return result;
        -: 1303:}
        -: 1304:
    #####: 1305:static void link_transfer_cancel_handler(ASYNC_OPERATION_HANDLE link_transfer_operation)
        -: 1306:{
    #####: 1307:    DELIVERY_INSTANCE* pending_delivery = GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, link_transfer_operation);
    #####: 1308:    if (pending_delivery->on_delivery_settled != NULL)
        -: 1309:    {
    #####: 1310:        pending_delivery->on_delivery_settled(pending_delivery->callback_context, pending_delivery->delivery_id, LINK_DELIVERY_SETTLE_REASON_CANCELLED, NULL);
        -: 1311:    }
        -: 1312:
    #####: 1313:    (void)singlylinkedlist_remove_if(((LINK_HANDLE)pending_delivery->link)->pending_deliveries, remove_pending_delivery_condition_function, pending_delivery);
        -: 1314:
    #####: 1315:    async_operation_destroy(link_transfer_operation);
    #####: 1316:}
        -: 1317:
    #####: 1318:ASYNC_OPERATION_HANDLE link_transfer_async(LINK_HANDLE link, message_format message_format, PAYLOAD* payloads, size_t payload_count, ON_DELIVERY_SETTLED on_delivery_settled, void* callback_context, LINK_TRANSFER_RESULT* link_transfer_error, tickcounter_ms_t timeout)
        -: 1319:{
        -: 1320:    ASYNC_OPERATION_HANDLE result;
        -: 1321:
    #####: 1322:    if ((link == NULL) ||
        -: 1323:        (link_transfer_error == NULL))
        -: 1324:    {
    #####: 1325:        if (link_transfer_error != NULL)
        -: 1326:        {
    #####: 1327:            *link_transfer_error = LINK_TRANSFER_ERROR;
        -: 1328:        }
        -: 1329:
    #####: 1330:        LogError("Invalid arguments: link = %p, link_transfer_error = %p",
        -: 1331:            link, link_transfer_error);
    #####: 1332:        result = NULL;
        -: 1333:    }
        -: 1334:    else
        -: 1335:    {
    #####: 1336:        if (link->role != role_sender)
        -: 1337:        {
    #####: 1338:            LogError("Link is not a sender link");
    #####: 1339:            *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1340:            result = NULL;
        -: 1341:        }
    #####: 1342:        else if (link->link_state != LINK_STATE_ATTACHED)
        -: 1343:        {
    #####: 1344:            LogError("Link is not attached");
    #####: 1345:            *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1346:            result = NULL;
        -: 1347:        }
    #####: 1348:        else if (link->current_link_credit == 0)
        -: 1349:        {
    #####: 1350:            *link_transfer_error = LINK_TRANSFER_BUSY;
    #####: 1351:            result = NULL;
        -: 1352:        }
        -: 1353:        else
        -: 1354:        {
    #####: 1355:            result = CREATE_ASYNC_OPERATION(DELIVERY_INSTANCE, link_transfer_cancel_handler);
    #####: 1356:            if (result == NULL)
        -: 1357:            {
    #####: 1358:                LogError("Error creating async operation");
    #####: 1359:                *link_transfer_error = LINK_TRANSFER_ERROR;
        -: 1360:            }
        -: 1361:            else
        -: 1362:            {
    #####: 1363:                TRANSFER_HANDLE transfer = transfer_create(0);
    #####: 1364:                if (transfer == NULL)
        -: 1365:                {
    #####: 1366:                    LogError("Error creating transfer");
    #####: 1367:                    *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1368:                    async_operation_destroy(result);
    #####: 1369:                    result = NULL;
        -: 1370:                }
        -: 1371:                else
        -: 1372:                {
    #####: 1373:                    sequence_no delivery_count = link->delivery_count + 1;
        -: 1374:                    unsigned char delivery_tag_bytes[sizeof(delivery_count)];
        -: 1375:                    delivery_tag delivery_tag;
        -: 1376:                    bool settled;
        -: 1377:
    #####: 1378:                    (void)memcpy(delivery_tag_bytes, &delivery_count, sizeof(delivery_count));
        -: 1379:
    #####: 1380:                    delivery_tag.bytes = &delivery_tag_bytes;
    #####: 1381:                    delivery_tag.length = sizeof(delivery_tag_bytes);
        -: 1382:
    #####: 1383:                    if (link->snd_settle_mode == sender_settle_mode_unsettled)
        -: 1384:                    {
    #####: 1385:                        settled = false;
        -: 1386:                    }
        -: 1387:                    else
        -: 1388:                    {
    #####: 1389:                        settled = true;
        -: 1390:                    }
        -: 1391:
    #####: 1392:                    if (transfer_set_delivery_tag(transfer, delivery_tag) != 0)
        -: 1393:                    {
    #####: 1394:                        LogError("Failed setting delivery tag");
    #####: 1395:                        *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1396:                        async_operation_destroy(result);
    #####: 1397:                        result = NULL;
        -: 1398:                    }
    #####: 1399:                    else if (transfer_set_message_format(transfer, message_format) != 0)
        -: 1400:                    {
    #####: 1401:                        LogError("Failed setting message format");
    #####: 1402:                        *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1403:                        async_operation_destroy(result);
    #####: 1404:                        result = NULL;
        -: 1405:                    }
    #####: 1406:                    else if (transfer_set_settled(transfer, settled) != 0)
        -: 1407:                    {
    #####: 1408:                        LogError("Failed setting settled flag");
    #####: 1409:                        *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1410:                        async_operation_destroy(result);
    #####: 1411:                        result = NULL;
        -: 1412:                    }
        -: 1413:                    else
        -: 1414:                    {
    #####: 1415:                        AMQP_VALUE transfer_value = amqpvalue_create_transfer(transfer);
    #####: 1416:                        if (transfer_value == NULL)
        -: 1417:                        {
    #####: 1418:                            LogError("Failed creating transfer performative AMQP value");
    #####: 1419:                            *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1420:                            async_operation_destroy(result);
    #####: 1421:                            result = NULL;
        -: 1422:                        }
        -: 1423:                        else
        -: 1424:                        {
    #####: 1425:                            DELIVERY_INSTANCE* pending_delivery = GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, result);
    #####: 1426:                            if (pending_delivery == NULL)
        -: 1427:                            {
    #####: 1428:                                LogError("Failed getting pending delivery");
    #####: 1429:                                *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1430:                                async_operation_destroy(result);
    #####: 1431:                                result = NULL;
        -: 1432:                            }
        -: 1433:                            else
        -: 1434:                            {
    #####: 1435:                                if (tickcounter_get_current_ms(link->tick_counter, &pending_delivery->start_tick) != 0)
        -: 1436:                                {
    #####: 1437:                                    LogError("Failed getting current tick");
    #####: 1438:                                    *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1439:                                    async_operation_destroy(result);
    #####: 1440:                                    result = NULL;
        -: 1441:                                }
        -: 1442:                                else
        -: 1443:                                {
        -: 1444:                                    LIST_ITEM_HANDLE delivery_instance_list_item;
    #####: 1445:                                    pending_delivery->timeout = timeout;
    #####: 1446:                                    pending_delivery->on_delivery_settled = on_delivery_settled;
    #####: 1447:                                    pending_delivery->callback_context = callback_context;
    #####: 1448:                                    pending_delivery->link = link;
    #####: 1449:                                    delivery_instance_list_item = singlylinkedlist_add(link->pending_deliveries, result);
        -: 1450:
    #####: 1451:                                    if (delivery_instance_list_item == NULL)
        -: 1452:                                    {
    #####: 1453:                                        LogError("Failed adding delivery to list");
    #####: 1454:                                        *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1455:                                        async_operation_destroy(result);
    #####: 1456:                                        result = NULL;
        -: 1457:                                    }
        -: 1458:                                    else
        -: 1459:                                    {
        -: 1460:                                        /* here we should feed data to the transfer frame */
    #####: 1461:                                        switch (session_send_transfer(link->link_endpoint, transfer, payloads, payload_count, &pending_delivery->delivery_id, (settled) ? on_send_complete : NULL, delivery_instance_list_item))
        -: 1462:                                        {
    #####: 1463:                                        default:
        -: 1464:                                        case SESSION_SEND_TRANSFER_ERROR:
    #####: 1465:                                            LogError("Failed session send transfer");
    #####: 1466:                                            if (singlylinkedlist_remove(link->pending_deliveries, delivery_instance_list_item) != 0)
        -: 1467:                                            {
    #####: 1468:                                                LogError("Error removing pending delivery from the list");
        -: 1469:                                            }
        -: 1470:
    #####: 1471:                                            *link_transfer_error = LINK_TRANSFER_ERROR;
    #####: 1472:                                            async_operation_destroy(result);
    #####: 1473:                                            result = NULL;
    #####: 1474:                                            break;
        -: 1475:
    #####: 1476:                                        case SESSION_SEND_TRANSFER_BUSY:
        -: 1477:                                            /* Ensure we remove from list again since sender will attempt to transfer again on flow on */
    #####: 1478:                                            LogError("Failed session send transfer");
    #####: 1479:                                            if (singlylinkedlist_remove(link->pending_deliveries, delivery_instance_list_item) != 0)
        -: 1480:                                            {
    #####: 1481:                                                LogError("Error removing pending delivery from the list");
        -: 1482:                                            }
        -: 1483:
    #####: 1484:                                            *link_transfer_error = LINK_TRANSFER_BUSY;
    #####: 1485:                                            async_operation_destroy(result);
    #####: 1486:                                            result = NULL;
    #####: 1487:                                            break;
        -: 1488:
    #####: 1489:                                        case SESSION_SEND_TRANSFER_OK:
    #####: 1490:                                            link->delivery_count = delivery_count;
    #####: 1491:                                            link->current_link_credit--;
    #####: 1492:                                            break;
        -: 1493:                                        }
        -: 1494:                                    }
        -: 1495:                                }
        -: 1496:                            }
        -: 1497:
    #####: 1498:                            amqpvalue_destroy(transfer_value);
        -: 1499:                        }
        -: 1500:                    }
        -: 1501:
    #####: 1502:                    transfer_destroy(transfer);
        -: 1503:                }
        -: 1504:            }
        -: 1505:        }
        -: 1506:    }
        -: 1507:
    #####: 1508:    return result;
        -: 1509:}
        -: 1510:
    #####: 1511:int link_get_name(LINK_HANDLE link, const char** link_name)
        -: 1512:{
        -: 1513:    int result;
        -: 1514:
    #####: 1515:    if (link == NULL)
        -: 1516:    {
    #####: 1517:        LogError("NULL link");
    #####: 1518:        result = MU_FAILURE;
        -: 1519:    }
        -: 1520:    else
        -: 1521:    {
    #####: 1522:        *link_name = link->name;
    #####: 1523:        result = 0;
        -: 1524:    }
        -: 1525:
    #####: 1526:    return result;
        -: 1527:}
        -: 1528:
    #####: 1529:int link_get_received_message_id(LINK_HANDLE link, delivery_number* message_id)
        -: 1530:{
        -: 1531:    int result;
        -: 1532:
    #####: 1533:    if (link == NULL)
        -: 1534:    {
    #####: 1535:        LogError("NULL link");
    #####: 1536:        result = MU_FAILURE;
        -: 1537:    }
        -: 1538:    else
        -: 1539:    {
    #####: 1540:        *message_id = link->received_delivery_id;
    #####: 1541:        result = 0;
        -: 1542:    }
        -: 1543:
    #####: 1544:    return result;
        -: 1545:}
        -: 1546:
    #####: 1547:int link_send_disposition(LINK_HANDLE link, delivery_number message_id, AMQP_VALUE delivery_state)
        -: 1548:{
        -: 1549:    int result;
        -: 1550:
    #####: 1551:    if (delivery_state == NULL)
        -: 1552:    {
    #####: 1553:        result = 0;
        -: 1554:    }
        -: 1555:    else
        -: 1556:    {
    #####: 1557:        result = send_disposition(link, message_id, delivery_state);
    #####: 1558:        if (result != 0)
        -: 1559:        {
    #####: 1560:            LogError("Cannot send disposition frame");
    #####: 1561:            result = MU_FAILURE;
        -: 1562:        }
        -: 1563:    }
        -: 1564:
    #####: 1565:    return result;
        -: 1566:}
        -: 1567:
    #####: 1568:void link_dowork(LINK_HANDLE link)
        -: 1569:{
    #####: 1570:    if (link == NULL)
        -: 1571:    {
    #####: 1572:        LogError("NULL link");
        -: 1573:    }
        -: 1574:    else
        -: 1575:    {
        -: 1576:        tickcounter_ms_t current_tick;
        -: 1577:
    #####: 1578:        if (tickcounter_get_current_ms(link->tick_counter, &current_tick) != 0)
        -: 1579:        {
    #####: 1580:            LogError("Cannot get tick counter value");
        -: 1581:        }
        -: 1582:        else
        -: 1583:        {
        -: 1584:            // go through all and find timed out deliveries
    #####: 1585:            LIST_ITEM_HANDLE item = singlylinkedlist_get_head_item(link->pending_deliveries);
    #####: 1586:            while (item != NULL)
        -: 1587:            {
    #####: 1588:                LIST_ITEM_HANDLE next_item = singlylinkedlist_get_next_item(item);
    #####: 1589:                ASYNC_OPERATION_HANDLE delivery_instance_async_operation = (ASYNC_OPERATION_HANDLE)singlylinkedlist_item_get_value(item);
    #####: 1590:                DELIVERY_INSTANCE* delivery_instance = (DELIVERY_INSTANCE*)GET_ASYNC_OPERATION_CONTEXT(DELIVERY_INSTANCE, delivery_instance_async_operation);
        -: 1591:
    #####: 1592:                if ((delivery_instance->timeout != 0) &&
    #####: 1593:                    (current_tick - delivery_instance->start_tick >= delivery_instance->timeout))
        -: 1594:                {
    #####: 1595:                    if (delivery_instance->on_delivery_settled != NULL)
        -: 1596:                    {
    #####: 1597:                        delivery_instance->on_delivery_settled(delivery_instance->callback_context, delivery_instance->delivery_id, LINK_DELIVERY_SETTLE_REASON_TIMEOUT, NULL);
        -: 1598:                    }
        -: 1599:
    #####: 1600:                    if (singlylinkedlist_remove(link->pending_deliveries, item) != 0)
        -: 1601:                    {
    #####: 1602:                        LogError("Cannot remove item from list");
        -: 1603:                    }
        -: 1604:
    #####: 1605:                    async_operation_destroy(delivery_instance_async_operation);
        -: 1606:                }
        -: 1607:
    #####: 1608:                item = next_item;
        -: 1609:            }
        -: 1610:        }
        -: 1611:    }
    #####: 1612:}
        -: 1613:
    #####: 1614:ON_LINK_DETACH_EVENT_SUBSCRIPTION_HANDLE link_subscribe_on_link_detach_received(LINK_HANDLE link, ON_LINK_DETACH_RECEIVED on_link_detach_received, void* context)
        -: 1615:{
        -: 1616:    ON_LINK_DETACH_EVENT_SUBSCRIPTION_HANDLE result;
        -: 1617:
    #####: 1618:    if ((link == NULL) ||
        -: 1619:        (on_link_detach_received == NULL))
        -: 1620:    {
    #####: 1621:        LogError("Invalid arguments: link = %p, on_link_detach_received = %p, context = %p",
        -: 1622:            link, on_link_detach_received, context);
    #####: 1623:        result = NULL;
        -: 1624:    }
        -: 1625:    else
        -: 1626:    {
    #####: 1627:        if (link->on_link_detach_received_event_subscription.on_link_detach_received != NULL)
        -: 1628:        {
    #####: 1629:            LogError("Already subscribed for on_link_detach_received events");
    #####: 1630:            result = NULL;
        -: 1631:        }
        -: 1632:        else
        -: 1633:        {
    #####: 1634:            link->on_link_detach_received_event_subscription.on_link_detach_received = on_link_detach_received;
    #####: 1635:            link->on_link_detach_received_event_subscription.context = context;
        -: 1636:
    #####: 1637:            result = &link->on_link_detach_received_event_subscription;
        -: 1638:        }
        -: 1639:    }
        -: 1640:
    #####: 1641:    return result;
        -: 1642:}
        -: 1643:
    #####: 1644:void link_unsubscribe_on_link_detach_received(ON_LINK_DETACH_EVENT_SUBSCRIPTION_HANDLE event_subscription)
        -: 1645:{
    #####: 1646:    if (event_subscription == NULL)
        -: 1647:    {
    #####: 1648:        LogError("NULL event_subscription");
        -: 1649:    }
        -: 1650:    else
        -: 1651:    {
    #####: 1652:        event_subscription->on_link_detach_received = NULL;
    #####: 1653:        event_subscription->context = NULL;
        -: 1654:    }
    #####: 1655:}
