        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/src/amqpvalue.c
        -:    0:Programs:101
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <stdint.h>
        -:    6:#include <string.h>
        -:    7:#include <stdbool.h>
        -:    8:#include "azure_macro_utils/macro_utils.h"
        -:    9:#include "azure_c_shared_utility/gballoc.h"
        -:   10:#include "azure_c_shared_utility/xlogging.h"
        -:   11:#include "azure_uamqp_c/amqp_types.h"
        -:   12:#include "azure_uamqp_c/amqpvalue.h"
        -:   13:#include "azure_c_shared_utility/refcount.h"
        -:   14:
        -:   15:/* Requirements satisfied by the current implementation without any code:
        -:   16:Codes_SRS_AMQPVALUE_01_270: [<encoding code="0x56" category="fixed" width="1" label="boolean with the octet 0x00 being false and octet 0x01 being true"/>]
        -:   17:Codes_SRS_AMQPVALUE_01_099: [Represents an approximate point in time using the Unix time t [IEEE1003] encoding of UTC, but with a precision of milliseconds.]
        -:   18:*/
        -:   19:
        -:   20:typedef struct AMQP_LIST_VALUE_TAG
        -:   21:{
        -:   22:    AMQP_VALUE* items;
        -:   23:    uint32_t count;
        -:   24:} AMQP_LIST_VALUE;
        -:   25:
        -:   26:typedef struct AMQP_ARRAY_VALUE_TAG
        -:   27:{
        -:   28:    AMQP_VALUE* items;
        -:   29:    uint32_t count;
        -:   30:} AMQP_ARRAY_VALUE;
        -:   31:
        -:   32:typedef struct AMQP_MAP_KEY_VALUE_PAIR_TAG
        -:   33:{
        -:   34:    AMQP_VALUE key;
        -:   35:    AMQP_VALUE value;
        -:   36:} AMQP_MAP_KEY_VALUE_PAIR;
        -:   37:
        -:   38:typedef struct AMQP_MAP_VALUE_TAG
        -:   39:{
        -:   40:    AMQP_MAP_KEY_VALUE_PAIR* pairs;
        -:   41:    uint32_t pair_count;
        -:   42:} AMQP_MAP_VALUE;
        -:   43:
        -:   44:typedef struct AMQP_STRING_VALUE_TAG
        -:   45:{
        -:   46:    char* chars;
        -:   47:} AMQP_STRING_VALUE;
        -:   48:
        -:   49:typedef struct AMQP_SYMBOL_VALUE_TAG
        -:   50:{
        -:   51:    char* chars;
        -:   52:} AMQP_SYMBOL_VALUE;
        -:   53:
        -:   54:typedef struct AMQP_BINARY_VALUE_TAG
        -:   55:{
        -:   56:    unsigned char* bytes;
        -:   57:    uint32_t length;
        -:   58:} AMQP_BINARY_VALUE;
        -:   59:
        -:   60:typedef struct DESCRIBED_VALUE_TAG
        -:   61:{
        -:   62:    AMQP_VALUE descriptor;
        -:   63:    AMQP_VALUE value;
        -:   64:} DESCRIBED_VALUE;
        -:   65:
        -:   66:typedef union AMQP_VALUE_UNION_TAG
        -:   67:{
        -:   68:    DESCRIBED_VALUE described_value;
        -:   69:    unsigned char ubyte_value;
        -:   70:    uint16_t ushort_value;
        -:   71:    uint32_t uint_value;
        -:   72:    uint64_t ulong_value;
        -:   73:    char byte_value;
        -:   74:    int16_t short_value;
        -:   75:    int32_t int_value;
        -:   76:    int64_t long_value;
        -:   77:    bool bool_value;
        -:   78:    float float_value;
        -:   79:    double double_value;
        -:   80:    uint32_t char_value;
        -:   81:    int64_t timestamp_value;
        -:   82:    uuid uuid_value;
        -:   83:    AMQP_STRING_VALUE string_value;
        -:   84:    amqp_binary binary_value;
        -:   85:    AMQP_LIST_VALUE list_value;
        -:   86:    AMQP_MAP_VALUE map_value;
        -:   87:    AMQP_ARRAY_VALUE array_value;
        -:   88:    AMQP_SYMBOL_VALUE symbol_value;
        -:   89:} AMQP_VALUE_UNION;
        -:   90:
        -:   91:typedef enum DECODE_LIST_STEP_TAG
        -:   92:{
        -:   93:    DECODE_LIST_STEP_SIZE,
        -:   94:    DECODE_LIST_STEP_COUNT,
        -:   95:    DECODE_LIST_STEP_ITEMS
        -:   96:} DECODE_LIST_STEP;
        -:   97:
        -:   98:typedef enum DECODE_ARRAY_STEP_TAG
        -:   99:{
        -:  100:    DECODE_ARRAY_STEP_SIZE,
        -:  101:    DECODE_ARRAY_STEP_COUNT,
        -:  102:    DECODE_ARRAY_STEP_ITEMS
        -:  103:} DECODE_ARRAY_STEP;
        -:  104:
        -:  105:typedef enum DECODE_DESCRIBED_VALUE_STEP_TAG
        -:  106:{
        -:  107:    DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR,
        -:  108:    DECODE_DESCRIBED_VALUE_STEP_VALUE
        -:  109:} DECODE_DESCRIBED_VALUE_STEP;
        -:  110:
        -:  111:typedef enum DECODE_MAP_STEP_TAG
        -:  112:{
        -:  113:    DECODE_MAP_STEP_SIZE,
        -:  114:    DECODE_MAP_STEP_COUNT,
        -:  115:    DECODE_MAP_STEP_PAIRS
        -:  116:} DECODE_MAP_STEP;
        -:  117:
        -:  118:typedef struct DECODE_LIST_VALUE_STATE_TAG
        -:  119:{
        -:  120:    DECODE_LIST_STEP list_value_state;
        -:  121:    uint32_t item;
        -:  122:} DECODE_LIST_VALUE_STATE;
        -:  123:
        -:  124:typedef struct DECODE_ARRAY_VALUE_STATE_TAG
        -:  125:{
        -:  126:    DECODE_ARRAY_STEP array_value_state;
        -:  127:    uint32_t item;
        -:  128:    unsigned char constructor_byte;
        -:  129:} DECODE_ARRAY_VALUE_STATE;
        -:  130:
        -:  131:typedef struct DECODE_DESCRIBED_VALUE_STATE_TAG
        -:  132:{
        -:  133:    DECODE_DESCRIBED_VALUE_STEP described_value_state;
        -:  134:} DECODE_DESCRIBED_VALUE_STATE;
        -:  135:
        -:  136:typedef struct DECODE_STRING_VALUE_STATE_TAG
        -:  137:{
        -:  138:    uint32_t length;
        -:  139:} DECODE_STRING_VALUE_STATE;
        -:  140:
        -:  141:typedef struct DECODE_SYMBOL_VALUE_STATE_TAG
        -:  142:{
        -:  143:    uint32_t length;
        -:  144:} DECODE_SYMBOL_VALUE_STATE;
        -:  145:
        -:  146:typedef struct DECODE_MAP_VALUE_STATE_TAG
        -:  147:{
        -:  148:    DECODE_MAP_STEP map_value_state;
        -:  149:    uint32_t item;
        -:  150:} DECODE_MAP_VALUE_STATE;
        -:  151:
        -:  152:typedef union DECODE_VALUE_STATE_UNION_TAG
        -:  153:{
        -:  154:    DECODE_LIST_VALUE_STATE list_value_state;
        -:  155:    DECODE_ARRAY_VALUE_STATE array_value_state;
        -:  156:    DECODE_DESCRIBED_VALUE_STATE described_value_state;
        -:  157:    DECODE_STRING_VALUE_STATE string_value_state;
        -:  158:    DECODE_SYMBOL_VALUE_STATE symbol_value_state;
        -:  159:    DECODE_MAP_VALUE_STATE map_value_state;
        -:  160:} DECODE_VALUE_STATE_UNION;
        -:  161:
        -:  162:typedef struct AMQP_VALUE_DATA_TAG
        -:  163:{
        -:  164:    AMQP_TYPE type;
        -:  165:    AMQP_VALUE_UNION value;
        -:  166:} AMQP_VALUE_DATA;
        -:  167:
     257*:  168:DEFINE_REFCOUNT_TYPE(AMQP_VALUE_DATA);
------------------
REFCOUNT_AMQP_VALUE_DATA_Destroy:
       85:  168:DEFINE_REFCOUNT_TYPE(AMQP_VALUE_DATA);
------------------
REFCOUNT_AMQP_VALUE_DATA_Create:
       86:  168:DEFINE_REFCOUNT_TYPE(AMQP_VALUE_DATA);
------------------
REFCOUNT_AMQP_VALUE_DATA_Create_With_Extra_Size:
      86*:  168:DEFINE_REFCOUNT_TYPE(AMQP_VALUE_DATA);
------------------
        -:  169:
        -:  170:typedef enum DECODER_STATE_TAG
        -:  171:{
        -:  172:    DECODER_STATE_CONSTRUCTOR,
        -:  173:    DECODER_STATE_TYPE_DATA,
        -:  174:    DECODER_STATE_DONE,
        -:  175:    DECODER_STATE_ERROR
        -:  176:} DECODER_STATE;
        -:  177:
        -:  178:typedef struct INTERNAL_DECODER_DATA_TAG* INTERNAL_DECODER_HANDLE;
        -:  179:
        -:  180:typedef struct INTERNAL_DECODER_DATA_TAG
        -:  181:{
        -:  182:    ON_VALUE_DECODED on_value_decoded;
        -:  183:    void* on_value_decoded_context;
        -:  184:    size_t bytes_decoded;
        -:  185:    DECODER_STATE decoder_state;
        -:  186:    uint8_t constructor_byte;
        -:  187:    AMQP_VALUE_DATA* decode_to_value;
        -:  188:    INTERNAL_DECODER_HANDLE inner_decoder;
        -:  189:    DECODE_VALUE_STATE_UNION decode_value_state;
        -:  190:    bool is_internal;
        -:  191:} INTERNAL_DECODER_DATA;
        -:  192:
        -:  193:typedef struct AMQPVALUE_DECODER_HANDLE_DATA_TAG
        -:  194:{
        -:  195:    INTERNAL_DECODER_DATA* internal_decoder;
        -:  196:    AMQP_VALUE_DATA* decode_to_value;
        -:  197:} AMQPVALUE_DECODER_HANDLE_DATA;
        -:  198:
        -:  199:static int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context);
        -:  200:static int amqpvalue_get_encoded_array_item_size(AMQP_VALUE item, size_t* encoded_size);
        -:  201:
        -:  202:/* Codes_SRS_AMQPVALUE_01_003: [1.6.1 null Indicates an empty value.] */
    #####:  203:AMQP_VALUE amqpvalue_create_null(void)
        -:  204:{
    #####:  205:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  206:    if (result == NULL)
        -:  207:    {
        -:  208:        /* Codes_SRS_AMQPVALUE_01_002: [If allocating the AMQP_VALUE fails then amqpvalue_create_null shall return NULL.] */
    #####:  209:        LogError("Could not allocate memory for AMQP value");
        -:  210:    }
        -:  211:    else
        -:  212:    {
        -:  213:        /* Codes_SRS_AMQPVALUE_01_001: [amqpvalue_create_null shall return a handle to an AMQP_VALUE that stores a null value.] */
    #####:  214:        result->type = AMQP_TYPE_NULL;
        -:  215:    }
        -:  216:
    #####:  217:    return result;
        -:  218:}
        -:  219:
        -:  220:/* Codes_SRS_AMQPVALUE_01_004: [1.6.2 boolean Represents a true or false value.] */
    #####:  221:AMQP_VALUE amqpvalue_create_boolean(bool value)
        -:  222:{
    #####:  223:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  224:    if (result == NULL)
        -:  225:    {
        -:  226:        /* Codes_SRS_AMQPVALUE_01_007: [If allocating the AMQP_VALUE fails then amqpvalue_create_boolean shall return NULL.] */
    #####:  227:        LogError("Could not allocate memory for AMQP value");
        -:  228:    }
        -:  229:    else
        -:  230:    {
        -:  231:        /* Codes_SRS_AMQPVALUE_01_006: [amqpvalue_create_boolean shall return a handle to an AMQP_VALUE that stores a boolean value.] */
    #####:  232:        result->type = AMQP_TYPE_BOOL;
    #####:  233:        result->value.bool_value = value;
        -:  234:    }
        -:  235:
    #####:  236:    return result;
        -:  237:}
        -:  238:
    #####:  239:int amqpvalue_get_boolean(AMQP_VALUE value, bool* bool_value)
        -:  240:{
        -:  241:    int result;
        -:  242:
        -:  243:    /* Codes_SRS_AMQPVALUE_01_009: [If any of the arguments is NULL then amqpvalue_get_boolean shall return a non-zero value.] */
    #####:  244:    if ((value == NULL) ||
        -:  245:        (bool_value == NULL))
        -:  246:    {
    #####:  247:        LogError("Bad arguments: value = %p, bool_value = %p",
        -:  248:            value, bool_value);
    #####:  249:        result = MU_FAILURE;
        -:  250:    }
        -:  251:    else
        -:  252:    {
    #####:  253:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  254:        /* Codes_SRS_AMQPVALUE_01_011: [If the type of the value is not Boolean, then amqpvalue_get_boolean shall return a non-zero value.] */
    #####:  255:        if (value_data->type != AMQP_TYPE_BOOL)
        -:  256:        {
    #####:  257:            LogError("Value is not of type bool");
    #####:  258:            result = MU_FAILURE;
        -:  259:        }
        -:  260:        else
        -:  261:        {
        -:  262:            /* Codes_SRS_AMQPVALUE_01_008: [amqpvalue_get_boolean shall fill in the bool_value argument the Boolean value stored by the AMQP value indicated by the value argument.] */
    #####:  263:            *bool_value = value_data->value.bool_value;
        -:  264:
        -:  265:            /* Codes_SRS_AMQPVALUE_01_010: [On success amqpvalue_get_boolean shall return 0.] */
    #####:  266:            result = 0;
        -:  267:        }
        -:  268:    }
        -:  269:
    #####:  270:    return result;
        -:  271:}
        -:  272:
        -:  273:/* Codes_SRS_AMQPVALUE_01_005: [1.6.3 ubyte Integer in the range 0 to 28 - 1 inclusive.] */
    #####:  274:AMQP_VALUE amqpvalue_create_ubyte(unsigned char value)
        -:  275:{
    #####:  276:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  277:    if (result != NULL)
        -:  278:    {
        -:  279:        /* Codes_SRS_AMQPVALUE_01_032: [amqpvalue_create_ubyte shall return a handle to an AMQP_VALUE that stores a unsigned char value.] */
    #####:  280:        result->type = AMQP_TYPE_UBYTE;
    #####:  281:        result->value.ubyte_value = value;
        -:  282:    }
        -:  283:
    #####:  284:    return result;
        -:  285:}
        -:  286:
    #####:  287:int amqpvalue_get_ubyte(AMQP_VALUE value, unsigned char* ubyte_value)
        -:  288:{
        -:  289:    int result;
        -:  290:
        -:  291:    /* Codes_SRS_AMQPVALUE_01_036: [If any of the arguments is NULL then amqpvalue_get_ubyte shall return a non-zero value.] */
    #####:  292:    if ((value == NULL) ||
        -:  293:        (ubyte_value == NULL))
        -:  294:    {
    #####:  295:        LogError("Bad arguments: value = %p, ubyte_value = %p",
        -:  296:            value, ubyte_value);
    #####:  297:        result = MU_FAILURE;
        -:  298:    }
        -:  299:    else
        -:  300:    {
    #####:  301:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  302:        /* Codes_SRS_AMQPVALUE_01_037: [If the type of the value is not ubyte (was not created with amqpvalue_create_ubyte), then amqpvalue_get_ubyte shall return a non-zero value.] */
    #####:  303:        if (value_data->type != AMQP_TYPE_UBYTE)
        -:  304:        {
    #####:  305:            LogError("Value is not of type UBYTE");
    #####:  306:            result = MU_FAILURE;
        -:  307:        }
        -:  308:        else
        -:  309:        {
        -:  310:            /* Codes_SRS_AMQPVALUE_01_034: [amqpvalue_get_ubyte shall fill in the ubyte_value argument the unsigned char value stored by the AMQP value indicated by the value argument.] */
    #####:  311:            *ubyte_value = value_data->value.ubyte_value;
        -:  312:
        -:  313:            /* Codes_SRS_AMQPVALUE_01_035: [On success amqpvalue_get_ubyte shall return 0.] */
    #####:  314:            result = 0;
        -:  315:        }
        -:  316:    }
        -:  317:
    #####:  318:    return result;
        -:  319:}
        -:  320:
        -:  321:/* Codes_SRS_AMQPVALUE_01_012: [1.6.4 ushort Integer in the range 0 to 216 - 1 inclusive.] */
    #####:  322:AMQP_VALUE amqpvalue_create_ushort(uint16_t value)
        -:  323:{
    #####:  324:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  325:    if (result == NULL)
        -:  326:    {
        -:  327:        /* Codes_SRS_AMQPVALUE_01_039: [If allocating the AMQP_VALUE fails then amqpvalue_create_ushort shall return NULL.] */
    #####:  328:        LogError("Could not allocate memory for AMQP value");
        -:  329:    }
        -:  330:    else
        -:  331:    {
        -:  332:        /* Codes_SRS_AMQPVALUE_01_038: [amqpvalue_create_ushort shall return a handle to an AMQP_VALUE that stores an uint16_t value.] */
    #####:  333:        result->type = AMQP_TYPE_USHORT;
    #####:  334:        result->value.ushort_value = value;
        -:  335:    }
        -:  336:
    #####:  337:    return result;
        -:  338:}
        -:  339:
    #####:  340:int amqpvalue_get_ushort(AMQP_VALUE value, uint16_t* ushort_value)
        -:  341:{
        -:  342:    int result;
        -:  343:
        -:  344:    /* Codes_SRS_AMQPVALUE_01_042: [If any of the arguments is NULL then amqpvalue_get_ushort shall return a non-zero value.] */
    #####:  345:    if ((value == NULL) ||
        -:  346:        (ushort_value == NULL))
        -:  347:    {
    #####:  348:        LogError("Bad arguments: value = %p, ushort_value = %p",
        -:  349:            value, ushort_value);
    #####:  350:        result = MU_FAILURE;
        -:  351:    }
        -:  352:    else
        -:  353:    {
    #####:  354:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  355:        /* Codes_SRS_AMQPVALUE_01_043: [If the type of the value is not ushort (was not created with amqpvalue_create_ushort), then amqpvalue_get_ushort shall return a non-zero value.] */
    #####:  356:        if (value_data->type != AMQP_TYPE_USHORT)
        -:  357:        {
    #####:  358:            LogError("Value is not of type USHORT");
    #####:  359:            result = MU_FAILURE;
        -:  360:        }
        -:  361:        else
        -:  362:        {
        -:  363:            /* Codes_SRS_AMQPVALUE_01_040: [amqpvalue_get_ushort shall fill in the ushort_value argument the uint16_t value stored by the AMQP value indicated by the value argument.] */
    #####:  364:            *ushort_value = value_data->value.ushort_value;
        -:  365:
        -:  366:            /* Codes_SRS_AMQPVALUE_01_041: [On success amqpvalue_get_ushort shall return 0.] */
    #####:  367:            result = 0;
        -:  368:        }
        -:  369:    }
        -:  370:
    #####:  371:    return result;
        -:  372:}
        -:  373:
        -:  374:/* Codes_SRS_AMQPVALUE_01_013: [1.6.5 uint Integer in the range 0 to 232 - 1 inclusive.] */
    #####:  375:AMQP_VALUE amqpvalue_create_uint(uint32_t value)
        -:  376:{
    #####:  377:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  378:    if (result == NULL)
        -:  379:    {
        -:  380:        /* Codes_SRS_AMQPVALUE_01_045: [If allocating the AMQP_VALUE fails then amqpvalue_create_uint shall return NULL.] */
    #####:  381:        LogError("Could not allocate memory for AMQP value");
        -:  382:    }
        -:  383:    else
        -:  384:    {
        -:  385:        /* Codes_SRS_AMQPVALUE_01_044: [amqpvalue_create_uint shall return a handle to an AMQP_VALUE that stores an uint32_t value.] */
    #####:  386:        result->type = AMQP_TYPE_UINT;
    #####:  387:        result->value.uint_value = value;
        -:  388:    }
        -:  389:
    #####:  390:    return result;
        -:  391:}
        -:  392:
    #####:  393:int amqpvalue_get_uint(AMQP_VALUE value, uint32_t* uint_value)
        -:  394:{
        -:  395:    int result;
        -:  396:
        -:  397:    /* Codes_SRS_AMQPVALUE_01_079: [If any of the arguments is NULL then amqpvalue_get_uint shall return a non-zero value.] */
    #####:  398:    if ((value == NULL) ||
        -:  399:        (uint_value == NULL))
        -:  400:    {
    #####:  401:        LogError("Bad arguments: value = %p, uint_value = %p",
        -:  402:            value, uint_value);
    #####:  403:        result = MU_FAILURE;
        -:  404:    }
        -:  405:    else
        -:  406:    {
    #####:  407:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  408:        /* Codes_SRS_AMQPVALUE_01_048: [If the type of the value is not uint (was not created with amqpvalue_create_uint), then amqpvalue_get_uint shall return a non-zero value.] */
    #####:  409:        if (value_data->type != AMQP_TYPE_UINT)
        -:  410:        {
    #####:  411:            LogError("Value is not of type UINT");
    #####:  412:            result = MU_FAILURE;
        -:  413:        }
        -:  414:        else
        -:  415:        {
        -:  416:            /* Codes_SRS_AMQPVALUE_01_046: [amqpvalue_get_uint shall fill in the uint_value argument the uint32_t value stored by the AMQP value indicated by the value argument.] */
    #####:  417:            *uint_value = value_data->value.uint_value;
        -:  418:
        -:  419:            /* Codes_SRS_AMQPVALUE_01_047: [On success amqpvalue_get_uint shall return 0.] */
    #####:  420:            result = 0;
        -:  421:        }
        -:  422:    }
        -:  423:
    #####:  424:    return result;
        -:  425:}
        -:  426:
        -:  427:/* Codes_SRS_AMQPVALUE_01_014: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */
       18:  428:AMQP_VALUE amqpvalue_create_ulong(uint64_t value)
        -:  429:{
       18:  430:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
       18:  431:    if (result == NULL)
        -:  432:    {
        -:  433:        /* Codes_SRS_AMQPVALUE_01_050: [If allocating the AMQP_VALUE fails then amqpvalue_create_ulong shall return NULL.] */
    #####:  434:        LogError("Could not allocate memory for AMQP value");
        -:  435:    }
        -:  436:    else
        -:  437:    {
        -:  438:        /* Codes_SRS_AMQPVALUE_01_049: [amqpvalue_create_ulong shall return a handle to an AMQP_VALUE that stores an uint64_t value.] */
       18:  439:        result->type = AMQP_TYPE_ULONG;
       18:  440:        result->value.ulong_value = value;
        -:  441:    }
        -:  442:
       18:  443:    return result;
        -:  444:}
        -:  445:
    #####:  446:int amqpvalue_get_ulong(AMQP_VALUE value, uint64_t* ulong_value)
        -:  447:{
        -:  448:    int result;
        -:  449:
        -:  450:    /* Codes_SRS_AMQPVALUE_01_053: [If any of the arguments is NULL then amqpvalue_get_ulong shall return a non-zero value.] */
    #####:  451:    if ((value == NULL) ||
        -:  452:        (ulong_value == NULL))
        -:  453:    {
    #####:  454:        LogError("Bad arguments: value = %p, ulong_value = %p",
        -:  455:            value, ulong_value);
    #####:  456:        result = MU_FAILURE;
        -:  457:    }
        -:  458:    else
        -:  459:    {
    #####:  460:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  461:        /* Codes_SRS_AMQPVALUE_01_054: [If the type of the value is not ulong (was not created with amqpvalue_create_ulong), then amqpvalue_get_ulong shall return a non-zero value.] */
    #####:  462:        if (value_data->type != AMQP_TYPE_ULONG)
        -:  463:        {
    #####:  464:            LogError("Value is not of type ULONG");
    #####:  465:            result = MU_FAILURE;
        -:  466:        }
        -:  467:        else
        -:  468:        {
        -:  469:            /* Codes_SRS_AMQPVALUE_01_051: [amqpvalue_get_ulong shall fill in the ulong_value argument the ulong64_t value stored by the AMQP value indicated by the value argument.] */
    #####:  470:            *ulong_value = value_data->value.ulong_value;
        -:  471:
        -:  472:            /* Codes_SRS_AMQPVALUE_01_052: [On success amqpvalue_get_ulong shall return 0.] */
    #####:  473:            result = 0;
        -:  474:        }
        -:  475:    }
        -:  476:
    #####:  477:    return result;
        -:  478:}
        -:  479:
        -:  480:/* Codes_SRS_AMQPVALUE_01_015: [1.6.7 byte Integer in the range -(27) to 27 - 1 inclusive.] */
    #####:  481:AMQP_VALUE amqpvalue_create_byte(char value)
        -:  482:{
    #####:  483:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  484:    if (result == NULL)
        -:  485:    {
        -:  486:        /* Codes_SRS_AMQPVALUE_01_056: [If allocating the AMQP_VALUE fails then amqpvalue_create_byte shall return NULL.] */
    #####:  487:        LogError("Could not allocate memory for AMQP value");
        -:  488:    }
        -:  489:    else
        -:  490:    {
        -:  491:        /* Codes_SRS_AMQPVALUE_01_055: [amqpvalue_create_byte shall return a handle to an AMQP_VALUE that stores a char value.] */
    #####:  492:        result->type = AMQP_TYPE_BYTE;
    #####:  493:        result->value.byte_value = value;
        -:  494:    }
        -:  495:
    #####:  496:    return result;
        -:  497:}
        -:  498:
    #####:  499:int amqpvalue_get_byte(AMQP_VALUE value, char* byte_value)
        -:  500:{
        -:  501:    int result;
        -:  502:
        -:  503:    /* Codes_SRS_AMQPVALUE_01_059: [If any of the arguments is NULL then amqpvalue_get_byte shall return a non-zero value.] */
    #####:  504:    if ((value == NULL) ||
        -:  505:        (byte_value == NULL))
        -:  506:    {
    #####:  507:        LogError("Bad arguments: value = %p, byte_value = %p",
        -:  508:            value, byte_value);
    #####:  509:        result = MU_FAILURE;
        -:  510:    }
        -:  511:    else
        -:  512:    {
    #####:  513:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  514:        /* Codes_SRS_AMQPVALUE_01_060: [If the type of the value is not byte (was not created with amqpvalue_create_byte), then amqpvalue_get_byte shall return a non-zero value.] */
    #####:  515:        if (value_data->type != AMQP_TYPE_BYTE)
        -:  516:        {
    #####:  517:            LogError("Value is not of type BYTE");
    #####:  518:            result = MU_FAILURE;
        -:  519:        }
        -:  520:        else
        -:  521:        {
        -:  522:            /* Codes_SRS_AMQPVALUE_01_057: [amqpvalue_get_byte shall fill in the byte_value argument the char value stored by the AMQP value indicated by the value argument.] */
    #####:  523:            *byte_value = value_data->value.byte_value;
        -:  524:
        -:  525:            /* Codes_SRS_AMQPVALUE_01_058: [On success amqpvalue_get_byte shall return 0.] */
    #####:  526:            result = 0;
        -:  527:        }
        -:  528:    }
        -:  529:
    #####:  530:    return result;
        -:  531:}
        -:  532:
        -:  533:/* Codes_SRS_AMQPVALUE_01_016: [1.6.8 short Integer in the range -(215) to 215 - 1 inclusive.] */
    #####:  534:AMQP_VALUE amqpvalue_create_short(int16_t value)
        -:  535:{
    #####:  536:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  537:    if (result == NULL)
        -:  538:    {
        -:  539:        /* Codes_SRS_AMQPVALUE_01_062: [If allocating the AMQP_VALUE fails then amqpvalue_create_short shall return NULL.] */
    #####:  540:        LogError("Could not allocate memory for AMQP value");
        -:  541:    }
        -:  542:    else
        -:  543:    {
        -:  544:        /* Codes_SRS_AMQPVALUE_01_061: [amqpvalue_create_short shall return a handle to an AMQP_VALUE that stores an int16_t value.] */
    #####:  545:        result->type = AMQP_TYPE_SHORT;
    #####:  546:        result->value.short_value = value;
        -:  547:    }
    #####:  548:    return result;
        -:  549:}
        -:  550:
    #####:  551:int amqpvalue_get_short(AMQP_VALUE value, int16_t* short_value)
        -:  552:{
        -:  553:    int result;
        -:  554:
        -:  555:    /* Codes_SRS_AMQPVALUE_01_065: [If any of the arguments is NULL then amqpvalue_get_short shall return a non-zero value.] */
    #####:  556:    if ((value == NULL) ||
        -:  557:        (short_value == NULL))
        -:  558:    {
    #####:  559:        LogError("Bad arguments: value = %p, short_value = %p",
        -:  560:            value, short_value);
    #####:  561:        result = MU_FAILURE;
        -:  562:    }
        -:  563:    else
        -:  564:    {
    #####:  565:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  566:        /* Codes_SRS_AMQPVALUE_01_066: [If the type of the value is not short (was not created with amqpvalue_create_short), then amqpvalue_get_short shall return a non-zero value.] */
    #####:  567:        if (value_data->type != AMQP_TYPE_SHORT)
        -:  568:        {
    #####:  569:            LogError("Value is not of type SHORT");
    #####:  570:            result = MU_FAILURE;
        -:  571:        }
        -:  572:        else
        -:  573:        {
        -:  574:            /* Codes_SRS_AMQPVALUE_01_063: [amqpvalue_get_short shall fill in the short_value argument the int16_t value stored by the AMQP value indicated by the value argument.] */
    #####:  575:            *short_value = value_data->value.short_value;
        -:  576:
        -:  577:            /* Codes_SRS_AMQPVALUE_01_064: [On success amqpvalue_get_short shall return 0.] */
    #####:  578:            result = 0;
        -:  579:        }
        -:  580:    }
        -:  581:
    #####:  582:    return result;
        -:  583:}
        -:  584:
        -:  585:/* Codes_SRS_AMQPVALUE_01_017: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */
    #####:  586:AMQP_VALUE amqpvalue_create_int(int32_t value)
        -:  587:{
    #####:  588:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  589:    if (result == NULL)
        -:  590:    {
        -:  591:        /* Codes_SRS_AMQPVALUE_01_068: [If allocating the AMQP_VALUE fails then amqpvalue_create_int shall return NULL.] */
    #####:  592:        LogError("Could not allocate memory for AMQP value");
        -:  593:    }
        -:  594:    else
        -:  595:    {
        -:  596:        /* Codes_SRS_AMQPVALUE_01_067: [amqpvalue_create_int shall return a handle to an AMQP_VALUE that stores an int32_t value.] */
    #####:  597:        result->type = AMQP_TYPE_INT;
    #####:  598:        result->value.int_value = value;
        -:  599:    }
        -:  600:
    #####:  601:    return result;
        -:  602:}
        -:  603:
    #####:  604:int amqpvalue_get_int(AMQP_VALUE value, int32_t* int_value)
        -:  605:{
        -:  606:    int result;
        -:  607:
        -:  608:    /* Codes_SRS_AMQPVALUE_01_071: [If any of the arguments is NULL then amqpvalue_get_int shall return a non-zero value.] */
    #####:  609:    if ((value == NULL) ||
        -:  610:        (int_value == NULL))
        -:  611:    {
    #####:  612:        LogError("Bad arguments: value = %p, int_value = %p",
        -:  613:            value, int_value);
    #####:  614:        result = MU_FAILURE;
        -:  615:    }
        -:  616:    else
        -:  617:    {
    #####:  618:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  619:        /* Codes_SRS_AMQPVALUE_01_072: [If the type of the value is not int (was not created with amqpvalue_create_int), then amqpvalue_get_int shall return a non-zero value.] */
    #####:  620:        if (value_data->type != AMQP_TYPE_INT)
        -:  621:        {
    #####:  622:            LogError("Value is not of type INT");
    #####:  623:            result = MU_FAILURE;
        -:  624:        }
        -:  625:        else
        -:  626:        {
        -:  627:            /* Codes_SRS_AMQPVALUE_01_069: [amqpvalue_get_int shall fill in the int_value argument the int32_t value stored by the AMQP value indicated by the value argument.] */
    #####:  628:            *int_value = value_data->value.int_value;
        -:  629:
        -:  630:            /* Codes_SRS_AMQPVALUE_01_070: [On success amqpvalue_get_int shall return 0.] */
    #####:  631:            result = 0;
        -:  632:        }
        -:  633:    }
        -:  634:
    #####:  635:    return result;
        -:  636:}
        -:  637:
        -:  638:/* Codes_SRS_AMQPVALUE_01_018: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */
    #####:  639:AMQP_VALUE amqpvalue_create_long(int64_t value)
        -:  640:{
    #####:  641:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  642:    if (result == NULL)
        -:  643:    {
        -:  644:        /* Codes_SRS_AMQPVALUE_01_074: [If allocating the AMQP_VALUE fails then amqpvalue_create_long shall return NULL.] */
    #####:  645:        LogError("Could not allocate memory for AMQP value");
        -:  646:    }
        -:  647:    else
        -:  648:    {
        -:  649:        /* Codes_SRS_AMQPVALUE_01_073: [amqpvalue_create_long shall return a handle to an AMQP_VALUE that stores an int64_t value.] */
    #####:  650:        result->type = AMQP_TYPE_LONG;
    #####:  651:        result->value.long_value = value;
        -:  652:    }
        -:  653:
    #####:  654:    return result;
        -:  655:}
        -:  656:
    #####:  657:int amqpvalue_get_long(AMQP_VALUE value, int64_t* long_value)
        -:  658:{
        -:  659:    int result;
        -:  660:
        -:  661:    /* Codes_SRS_AMQPVALUE_01_077: [If any of the arguments is NULL then amqpvalue_get_long shall return a non-zero value.] */
    #####:  662:    if ((value == NULL) ||
        -:  663:        (long_value == NULL))
        -:  664:    {
    #####:  665:        LogError("Bad arguments: value = %p, long_value = %p",
        -:  666:            value, long_value);
    #####:  667:        result = MU_FAILURE;
        -:  668:    }
        -:  669:    else
        -:  670:    {
    #####:  671:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  672:        /* Codes_SRS_AMQPVALUE_01_078: [If the type of the value is not long (was not created with amqpvalue_create_long), then amqpvalue_get_long shall return a non-zero value.] */
    #####:  673:        if (value_data->type != AMQP_TYPE_LONG)
        -:  674:        {
    #####:  675:            LogError("Value is not of type LONG");
    #####:  676:            result = MU_FAILURE;
        -:  677:        }
        -:  678:        else
        -:  679:        {
        -:  680:            /* Codes_SRS_AMQPVALUE_01_075: [amqpvalue_get_long shall fill in the long_value argument the int64_t value stored by the AMQP value indicated by the value argument.] */
    #####:  681:            *long_value = value_data->value.long_value;
        -:  682:
        -:  683:            /* Codes_SRS_AMQPVALUE_01_076: [On success amqpvalue_get_long shall return 0.] */
    #####:  684:            result = 0;
        -:  685:        }
        -:  686:    }
        -:  687:
    #####:  688:    return result;
        -:  689:}
        -:  690:
        -:  691:/* Codes_SRS_AMQPVALUE_01_019: [1.6.11 float 32-bit floating point number (IEEE 754-2008 binary32).]  */
    #####:  692:AMQP_VALUE amqpvalue_create_float(float value)
        -:  693:{
    #####:  694:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  695:    if (result == NULL)
        -:  696:    {
        -:  697:        /* Codes_SRS_AMQPVALUE_01_081: [If allocating the AMQP_VALUE fails then amqpvalue_create_float shall return NULL.] */
    #####:  698:        LogError("Could not allocate memory for AMQP value");
        -:  699:    }
        -:  700:    else
        -:  701:    {
        -:  702:        /* Codes_SRS_AMQPVALUE_01_080: [amqpvalue_create_float shall return a handle to an AMQP_VALUE that stores a float value.] */
    #####:  703:        result->type = AMQP_TYPE_FLOAT;
    #####:  704:        result->value.float_value = value;
        -:  705:    }
        -:  706:
    #####:  707:    return result;
        -:  708:}
        -:  709:
    #####:  710:int amqpvalue_get_float(AMQP_VALUE value, float* float_value)
        -:  711:{
        -:  712:    int result;
        -:  713:
        -:  714:    /* Codes_SRS_AMQPVALUE_01_084: [If any of the arguments is NULL then amqpvalue_get_float shall return a non-zero value.] */
    #####:  715:    if ((value == NULL) ||
        -:  716:        (float_value == NULL))
        -:  717:    {
    #####:  718:        LogError("Bad arguments: value = %p, float_value = %p",
        -:  719:            value, float_value);
    #####:  720:        result = MU_FAILURE;
        -:  721:    }
        -:  722:    else
        -:  723:    {
    #####:  724:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  725:        /* Codes_SRS_AMQPVALUE_01_085: [If the type of the value is not float (was not created with amqpvalue_create_float), then amqpvalue_get_float shall return a non-zero value.] */
    #####:  726:        if (value_data->type != AMQP_TYPE_FLOAT)
        -:  727:        {
    #####:  728:            LogError("Value is not of type FLOAT");
    #####:  729:            result = MU_FAILURE;
        -:  730:        }
        -:  731:        else
        -:  732:        {
        -:  733:            /* Codes_SRS_AMQPVALUE_01_082: [amqpvalue_get_float shall fill in the float_value argument the float value stored by the AMQP value indicated by the value argument.] */
    #####:  734:            *float_value = value_data->value.float_value;
        -:  735:
        -:  736:            /* Codes_SRS_AMQPVALUE_01_083: [On success amqpvalue_get_float shall return 0.] */
    #####:  737:            result = 0;
        -:  738:        }
        -:  739:    }
        -:  740:
    #####:  741:    return result;
        -:  742:}
        -:  743:
        -:  744:/* Codes_SRS_AMQPVALUE_01_020: [1.6.12 double 64-bit floating point number (IEEE 754-2008 binary64).] */
    #####:  745:AMQP_VALUE amqpvalue_create_double(double value)
        -:  746:{
    #####:  747:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  748:    if (result == NULL)
        -:  749:    {
        -:  750:        /* Codes_SRS_AMQPVALUE_01_087: [If allocating the AMQP_VALUE fails then amqpvalue_create_double shall return NULL.] */
    #####:  751:        LogError("Could not allocate memory for AMQP value");
        -:  752:    }
        -:  753:    else
        -:  754:    {
        -:  755:        /* Codes_SRS_AMQPVALUE_01_086: [amqpvalue_create_double shall return a handle to an AMQP_VALUE that stores a double value.] */
    #####:  756:        result->type = AMQP_TYPE_DOUBLE;
    #####:  757:        result->value.double_value = value;
        -:  758:    }
        -:  759:
    #####:  760:    return result;
        -:  761:}
        -:  762:
    #####:  763:int amqpvalue_get_double(AMQP_VALUE value, double* double_value)
        -:  764:{
        -:  765:    int result;
        -:  766:
        -:  767:    /* Codes_SRS_AMQPVALUE_01_090: [If any of the arguments is NULL then amqpvalue_get_double shall return a non-zero value.] */
    #####:  768:    if ((value == NULL) ||
        -:  769:        (double_value == NULL))
        -:  770:    {
    #####:  771:        LogError("Bad arguments: value = %p, double_value = %p",
        -:  772:            value, double_value);
    #####:  773:        result = MU_FAILURE;
        -:  774:    }
        -:  775:    else
        -:  776:    {
    #####:  777:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  778:        /* Codes_SRS_AMQPVALUE_01_091: [If the type of the value is not double (was not created with amqpvalue_create_double), then amqpvalue_get_double shall return a non-zero value.] */
    #####:  779:        if (value_data->type != AMQP_TYPE_DOUBLE)
        -:  780:        {
    #####:  781:            LogError("Value is not of type DOUBLE");
    #####:  782:            result = MU_FAILURE;
        -:  783:        }
        -:  784:        else
        -:  785:        {
        -:  786:            /* Codes_SRS_AMQPVALUE_01_088: [amqpvalue_get_double shall fill in the double_value argument the double value stored by the AMQP value indicated by the value argument.] */
    #####:  787:            *double_value = value_data->value.double_value;
        -:  788:
        -:  789:            /* Codes_SRS_AMQPVALUE_01_089: [On success amqpvalue_get_double shall return 0.] */
    #####:  790:            result = 0;
        -:  791:        }
        -:  792:    }
        -:  793:
    #####:  794:    return result;
        -:  795:}
        -:  796:
        -:  797:/* Codes_SRS_AMQPVALUE_01_024: [1.6.16 char A single Unicode character.] */
    #####:  798:AMQP_VALUE amqpvalue_create_char(uint32_t value)
        -:  799:{
        -:  800:    AMQP_VALUE result;
        -:  801:
        -:  802:    /* Codes_SRS_AMQPVALUE_01_098: [If the code point value is outside of the allowed range [0, 0x10FFFF] then amqpvalue_create_char shall return NULL.] */
    #####:  803:    if (value > 0x10FFFF)
        -:  804:    {
    #####:  805:        LogError("Invalid value for a Unicode char");
    #####:  806:        result = NULL;
        -:  807:    }
        -:  808:    else
        -:  809:    {
    #####:  810:        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  811:        if (result == NULL)
        -:  812:        {
        -:  813:            /* Codes_SRS_AMQPVALUE_01_093: [If allocating the AMQP_VALUE fails then amqpvalue_create_char shall return NULL.] */
    #####:  814:            LogError("Could not allocate memory for AMQP value");
        -:  815:        }
        -:  816:        else
        -:  817:        {
        -:  818:            /* Codes_SRS_AMQPVALUE_01_092: [amqpvalue_create_char shall return a handle to an AMQP_VALUE that stores a single UTF-32 character value.] */
    #####:  819:            result->type = AMQP_TYPE_CHAR;
    #####:  820:            result->value.char_value = value;
        -:  821:        }
        -:  822:    }
        -:  823:
    #####:  824:    return result;
        -:  825:}
        -:  826:
    #####:  827:int amqpvalue_get_char(AMQP_VALUE value, uint32_t* char_value)
        -:  828:{
        -:  829:    int result;
        -:  830:
        -:  831:    /* Codes_SRS_AMQPVALUE_01_096: [If any of the arguments is NULL then amqpvalue_get_char shall return a non-zero value.] */
    #####:  832:    if ((value == NULL) ||
        -:  833:        (char_value == NULL))
        -:  834:    {
    #####:  835:        LogError("Bad arguments: value = %p, double_value = %p",
        -:  836:            value, char_value);
    #####:  837:        result = MU_FAILURE;
        -:  838:    }
        -:  839:    else
        -:  840:    {
    #####:  841:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  842:        /* Codes_SRS_AMQPVALUE_01_097: [If the type of the value is not char (was not created with amqpvalue_create_char), then amqpvalue_get_char shall return a non-zero value.] */
    #####:  843:        if (value_data->type != AMQP_TYPE_CHAR)
        -:  844:        {
    #####:  845:            LogError("Value is not of type CHAR");
    #####:  846:            result = MU_FAILURE;
        -:  847:        }
        -:  848:        else
        -:  849:        {
        -:  850:            /* Codes_SRS_AMQPVALUE_01_094: [amqpvalue_get_char shall fill in the char_value argument the UTF32 char value stored by the AMQP value indicated by the value argument.] */
    #####:  851:            *char_value = value_data->value.char_value;
        -:  852:
        -:  853:            /* Codes_SRS_AMQPVALUE_01_095: [On success amqpvalue_get_char shall return 0.] */
    #####:  854:            result = 0;
        -:  855:        }
        -:  856:    }
        -:  857:
    #####:  858:    return result;
        -:  859:}
        -:  860:
        -:  861:/* Codes_SRS_AMQPVALUE_01_025: [1.6.17 timestamp An absolute point in time.] */
    #####:  862:AMQP_VALUE amqpvalue_create_timestamp(int64_t value)
        -:  863:{
    #####:  864:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  865:    if (result == NULL)
        -:  866:    {
        -:  867:        /* Codes_SRS_AMQPVALUE_01_108: [If allocating the AMQP_VALUE fails then amqpvalue_create_timestamp shall return NULL.] */
    #####:  868:        LogError("Could not allocate memory for AMQP value");
        -:  869:    }
        -:  870:    else
        -:  871:    {
        -:  872:        /* Codes_SRS_AMQPVALUE_01_107: [amqpvalue_create_timestamp shall return a handle to an AMQP_VALUE that stores an uint64_t value that represents a millisecond precision Unix time.] */
    #####:  873:        result->type = AMQP_TYPE_TIMESTAMP;
    #####:  874:        result->value.timestamp_value = value;
        -:  875:    }
        -:  876:
    #####:  877:    return result;
        -:  878:}
        -:  879:
    #####:  880:int amqpvalue_get_timestamp(AMQP_VALUE value, int64_t* timestamp_value)
        -:  881:{
        -:  882:    int result;
        -:  883:
        -:  884:    /* Codes_SRS_AMQPVALUE_01_111: [If any of the arguments is NULL then amqpvalue_get_timestamp shall return a non-zero value.] */
    #####:  885:    if ((value == NULL) ||
        -:  886:        (timestamp_value == NULL))
        -:  887:    {
    #####:  888:        LogError("Bad arguments: value = %p, timestamp_value = %p",
        -:  889:            value, timestamp_value);
    #####:  890:        result = MU_FAILURE;
        -:  891:    }
        -:  892:    else
        -:  893:    {
    #####:  894:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  895:        /* Codes_SRS_AMQPVALUE_01_112: [If the type of the value is not timestamp (was not created with amqpvalue_create_timestamp), then amqpvalue_get_timestamp shall return a non-zero value.] */
    #####:  896:        if (value_data->type != AMQP_TYPE_TIMESTAMP)
        -:  897:        {
    #####:  898:            LogError("Value is not of type TIMESTAMP");
    #####:  899:            result = MU_FAILURE;
        -:  900:        }
        -:  901:        else
        -:  902:        {
        -:  903:            /* Codes_SRS_AMQPVALUE_01_109: [amqpvalue_get_timestamp shall fill in the timestamp_value argument the timestamp value stored by the AMQP value indicated by the value argument.] */
    #####:  904:            *timestamp_value = value_data->value.timestamp_value;
        -:  905:
        -:  906:            /* Codes_SRS_AMQPVALUE_01_110: [On success amqpvalue_get_timestamp shall return 0.] */
    #####:  907:            result = 0;
        -:  908:        }
        -:  909:    }
        -:  910:
    #####:  911:    return result;
        -:  912:}
        -:  913:
        -:  914:/* Codes_SRS_AMQPVALUE_01_026: [1.6.18 uuid A universally unique identifier as defined by RFC-4122 section 4.1.2 .] */
    #####:  915:AMQP_VALUE amqpvalue_create_uuid(uuid value)
        -:  916:{
    #####:  917:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  918:    if (result == NULL)
        -:  919:    {
        -:  920:        /* Codes_SRS_AMQPVALUE_01_114: [If allocating the AMQP_VALUE fails then amqpvalue_create_uuid shall return NULL.] */
    #####:  921:        LogError("Could not allocate memory for AMQP value");
        -:  922:    }
        -:  923:    else
        -:  924:    {
        -:  925:        /* Codes_SRS_AMQPVALUE_01_113: [amqpvalue_create_uuid shall return a handle to an AMQP_VALUE that stores an uuid value that represents a unique identifier per RFC-4122 section 4.1.2.] */
    #####:  926:        result->type = AMQP_TYPE_UUID;
    #####:  927:        (void)memcpy(&result->value.uuid_value, value, 16);
        -:  928:    }
        -:  929:
    #####:  930:    return result;
        -:  931:}
        -:  932:
    #####:  933:int amqpvalue_get_uuid(AMQP_VALUE value, uuid* uuid_value)
        -:  934:{
        -:  935:    int result;
        -:  936:
        -:  937:    /* Codes_SRS_AMQPVALUE_01_117: [If any of the arguments is NULL then amqpvalue_get_uuid shall return a non-zero value.] */
    #####:  938:    if ((value == NULL) ||
        -:  939:        (uuid_value == NULL))
        -:  940:    {
    #####:  941:        LogError("Bad arguments: value = %p, uuid_value = %p",
        -:  942:            value, uuid_value);
    #####:  943:        result = MU_FAILURE;
        -:  944:    }
        -:  945:    else
        -:  946:    {
    #####:  947:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -:  948:        /* Codes_SRS_AMQPVALUE_01_118: [If the type of the value is not uuid (was not created with amqpvalue_create_uuid), then amqpvalue_get_uuid shall return a non-zero value.] */
    #####:  949:        if (value_data->type != AMQP_TYPE_UUID)
        -:  950:        {
    #####:  951:            LogError("Value is not of type UUID");
    #####:  952:            result = MU_FAILURE;
        -:  953:        }
        -:  954:        else
        -:  955:        {
        -:  956:            /* Codes_SRS_AMQPVALUE_01_115: [amqpvalue_get_uuid shall fill in the uuid_value argument the uuid value stored by the AMQP value indicated by the value argument.] */
    #####:  957:            (void)memcpy(*uuid_value, value_data->value.uuid_value, 16);
        -:  958:
        -:  959:            /* Codes_SRS_AMQPVALUE_01_116: [On success amqpvalue_get_uuid shall return 0.] */
    #####:  960:            result = 0;
        -:  961:        }
        -:  962:    }
        -:  963:
    #####:  964:    return result;
        -:  965:}
        -:  966:
        -:  967:/* Codes_SRS_AMQPVALUE_01_027: [1.6.19 binary A sequence of octets.] */
    #####:  968:AMQP_VALUE amqpvalue_create_binary(amqp_binary value)
        -:  969:{
        -:  970:    AMQP_VALUE result;
    #####:  971:    if ((value.bytes == NULL) &&
    #####:  972:        (value.length > 0))
        -:  973:    {
        -:  974:        /* Codes_SRS_AMQPVALUE_01_129: [If value.data is NULL and value.length is positive then amqpvalue_create_binary shall return NULL.] */
    #####:  975:        LogError("NULL bytes with non-zero length");
    #####:  976:        result = NULL;
        -:  977:    }
        -:  978:    else
        -:  979:    {
    #####:  980:        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####:  981:        if (result == NULL)
        -:  982:        {
        -:  983:            /* Codes_SRS_AMQPVALUE_01_128: [If allocating the AMQP_VALUE fails then amqpvalue_create_binary shall return NULL.] */
    #####:  984:            LogError("Could not allocate memory for AMQP value");
        -:  985:        }
        -:  986:        else
        -:  987:        {
        -:  988:            /* Codes_SRS_AMQPVALUE_01_127: [amqpvalue_create_binary shall return a handle to an AMQP_VALUE that stores a sequence of bytes.] */
    #####:  989:            result->type = AMQP_TYPE_BINARY;
    #####:  990:            if (value.length > 0)
        -:  991:            {
    #####:  992:                result->value.binary_value.bytes = malloc(value.length);
        -:  993:            }
        -:  994:            else
        -:  995:            {
    #####:  996:                result->value.binary_value.bytes = NULL;
        -:  997:            }
        -:  998:
    #####:  999:            result->value.binary_value.length = value.length;
        -: 1000:
    #####: 1001:            if ((result->value.binary_value.bytes == NULL) && (value.length > 0))
        -: 1002:            {
        -: 1003:                /* Codes_SRS_AMQPVALUE_01_128: [If allocating the AMQP_VALUE fails then amqpvalue_create_binary shall return NULL.] */
    #####: 1004:                LogError("Could not allocate memory for binary payload of AMQP value");
    #####: 1005:                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 1006:                result = NULL;
        -: 1007:            }
        -: 1008:            else
        -: 1009:            {
    #####: 1010:                if (value.length > 0)
        -: 1011:                {
    #####: 1012:                    (void)memcpy((void*)result->value.binary_value.bytes, value.bytes, value.length);
        -: 1013:                }
        -: 1014:            }
        -: 1015:        }
        -: 1016:    }
        -: 1017:
    #####: 1018:    return result;
        -: 1019:}
        -: 1020:
    #####: 1021:int amqpvalue_get_binary(AMQP_VALUE value, amqp_binary* binary_value)
        -: 1022:{
        -: 1023:    int result;
        -: 1024:
        -: 1025:    /* Codes_SRS_AMQPVALUE_01_132: [If any of the arguments is NULL then amqpvalue_get_binary shall return NULL.] */
    #####: 1026:    if ((value == NULL) ||
        -: 1027:        (binary_value == NULL))
        -: 1028:    {
    #####: 1029:        LogError("Bad arguments: value = %p, binary_value = %p",
        -: 1030:            value, binary_value);
    #####: 1031:        result = MU_FAILURE;
        -: 1032:    }
        -: 1033:    else
        -: 1034:    {
    #####: 1035:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1036:        /* Codes_SRS_AMQPVALUE_01_133: [If the type of the value is not binary (was not created with amqpvalue_create_binary), then amqpvalue_get_binary shall return NULL.] */
    #####: 1037:        if (value_data->type != AMQP_TYPE_BINARY)
        -: 1038:        {
    #####: 1039:            LogError("Value is not of type BINARY");
    #####: 1040:            result = MU_FAILURE;
        -: 1041:        }
        -: 1042:        else
        -: 1043:        {
        -: 1044:            /* Codes_SRS_AMQPVALUE_01_131: [amqpvalue_get_binary shall yield a pointer to the sequence of bytes held by the AMQP_VALUE in binary_value.data and fill in the binary_value.length argument the number of bytes held in the binary value.] */
    #####: 1045:            binary_value->length = value_data->value.binary_value.length;
    #####: 1046:            binary_value->bytes = value_data->value.binary_value.bytes;
        -: 1047:
    #####: 1048:            result = 0;
        -: 1049:        }
        -: 1050:    }
        -: 1051:
    #####: 1052:    return result;
        -: 1053:}
        -: 1054:
        -: 1055:/* Codes_SRS_AMQPVALUE_01_135: [amqpvalue_create_string shall return a handle to an AMQP_VALUE that stores a sequence of Unicode characters.] */
        -: 1056:/* Codes_SRS_AMQPVALUE_01_028: [1.6.20 string A sequence of Unicode characters.] */
       20: 1057:AMQP_VALUE amqpvalue_create_string(const char* value)
        -: 1058:{
        -: 1059:    AMQP_VALUE result;
       20: 1060:    if (value == NULL)
        -: 1061:    {
    #####: 1062:        LogError("NULL argument value");
    #####: 1063:        result = NULL;
        -: 1064:    }
        -: 1065:    else
        -: 1066:    {
       20: 1067:        size_t length = strlen(value);
        -: 1068:
       20: 1069:        result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
       20: 1070:        if (result == NULL)
        -: 1071:        {
        -: 1072:            /* Codes_SRS_AMQPVALUE_01_136: [If allocating the AMQP_VALUE fails then amqpvalue_create_string shall return NULL.] */
    #####: 1073:            LogError("Could not allocate memory for AMQP value");
        -: 1074:        }
        -: 1075:        else
        -: 1076:        {
       20: 1077:            result->type = AMQP_TYPE_STRING;
       20: 1078:            result->value.string_value.chars = (char*)malloc(length + 1);
       20: 1079:            if (result->value.string_value.chars == NULL)
        -: 1080:            {
        -: 1081:                /* Codes_SRS_AMQPVALUE_01_136: [If allocating the AMQP_VALUE fails then amqpvalue_create_string shall return NULL.] */
    #####: 1082:                LogError("Could not allocate memory for string AMQP value");
    #####: 1083:                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 1084:                result = NULL;
        -: 1085:            }
        -: 1086:            else
        -: 1087:            {
       20: 1088:                (void)memcpy(result->value.string_value.chars, value, length + 1);
        -: 1089:            }
        -: 1090:        }
        -: 1091:    }
        -: 1092:
       20: 1093:    return result;
        -: 1094:}
        -: 1095:
    #####: 1096:int amqpvalue_get_string(AMQP_VALUE value, const char** string_value)
        -: 1097:{
        -: 1098:    int result;
        -: 1099:
        -: 1100:    /* Codes_SRS_AMQPVALUE_01_139: [If any of the arguments is NULL then amqpvalue_get_string shall return a non-zero value.] */
    #####: 1101:    if ((value == NULL) ||
        -: 1102:        (string_value == NULL))
        -: 1103:    {
    #####: 1104:        LogError("Bad arguments: value = %p, string_value = %p",
        -: 1105:            value, string_value);
    #####: 1106:        result = MU_FAILURE;
        -: 1107:    }
        -: 1108:    else
        -: 1109:    {
    #####: 1110:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1111:
        -: 1112:        /* Codes_SRS_AMQPVALUE_01_140: [If the type of the value is not string (was not created with amqpvalue_create_string), then amqpvalue_get_string shall return a non-zero value.] */
    #####: 1113:        if (value_data->type != AMQP_TYPE_STRING)
        -: 1114:        {
    #####: 1115:            LogError("Value is not of type STRING");
    #####: 1116:            result = MU_FAILURE;
        -: 1117:        }
        -: 1118:        else
        -: 1119:        {
        -: 1120:            /* Codes_SRS_AMQPVALUE_01_138: [amqpvalue_get_string shall yield a pointer to the sequence of bytes held by the AMQP_VALUE in string_value.] */
    #####: 1121:            *string_value = value_data->value.string_value.chars;
        -: 1122:
        -: 1123:            /* Codes_SRS_AMQPVALUE_01_141: [On success, amqpvalue_get_string shall return 0.] */
    #####: 1124:            result = 0;
        -: 1125:        }
        -: 1126:    }
        -: 1127:
    #####: 1128:    return result;
        -: 1129:}
        -: 1130:
        -: 1131:/* Codes_SRS_AMQPVALUE_01_029: [1.6.21 symbol Symbolic values from a constrained domain.] */
    #####: 1132:AMQP_VALUE amqpvalue_create_symbol(const char* value)
        -: 1133:{
        -: 1134:    AMQP_VALUE result;
    #####: 1135:    if (value == NULL)
        -: 1136:    {
        -: 1137:        /* Codes_SRS_AMQPVALUE_01_400: [If value is NULL, amqpvalue_create_symbol shall fail and return NULL.] */
    #####: 1138:        LogError("NULL argument");
    #####: 1139:        result = NULL;
        -: 1140:    }
        -: 1141:    else
        -: 1142:    {
    #####: 1143:        size_t length = strlen(value);
    #####: 1144:        if (length > UINT32_MAX)
        -: 1145:        {
        -: 1146:            /* Codes_SRS_AMQPVALUE_01_401: [ If the string pointed to by value is longer than 2^32-1 then amqpvalue_create_symbol shall return NULL. ]*/
    #####: 1147:            LogError("string too long to be represented as a symbol");
    #####: 1148:            result = NULL;
        -: 1149:        }
        -: 1150:        else
        -: 1151:        {
        -: 1152:            /* Codes_SRS_AMQPVALUE_01_143: [If allocating the AMQP_VALUE fails then amqpvalue_create_symbol shall return NULL.] */
    #####: 1153:            result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 1154:            if (result == NULL)
        -: 1155:            {
    #####: 1156:                LogError("Cannot allocate memory for AMQP value");
    #####: 1157:                result = NULL;
        -: 1158:            }
        -: 1159:            else
        -: 1160:            {
        -: 1161:                /* Codes_SRS_AMQPVALUE_01_142: [amqpvalue_create_symbol shall return a handle to an AMQP_VALUE that stores a symbol (ASCII string) value.] */
    #####: 1162:                result->type = AMQP_TYPE_SYMBOL;
    #####: 1163:                result->value.symbol_value.chars = (char*)malloc(length + 1);
    #####: 1164:                if (result->value.symbol_value.chars == NULL)
        -: 1165:                {
    #####: 1166:                    LogError("Cannot allocate memory for symbol string");
    #####: 1167:                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 1168:                    result = NULL;
        -: 1169:                }
        -: 1170:                else
        -: 1171:                {
    #####: 1172:                    (void)memcpy(result->value.symbol_value.chars, value, length + 1);
        -: 1173:                }
        -: 1174:            }
        -: 1175:        }
        -: 1176:    }
        -: 1177:
    #####: 1178:    return result;
        -: 1179:}
        -: 1180:
    #####: 1181:int amqpvalue_get_symbol(AMQP_VALUE value, const char** symbol_value)
        -: 1182:{
        -: 1183:    int result;
        -: 1184:
        -: 1185:    /* Codes_SRS_AMQPVALUE_01_147: [If any of the arguments is NULL then amqpvalue_get_symbol shall return a non-zero value.] */
    #####: 1186:    if ((value == NULL) ||
        -: 1187:        (symbol_value == NULL))
        -: 1188:    {
    #####: 1189:        LogError("Bad arguments: value = %p, symbol_value = %p",
        -: 1190:            value, symbol_value);
    #####: 1191:        result = MU_FAILURE;
        -: 1192:    }
        -: 1193:    else
        -: 1194:    {
    #####: 1195:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1196:
        -: 1197:        /* Codes_SRS_AMQPVALUE_01_148: [If the type of the value is not symbol (was not created with amqpvalue_create_symbol), then amqpvalue_get_symbol shall return a non-zero value.] */
    #####: 1198:        if (value_data->type != AMQP_TYPE_SYMBOL)
        -: 1199:        {
    #####: 1200:            LogError("Value is not of type SYMBOL");
    #####: 1201:            result = MU_FAILURE;
        -: 1202:        }
        -: 1203:        else
        -: 1204:        {
        -: 1205:            /* Codes_SRS_AMQPVALUE_01_145: [amqpvalue_get_symbol shall fill in the symbol_value the symbol value string held by the AMQP_VALUE.] */
    #####: 1206:            *symbol_value = value_data->value.symbol_value.chars;
        -: 1207:
        -: 1208:            /* Codes_SRS_AMQPVALUE_01_146: [On success, amqpvalue_get_symbol shall return 0.] */
    #####: 1209:            result = 0;
        -: 1210:        }
        -: 1211:    }
        -: 1212:
    #####: 1213:    return result;
        -: 1214:}
        -: 1215:
        -: 1216:/* Codes_SRS_AMQPVALUE_01_030: [1.6.22 list A sequence of polymorphic values.] */
       18: 1217:AMQP_VALUE amqpvalue_create_list(void)
        -: 1218:{
       18: 1219:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
       18: 1220:    if (result == NULL)
        -: 1221:    {
        -: 1222:        /* Codes_SRS_AMQPVALUE_01_150: [If allocating the AMQP_VALUE fails then amqpvalue_create_list shall return NULL.] */
    #####: 1223:        LogError("Could not allocate memory for AMQP value");
        -: 1224:    }
        -: 1225:    else
        -: 1226:    {
        -: 1227:        /* Codes_SRS_AMQPVALUE_01_149: [amqpvalue_create_list shall return a handle to an AMQP_VALUE that stores a list.] */
       18: 1228:        result->type = AMQP_TYPE_LIST;
        -: 1229:
        -: 1230:        /* Codes_SRS_AMQPVALUE_01_151: [The list shall have an initial size of zero.] */
       18: 1231:        result->value.list_value.count = 0;
       18: 1232:        result->value.list_value.items = NULL;
        -: 1233:    }
        -: 1234:
       18: 1235:    return result;
        -: 1236:}
        -: 1237:
    #####: 1238:int amqpvalue_set_list_item_count(AMQP_VALUE value, uint32_t list_size)
        -: 1239:{
        -: 1240:    int result;
        -: 1241:
        -: 1242:    /* Codes_SRS_AMQPVALUE_01_155: [If the value argument is NULL, amqpvalue_set_list_item_count shall return a non-zero value.] */
    #####: 1243:    if (value == NULL)
        -: 1244:    {
    #####: 1245:        LogError("NULL list value");
    #####: 1246:        result = MU_FAILURE;
        -: 1247:    }
        -: 1248:    else
        -: 1249:    {
    #####: 1250:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 1251:        if (value_data->type != AMQP_TYPE_LIST)
        -: 1252:        {
        -: 1253:            /* Codes_SRS_AMQPVALUE_01_156: [If the value is not of type list, then amqpvalue_set_list_item_count shall return a non-zero value.] */
    #####: 1254:            LogError("Value is not of type LIST");
    #####: 1255:            result = MU_FAILURE;
        -: 1256:        }
        -: 1257:        else
        -: 1258:        {
    #####: 1259:            if (value_data->value.list_value.count < list_size)
        -: 1260:            {
        -: 1261:                AMQP_VALUE* new_list;
        -: 1262:
        -: 1263:                /* Codes_SRS_AMQPVALUE_01_152: [amqpvalue_set_list_item_count shall resize an AMQP list.] */
    #####: 1264:                new_list = (AMQP_VALUE*)realloc(value_data->value.list_value.items, list_size * sizeof(AMQP_VALUE));
    #####: 1265:                if (new_list == NULL)
        -: 1266:                {
        -: 1267:                    /* Codes_SRS_AMQPVALUE_01_154: [If allocating memory for the list according to the new size fails, then amqpvalue_set_list_item_count shall return a non-zero value, while preserving the existing list contents.] */
    #####: 1268:                    LogError("Could not reallocate list memory");
    #####: 1269:                    result = MU_FAILURE;
        -: 1270:                }
        -: 1271:                else
        -: 1272:                {
        -: 1273:                    uint32_t i;
    #####: 1274:                    value_data->value.list_value.items = new_list;
        -: 1275:
        -: 1276:                    /* Codes_SRS_AMQPVALUE_01_162: [When a list is grown a null AMQP_VALUE shall be inserted as new list items to fill the list up to the new size.] */
    #####: 1277:                    for (i = value_data->value.list_value.count; i < list_size; i++)
        -: 1278:                    {
    #####: 1279:                        new_list[i] = amqpvalue_create_null();
    #####: 1280:                        if (new_list[i] == NULL)
        -: 1281:                        {
    #####: 1282:                            LogError("Could not create NULL AMQP value to be inserted in list");
    #####: 1283:                            break;
        -: 1284:                        }
        -: 1285:                    }
        -: 1286:
    #####: 1287:                    if (i < list_size)
        -: 1288:                    {
        -: 1289:                        /* Codes_SRS_AMQPVALUE_01_154: [If allocating memory for the list according to the new size fails, then amqpvalue_set_list_item_count shall return a non-zero value, while preserving the existing list contents.] */
        -: 1290:                        uint32_t j;
    #####: 1291:                        for (j = value_data->value.list_value.count; j < i; j++)
        -: 1292:                        {
    #####: 1293:                            amqpvalue_destroy(new_list[j]);
        -: 1294:                        }
        -: 1295:
    #####: 1296:                        result = MU_FAILURE;
        -: 1297:                    }
        -: 1298:                    else
        -: 1299:                    {
    #####: 1300:                        value_data->value.list_value.count = list_size;
        -: 1301:
        -: 1302:                        /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */
    #####: 1303:                        result = 0;
        -: 1304:                    }
        -: 1305:                }
        -: 1306:            }
    #####: 1307:            else if (value_data->value.list_value.count > list_size)
        -: 1308:            {
        -: 1309:                uint32_t i;
        -: 1310:
        -: 1311:                /* Codes_SRS_AMQPVALUE_01_161: [When the list is shrunk, the extra items shall be freed by using amqp_value_destroy.] */
    #####: 1312:                for (i = list_size; i < value_data->value.list_value.count; i++)
        -: 1313:                {
    #####: 1314:                    amqpvalue_destroy(value_data->value.list_value.items[i]);
        -: 1315:                }
        -: 1316:
    #####: 1317:                value_data->value.list_value.count = list_size;
        -: 1318:
        -: 1319:                /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */
    #####: 1320:                result = 0;
        -: 1321:            }
        -: 1322:            else
        -: 1323:            {
        -: 1324:                /* Codes_SRS_AMQPVALUE_01_153: [On success amqpvalue_set_list_item_count shall return 0.] */
    #####: 1325:                result = 0;
        -: 1326:            }
        -: 1327:        }
        -: 1328:    }
        -: 1329:
    #####: 1330:    return result;
        -: 1331:}
        -: 1332:
    #####: 1333:int amqpvalue_get_list_item_count(AMQP_VALUE value, uint32_t* size)
        -: 1334:{
        -: 1335:    int result;
        -: 1336:
        -: 1337:    /* Codes_SRS_AMQPVALUE_01_159: [If any of the arguments are NULL, amqpvalue_get_list_item_count shall return a non-zero value.] */
    #####: 1338:    if ((value == NULL) ||
        -: 1339:        (size == NULL))
        -: 1340:    {
    #####: 1341:        LogError("Bad arguments: value = %p, size = %p",
        -: 1342:            value, size);
    #####: 1343:        result = MU_FAILURE;
        -: 1344:    }
        -: 1345:    else
        -: 1346:    {
    #####: 1347:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1348:
        -: 1349:        /* Codes_SRS_AMQPVALUE_01_160: [If the AMQP_VALUE is not a list then amqpvalue_get_list_item_count shall return a non-zero value.] */
    #####: 1350:        if (value_data->type != AMQP_TYPE_LIST)
        -: 1351:        {
    #####: 1352:            LogError("Value is not of type LIST");
    #####: 1353:            result = MU_FAILURE;
        -: 1354:        }
        -: 1355:        else
        -: 1356:        {
        -: 1357:            /* Codes_SRS_AMQPVALUE_01_157: [amqpvalue_get_list_item_count shall fill in the size argument the number of items held by the AMQP list.] */
    #####: 1358:            *size = value_data->value.list_value.count;
        -: 1359:
        -: 1360:            /* Codes_SRS_AMQPVALUE_01_158: [On success amqpvalue_get_list_item_count shall return 0.] */
    #####: 1361:            result = 0;
        -: 1362:        }
        -: 1363:    }
        -: 1364:
    #####: 1365:    return result;
        -: 1366:}
        -: 1367:
       18: 1368:int amqpvalue_set_list_item(AMQP_VALUE value, uint32_t index, AMQP_VALUE list_item_value)
        -: 1369:{
        -: 1370:    int result;
        -: 1371:
        -: 1372:    /* Codes_SRS_AMQPVALUE_01_165: [If value or list_item_value is NULL, amqpvalue_set_list_item shall fail and return a non-zero value.] */
       18: 1373:    if (value == NULL)
        -: 1374:    {
    #####: 1375:        LogError("NULL list value");
    #####: 1376:        result = MU_FAILURE;
        -: 1377:    }
        -: 1378:    else
        -: 1379:    {
       18: 1380:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
       18: 1381:        if (value_data->type != AMQP_TYPE_LIST)
        -: 1382:        {
    #####: 1383:            LogError("Value is not of type LIST");
    #####: 1384:            result = MU_FAILURE;
        -: 1385:        }
        -: 1386:        else
        -: 1387:        {
        -: 1388:            /* Codes_SRS_AMQPVALUE_01_168: [The item stored at the index-th position in the list shall be a clone of list_item_value.] */
       18: 1389:            AMQP_VALUE cloned_item = amqpvalue_clone(list_item_value);
       18: 1390:            if (cloned_item == NULL)
        -: 1391:            {
        -: 1392:                /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */
        -: 1393:                /* Codes_SRS_AMQPVALUE_01_169: [If cloning the item fails, amqpvalue_set_list_item shall fail and return a non-zero value.] */
    #####: 1394:                LogError("Could not clone list item");
    #####: 1395:                result = MU_FAILURE;
        -: 1396:            }
        -: 1397:            else
        -: 1398:            {
       18: 1399:                if (index >= value_data->value.list_value.count)
        -: 1400:                {
       18: 1401:                    AMQP_VALUE* new_list = (AMQP_VALUE*)realloc(value_data->value.list_value.items, (index + 1) * sizeof(AMQP_VALUE));
       18: 1402:                    if (new_list == NULL)
        -: 1403:                    {
        -: 1404:                        /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */
    #####: 1405:                        LogError("Could not reallocate list storage");
    #####: 1406:                        amqpvalue_destroy(cloned_item);
    #####: 1407:                        result = MU_FAILURE;
        -: 1408:                    }
        -: 1409:                    else
        -: 1410:                    {
        -: 1411:                        uint32_t i;
        -: 1412:
       18: 1413:                        value_data->value.list_value.items = new_list;
        -: 1414:
      18*: 1415:                        for (i = value_data->value.list_value.count; i < index; i++)
        -: 1416:                        {
    #####: 1417:                            new_list[i] = amqpvalue_create_null();
    #####: 1418:                            if (new_list[i] == NULL)
        -: 1419:                            {
    #####: 1420:                                LogError("Could not allocate NULL value for list entries");
    #####: 1421:                                break;
        -: 1422:                            }
        -: 1423:                        }
        -: 1424:
       18: 1425:                        if (i < index)
        -: 1426:                        {
        -: 1427:                            /* Codes_SRS_AMQPVALUE_01_170: [When amqpvalue_set_list_item fails due to not being able to clone the item or grow the list, the list shall not be altered.] */
        -: 1428:                            uint32_t j;
        -: 1429:
    #####: 1430:                            for (j = value_data->value.list_value.count; j < i; j++)
        -: 1431:                            {
    #####: 1432:                                amqpvalue_destroy(new_list[j]);
        -: 1433:                            }
        -: 1434:
    #####: 1435:                            amqpvalue_destroy(cloned_item);
        -: 1436:
        -: 1437:                            /* Codes_SRS_AMQPVALUE_01_172: [If growing the list fails, then amqpvalue_set_list_item shall fail and return a non-zero value.] */
    #####: 1438:                            result = MU_FAILURE;
        -: 1439:                        }
        -: 1440:                        else
        -: 1441:                        {
       18: 1442:                            value_data->value.list_value.count = index + 1;
       18: 1443:                            value_data->value.list_value.items[index] = cloned_item;
        -: 1444:
        -: 1445:                            /* Codes_SRS_AMQPVALUE_01_164: [On success amqpvalue_set_list_item shall return 0.] */
       18: 1446:                            result = 0;
        -: 1447:                        }
        -: 1448:                    }
        -: 1449:                }
        -: 1450:                else
        -: 1451:                {
        -: 1452:                    /* Codes_SRS_AMQPVALUE_01_167: [Any previous value stored at the position index in the list shall be freed by using amqpvalue_destroy.] */
    #####: 1453:                    amqpvalue_destroy(value_data->value.list_value.items[index]);
        -: 1454:
        -: 1455:                    /* Codes_SRS_AMQPVALUE_01_163: [amqpvalue_set_list_item shall replace the item at the 0 based index-th position in the list identified by the value argument with the AMQP_VALUE specified by list_item_value.] */
    #####: 1456:                    value_data->value.list_value.items[index] = cloned_item;
        -: 1457:
        -: 1458:                    /* Codes_SRS_AMQPVALUE_01_164: [On success amqpvalue_set_list_item shall return 0.] */
    #####: 1459:                    result = 0;
        -: 1460:                }
        -: 1461:            }
        -: 1462:        }
        -: 1463:    }
        -: 1464:
       18: 1465:    return result;
        -: 1466:}
        -: 1467:
    #####: 1468:AMQP_VALUE amqpvalue_get_list_item(AMQP_VALUE value, size_t index)
        -: 1469:{
        -: 1470:    AMQP_VALUE result;
        -: 1471:
    #####: 1472:    if (value == NULL)
        -: 1473:    {
        -: 1474:        /* Codes_SRS_AMQPVALUE_01_174: [If the value argument is NULL, amqpvalue_get_list_item shall fail and return NULL.] */
    #####: 1475:        LogError("NULL list value");
    #####: 1476:        result = NULL;
        -: 1477:    }
        -: 1478:    else
        -: 1479:    {
    #####: 1480:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1481:
        -: 1482:        /* Codes_SRS_AMQPVALUE_01_177: [If value is not a list then amqpvalue_get_list_item shall fail and return NULL.] */
    #####: 1483:        if (value_data->type != AMQP_TYPE_LIST)
        -: 1484:        {
    #####: 1485:            LogError("Value is not of type LIST");
    #####: 1486:            result = NULL;
        -: 1487:        }
        -: 1488:        /* Codes_SRS_AMQPVALUE_01_175: [If index is greater or equal to the number of items in the list then amqpvalue_get_list_item shall fail and return NULL.] */
    #####: 1489:        else if (value_data->value.list_value.count <= index)
        -: 1490:        {
    #####: 1491:            LogError("Bad index value %u", (unsigned int)index);
    #####: 1492:            result = NULL;
        -: 1493:        }
        -: 1494:        else
        -: 1495:        {
        -: 1496:            /* Codes_SRS_AMQPVALUE_01_173: [amqpvalue_get_list_item shall return a copy of the AMQP_VALUE stored at the 0 based position index in the list identified by value.] */
        -: 1497:            /* Codes_SRS_AMQPVALUE_01_176: [If cloning the item at position index fails, then amqpvalue_get_list_item shall fail and return NULL.] */
    #####: 1498:            result = amqpvalue_clone(value_data->value.list_value.items[index]);
        -: 1499:        }
        -: 1500:    }
        -: 1501:
    #####: 1502:    return result;
        -: 1503:}
        -: 1504:
        -: 1505:/* Codes_SRS_AMQPVALUE_01_178: [amqpvalue_create_map shall create an AMQP value that holds a map and return a handle to it.] */
        -: 1506:/* Codes_SRS_AMQPVALUE_01_031: [1.6.23 map A polymorphic mapping from distinct keys to values.] */
        1: 1507:AMQP_VALUE amqpvalue_create_map(void)
        -: 1508:{
        1: 1509:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
        1: 1510:    if (result == NULL)
        -: 1511:    {
        -: 1512:        /* Codes_SRS_AMQPVALUE_01_179: [If allocating memory for the map fails, then amqpvalue_create_map shall return NULL.] */
    #####: 1513:        LogError("Could not allocate memory for AMQP value");
        -: 1514:    }
        -: 1515:    else
        -: 1516:    {
        1: 1517:        result->type = AMQP_TYPE_MAP;
        -: 1518:
        -: 1519:        /* Codes_SRS_AMQPVALUE_01_180: [The number of key/value pairs in the newly created map shall be zero.] */
        1: 1520:        result->value.map_value.pairs = NULL;
        1: 1521:        result->value.map_value.pair_count = 0;
        -: 1522:    }
        -: 1523:
        1: 1524:    return result;
        -: 1525:}
        -: 1526:
        1: 1527:int amqpvalue_set_map_value(AMQP_VALUE map, AMQP_VALUE key, AMQP_VALUE value)
        -: 1528:{
        -: 1529:    int result;
        -: 1530:
        -: 1531:    /* Codes_SRS_AMQPVALUE_01_183: [If any of the arguments are NULL, amqpvalue_set_map_value shall fail and return a non-zero value.] */
        1: 1532:    if ((map == NULL) ||
        1: 1533:        (key == NULL) ||
        -: 1534:        (value == NULL))
        -: 1535:    {
    #####: 1536:        LogError("Bad arguments: map = %p, key = %p, value = %p",
        -: 1537:            map, key, value);
    #####: 1538:        result = MU_FAILURE;
        -: 1539:    }
        -: 1540:    else
        -: 1541:    {
        1: 1542:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;
        -: 1543:
        -: 1544:        /* Codes_SRS_AMQPVALUE_01_196: [If the map argument is not an AMQP value created with the amqpvalue_create_map function than amqpvalue_set_map_value shall fail and return a non-zero value.] */
        1: 1545:        if (value_data->type != AMQP_TYPE_MAP)
        -: 1546:        {
    #####: 1547:            LogError("Value is not of type MAP");
    #####: 1548:            result = MU_FAILURE;
        -: 1549:        }
        -: 1550:        else
        -: 1551:        {
        -: 1552:            AMQP_VALUE cloned_value;
        -: 1553:
        -: 1554:            /* Codes_SRS_AMQPVALUE_01_185: [When storing the key or value, their contents shall be cloned.] */
        1: 1555:            cloned_value = amqpvalue_clone(value);
        1: 1556:            if (cloned_value == NULL)
        -: 1557:            {
        -: 1558:                /* Codes_SRS_AMQPVALUE_01_188: [If cloning the value fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */
    #####: 1559:                LogError("Could not clone value to set in the map");
    #####: 1560:                result = MU_FAILURE;
        -: 1561:            }
        -: 1562:            else
        -: 1563:            {
        -: 1564:                uint32_t i;
        -: 1565:                AMQP_VALUE cloned_key;
        -: 1566:
       1*: 1567:                for (i = 0; i < value_data->value.map_value.pair_count; i++)
        -: 1568:                {
    #####: 1569:                    if (amqpvalue_are_equal(value_data->value.map_value.pairs[i].key, key))
        -: 1570:                    {
    #####: 1571:                        LogError("Could not allocate NULL value for map entries");
    #####: 1572:                        break;
        -: 1573:                    }
        -: 1574:                }
        -: 1575:
        1: 1576:                if (i < value_data->value.map_value.pair_count)
        -: 1577:                {
        -: 1578:                    /* Codes_SRS_AMQPVALUE_01_184: [If the key already exists in the map, its value shall be replaced with the value provided by the value argument.] */
        -: 1579:                    /* Codes_SRS_AMQPVALUE_01_125: [A map in which there exist two identical key values is invalid.] */
    #####: 1580:                    amqpvalue_destroy(value_data->value.map_value.pairs[i].value);
    #####: 1581:                    value_data->value.map_value.pairs[i].value = cloned_value;
        -: 1582:
        -: 1583:                    /* Codes_SRS_AMQPVALUE_01_182: [On success amqpvalue_set_map_value shall return 0.] */
    #####: 1584:                    result = 0;
        -: 1585:                }
        -: 1586:                else
        -: 1587:                {
        -: 1588:                    /* Codes_SRS_AMQPVALUE_01_185: [When storing the key or value, their contents shall be cloned.] */
        1: 1589:                    cloned_key = amqpvalue_clone(key);
        1: 1590:                    if (cloned_key == NULL)
        -: 1591:                    {
        -: 1592:                        /* Codes_SRS_AMQPVALUE_01_187: [If cloning the key fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */
    #####: 1593:                        amqpvalue_destroy(cloned_value);
    #####: 1594:                        LogError("Could not clone key for map");
    #####: 1595:                        result = MU_FAILURE;
        -: 1596:                    }
        -: 1597:                    else
        -: 1598:                    {
        1: 1599:                        AMQP_MAP_KEY_VALUE_PAIR* new_pairs = (AMQP_MAP_KEY_VALUE_PAIR*)realloc(value_data->value.map_value.pairs, (value_data->value.map_value.pair_count + 1) * sizeof(AMQP_MAP_KEY_VALUE_PAIR));
        1: 1600:                        if (new_pairs == NULL)
        -: 1601:                        {
        -: 1602:                            /* Codes_SRS_AMQPVALUE_01_186: [If allocating memory to hold a new key/value pair fails, amqpvalue_set_map_value shall fail and return a non-zero value.] */
    #####: 1603:                            amqpvalue_destroy(cloned_key);
    #####: 1604:                            amqpvalue_destroy(cloned_value);
    #####: 1605:                            LogError("Could not reallocate memory for map");
    #####: 1606:                            result = MU_FAILURE;
        -: 1607:                        }
        -: 1608:                        else
        -: 1609:                        {
        1: 1610:                            value_data->value.map_value.pairs = new_pairs;
        -: 1611:
        -: 1612:                            /* Codes_SRS_AMQPVALUE_01_181: [amqpvalue_set_map_value shall set the value in the map identified by the map argument for a key/value pair identified by the key argument.] */
        1: 1613:                            value_data->value.map_value.pairs[value_data->value.map_value.pair_count].key = cloned_key;
        1: 1614:                            value_data->value.map_value.pairs[value_data->value.map_value.pair_count].value = cloned_value;
        1: 1615:                            value_data->value.map_value.pair_count++;
        -: 1616:
        -: 1617:                            /* Codes_SRS_AMQPVALUE_01_182: [On success amqpvalue_set_map_value shall return 0.] */
        1: 1618:                            result = 0;
        -: 1619:                        }
        -: 1620:                    }
        -: 1621:                }
        -: 1622:            }
        -: 1623:        }
        -: 1624:    }
        -: 1625:
        1: 1626:    return result;
        -: 1627:}
        -: 1628:
    #####: 1629:AMQP_VALUE amqpvalue_get_map_value(AMQP_VALUE map, AMQP_VALUE key)
        -: 1630:{
        -: 1631:    AMQP_VALUE result;
        -: 1632:
        -: 1633:    /* Codes_SRS_AMQPVALUE_01_190: [If any argument is NULL, amqpvalue_get_map_value shall return NULL.] */
    #####: 1634:    if ((map == NULL) ||
        -: 1635:        (key == NULL))
        -: 1636:    {
    #####: 1637:        LogError("Bad arguments: map = %p, key = %p",
        -: 1638:            map, key);
    #####: 1639:        result = NULL;
        -: 1640:    }
        -: 1641:    else
        -: 1642:    {
    #####: 1643:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;
        -: 1644:
        -: 1645:        /* Codes_SRS_AMQPVALUE_01_197: [If the map argument is not an AMQP value created with the amqpvalue_create_map function than amqpvalue_get_map_value shall return NULL.] */
    #####: 1646:        if (value_data->type != AMQP_TYPE_MAP)
        -: 1647:        {
    #####: 1648:            LogError("Value is not of type MAP");
    #####: 1649:            result = NULL;
        -: 1650:        }
        -: 1651:        else
        -: 1652:        {
        -: 1653:            uint32_t i;
        -: 1654:
    #####: 1655:            for (i = 0; i < value_data->value.map_value.pair_count; i++)
        -: 1656:            {
    #####: 1657:                if (amqpvalue_are_equal(value_data->value.map_value.pairs[i].key, key))
        -: 1658:                {
    #####: 1659:                    break;
        -: 1660:                }
        -: 1661:            }
        -: 1662:
    #####: 1663:            if (i == value_data->value.map_value.pair_count)
        -: 1664:            {
        -: 1665:                /* Codes_SRS_AMQPVALUE_01_191: [If the key cannot be found, amqpvalue_get_map_value shall return NULL.] */
    #####: 1666:                result = NULL;
        -: 1667:            }
        -: 1668:            else
        -: 1669:            {
        -: 1670:                /* Codes_SRS_AMQPVALUE_01_189: [amqpvalue_get_map_value shall return the value whose key is identified by the key argument.] */
        -: 1671:                /* Codes_SRS_AMQPVALUE_01_192: [The returned value shall be a clone of the actual value stored in the map.] */
    #####: 1672:                result = amqpvalue_clone(value_data->value.map_value.pairs[i].value);
        -: 1673:            }
        -: 1674:        }
        -: 1675:    }
        -: 1676:
    #####: 1677:    return result;
        -: 1678:}
        -: 1679:
    #####: 1680:int amqpvalue_get_map_pair_count(AMQP_VALUE map, uint32_t* pair_count)
        -: 1681:{
        -: 1682:    int result;
        -: 1683:
        -: 1684:    /* Codes_SRS_AMQPVALUE_01_195: [If any of the arguments is NULL, amqpvalue_get_map_pair_count shall fail and return a non-zero value.] */
    #####: 1685:    if ((map == NULL) ||
        -: 1686:        (pair_count == NULL))
        -: 1687:    {
    #####: 1688:        LogError("Bad arguments: map = %p, pair_count = %p",
        -: 1689:            map, pair_count);
    #####: 1690:        result = MU_FAILURE;
        -: 1691:    }
        -: 1692:    else
        -: 1693:    {
    #####: 1694:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;
        -: 1695:
    #####: 1696:        if (value_data->type != AMQP_TYPE_MAP)
        -: 1697:        {
        -: 1698:            /* Codes_SRS_AMQPVALUE_01_198: [If the map argument is not an AMQP value created with the amqpvalue_create_map function then amqpvalue_get_map_pair_count shall fail and return a non-zero value.] */
    #####: 1699:            LogError("Value is not of type MAP");
    #####: 1700:            result = MU_FAILURE;
        -: 1701:        }
        -: 1702:        else
        -: 1703:        {
        -: 1704:            /* Codes_SRS_AMQPVALUE_01_193: [amqpvalue_get_map_pair_count shall fill in the number of key/value pairs in the map in the pair_count argument.] */
    #####: 1705:            *pair_count = value_data->value.map_value.pair_count;
        -: 1706:
        -: 1707:            /* Codes_SRS_AMQPVALUE_01_194: [On success amqpvalue_get_map_pair_count shall return 0.] */
    #####: 1708:            result = 0;
        -: 1709:        }
        -: 1710:    }
        -: 1711:
    #####: 1712:    return result;
        -: 1713:}
        -: 1714:
    #####: 1715:int amqpvalue_get_map_key_value_pair(AMQP_VALUE map, uint32_t index, AMQP_VALUE* key, AMQP_VALUE* value)
        -: 1716:{
        -: 1717:    int result;
        -: 1718:
        -: 1719:    /* Codes_SRS_AMQPVALUE_01_201: [If any of the map, key or value arguments is NULL, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */
    #####: 1720:    if ((map == NULL) ||
    #####: 1721:        (key == NULL) ||
        -: 1722:        (value == NULL))
        -: 1723:    {
    #####: 1724:        LogError("Bad arguments: map = %p, key = %p, value = %p",
        -: 1725:            map, key, value);
    #####: 1726:        result = MU_FAILURE;
        -: 1727:    }
        -: 1728:    else
        -: 1729:    {
    #####: 1730:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)map;
        -: 1731:
    #####: 1732:        if (value_data->type != AMQP_TYPE_MAP)
        -: 1733:        {
        -: 1734:            /* Codes_SRS_AMQPVALUE_01_205: [If the map argument is not an AMQP value created with the amqpvalue_create_map function then amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */
    #####: 1735:            LogError("Value is not of type MAP");
    #####: 1736:            result = MU_FAILURE;
        -: 1737:        }
    #####: 1738:        else if (value_data->value.map_value.pair_count <= index)
        -: 1739:        {
        -: 1740:            /* Codes_SRS_AMQPVALUE_01_204: [If the index argument is greater or equal to the number of key/value pairs in the map then amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */
    #####: 1741:            LogError("Index out of range: %u", (unsigned int)index);
    #####: 1742:            result = MU_FAILURE;
        -: 1743:        }
        -: 1744:        else
        -: 1745:        {
        -: 1746:            /* Codes_SRS_AMQPVALUE_01_199: [amqpvalue_get_map_key_value_pair shall fill in the key and value arguments copies of the key/value pair on the 0 based position index in a map.] */
    #####: 1747:            *key = amqpvalue_clone(value_data->value.map_value.pairs[index].key);
    #####: 1748:            if (*key == NULL)
        -: 1749:            {
        -: 1750:                /* Codes_SRS_AMQPVALUE_01_202: [If cloning the key fails, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */
    #####: 1751:                LogError("Could not clone index %u key", (unsigned int)index);
    #####: 1752:                result = MU_FAILURE;
        -: 1753:            }
        -: 1754:            else
        -: 1755:            {
    #####: 1756:                *value = amqpvalue_clone(value_data->value.map_value.pairs[index].value);
    #####: 1757:                if (*value == NULL)
        -: 1758:                {
        -: 1759:                    /* Codes_SRS_AMQPVALUE_01_203: [If cloning the value fails, amqpvalue_get_map_key_value_pair shall fail and return a non-zero value.] */
    #####: 1760:                    amqpvalue_destroy(*key);
    #####: 1761:                    LogError("Could not clone index %u value", (unsigned int)index);
    #####: 1762:                    result = MU_FAILURE;
        -: 1763:                }
        -: 1764:                else
        -: 1765:                {
        -: 1766:                    /* Codes_SRS_AMQPVALUE_01_200: [On success amqpvalue_get_map_key_value_pair shall return 0.] */
    #####: 1767:                    result = 0;
        -: 1768:                }
        -: 1769:            }
        -: 1770:        }
        -: 1771:    }
        -: 1772:
    #####: 1773:    return result;
        -: 1774:}
        -: 1775:
    #####: 1776:int amqpvalue_get_map(AMQP_VALUE value, AMQP_VALUE* map_value)
        -: 1777:{
        -: 1778:    int result;
        -: 1779:
    #####: 1780:    if ((value == NULL) ||
        -: 1781:        (map_value == NULL))
        -: 1782:    {
    #####: 1783:        LogError("Bad arguments: value = %p, map_value = %p",
        -: 1784:            value, map_value);
    #####: 1785:        result = MU_FAILURE;
        -: 1786:    }
        -: 1787:    else
        -: 1788:    {
    #####: 1789:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 1790:        if (value_data->type != AMQP_TYPE_MAP)
        -: 1791:        {
    #####: 1792:            LogError("Value is not of type MAP");
    #####: 1793:            result = MU_FAILURE;
        -: 1794:        }
        -: 1795:        else
        -: 1796:        {
    #####: 1797:            *map_value = value;
    #####: 1798:            result = 0;
        -: 1799:        }
        -: 1800:    }
        -: 1801:
    #####: 1802:    return result;
        -: 1803:}
        -: 1804:
        -: 1805:/* Codes_SRS_AMQPVALUE_01_397: [1.6.24 array A sequence of values of a single type.] */
    #####: 1806:AMQP_VALUE amqpvalue_create_array(void)
        -: 1807:{
    #####: 1808:    AMQP_VALUE result = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 1809:    if (result == NULL)
        -: 1810:    {
        -: 1811:        /* Codes_SRS_AMQPVALUE_01_405: [ If allocating memory for the array fails, then `amqpvalue_create_array` shall return NULL. ] */
    #####: 1812:        LogError("Could not allocate memory for AMQP value");
        -: 1813:    }
        -: 1814:    else
        -: 1815:    {
        -: 1816:        /* Codes_SRS_AMQPVALUE_01_404: [ `amqpvalue_create_array` shall return a handle to an AMQP_VALUE that stores an array. ] */
    #####: 1817:        result->type = AMQP_TYPE_ARRAY;
        -: 1818:
        -: 1819:        /* Codes_SRS_AMQPVALUE_01_406: [ The array shall have an initial size of zero. ] */
    #####: 1820:        result->value.array_value.items = NULL;
    #####: 1821:        result->value.array_value.count = 0;
        -: 1822:    }
        -: 1823:
    #####: 1824:    return result;
        -: 1825:}
        -: 1826:
    #####: 1827:int amqpvalue_get_array_item_count(AMQP_VALUE value, uint32_t* count)
        -: 1828:{
        -: 1829:    int result;
        -: 1830:
        -: 1831:    /* Tests_SRS_AMQPVALUE_01_421: [ If any of the arguments is NULL, `amqpvalue_get_array_item_count` shall fail and return a non-zero value. ]*/
    #####: 1832:    if ((value == NULL) ||
        -: 1833:        (count == NULL))
        -: 1834:    {
    #####: 1835:        LogError("Bad arguments: value = %p, count = %p",
        -: 1836:            value, count);
    #####: 1837:        result = MU_FAILURE;
        -: 1838:    }
        -: 1839:    else
        -: 1840:    {
    #####: 1841:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1842:
        -: 1843:        /* Codes_SRS_AMQPVALUE_01_422: [ If the array argument is not an AMQP value created with the `amqpvalue_create_array` function then `amqpvalue_get_array_item_count` shall fail and return a non-zero value. ]*/
    #####: 1844:        if (value_data->type != AMQP_TYPE_ARRAY)
        -: 1845:        {
    #####: 1846:            LogError("Value is not of type ARRAY");
    #####: 1847:            result = MU_FAILURE;
        -: 1848:        }
        -: 1849:        else
        -: 1850:        {
        -: 1851:            /* Codes_SRS_AMQPVALUE_01_419: [ `amqpvalue_get_array_item_count` shall return in `count` the number of items in the array. ]*/
    #####: 1852:            *count = value_data->value.array_value.count;
        -: 1853:
        -: 1854:            /* Codes_SRS_AMQPVALUE_01_420: [ On success `amqpvalue_get_array_item_count` shall return 0. ]*/
    #####: 1855:            result = 0;
        -: 1856:        }
        -: 1857:    }
        -: 1858:
    #####: 1859:    return result;
        -: 1860:}
        -: 1861:
    #####: 1862:int amqpvalue_add_array_item(AMQP_VALUE value, AMQP_VALUE array_item_value)
        -: 1863:{
        -: 1864:    int result;
        -: 1865:
        -: 1866:    /* Codes_SRS_AMQPVALUE_01_409: [ If `value` or `array_item_value` is NULL, amqpvalue_add_array_item shall fail and return a non-zero value. ]*/
    #####: 1867:    if (value == NULL)
        -: 1868:    {
    #####: 1869:        LogError("NULL value");
    #####: 1870:        result = MU_FAILURE;
        -: 1871:    }
        -: 1872:    else
        -: 1873:    {
        -: 1874:        /* Codes_SRS_AMQPVALUE_01_413: [ If the `value` argument is not an AMQP array created with the `amqpvalue_create_array` function than `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */
    #####: 1875:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 1876:        if (value_data->type != AMQP_TYPE_ARRAY)
        -: 1877:        {
    #####: 1878:            LogError("Value is not of type ARRAY");
    #####: 1879:            result = MU_FAILURE;
        -: 1880:        }
        -: 1881:        else
        -: 1882:        {
        -: 1883:            /* Codes_SRS_AMQPVALUE_01_425: [ If the type of `array_item_value` does not match that of items already in the array then `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */
    #####: 1884:            AMQP_VALUE_DATA* array_item_value_data = (AMQP_VALUE_DATA*)array_item_value;
    #####: 1885:            if ((value_data->value.array_value.count > 0) &&
    #####: 1886:                (array_item_value_data->type != value_data->value.array_value.items[0]->type))
        -: 1887:            {
    #####: 1888:                LogError("Cannot put different types in the same array");
    #####: 1889:                result = MU_FAILURE;
        -: 1890:            }
        -: 1891:            else
        -: 1892:            {
        -: 1893:                /* Codes_SRS_AMQPVALUE_01_410: [ The item stored at the n-th position in the array shall be a clone of `array_item_value`. ] */
    #####: 1894:                AMQP_VALUE cloned_item = amqpvalue_clone(array_item_value);
    #####: 1895:                if (cloned_item == NULL)
        -: 1896:                {
        -: 1897:                    /* Codes_SRS_AMQPVALUE_01_423: [ When `amqpvalue_add_array_item` fails due to not being able to clone the item or grow the array, the array shall not be altered. ] */
        -: 1898:                    /* Codes_SRS_AMQPVALUE_01_412: [ If cloning the item fails, `amqpvalue_add_array_item` shall fail and return a non-zero value. ]*/
    #####: 1899:                    LogError("Cannot clone value to put in the array");
    #####: 1900:                    result = MU_FAILURE;
        -: 1901:                }
        -: 1902:                else
        -: 1903:                {
    #####: 1904:                    AMQP_VALUE* new_array = (AMQP_VALUE*)realloc(value_data->value.array_value.items, (value_data->value.array_value.count + 1) * sizeof(AMQP_VALUE));
    #####: 1905:                    if (new_array == NULL)
        -: 1906:                    {
        -: 1907:                        /* Codes_SRS_AMQPVALUE_01_423: [ When `amqpvalue_add_array_item` fails due to not being able to clone the item or grow the array, the array shall not be altered. ] */
        -: 1908:                        /* Codes_SRS_AMQPVALUE_01_424: [ If growing the array fails, then `amqpvalue_add_array_item` shall fail and return a non-zero value. ] */
    #####: 1909:                        amqpvalue_destroy(cloned_item);
    #####: 1910:                        LogError("Cannot resize array");
    #####: 1911:                        result = MU_FAILURE;
        -: 1912:                    }
        -: 1913:                    else
        -: 1914:                    {
    #####: 1915:                        value_data->value.array_value.items = new_array;
        -: 1916:
        -: 1917:                        /* Codes_SRS_AMQPVALUE_01_407: [ `amqpvalue_add_array_item` shall add the AMQP_VALUE specified by `array_item_value` at the 0 based n-th position in the array. ]*/
    #####: 1918:                        value_data->value.array_value.items[value_data->value.array_value.count] = cloned_item;
    #####: 1919:                        value_data->value.array_value.count++;
        -: 1920:
        -: 1921:                        /* Codes_SRS_AMQPVALUE_01_408: [ On success `amqpvalue_add_array_item` shall return 0. ]*/
    #####: 1922:                        result = 0;
        -: 1923:                    }
        -: 1924:                }
        -: 1925:            }
        -: 1926:        }
        -: 1927:    }
        -: 1928:
    #####: 1929:    return result;
        -: 1930:}
        -: 1931:
    #####: 1932:AMQP_VALUE amqpvalue_get_array_item(AMQP_VALUE value, uint32_t index)
        -: 1933:{
        -: 1934:    AMQP_VALUE result;
        -: 1935:
    #####: 1936:    if (value == NULL)
        -: 1937:    {
        -: 1938:        /* Codes_SRS_AMQPVALUE_01_416: [ If the `value` argument is NULL, `amqpvalue_get_array_item` shall fail and return NULL. ] */
    #####: 1939:        LogError("NULL value");
    #####: 1940:        result = NULL;
        -: 1941:    }
        -: 1942:    else
        -: 1943:    {
    #####: 1944:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 1945:
        -: 1946:        /* Codes_SRS_AMQPVALUE_01_418: [ If value is not an array then `amqpvalue_get_array_item` shall fail and return NULL. ] */
    #####: 1947:        if (value_data->type != AMQP_TYPE_ARRAY)
        -: 1948:        {
    #####: 1949:            LogError("Value is not of type ARRAY");
    #####: 1950:            result = NULL;
        -: 1951:        }
        -: 1952:        /* Codes_SRS_AMQPVALUE_01_417: [ If `index` is greater or equal to the number of items in the array then `amqpvalue_get_array_item` shall fail and return NULL. ] */
    #####: 1953:        else if (value_data->value.array_value.count <= index)
        -: 1954:        {
    #####: 1955:            LogError("Index out of range: %u", (unsigned int)index);
    #####: 1956:            result = NULL;
        -: 1957:        }
        -: 1958:        else
        -: 1959:        {
        -: 1960:            /* Codes_SRS_AMQPVALUE_01_414: [ `amqpvalue_get_array_item` shall return a copy of the AMQP_VALUE stored at the 0 based position `index` in the array identified by `value`. ] */
        -: 1961:            /* Codes_SRS_AMQPVALUE_01_426: [ If cloning the item at position `index` fails, then `amqpvalue_get_array_item` shall fail and return NULL. ] */
    #####: 1962:            result = amqpvalue_clone(value_data->value.array_value.items[index]);
        -: 1963:        }
        -: 1964:    }
        -: 1965:
    #####: 1966:    return result;
        -: 1967:}
        -: 1968:
    #####: 1969:int amqpvalue_get_array(AMQP_VALUE value, AMQP_VALUE* array_value)
        -: 1970:{
        -: 1971:    int result;
        -: 1972:
    #####: 1973:    if ((value == NULL) ||
        -: 1974:        (array_value == NULL))
        -: 1975:    {
    #####: 1976:        LogError("Bad arguments: value = %p, array_value = %p",
        -: 1977:            value, array_value);
    #####: 1978:        result = MU_FAILURE;
        -: 1979:    }
        -: 1980:    else
        -: 1981:    {
    #####: 1982:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 1983:        if (value_data->type != AMQP_TYPE_ARRAY)
        -: 1984:        {
    #####: 1985:            LogError("Value is not of type ARRAY");
    #####: 1986:            result = MU_FAILURE;
        -: 1987:        }
        -: 1988:        else
        -: 1989:        {
    #####: 1990:            *array_value = value;
    #####: 1991:            result = 0;
        -: 1992:        }
        -: 1993:    }
        -: 1994:
    #####: 1995:    return result;
        -: 1996:}
        -: 1997:
        -: 1998:/* Codes_SRS_AMQPVALUE_01_206: [amqpvalue_are_equal shall return true if the contents of value1 and value2 are equal.] */
    #####: 1999:bool amqpvalue_are_equal(AMQP_VALUE value1, AMQP_VALUE value2)
        -: 2000:{
        -: 2001:    bool result;
        -: 2002:
        -: 2003:    /* Codes_SRS_AMQPVALUE_01_207: [If value1 and value2 are NULL, amqpvalue_are_equal shall return true.] */
    #####: 2004:    if ((value1 == NULL) &&
        -: 2005:        (value2 == NULL))
        -: 2006:    {
    #####: 2007:        LogError("Bad arguments: value1 = %p, value2 = %p",
        -: 2008:            value1, value2);
    #####: 2009:        result = true;
        -: 2010:    }
        -: 2011:    /* Codes_SRS_AMQPVALUE_01_208: [If one of the arguments is NULL and the other is not, amqpvalue_are_equal shall return false.] */
    #####: 2012:    else if ((value1 != value2) && ((value1 == NULL) || (value2 == NULL)))
        -: 2013:    {
    #####: 2014:        result = false;
        -: 2015:    }
        -: 2016:    else
        -: 2017:    {
    #####: 2018:        AMQP_VALUE_DATA* value1_data = (AMQP_VALUE_DATA*)value1;
    #####: 2019:        AMQP_VALUE_DATA* value2_data = (AMQP_VALUE_DATA*)value2;
        -: 2020:
        -: 2021:        /* Codes_SRS_AMQPVALUE_01_209: [If the types for value1 and value2 are different amqpvalue_are_equal shall return false.] */
        -: 2022:#if _MSC_VER
        -: 2023:#pragma warning(suppress: 28182) /* The compiler states that value2_data can be NULL, but it cannot. And there are tests for it. */
        -: 2024:#endif
    #####: 2025:        if (value1_data->type != value2_data->type)
        -: 2026:        {
    #####: 2027:            result = false;
        -: 2028:        }
        -: 2029:        else
        -: 2030:        {
    #####: 2031:            switch (value1_data->type)
        -: 2032:            {
    #####: 2033:            default:
    #####: 2034:                result = false;
    #####: 2035:                break;
        -: 2036:
    #####: 2037:            case AMQP_TYPE_NULL:
        -: 2038:                /* Codes_SRS_AMQPVALUE_01_210: [- null: always equal.] */
    #####: 2039:                result = true;
    #####: 2040:                break;
        -: 2041:
    #####: 2042:            case AMQP_TYPE_BOOL:
        -: 2043:                /* Codes_SRS_AMQPVALUE_01_211: [- boolean: compare the bool content.] */
    #####: 2044:                result = (value1_data->value.bool_value == value2_data->value.bool_value);
    #####: 2045:                break;
        -: 2046:
    #####: 2047:            case AMQP_TYPE_UBYTE:
        -: 2048:                /* Codes_SRS_AMQPVALUE_01_212: [- ubyte: compare the unsigned char content.] */
    #####: 2049:                result = (value1_data->value.ubyte_value == value2_data->value.ubyte_value);
    #####: 2050:                break;
        -: 2051:
    #####: 2052:            case AMQP_TYPE_USHORT:
        -: 2053:                /* Codes_SRS_AMQPVALUE_01_213: [- ushort: compare the uint16_t content.] */
    #####: 2054:                result = (value1_data->value.ushort_value == value2_data->value.ushort_value);
    #####: 2055:                break;
        -: 2056:
    #####: 2057:            case AMQP_TYPE_UINT:
        -: 2058:                /* Codes_SRS_AMQPVALUE_01_214: [- uint: compare the uint32_t content.] */
    #####: 2059:                result = (value1_data->value.uint_value == value2_data->value.uint_value);
    #####: 2060:                break;
        -: 2061:
    #####: 2062:            case AMQP_TYPE_ULONG:
        -: 2063:                /* Codes_SRS_AMQPVALUE_01_215: [- ulong: compare the uint64_t content.] */
    #####: 2064:                result = (value1_data->value.ulong_value == value2_data->value.ulong_value);
    #####: 2065:                break;
        -: 2066:
    #####: 2067:            case AMQP_TYPE_BYTE:
        -: 2068:                /* Codes_SRS_AMQPVALUE_01_216: [- byte: compare the char content.] */
    #####: 2069:                result = (value1_data->value.byte_value == value2_data->value.byte_value);
    #####: 2070:                break;
        -: 2071:
    #####: 2072:            case AMQP_TYPE_SHORT:
        -: 2073:                /* Codes_SRS_AMQPVALUE_01_217: [- short: compare the int16_t content.] */
    #####: 2074:                result = (value1_data->value.short_value == value2_data->value.short_value);
    #####: 2075:                break;
        -: 2076:
    #####: 2077:            case AMQP_TYPE_INT:
        -: 2078:                /* Codes_SRS_AMQPVALUE_01_218: [- int: compare the int32_t content.] */
    #####: 2079:                result = (value1_data->value.int_value == value2_data->value.int_value);
    #####: 2080:                break;
        -: 2081:
    #####: 2082:            case AMQP_TYPE_LONG:
        -: 2083:                /* Codes_SRS_AMQPVALUE_01_219: [- long: compare the int64_t content.] */
    #####: 2084:                result = (value1_data->value.long_value == value2_data->value.long_value);
    #####: 2085:                break;
        -: 2086:
    #####: 2087:            case AMQP_TYPE_FLOAT:
        -: 2088:                /* Codes_SRS_AMQPVALUE_01_224: [- float: compare the float content.] */
    #####: 2089:                result = (value1_data->value.float_value == value2_data->value.float_value);
    #####: 2090:                break;
        -: 2091:
    #####: 2092:            case AMQP_TYPE_DOUBLE:
        -: 2093:                /* Codes_SRS_AMQPVALUE_01_225: [- double: compare the double content.] */
    #####: 2094:                result = (value1_data->value.double_value == value2_data->value.double_value);
    #####: 2095:                break;
        -: 2096:
    #####: 2097:            case AMQP_TYPE_CHAR:
        -: 2098:                /* Codes_SRS_AMQPVALUE_01_226: [- char: compare the UNICODE character.] */
    #####: 2099:                result = (value1_data->value.char_value == value2_data->value.char_value);
    #####: 2100:                break;
        -: 2101:
    #####: 2102:            case AMQP_TYPE_TIMESTAMP:
        -: 2103:                /* Codes_SRS_AMQPVALUE_01_227: [- timestamp: compare the underlying 64 bit integer.] */
    #####: 2104:                result = (value1_data->value.timestamp_value == value2_data->value.timestamp_value);
    #####: 2105:                break;
        -: 2106:
    #####: 2107:            case AMQP_TYPE_UUID:
        -: 2108:                /* Codes_SRS_AMQPVALUE_01_228: [- uuid: compare all uuid bytes.] */
    #####: 2109:                result = (memcmp(value1_data->value.uuid_value, value2_data->value.uuid_value, sizeof(value1_data->value.uuid_value)) == 0);
    #####: 2110:                break;
        -: 2111:
    #####: 2112:            case AMQP_TYPE_BINARY:
        -: 2113:                /* Codes_SRS_AMQPVALUE_01_229: [- binary: compare all binary bytes.] */
    #####: 2114:                result = (value1_data->value.binary_value.length == value2_data->value.binary_value.length) &&
    #####: 2115:                    (memcmp(value1_data->value.binary_value.bytes, value2_data->value.binary_value.bytes, value1_data->value.binary_value.length) == 0);
    #####: 2116:                break;
        -: 2117:
    #####: 2118:            case AMQP_TYPE_STRING:
        -: 2119:                /* Codes_SRS_AMQPVALUE_01_230: [- string: compare all string characters.] */
    #####: 2120:                result = (strcmp(value1_data->value.string_value.chars, value2_data->value.string_value.chars) == 0);
    #####: 2121:                break;
        -: 2122:
    #####: 2123:            case AMQP_TYPE_SYMBOL:
        -: 2124:                /* Codes_SRS_AMQPVALUE_01_263: [- symbol: compare all symbol characters.] */
    #####: 2125:                result = (strcmp(value1_data->value.symbol_value.chars, value2_data->value.symbol_value.chars) == 0);
    #####: 2126:                break;
        -: 2127:
    #####: 2128:            case AMQP_TYPE_LIST:
        -: 2129:            {
        -: 2130:                /* Codes_SRS_AMQPVALUE_01_231: [- list: compare list item count and each element.] */
    #####: 2131:                if (value1_data->value.list_value.count != value2_data->value.list_value.count)
        -: 2132:                {
    #####: 2133:                    result = false;
        -: 2134:                }
        -: 2135:                else
        -: 2136:                {
        -: 2137:                    uint32_t i;
        -: 2138:
    #####: 2139:                    for (i = 0; i < value1_data->value.list_value.count; i++)
        -: 2140:                    {
        -: 2141:                        /* Codes_SRS_AMQPVALUE_01_232: [Nesting shall be considered in comparison.] */
    #####: 2142:                        if (!amqpvalue_are_equal(value1_data->value.list_value.items[i], value2_data->value.list_value.items[i]))
        -: 2143:                        {
    #####: 2144:                            break;
        -: 2145:                        }
        -: 2146:                    }
        -: 2147:
    #####: 2148:                    result = (i == value1_data->value.list_value.count);
        -: 2149:                }
        -: 2150:
    #####: 2151:                break;
        -: 2152:            }
    #####: 2153:            case AMQP_TYPE_ARRAY:
        -: 2154:            {
        -: 2155:                /* Codes_SRS_AMQPVALUE_01_427: [- array: compare array item count and each element. ] */
    #####: 2156:                if (value1_data->value.array_value.count != value2_data->value.array_value.count)
        -: 2157:                {
    #####: 2158:                    result = false;
        -: 2159:                }
        -: 2160:                else
        -: 2161:                {
        -: 2162:                    uint32_t i;
        -: 2163:
    #####: 2164:                    for (i = 0; i < value1_data->value.array_value.count; i++)
        -: 2165:                    {
        -: 2166:                        /* Codes_SRS_AMQPVALUE_01_428: [ Nesting shall be considered in comparison. ] */
    #####: 2167:                        if (!amqpvalue_are_equal(value1_data->value.array_value.items[i], value2_data->value.array_value.items[i]))
        -: 2168:                        {
    #####: 2169:                            break;
        -: 2170:                        }
        -: 2171:                    }
        -: 2172:
    #####: 2173:                    result = (i == value1_data->value.array_value.count);
        -: 2174:                }
        -: 2175:
    #####: 2176:                break;
        -: 2177:            }
    #####: 2178:            case AMQP_TYPE_MAP:
        -: 2179:            {
        -: 2180:                /* Codes_SRS_AMQPVALUE_01_233: [- map: compare map pair count and each key/value pair.] */
    #####: 2181:                if (value1_data->value.map_value.pair_count != value2_data->value.map_value.pair_count)
        -: 2182:                {
    #####: 2183:                    result = false;
        -: 2184:                }
        -: 2185:                else
        -: 2186:                {
        -: 2187:                    uint32_t i;
        -: 2188:
        -: 2189:                    /* Codes_SRS_AMQPVALUE_01_126: [Unless known to be otherwise, maps MUST be considered to be ordered, that is, the order of the key-value pairs is semantically important and two maps which are different only in the order in which their key-value pairs are encoded are not equal.] */
    #####: 2190:                    for (i = 0; i < value1_data->value.map_value.pair_count; i++)
        -: 2191:                    {
        -: 2192:                        /* Codes_SRS_AMQPVALUE_01_234: [Nesting shall be considered in comparison.] */
    #####: 2193:                        if ((!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].key, value2_data->value.map_value.pairs[i].key)) ||
    #####: 2194:                            (!amqpvalue_are_equal(value1_data->value.map_value.pairs[i].value, value2_data->value.map_value.pairs[i].value)))
        -: 2195:                        {
        -: 2196:                            break;
        -: 2197:                        }
        -: 2198:                    }
        -: 2199:
    #####: 2200:                    result = (i == value1_data->value.map_value.pair_count);
        -: 2201:                }
        -: 2202:
    #####: 2203:                break;
        -: 2204:            }
        -: 2205:            }
        -: 2206:        }
        -: 2207:    }
        -: 2208:
    #####: 2209:    return result;
        -: 2210:}
        -: 2211:
       81: 2212:AMQP_VALUE amqpvalue_clone(AMQP_VALUE value)
        -: 2213:{
        -: 2214:    AMQP_VALUE result;
        -: 2215:
       81: 2216:    if (value == NULL)
        -: 2217:    {
        -: 2218:        /* Codes_SRS_AMQPVALUE_01_402: [ If `value` is NULL, `amqpvalue_clone` shall return NULL. ]*/
    #####: 2219:        LogError("NULL value");
    #####: 2220:        result = NULL;
        -: 2221:    }
        -: 2222:    else
        -: 2223:    {
        -: 2224:        /* Codes_SRS_AMQPVALUE_01_235: [amqpvalue_clone shall clone the value passed as argument and return a new non-NULL handle to the cloned AMQP value.] */
       81: 2225:        INC_REF(AMQP_VALUE_DATA, value);
       81: 2226:        result = value;
        -: 2227:    }
        -: 2228:
       81: 2229:    return result;
        -: 2230:}
        -: 2231:
    #####: 2232:AMQP_TYPE amqpvalue_get_type(AMQP_VALUE value)
        -: 2233:{
    #####: 2234:    AMQP_VALUE_DATA* amqpvalue_data = (AMQP_VALUE_DATA*)value;
    #####: 2235:    return amqpvalue_data->type;
        -: 2236:}
        -: 2237:
    #####: 2238:static int output_byte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char b)
        -: 2239:{
        -: 2240:    int result;
        -: 2241:
    #####: 2242:    if (encoder_output != NULL)
        -: 2243:    {
        -: 2244:        /* Codes_SRS_AMQPVALUE_01_267: [amqpvalue_encode shall pass the encoded bytes to the encoder_output function.] */
        -: 2245:        /* Codes_SRS_AMQPVALUE_01_268: [On each call to the encoder_output function, amqpvalue_encode shall also pass the context argument.] */
    #####: 2246:        result = encoder_output(context, &b, 1);
        -: 2247:    }
        -: 2248:    else
        -: 2249:    {
    #####: 2250:        result = 0;
        -: 2251:    }
        -: 2252:
    #####: 2253:    return result;
        -: 2254:}
        -: 2255:
    #####: 2256:static int output_bytes(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const void* bytes, size_t length)
        -: 2257:{
        -: 2258:    int result;
        -: 2259:
    #####: 2260:    if (encoder_output != NULL)
        -: 2261:    {
        -: 2262:        /* Codes_SRS_AMQPVALUE_01_267: [amqpvalue_encode shall pass the encoded bytes to the encoder_output function.] */
        -: 2263:        /* Codes_SRS_AMQPVALUE_01_268: [On each call to the encoder_output function, amqpvalue_encode shall also pass the context argument.] */
    #####: 2264:        result = encoder_output(context, (const unsigned char*)bytes, length);
        -: 2265:    }
        -: 2266:    else
        -: 2267:    {
    #####: 2268:        result = 0;
        -: 2269:    }
        -: 2270:
    #####: 2271:    return result;
        -: 2272:}
        -: 2273:
    #####: 2274:static int encode_null_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2275:{
        -: 2276:    int result;
        -: 2277:
        -: 2278:    /* Codes_SRS_AMQPVALUE_01_264: [<encoding code="0x40" category="fixed" width="0" label="the null value"/>] */
    #####: 2279:    if (output_byte(encoder_output, context, (unsigned char)0x40) != 0)
        -: 2280:    {
        -: 2281:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2282:        LogError("Failed encoding NULL constructor");
    #####: 2283:        result = MU_FAILURE;
        -: 2284:    }
        -: 2285:    else
        -: 2286:    {
        -: 2287:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2288:        result = 0;
        -: 2289:    }
        -: 2290:
    #####: 2291:    return result;
        -: 2292:}
        -: 2293:
    #####: 2294:static int encode_null_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2295:{
    #####: 2296:    int result = 0;
        -: 2297:    (void)encoder_output;
        -: 2298:    (void)context;
        -: 2299:
        -: 2300:    /* Codes_SRS_AMQPVALUE_01_264: [<encoding code="0x40" category="fixed" width="0" label="the null value"/>] */
    #####: 2301:    return result;
        -: 2302:}
        -: 2303:
    #####: 2304:static int encode_null(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2305:{
        -: 2306:    int result;
        -: 2307:
    #####: 2308:    if ((encode_null_constructor(encoder_output, context) != 0) ||
    #####: 2309:        (encode_null_value(encoder_output, context) != 0))
        -: 2310:    {
        -: 2311:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2312:        LogError("Failed encoding NULL");
    #####: 2313:        result = MU_FAILURE;
        -: 2314:    }
        -: 2315:    else
        -: 2316:    {
        -: 2317:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2318:        result = 0;
        -: 2319:    }
        -: 2320:
    #####: 2321:    return result;
        -: 2322:}
        -: 2323:
    #####: 2324:static int encode_boolean_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2325:{
        -: 2326:    int result;
        -: 2327:
        -: 2328:    /* Codes_SRS_AMQPVALUE_01_270: [<encoding code="0x56" category="fixed" width="1" label="boolean with the octet 0x00 being false and octet 0x01 being true"/>] */
    #####: 2329:    if (output_byte(encoder_output, context, 0x56) != 0)
        -: 2330:    {
        -: 2331:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2332:        LogError("Failed encoding boolean constructor");
    #####: 2333:        result = MU_FAILURE;
        -: 2334:    }
        -: 2335:    else
        -: 2336:    {
        -: 2337:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2338:        result = 0;
        -: 2339:    }
        -: 2340:
    #####: 2341:    return result;
        -: 2342:}
        -: 2343:
    #####: 2344:static int encode_boolean_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool value)
        -: 2345:{
        -: 2346:    int result;
        -: 2347:
    #####: 2348:    if (value == false)
        -: 2349:    {
        -: 2350:        /* Codes_SRS_AMQPVALUE_01_270: [<encoding code="0x56" category="fixed" width="1" label="boolean with the octet 0x00 being false and octet 0x01 being true"/>] */
    #####: 2351:        if (output_byte(encoder_output, context, 0x00) != 0)
        -: 2352:        {
        -: 2353:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2354:            LogError("Failed encoding boolean value");
    #####: 2355:            result = MU_FAILURE;
        -: 2356:        }
        -: 2357:        else
        -: 2358:        {
    #####: 2359:            result = 0;
        -: 2360:        }
        -: 2361:    }
        -: 2362:    else
        -: 2363:    {
        -: 2364:        /* Codes_SRS_AMQPVALUE_01_270: [<encoding code="0x56" category="fixed" width="1" label="boolean with the octet 0x00 being false and octet 0x01 being true"/>] */
    #####: 2365:        if (output_byte(encoder_output, context, 0x01) != 0)
        -: 2366:        {
        -: 2367:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2368:            LogError("Failed encoding boolean value");
    #####: 2369:            result = MU_FAILURE;
        -: 2370:        }
        -: 2371:        else
        -: 2372:        {
    #####: 2373:            result = 0;
        -: 2374:        }
        -: 2375:    }
        -: 2376:
    #####: 2377:    return result;
        -: 2378:}
        -: 2379:
    #####: 2380:static int encode_boolean(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool value)
        -: 2381:{
        -: 2382:    int result;
        -: 2383:
    #####: 2384:    if (value == false)
        -: 2385:    {
        -: 2386:        /* Codes_SRS_AMQPVALUE_01_273: [<encoding name="false" code="0x42" category="fixed" width="0" label="the boolean value false"/>] */
    #####: 2387:        if (output_byte(encoder_output, context, 0x42) != 0)
        -: 2388:        {
        -: 2389:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2390:            LogError("Failed encoding boolean");
    #####: 2391:            result = MU_FAILURE;
        -: 2392:        }
        -: 2393:        else
        -: 2394:        {
    #####: 2395:            result = 0;
        -: 2396:        }
        -: 2397:    }
        -: 2398:    else
        -: 2399:    {
        -: 2400:        /* Codes_SRS_AMQPVALUE_01_272: [<encoding name="true" code="0x41" category="fixed" width="0" label="the boolean value true"/>] */
    #####: 2401:        if (output_byte(encoder_output, context, 0x41) != 0)
        -: 2402:        {
        -: 2403:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2404:            LogError("Failed encoding boolean");
    #####: 2405:            result = MU_FAILURE;
        -: 2406:        }
        -: 2407:        else
        -: 2408:        {
    #####: 2409:            result = 0;
        -: 2410:        }
        -: 2411:    }
        -: 2412:
    #####: 2413:    return result;
        -: 2414:}
        -: 2415:
    #####: 2416:static int encode_ubyte_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2417:{
        -: 2418:    int result;
        -: 2419:
        -: 2420:    /* Codes_SRS_AMQPVALUE_01_275: [<encoding code="0x50" category="fixed" width="1" label="8-bit unsigned integer"/>] */
    #####: 2421:    if (output_byte(encoder_output, context, 0x50) != 0)
        -: 2422:    {
        -: 2423:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2424:        LogError("Failed encoding ubyte constructor");
    #####: 2425:        result = MU_FAILURE;
        -: 2426:    }
        -: 2427:    else
        -: 2428:    {
        -: 2429:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2430:        result = 0;
        -: 2431:    }
        -: 2432:
    #####: 2433:    return result;
        -: 2434:}
        -: 2435:
    #####: 2436:static int encode_ubyte_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char value)
        -: 2437:{
        -: 2438:    int result;
        -: 2439:
        -: 2440:    /* Codes_SRS_AMQPVALUE_01_275: [<encoding code="0x50" category="fixed" width="1" label="8-bit unsigned integer"/>] */
    #####: 2441:    if (output_byte(encoder_output, context, value) != 0)
        -: 2442:    {
        -: 2443:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2444:        LogError("Failed encoding ubyte value");
    #####: 2445:        result = MU_FAILURE;
        -: 2446:    }
        -: 2447:    else
        -: 2448:    {
        -: 2449:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2450:        result = 0;
        -: 2451:    }
        -: 2452:
    #####: 2453:    return result;
        -: 2454:}
        -: 2455:
    #####: 2456:static int encode_ubyte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, unsigned char value)
        -: 2457:{
        -: 2458:    int result;
        -: 2459:
    #####: 2460:    if ((encode_ubyte_constructor(encoder_output, context) != 0) ||
    #####: 2461:        (encode_ubyte_value(encoder_output, context, value) != 0))
        -: 2462:    {
        -: 2463:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2464:        LogError("Failed encoding ubyte");
    #####: 2465:        result = MU_FAILURE;
        -: 2466:    }
        -: 2467:    else
        -: 2468:    {
        -: 2469:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2470:        result = 0;
        -: 2471:    }
        -: 2472:
    #####: 2473:    return result;
        -: 2474:}
        -: 2475:
    #####: 2476:static int encode_ushort_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2477:{
        -: 2478:    int result;
        -: 2479:
        -: 2480:    /* Codes_SRS_AMQPVALUE_01_276: [<encoding code="0x60" category="fixed" width="2" label="16-bit unsigned integer in network byte order"/>] */
    #####: 2481:    if (output_byte(encoder_output, context, 0x60) != 0)
        -: 2482:    {
        -: 2483:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2484:        LogError("Failed encoding ushort constructor");
    #####: 2485:        result = MU_FAILURE;
        -: 2486:    }
        -: 2487:    else
        -: 2488:    {
        -: 2489:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2490:        result = 0;
        -: 2491:    }
        -: 2492:
    #####: 2493:    return result;
        -: 2494:}
        -: 2495:
    #####: 2496:static int encode_ushort_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint16_t value)
        -: 2497:{
        -: 2498:    int result;
        -: 2499:
        -: 2500:    /* Codes_SRS_AMQPVALUE_01_276: [<encoding code="0x60" category="fixed" width="2" label="16-bit unsigned integer in network byte order"/>] */
    #####: 2501:    if ((output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 2502:        (output_byte(encoder_output, context, (value & 0xFF)) != 0))
        -: 2503:    {
        -: 2504:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2505:        LogError("Failed encoding ushort value");
    #####: 2506:        result = MU_FAILURE;
        -: 2507:    }
        -: 2508:    else
        -: 2509:    {
        -: 2510:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2511:        result = 0;
        -: 2512:    }
        -: 2513:
    #####: 2514:    return result;
        -: 2515:}
        -: 2516:
    #####: 2517:static int encode_ushort(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint16_t value)
        -: 2518:{
        -: 2519:    int result;
        -: 2520:
    #####: 2521:    if ((encode_ushort_constructor(encoder_output, context) != 0) ||
    #####: 2522:        (encode_ushort_value(encoder_output, context, value) != 0))
        -: 2523:    {
        -: 2524:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2525:        LogError("Failed encoding ushort");
    #####: 2526:        result = MU_FAILURE;
        -: 2527:    }
        -: 2528:    else
        -: 2529:    {
        -: 2530:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2531:        result = 0;
        -: 2532:    }
        -: 2533:
    #####: 2534:    return result;
        -: 2535:}
        -: 2536:
    #####: 2537:static int encode_uint_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 2538:{
        -: 2539:    int result;
        -: 2540:
    #####: 2541:    if (use_smallest)
        -: 2542:    {
        -: 2543:        /* smalluint */
        -: 2544:        /* Codes_SRS_AMQPVALUE_01_278: [<encoding name="smalluint" code="0x52" category="fixed" width="1" label="unsigned integer value in the range 0 to 255 inclusive"/>] */
    #####: 2545:        if (output_byte(encoder_output, context, 0x52) != 0)
        -: 2546:        {
        -: 2547:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2548:            LogError("Failed encoding small uint constructor");
    #####: 2549:            result = MU_FAILURE;
        -: 2550:        }
        -: 2551:        else
        -: 2552:        {
        -: 2553:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2554:            result = 0;
        -: 2555:        }
        -: 2556:    }
        -: 2557:    else
        -: 2558:    {
        -: 2559:        /* Codes_SRS_AMQPVALUE_01_277: [<encoding code="0x70" category="fixed" width="4" label="32-bit unsigned integer in network byte order"/>] */
    #####: 2560:        if (output_byte(encoder_output, context, 0x70) != 0)
        -: 2561:        {
        -: 2562:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2563:            LogError("Failed encoding uint constructor");
    #####: 2564:            result = MU_FAILURE;
        -: 2565:        }
        -: 2566:        else
        -: 2567:        {
        -: 2568:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2569:            result = 0;
        -: 2570:        }
        -: 2571:    }
        -: 2572:
    #####: 2573:    return result;
        -: 2574:}
        -: 2575:
    #####: 2576:static int encode_uint_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t value, bool use_smallest)
        -: 2577:{
        -: 2578:    int result;
        -: 2579:
    #####: 2580:    if (use_smallest)
        -: 2581:    {
        -: 2582:        /* smalluint */
        -: 2583:        /* Codes_SRS_AMQPVALUE_01_278: [<encoding name="smalluint" code="0x52" category="fixed" width="1" label="unsigned integer value in the range 0 to 255 inclusive"/>] */
    #####: 2584:        if (output_byte(encoder_output, context, value & 0xFF) != 0)
        -: 2585:        {
        -: 2586:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2587:            LogError("Failed encoding small uint value");
    #####: 2588:            result = MU_FAILURE;
        -: 2589:        }
        -: 2590:        else
        -: 2591:        {
        -: 2592:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2593:            result = 0;
        -: 2594:        }
        -: 2595:    }
        -: 2596:    else
        -: 2597:    {
        -: 2598:        /* Codes_SRS_AMQPVALUE_01_277: [<encoding code="0x70" category="fixed" width="4" label="32-bit unsigned integer in network byte order"/>] */
    #####: 2599:        if ((output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||
    #####: 2600:            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||
    #####: 2601:            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 2602:            (output_byte(encoder_output, context, value & 0xFF) != 0))
        -: 2603:        {
        -: 2604:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2605:            LogError("Failed encoding uint value");
    #####: 2606:            result = MU_FAILURE;
        -: 2607:        }
        -: 2608:        else
        -: 2609:        {
        -: 2610:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2611:            result = 0;
        -: 2612:        }
        -: 2613:    }
        -: 2614:
    #####: 2615:    return result;
        -: 2616:}
        -: 2617:
    #####: 2618:static int encode_uint(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t value)
        -: 2619:{
        -: 2620:    int result;
        -: 2621:
    #####: 2622:    if (value == 0)
        -: 2623:    {
        -: 2624:        /* uint0 */
        -: 2625:        /* Codes_SRS_AMQPVALUE_01_279: [<encoding name="uint0" code="0x43" category="fixed" width="0" label="the uint value 0"/>] */
    #####: 2626:        if (output_byte(encoder_output, context, 0x43) != 0)
        -: 2627:        {
    #####: 2628:            LogError("Failed encoding uint");
    #####: 2629:            result = MU_FAILURE;
        -: 2630:        }
        -: 2631:        else
        -: 2632:        {
        -: 2633:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2634:            result = 0;
        -: 2635:        }
        -: 2636:    }
        -: 2637:    else
        -: 2638:    {
    #####: 2639:        bool use_smallest = (value <= 255);
        -: 2640:
    #####: 2641:        if ((encode_uint_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 2642:            (encode_uint_value(encoder_output, context, value, use_smallest) != 0))
        -: 2643:        {
        -: 2644:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2645:            LogError("Failed encoding uint");
    #####: 2646:            result = MU_FAILURE;
        -: 2647:        }
        -: 2648:        else
        -: 2649:        {
        -: 2650:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2651:            result = 0;
        -: 2652:        }
        -: 2653:    }
        -: 2654:
    #####: 2655:    return result;
        -: 2656:}
        -: 2657:
    #####: 2658:static int encode_ulong_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 2659:{
        -: 2660:    int result;
        -: 2661:
    #####: 2662:    if (use_smallest)
        -: 2663:    {
        -: 2664:        /* smallulong */
        -: 2665:        /* Codes_SRS_AMQPVALUE_01_281: [<encoding name="smallulong" code="0x53" category="fixed" width="1" label="unsigned long value in the range 0 to 255 inclusive"/>] */
    #####: 2666:        if (output_byte(encoder_output, context, 0x53) != 0)
        -: 2667:        {
        -: 2668:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2669:            LogError("Failed encoding small ulong constructor");
    #####: 2670:            result = MU_FAILURE;
        -: 2671:        }
        -: 2672:        else
        -: 2673:        {
        -: 2674:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2675:            result = 0;
        -: 2676:        }
        -: 2677:    }
        -: 2678:    else
        -: 2679:    {
        -: 2680:        /* Codes_SRS_AMQPVALUE_01_280: [<encoding code="0x80" category="fixed" width="8" label="64-bit unsigned integer in network byte order"/>] */
    #####: 2681:        if (output_byte(encoder_output, context, 0x80) != 0)
        -: 2682:        {
        -: 2683:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2684:            LogError("Failed encoding ulong constructor");
    #####: 2685:            result = MU_FAILURE;
        -: 2686:        }
        -: 2687:        else
        -: 2688:        {
        -: 2689:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2690:            result = 0;
        -: 2691:        }
        -: 2692:    }
        -: 2693:
    #####: 2694:    return result;
        -: 2695:}
        -: 2696:
    #####: 2697:static int encode_ulong_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint64_t value, bool use_smallest)
        -: 2698:{
        -: 2699:    int result;
        -: 2700:
    #####: 2701:    if (use_smallest)
        -: 2702:    {
        -: 2703:        /* smallulong */
        -: 2704:        /* Codes_SRS_AMQPVALUE_01_281: [<encoding name="smallulong" code="0x53" category="fixed" width="1" label="unsigned long value in the range 0 to 255 inclusive"/>] */
    #####: 2705:        if (output_byte(encoder_output, context, value & 0xFF) != 0)
        -: 2706:        {
        -: 2707:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2708:            LogError("Failed encoding small ulong value");
    #####: 2709:            result = MU_FAILURE;
        -: 2710:        }
        -: 2711:        else
        -: 2712:        {
        -: 2713:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2714:            result = 0;
        -: 2715:        }
        -: 2716:    }
        -: 2717:    else
        -: 2718:    {
        -: 2719:        /* Codes_SRS_AMQPVALUE_01_280: [<encoding code="0x80" category="fixed" width="8" label="64-bit unsigned integer in network byte order"/>] */
    #####: 2720:        if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||
    #####: 2721:            (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||
    #####: 2722:            (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||
    #####: 2723:            (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||
    #####: 2724:            (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||
    #####: 2725:            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||
    #####: 2726:            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 2727:            (output_byte(encoder_output, context, value & 0xFF) != 0))
        -: 2728:        {
        -: 2729:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2730:            LogError("Failed encoding ulong value");
    #####: 2731:            result = MU_FAILURE;
        -: 2732:        }
        -: 2733:        else
        -: 2734:        {
        -: 2735:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2736:            result = 0;
        -: 2737:        }
        -: 2738:    }
        -: 2739:
    #####: 2740:    return result;
        -: 2741:}
        -: 2742:
    #####: 2743:static int encode_ulong(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint64_t value)
        -: 2744:{
        -: 2745:    int result;
    #####: 2746:    if (value == 0)
        -: 2747:    {
        -: 2748:        /* ulong0 */
        -: 2749:        /* Codes_SRS_AMQPVALUE_01_282: [<encoding name="ulong0" code="0x44" category="fixed" width="0" label="the ulong value 0"/>] */
    #####: 2750:        if (output_byte(encoder_output, context, 0x44) != 0)
        -: 2751:        {
        -: 2752:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2753:            LogError("Failed encoding ulong");
    #####: 2754:            result = MU_FAILURE;
        -: 2755:        }
        -: 2756:        else
        -: 2757:        {
        -: 2758:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2759:            result = 0;
        -: 2760:        }
        -: 2761:    }
        -: 2762:    else
        -: 2763:    {
    #####: 2764:        bool use_smallest = (value <= 255);
        -: 2765:
    #####: 2766:        if ((encode_ulong_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 2767:            (encode_ulong_value(encoder_output, context, value, use_smallest) != 0))
        -: 2768:        {
        -: 2769:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2770:            LogError("Failed encoding ulong");
    #####: 2771:            result = MU_FAILURE;
        -: 2772:        }
        -: 2773:        else
        -: 2774:        {
        -: 2775:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2776:            result = 0;
        -: 2777:        }
        -: 2778:    }
        -: 2779:
    #####: 2780:    return result;
        -: 2781:}
        -: 2782:
    #####: 2783:static int encode_byte_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2784:{
        -: 2785:    int result;
        -: 2786:
        -: 2787:    /* Codes_SRS_AMQPVALUE_01_283: [<encoding code="0x51" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 2788:    if (output_byte(encoder_output, context, 0x51) != 0)
        -: 2789:    {
        -: 2790:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2791:        LogError("Failed encoding byte constructor");
    #####: 2792:        result = MU_FAILURE;
        -: 2793:    }
        -: 2794:    else
        -: 2795:    {
        -: 2796:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2797:        result = 0;
        -: 2798:    }
        -: 2799:
    #####: 2800:    return result;
        -: 2801:}
        -: 2802:
    #####: 2803:static int encode_byte_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, char value)
        -: 2804:{
        -: 2805:    int result;
        -: 2806:
        -: 2807:    /* Codes_SRS_AMQPVALUE_01_283: [<encoding code="0x51" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 2808:    if (output_byte(encoder_output, context, value) != 0)
        -: 2809:    {
        -: 2810:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2811:        LogError("Failed encoding byte value");
    #####: 2812:        result = MU_FAILURE;
        -: 2813:    }
        -: 2814:    else
        -: 2815:    {
        -: 2816:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2817:        result = 0;
        -: 2818:    }
        -: 2819:
    #####: 2820:    return result;
        -: 2821:}
        -: 2822:
    #####: 2823:static int encode_byte(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, char value)
        -: 2824:{
        -: 2825:    int result;
        -: 2826:
    #####: 2827:    if ((encode_byte_constructor(encoder_output, context) != 0) ||
    #####: 2828:        (encode_byte_value(encoder_output, context, value) != 0))
        -: 2829:    {
        -: 2830:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2831:        LogError("Failed encoding byte");
    #####: 2832:        result = MU_FAILURE;
        -: 2833:    }
        -: 2834:    else
        -: 2835:    {
        -: 2836:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2837:        result = 0;
        -: 2838:    }
        -: 2839:
    #####: 2840:    return result;
        -: 2841:}
        -: 2842:
    #####: 2843:static int encode_short_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 2844:{
        -: 2845:    int result;
        -: 2846:
        -: 2847:    /* Codes_SRS_AMQPVALUE_01_284: [<encoding code="0x61" category="fixed" width="2" label="16-bit two's-complement integer in network byte order"/>] */
    #####: 2848:    if (output_byte(encoder_output, context, 0x61) != 0)
        -: 2849:    {
        -: 2850:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2851:        LogError("Failed encoding short constructor");
    #####: 2852:        result = MU_FAILURE;
        -: 2853:    }
        -: 2854:    else
        -: 2855:    {
        -: 2856:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2857:        result = 0;
        -: 2858:    }
        -: 2859:
    #####: 2860:    return result;
        -: 2861:}
        -: 2862:
    #####: 2863:static int encode_short_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int16_t value)
        -: 2864:{
        -: 2865:    int result;
        -: 2866:
        -: 2867:    /* Codes_SRS_AMQPVALUE_01_284: [<encoding code="0x61" category="fixed" width="2" label="16-bit two's-complement integer in network byte order"/>] */
    #####: 2868:    if ((output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 2869:        (output_byte(encoder_output, context, (value & 0xFF)) != 0))
        -: 2870:    {
        -: 2871:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2872:        LogError("Failed encoding short value");
    #####: 2873:        result = MU_FAILURE;
        -: 2874:    }
        -: 2875:    else
        -: 2876:    {
        -: 2877:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2878:        result = 0;
        -: 2879:    }
        -: 2880:
    #####: 2881:    return result;
        -: 2882:}
        -: 2883:
    #####: 2884:static int encode_short(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int16_t value)
        -: 2885:{
        -: 2886:    int result;
        -: 2887:
    #####: 2888:    if ((encode_short_constructor(encoder_output, context) != 0) ||
    #####: 2889:        (encode_short_value(encoder_output, context, value) != 0))
        -: 2890:    {
        -: 2891:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2892:        LogError("Failed encoding short");
    #####: 2893:        result = MU_FAILURE;
        -: 2894:    }
        -: 2895:    else
        -: 2896:    {
        -: 2897:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2898:        result = 0;
        -: 2899:    }
        -: 2900:
    #####: 2901:    return result;
        -: 2902:}
        -: 2903:
    #####: 2904:static int encode_int_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 2905:{
        -: 2906:    int result;
        -: 2907:
    #####: 2908:    if (use_smallest)
        -: 2909:    {
        -: 2910:        /* Codes_SRS_AMQPVALUE_01_286: [<encoding name="smallint" code="0x54" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 2911:        if (output_byte(encoder_output, context, 0x54) != 0)
        -: 2912:        {
        -: 2913:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2914:            LogError("Failed encoding small int constructor");
    #####: 2915:            result = MU_FAILURE;
        -: 2916:        }
        -: 2917:        else
        -: 2918:        {
        -: 2919:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2920:            result = 0;
        -: 2921:        }
        -: 2922:    }
        -: 2923:    else
        -: 2924:    {
        -: 2925:        /* Codes_SRS_AMQPVALUE_01_285: [<encoding code="0x71" category="fixed" width="4" label="32-bit two's-complement integer in network byte order"/>] */
    #####: 2926:        if (output_byte(encoder_output, context, 0x71) != 0)
        -: 2927:        {
        -: 2928:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2929:            LogError("Failed encoding int constructor");
    #####: 2930:            result = MU_FAILURE;
        -: 2931:        }
        -: 2932:        else
        -: 2933:        {
        -: 2934:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2935:            result = 0;
        -: 2936:        }
        -: 2937:    }
        -: 2938:
    #####: 2939:    return result;
        -: 2940:}
        -: 2941:
    #####: 2942:static int encode_int_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int32_t value, bool use_smallest)
        -: 2943:{
        -: 2944:    int result;
        -: 2945:
    #####: 2946:    if (use_smallest)
        -: 2947:    {
        -: 2948:        /* Codes_SRS_AMQPVALUE_01_286: [<encoding name="smallint" code="0x54" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 2949:        if (output_byte(encoder_output, context, value & 0xFF) != 0)
        -: 2950:        {
        -: 2951:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2952:            LogError("Failed encoding small int value");
    #####: 2953:            result = MU_FAILURE;
        -: 2954:        }
        -: 2955:        else
        -: 2956:        {
        -: 2957:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2958:            result = 0;
        -: 2959:        }
        -: 2960:    }
        -: 2961:    else
        -: 2962:    {
        -: 2963:        /* Codes_SRS_AMQPVALUE_01_285: [<encoding code="0x71" category="fixed" width="4" label="32-bit two's-complement integer in network byte order"/>] */
    #####: 2964:        if ((output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||
    #####: 2965:            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||
    #####: 2966:            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 2967:            (output_byte(encoder_output, context, value & 0xFF) != 0))
        -: 2968:        {
        -: 2969:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2970:            LogError("Failed encoding int value");
    #####: 2971:            result = MU_FAILURE;
        -: 2972:        }
        -: 2973:        else
        -: 2974:        {
        -: 2975:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2976:            result = 0;
        -: 2977:        }
        -: 2978:    }
        -: 2979:
    #####: 2980:    return result;
        -: 2981:}
        -: 2982:
    #####: 2983:static int encode_int(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int32_t value)
        -: 2984:{
        -: 2985:    int result;
    #####: 2986:    bool use_smallest = ((value <= 127) && (value >= -128));
        -: 2987:
    #####: 2988:    if ((encode_int_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 2989:        (encode_int_value(encoder_output, context, value, use_smallest) != 0))
        -: 2990:    {
        -: 2991:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 2992:        LogError("Failed encoding int");
    #####: 2993:        result = MU_FAILURE;
        -: 2994:    }
        -: 2995:    else
        -: 2996:    {
        -: 2997:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 2998:        result = 0;
        -: 2999:    }
        -: 3000:
    #####: 3001:    return result;
        -: 3002:}
        -: 3003:
    #####: 3004:static int encode_long_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 3005:{
        -: 3006:    int result;
        -: 3007:
    #####: 3008:    if (use_smallest)
        -: 3009:    {
        -: 3010:        /* Codes_SRS_AMQPVALUE_01_288: [<encoding name="smalllong" code="0x55" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 3011:        if (output_byte(encoder_output, context, 0x55) != 0)
        -: 3012:        {
        -: 3013:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3014:            LogError("Failed encoding small long constructor");
    #####: 3015:            result = MU_FAILURE;
        -: 3016:        }
        -: 3017:        else
        -: 3018:        {
        -: 3019:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3020:            result = 0;
        -: 3021:        }
        -: 3022:    }
        -: 3023:    else
        -: 3024:    {
        -: 3025:        /* Codes_SRS_AMQPVALUE_01_287: [<encoding code="0x81" category="fixed" width="8" label="64-bit two's-complement integer in network byte order"/>] */
    #####: 3026:        if (output_byte(encoder_output, context, 0x81) != 0)
        -: 3027:        {
        -: 3028:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3029:            LogError("Failed encoding long constructor");
    #####: 3030:            result = MU_FAILURE;
        -: 3031:        }
        -: 3032:        else
        -: 3033:        {
        -: 3034:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3035:            result = 0;
        -: 3036:        }
        -: 3037:    }
        -: 3038:
    #####: 3039:    return result;
        -: 3040:}
        -: 3041:
    #####: 3042:static int encode_long_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value, bool use_smallest)
        -: 3043:{
        -: 3044:    int result;
        -: 3045:
    #####: 3046:    if (use_smallest)
        -: 3047:    {
        -: 3048:        /* Codes_SRS_AMQPVALUE_01_288: [<encoding name="smalllong" code="0x55" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 3049:        if (output_byte(encoder_output, context, value & 0xFF) != 0)
        -: 3050:        {
        -: 3051:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3052:            LogError("Failed encoding small long value");
    #####: 3053:            result = MU_FAILURE;
        -: 3054:        }
        -: 3055:        else
        -: 3056:        {
        -: 3057:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3058:            result = 0;
        -: 3059:        }
        -: 3060:    }
        -: 3061:    else
        -: 3062:    {
        -: 3063:        /* Codes_SRS_AMQPVALUE_01_287: [<encoding code="0x81" category="fixed" width="8" label="64-bit two's-complement integer in network byte order"/>] */
    #####: 3064:        if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||
    #####: 3065:            (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||
    #####: 3066:            (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||
    #####: 3067:            (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||
    #####: 3068:            (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||
    #####: 3069:            (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||
    #####: 3070:            (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 3071:            (output_byte(encoder_output, context, value & 0xFF) != 0))
        -: 3072:        {
        -: 3073:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3074:            LogError("Failed encoding long value");
    #####: 3075:            result = MU_FAILURE;
        -: 3076:        }
        -: 3077:        else
        -: 3078:        {
        -: 3079:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3080:            result = 0;
        -: 3081:        }
        -: 3082:    }
        -: 3083:
    #####: 3084:    return result;
        -: 3085:}
        -: 3086:
    #####: 3087:static int encode_long(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)
        -: 3088:{
        -: 3089:    int result;
    #####: 3090:    bool use_smallest = ((value <= 127) && (value >= -128));
        -: 3091:
    #####: 3092:    if ((encode_long_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 3093:        (encode_long_value(encoder_output, context, value, use_smallest) != 0))
        -: 3094:    {
        -: 3095:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3096:        LogError("Failed encoding long");
    #####: 3097:        result = MU_FAILURE;
        -: 3098:    }
        -: 3099:    else
        -: 3100:    {
        -: 3101:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3102:        result = 0;
        -: 3103:    }
        -: 3104:
    #####: 3105:    return result;
        -: 3106:}
        -: 3107:
    #####: 3108:static int encode_float_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 3109:{
        -: 3110:    int result;
        -: 3111:
        -: 3112:    /* Codes_SRS_AMQPVALUE_01_289: [\<encoding name="ieee-754" code="0x72" category="fixed" width="4" label="IEEE 754-2008 binary32"/>] */
    #####: 3113:    if (output_byte(encoder_output, context, 0x72) != 0)
        -: 3114:    {
        -: 3115:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3116:        LogError("Failure encoding constructor for float");
    #####: 3117:        result = MU_FAILURE;
        -: 3118:    }
        -: 3119:    else
        -: 3120:    {
        -: 3121:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3122:        result = 0;
        -: 3123:    }
        -: 3124:
    #####: 3125:    return result;
        -: 3126:}
        -: 3127:
    #####: 3128:static int encode_float_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, float value)
        -: 3129:{
        -: 3130:    int result;
        -: 3131:
    #####: 3132:    uint32_t value_as_uint32 = *((uint32_t*)(void*)&value);
        -: 3133:    /* Codes_SRS_AMQPVALUE_01_289: [\<encoding name="ieee-754" code="0x72" category="fixed" width="4" label="IEEE 754-2008 binary32"/>] */
    #####: 3134:    if ((output_byte(encoder_output, context, (value_as_uint32 >> 24) & 0xFF) != 0) ||
    #####: 3135:        (output_byte(encoder_output, context, (value_as_uint32 >> 16) & 0xFF) != 0) ||
    #####: 3136:        (output_byte(encoder_output, context, (value_as_uint32 >> 8) & 0xFF) != 0) ||
    #####: 3137:        (output_byte(encoder_output, context, (value_as_uint32) & 0xFF) != 0))
        -: 3138:    {
        -: 3139:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3140:        LogError("Failure encoding bytes for float");
    #####: 3141:        result = MU_FAILURE;
        -: 3142:    }
        -: 3143:    else
        -: 3144:    {
        -: 3145:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3146:        result = 0;
        -: 3147:    }
        -: 3148:
    #####: 3149:    return result;
        -: 3150:}
        -: 3151:
    #####: 3152:static int encode_float(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, float value)
        -: 3153:{
        -: 3154:    int result;
        -: 3155:
    #####: 3156:    if ((encode_float_constructor(encoder_output, context) != 0) ||
    #####: 3157:        (encode_float_value(encoder_output, context, value) != 0))
        -: 3158:    {
        -: 3159:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3160:        LogError("Failure encoding float value");
    #####: 3161:        result = MU_FAILURE;
        -: 3162:    }
        -: 3163:    else
        -: 3164:    {
        -: 3165:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3166:        result = 0;
        -: 3167:    }
        -: 3168:
    #####: 3169:    return result;
        -: 3170:}
        -: 3171:
    #####: 3172:static int encode_double_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 3173:{
        -: 3174:    int result;
        -: 3175:
        -: 3176:    /* Codes_SRS_AMQPVALUE_01_290: [\<encoding name="ieee-754" code="0x82" category="fixed" width="8" label="IEEE 754-2008 binary64"/>] */
    #####: 3177:    if (output_byte(encoder_output, context, 0x82) != 0)
        -: 3178:    {
        -: 3179:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3180:        LogError("Failure encoding constructor for double");
    #####: 3181:        result = MU_FAILURE;
        -: 3182:    }
        -: 3183:    else
        -: 3184:    {
        -: 3185:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3186:        result = 0;
        -: 3187:    }
        -: 3188:
    #####: 3189:    return result;
        -: 3190:}
        -: 3191:
    #####: 3192:static int encode_double_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, double value)
        -: 3193:{
        -: 3194:    int result;
        -: 3195:
    #####: 3196:    uint64_t value_as_uint64 = *((uint64_t*)(void*)&value);
        -: 3197:    /* Codes_SRS_AMQPVALUE_01_290: [\<encoding name="ieee-754" code="0x82" category="fixed" width="8" label="IEEE 754-2008 binary64"/>] */
    #####: 3198:    if ((output_byte(encoder_output, context, (value_as_uint64 >> 56) & 0xFF) != 0) ||
    #####: 3199:        (output_byte(encoder_output, context, (value_as_uint64 >> 48) & 0xFF) != 0) ||
    #####: 3200:        (output_byte(encoder_output, context, (value_as_uint64 >> 40) & 0xFF) != 0) ||
    #####: 3201:        (output_byte(encoder_output, context, (value_as_uint64 >> 32) & 0xFF) != 0) ||
    #####: 3202:        (output_byte(encoder_output, context, (value_as_uint64 >> 24) & 0xFF) != 0) ||
    #####: 3203:        (output_byte(encoder_output, context, (value_as_uint64 >> 16) & 0xFF) != 0) ||
    #####: 3204:        (output_byte(encoder_output, context, (value_as_uint64 >> 8) & 0xFF) != 0) ||
    #####: 3205:        (output_byte(encoder_output, context, (value_as_uint64) & 0xFF) != 0))
        -: 3206:    {
        -: 3207:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3208:        LogError("Failure encoding bytes for double");
    #####: 3209:        result = MU_FAILURE;
        -: 3210:    }
        -: 3211:    else
        -: 3212:    {
        -: 3213:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3214:        result = 0;
        -: 3215:    }
        -: 3216:
    #####: 3217:    return result;
        -: 3218:}
        -: 3219:
    #####: 3220:static int encode_double(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, double value)
        -: 3221:{
        -: 3222:    int result;
        -: 3223:
    #####: 3224:    if ((encode_double_constructor(encoder_output, context) != 0) ||
    #####: 3225:        (encode_double_value(encoder_output, context, value) != 0))
        -: 3226:    {
        -: 3227:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3228:        LogError("Failure encoding double value");
    #####: 3229:        result = MU_FAILURE;
        -: 3230:    }
        -: 3231:    else
        -: 3232:    {
        -: 3233:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3234:        result = 0;
        -: 3235:    }
        -: 3236:
    #####: 3237:    return result;
        -: 3238:}
        -: 3239:
    #####: 3240:static int encode_timestamp_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 3241:{
        -: 3242:    int result;
        -: 3243:
        -: 3244:    /* Codes_SRS_AMQPVALUE_01_295: [<encoding name="ms64" code="0x83" category="fixed" width="8" label="64-bit two's-complement integer representing milliseconds since the unix epoch"/>] */
    #####: 3245:    if (output_byte(encoder_output, context, 0x83) != 0)
        -: 3246:    {
        -: 3247:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3248:        LogError("Failed encoding timestamp constructor");
    #####: 3249:        result = MU_FAILURE;
        -: 3250:    }
        -: 3251:    else
        -: 3252:    {
        -: 3253:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3254:        result = 0;
        -: 3255:    }
        -: 3256:
    #####: 3257:    return result;
        -: 3258:}
        -: 3259:
    #####: 3260:static int encode_timestamp_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)
        -: 3261:{
        -: 3262:    int result;
        -: 3263:
        -: 3264:    /* Codes_SRS_AMQPVALUE_01_295: [<encoding name="ms64" code="0x83" category="fixed" width="8" label="64-bit two's-complement integer representing milliseconds since the unix epoch"/>] */
    #####: 3265:    if ((output_byte(encoder_output, context, (value >> 56) & 0xFF) != 0) ||
    #####: 3266:        (output_byte(encoder_output, context, (value >> 48) & 0xFF) != 0) ||
    #####: 3267:        (output_byte(encoder_output, context, (value >> 40) & 0xFF) != 0) ||
    #####: 3268:        (output_byte(encoder_output, context, (value >> 32) & 0xFF) != 0) ||
    #####: 3269:        (output_byte(encoder_output, context, (value >> 24) & 0xFF) != 0) ||
    #####: 3270:        (output_byte(encoder_output, context, (value >> 16) & 0xFF) != 0) ||
    #####: 3271:        (output_byte(encoder_output, context, (value >> 8) & 0xFF) != 0) ||
    #####: 3272:        (output_byte(encoder_output, context, value & 0xFF) != 0))
        -: 3273:    {
        -: 3274:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3275:        LogError("Failed encoding timestamp value");
    #####: 3276:        result = MU_FAILURE;
        -: 3277:    }
        -: 3278:    else
        -: 3279:    {
        -: 3280:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3281:        result = 0;
        -: 3282:    }
        -: 3283:
    #####: 3284:    return result;
        -: 3285:}
        -: 3286:
    #####: 3287:static int encode_timestamp(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, int64_t value)
        -: 3288:{
        -: 3289:    int result;
        -: 3290:
    #####: 3291:    if ((encode_timestamp_constructor(encoder_output, context) != 0) ||
    #####: 3292:        (encode_timestamp_value(encoder_output, context, value) != 0))
        -: 3293:    {
        -: 3294:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3295:        LogError("Failed encoding timestamp");
    #####: 3296:        result = MU_FAILURE;
        -: 3297:    }
        -: 3298:    else
        -: 3299:    {
        -: 3300:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3301:        result = 0;
        -: 3302:    }
        -: 3303:
    #####: 3304:    return result;
        -: 3305:}
        -: 3306:
    #####: 3307:static int encode_uuid_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 3308:{
        -: 3309:    int result;
        -: 3310:
        -: 3311:    /* Codes_SRS_AMQPVALUE_01_296: [<encoding code="0x98" category="fixed" width="16" label="UUID as defined in section 4.1.2 of RFC-4122"/>] */
    #####: 3312:    if (output_byte(encoder_output, context, 0x98) != 0)
        -: 3313:    {
        -: 3314:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3315:        LogError("Failed encoding uuid constructor");
    #####: 3316:        result = MU_FAILURE;
        -: 3317:    }
        -: 3318:    else
        -: 3319:    {
        -: 3320:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3321:        result = 0;
        -: 3322:    }
        -: 3323:
    #####: 3324:    return result;
        -: 3325:}
        -: 3326:
    #####: 3327:static int encode_uuid_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uuid uuid)
        -: 3328:{
        -: 3329:    int result;
        -: 3330:
        -: 3331:    /* Codes_SRS_AMQPVALUE_01_296: [<encoding code="0x98" category="fixed" width="16" label="UUID as defined in section 4.1.2 of RFC-4122"/>] */
    #####: 3332:    if (output_bytes(encoder_output, context, uuid, 16)  != 0)
        -: 3333:    {
        -: 3334:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3335:        LogError("Failed encoding uuid value");
    #####: 3336:        result = MU_FAILURE;
        -: 3337:    }
        -: 3338:    else
        -: 3339:    {
        -: 3340:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3341:        result = 0;
        -: 3342:    }
        -: 3343:
    #####: 3344:    return result;
        -: 3345:}
        -: 3346:
    #####: 3347:static int encode_uuid(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uuid uuid)
        -: 3348:{
        -: 3349:    int result;
        -: 3350:
    #####: 3351:    if ((encode_uuid_constructor(encoder_output, context) != 0) ||
    #####: 3352:        (encode_uuid_value(encoder_output, context, uuid) != 0))
        -: 3353:    {
        -: 3354:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3355:        LogError("Failed encoding uuid");
    #####: 3356:        result = MU_FAILURE;
        -: 3357:    }
        -: 3358:    else
        -: 3359:    {
        -: 3360:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3361:        result = 0;
        -: 3362:    }
        -: 3363:
    #####: 3364:    return result;
        -: 3365:}
        -: 3366:
    #####: 3367:static int encode_binary_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 3368:{
        -: 3369:    int result;
    #####: 3370:    if (use_smallest)
        -: 3371:    {
        -: 3372:        /* Codes_SRS_AMQPVALUE_01_297: [<encoding name="vbin8" code="0xa0" category="variable" width="1" label="up to 2^8 - 1 octets of binary data"/>] */
    #####: 3373:        if (output_byte(encoder_output, context, 0xA0) != 0)
        -: 3374:        {
        -: 3375:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3376:            LogError("Failed encoding small binary constructor");
    #####: 3377:            result = MU_FAILURE;
        -: 3378:        }
        -: 3379:        else
        -: 3380:        {
        -: 3381:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3382:            result = 0;
        -: 3383:        }
        -: 3384:    }
        -: 3385:    else
        -: 3386:    {
        -: 3387:        /* Codes_SRS_AMQPVALUE_01_298: [<encoding name="vbin32" code="0xb0" category="variable" width="4" label="up to 2^32 - 1 octets of binary data"/>] */
    #####: 3388:        if (output_byte(encoder_output, context, 0xB0) != 0)
        -: 3389:        {
        -: 3390:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3391:            LogError("Failed encoding large binary constructor");
    #####: 3392:            result = MU_FAILURE;
        -: 3393:        }
        -: 3394:        else
        -: 3395:        {
        -: 3396:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3397:            result = 0;
        -: 3398:        }
        -: 3399:    }
        -: 3400:
    #####: 3401:    return result;
        -: 3402:}
        -: 3403:
    #####: 3404:static int encode_binary_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const unsigned char* value, uint32_t length, bool use_smallest)
        -: 3405:{
        -: 3406:    int result;
    #####: 3407:    if (use_smallest)
        -: 3408:    {
        -: 3409:        /* Codes_SRS_AMQPVALUE_01_297: [<encoding name="vbin8" code="0xa0" category="variable" width="1" label="up to 2^8 - 1 octets of binary data"/>] */
    #####: 3410:        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||
    #####: 3411:            ((length > 0) && (output_bytes(encoder_output, context, value, length) != 0)))
        -: 3412:        {
        -: 3413:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3414:            LogError("Failed encoding small binary value");
    #####: 3415:            result = MU_FAILURE;
        -: 3416:        }
        -: 3417:        else
        -: 3418:        {
        -: 3419:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3420:            result = 0;
        -: 3421:        }
        -: 3422:    }
        -: 3423:    else
        -: 3424:    {
        -: 3425:        /* Codes_SRS_AMQPVALUE_01_298: [<encoding name="vbin32" code="0xb0" category="variable" width="4" label="up to 2^32 - 1 octets of binary data"/>] */
    #####: 3426:        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||
    #####: 3427:            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||
    #####: 3428:            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||
    #####: 3429:            (output_byte(encoder_output, context, length & 0xFF) != 0) ||
    #####: 3430:            (output_bytes(encoder_output, context, value, length) != 0))
        -: 3431:        {
        -: 3432:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3433:            LogError("Failed encoding large binary value");
    #####: 3434:            result = MU_FAILURE;
        -: 3435:        }
        -: 3436:        else
        -: 3437:        {
        -: 3438:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3439:            result = 0;
        -: 3440:        }
        -: 3441:    }
        -: 3442:
    #####: 3443:    return result;
        -: 3444:}
        -: 3445:
    #####: 3446:static int encode_binary(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const unsigned char* value, uint32_t length)
        -: 3447:{
        -: 3448:    int result;
    #####: 3449:    bool use_smallest = (length <= 255);
        -: 3450:
    #####: 3451:    if ((encode_binary_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 3452:        (encode_binary_value(encoder_output, context, value, length, use_smallest) != 0))
        -: 3453:    {
        -: 3454:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3455:        LogError("Failed encoding binary");
    #####: 3456:        result = MU_FAILURE;
        -: 3457:    }
        -: 3458:    else
        -: 3459:    {
        -: 3460:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3461:        result = 0;
        -: 3462:    }
        -: 3463:
    #####: 3464:    return result;
        -: 3465:}
        -: 3466:
    #####: 3467:static int encode_string_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 3468:{
        -: 3469:    int result;
        -: 3470:
    #####: 3471:    if (use_smallest)
        -: 3472:    {
        -: 3473:        /* Codes_SRS_AMQPVALUE_01_299: [<encoding name="str8-utf8" code="0xa1" category="variable" width="1" label="up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 3474:        if (output_byte(encoder_output, context, (unsigned char)0xA1) != 0)
        -: 3475:        {
        -: 3476:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3477:            LogError("Failed encoding small string constructor");
    #####: 3478:            result = MU_FAILURE;
        -: 3479:        }
        -: 3480:        else
        -: 3481:        {
        -: 3482:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3483:            result = 0;
        -: 3484:        }
        -: 3485:    }
        -: 3486:    else
        -: 3487:    {
        -: 3488:        /* Codes_SRS_AMQPVALUE_01_300: [<encoding name="str32-utf8" code="0xb1" category="variable" width="4" label="up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 3489:        if (output_byte(encoder_output, context, 0xB1) != 0)
        -: 3490:        {
        -: 3491:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3492:            LogError("Failed encoding large string constructor");
    #####: 3493:            result = MU_FAILURE;
        -: 3494:        }
        -: 3495:        else
        -: 3496:        {
        -: 3497:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3498:            result = 0;
        -: 3499:        }
        -: 3500:    }
        -: 3501:
    #####: 3502:    return result;
        -: 3503:}
        -: 3504:
    #####: 3505:static int encode_string_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value, size_t length, bool use_smallest)
        -: 3506:{
        -: 3507:    int result;
        -: 3508:
    #####: 3509:    if (use_smallest)
        -: 3510:    {
        -: 3511:        /* Codes_SRS_AMQPVALUE_01_299: [<encoding name="str8-utf8" code="0xa1" category="variable" width="1" label="up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 3512:        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||
    #####: 3513:            (output_bytes(encoder_output, context, value, length) != 0))
        -: 3514:        {
        -: 3515:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3516:            LogError("Failed encoding small string value");
    #####: 3517:            result = MU_FAILURE;
        -: 3518:        }
        -: 3519:        else
        -: 3520:        {
        -: 3521:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3522:            result = 0;
        -: 3523:        }
        -: 3524:    }
        -: 3525:    else
        -: 3526:    {
        -: 3527:        /* Codes_SRS_AMQPVALUE_01_300: [<encoding name="str32-utf8" code="0xb1" category="variable" width="4" label="up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 3528:        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||
    #####: 3529:            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||
    #####: 3530:            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||
    #####: 3531:            (output_byte(encoder_output, context, length & 0xFF) != 0) ||
    #####: 3532:            (output_bytes(encoder_output, context, value, length) != 0))
        -: 3533:        {
        -: 3534:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3535:            LogError("Failed encoding large string value");
    #####: 3536:            result = MU_FAILURE;
        -: 3537:        }
        -: 3538:        else
        -: 3539:        {
        -: 3540:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3541:            result = 0;
        -: 3542:        }
        -: 3543:    }
        -: 3544:
    #####: 3545:    return result;
        -: 3546:
        -: 3547:}
        -: 3548:
    #####: 3549:static int encode_string(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value)
        -: 3550:{
        -: 3551:    int result;
    #####: 3552:    size_t length = strlen(value);
    #####: 3553:    bool use_smallest = (length <= 255);
        -: 3554:
    #####: 3555:    if ((encode_string_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 3556:        (encode_string_value(encoder_output, context, value, length, use_smallest) != 0))
        -: 3557:    {
        -: 3558:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3559:        LogError("Failed encoding string");
    #####: 3560:        result = MU_FAILURE;
        -: 3561:    }
        -: 3562:    else
        -: 3563:    {
        -: 3564:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3565:        result = 0;
        -: 3566:    }
        -: 3567:
    #####: 3568:    return result;
        -: 3569:}
        -: 3570:
    #####: 3571:static int encode_symbol_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 3572:{
        -: 3573:    int result;
        -: 3574:
    #####: 3575:    if (use_smallest)
        -: 3576:    {
        -: 3577:        /* Codes_SRS_AMQPVALUE_01_301: [<encoding name="sym8" code="0xa3" category="variable" width="1" label="up to 2^8 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 3578:        if (output_byte(encoder_output, context, (unsigned char)0xA3) != 0)
        -: 3579:        {
        -: 3580:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3581:            LogError("Failed encoding small symbol constructor");
    #####: 3582:            result = MU_FAILURE;
        -: 3583:        }
        -: 3584:        else
        -: 3585:        {
        -: 3586:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3587:            result = 0;
        -: 3588:        }
        -: 3589:    }
        -: 3590:    else
        -: 3591:    {
        -: 3592:        /* Codes_SRS_AMQPVALUE_01_302: [<encoding name="sym32" code="0xb3" category="variable" width="4" label="up to 2^32 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 3593:        if (output_byte(encoder_output, context, 0xB3) != 0)
        -: 3594:        {
        -: 3595:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3596:            LogError("Failed encoding large symbol constructor");
    #####: 3597:            result = MU_FAILURE;
        -: 3598:        }
        -: 3599:        else
        -: 3600:        {
        -: 3601:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3602:            result = 0;
        -: 3603:        }
        -: 3604:    }
        -: 3605:
    #####: 3606:    return result;
        -: 3607:}
        -: 3608:
    #####: 3609:static int encode_symbol_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value, size_t length, bool use_smallest)
        -: 3610:{
        -: 3611:    int result;
        -: 3612:
    #####: 3613:    if (use_smallest)
        -: 3614:    {
        -: 3615:        /* Codes_SRS_AMQPVALUE_01_301: [<encoding name="sym8" code="0xa3" category="variable" width="1" label="up to 2^8 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 3616:        if ((output_byte(encoder_output, context, (unsigned char)length) != 0) ||
    #####: 3617:            (output_bytes(encoder_output, context, value, length) != 0))
        -: 3618:        {
        -: 3619:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3620:            LogError("Failed encoding small symbol value");
    #####: 3621:            result = MU_FAILURE;
        -: 3622:        }
        -: 3623:        else
        -: 3624:        {
        -: 3625:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3626:            result = 0;
        -: 3627:        }
        -: 3628:    }
        -: 3629:    else
        -: 3630:    {
        -: 3631:        /* Codes_SRS_AMQPVALUE_01_302: [<encoding name="sym32" code="0xb3" category="variable" width="4" label="up to 2^32 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 3632:        if ((output_byte(encoder_output, context, (length >> 24) & 0xFF) != 0) ||
    #####: 3633:            (output_byte(encoder_output, context, (length >> 16) & 0xFF) != 0) ||
    #####: 3634:            (output_byte(encoder_output, context, (length >> 8) & 0xFF) != 0) ||
    #####: 3635:            (output_byte(encoder_output, context, length & 0xFF) != 0) ||
        -: 3636:            /* Codes_SRS_AMQPVALUE_01_122: [Symbols are encoded as ASCII characters [ASCII].] */
    #####: 3637:            (output_bytes(encoder_output, context, value, length) != 0))
        -: 3638:        {
        -: 3639:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3640:            LogError("Failed encoding large symbol value");
    #####: 3641:            result = MU_FAILURE;
        -: 3642:        }
        -: 3643:        else
        -: 3644:        {
        -: 3645:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3646:            result = 0;
        -: 3647:        }
        -: 3648:    }
        -: 3649:
    #####: 3650:    return result;
        -: 3651:}
        -: 3652:
    #####: 3653:static int encode_symbol(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, const char* value)
        -: 3654:{
        -: 3655:    int result;
    #####: 3656:    size_t length = strlen(value);
    #####: 3657:    bool use_smallest = (length <= 255);
        -: 3658:
    #####: 3659:    if ((encode_symbol_constructor(encoder_output, context, use_smallest) != 0) ||
    #####: 3660:        (encode_symbol_value(encoder_output, context, value, length, use_smallest) != 0))
        -: 3661:    {
        -: 3662:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3663:        LogError("Failed encoding symbol");
    #####: 3664:        result = MU_FAILURE;
        -: 3665:    }
        -: 3666:    else
        -: 3667:    {
        -: 3668:        /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3669:        result = 0;
        -: 3670:    }
        -: 3671:
    #####: 3672:    return result;
        -: 3673:}
        -: 3674:
    #####: 3675:static int encode_list_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 3676:{
        -: 3677:    int result;
        -: 3678:
    #####: 3679:    if (use_smallest)
        -: 3680:    {
        -: 3681:        /* Codes_SRS_AMQPVALUE_01_304: [<encoding name="list8" code="0xc0" category="compound" width="1" label="up to 2^8 - 1 list elements with total size less than 2^8 octets"/>] */
    #####: 3682:        if (output_byte(encoder_output, context, 0xC0) != 0)
        -: 3683:        {
        -: 3684:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3685:            LogError("Failed encoding list constructor");
    #####: 3686:            result = MU_FAILURE;
        -: 3687:        }
        -: 3688:        else
        -: 3689:        {
        -: 3690:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3691:            result = 0;
        -: 3692:        }
        -: 3693:    }
        -: 3694:    else
        -: 3695:    {
        -: 3696:        /* Codes_SRS_AMQPVALUE_01_305: [<encoding name="list32" code="0xd0" category="compound" width="4" label="up to 2^32 - 1 list elements with total size less than 2^32 octets"/>] */
    #####: 3697:        if (output_byte(encoder_output, context, 0xD0) != 0)
        -: 3698:        {
        -: 3699:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3700:            LogError("Failed encoding large list constructor");
    #####: 3701:            result = MU_FAILURE;
        -: 3702:        }
        -: 3703:        else
        -: 3704:        {
        -: 3705:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3706:            result = 0;
        -: 3707:        }
        -: 3708:    }
        -: 3709:
    #####: 3710:    return result;
        -: 3711:}
        -: 3712:
    #####: 3713:static int amqpvalue_get_encoded_list_size(AMQP_VALUE* items, uint32_t count, uint32_t* encoded_size)
        -: 3714:{
        -: 3715:    int result;
        -: 3716:    size_t i;
        -: 3717:
    #####: 3718:    if (encoded_size == NULL)
        -: 3719:    {
    #####: 3720:        LogError("Bad arguments: encoded_size = %p", encoded_size);
    #####: 3721:        result = MU_FAILURE;
        -: 3722:    }
        -: 3723:    else
        -: 3724:    {
    #####: 3725:        *encoded_size = 0;
        -: 3726:
        -: 3727:        /* Get the size of all items in the list */
    #####: 3728:        for (i = 0; i < count; i++)
        -: 3729:        {
        -: 3730:            size_t item_size;
    #####: 3731:            if (amqpvalue_get_encoded_size(items[i], &item_size) != 0)
        -: 3732:            {
    #####: 3733:                LogError("Could not get encoded size for element %u of the list", (unsigned int)i);
    #####: 3734:                break;
        -: 3735:            }
        -: 3736:
    #####: 3737:            if ((item_size > UINT32_MAX) ||
    #####: 3738:                *encoded_size + (uint32_t)item_size < *encoded_size)
        -: 3739:            {
    #####: 3740:                LogError("Overflow in list size computation");
    #####: 3741:                break;
        -: 3742:            }
        -: 3743:
    #####: 3744:            *encoded_size = (uint32_t)(*encoded_size + item_size);
        -: 3745:        }
        -: 3746:
    #####: 3747:        if (i < count)
        -: 3748:        {
    #####: 3749:            result = MU_FAILURE;
        -: 3750:        }
        -: 3751:        else
        -: 3752:        {
    #####: 3753:            result = 0;
        -: 3754:        }
        -: 3755:    }
    #####: 3756:    return result;
        -: 3757:}
        -: 3758:
    #####: 3759:static int encode_list_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_VALUE* items, bool use_smallest)
        -: 3760:{
        -: 3761:    int result;
        -: 3762:    size_t i;
        -: 3763:
    #####: 3764:    if (use_smallest)
        -: 3765:    {
    #####: 3766:        size++;
        -: 3767:
        -: 3768:        /* Codes_SRS_AMQPVALUE_01_304: [<encoding name="list8" code="0xc0" category="compound" width="1" label="up to 2^8 - 1 list elements with total size less than 2^8 octets"/>] */
    #####: 3769:        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||
    #####: 3770:            (output_byte(encoder_output, context, (count & 0xFF)) != 0))
        -: 3771:        {
        -: 3772:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3773:            LogError("Failed encoding list value");
    #####: 3774:            result = MU_FAILURE;
        -: 3775:        }
        -: 3776:        else
        -: 3777:        {
        -: 3778:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3779:            result = 0;
        -: 3780:        }
        -: 3781:    }
        -: 3782:    else
        -: 3783:    {
    #####: 3784:        size += 4;
        -: 3785:
        -: 3786:        /* Codes_SRS_AMQPVALUE_01_305: [<encoding name="list32" code="0xd0" category="compound" width="4" label="up to 2^32 - 1 list elements with total size less than 2^32 octets"/>] */
    #####: 3787:        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||
    #####: 3788:            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||
    #####: 3789:            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||
    #####: 3790:            (output_byte(encoder_output, context, size & 0xFF) != 0) ||
    #####: 3791:            (output_byte(encoder_output, context, (count >> 24) & 0xFF) != 0) ||
    #####: 3792:            (output_byte(encoder_output, context, (count >> 16) & 0xFF) != 0) ||
    #####: 3793:            (output_byte(encoder_output, context, (count >> 8) & 0xFF) != 0) ||
    #####: 3794:            (output_byte(encoder_output, context, count & 0xFF) != 0))
        -: 3795:        {
        -: 3796:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3797:            LogError("Failed encoding large list value");
    #####: 3798:            result = MU_FAILURE;
        -: 3799:        }
        -: 3800:        else
        -: 3801:        {
        -: 3802:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3803:            result = 0;
        -: 3804:        }
        -: 3805:    }
        -: 3806:
    #####: 3807:    if (result == 0)
        -: 3808:    {
    #####: 3809:        for (i = 0; i < count; i++)
        -: 3810:        {
    #####: 3811:            if (amqpvalue_encode(items[i], encoder_output, context) != 0)
        -: 3812:            {
    #####: 3813:                break;
        -: 3814:            }
        -: 3815:        }
        -: 3816:
    #####: 3817:        if (i < count)
        -: 3818:        {
    #####: 3819:            LogError("Failed encoding element %u of the list", (unsigned int)i);
    #####: 3820:            result = MU_FAILURE;
        -: 3821:        }
        -: 3822:        else
        -: 3823:        {
    #####: 3824:            result = 0;
        -: 3825:        }
        -: 3826:    }
    #####: 3827:    return result;
        -: 3828:}
        -: 3829:
    #####: 3830:static int encode_list(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_VALUE* items)
        -: 3831:{
        -: 3832:    int result;
        -: 3833:
    #####: 3834:    if (count == 0)
        -: 3835:    {
        -: 3836:        /* Codes_SRS_AMQPVALUE_01_303: [<encoding name="list0" code="0x45" category="fixed" width="0" label="the empty list (i.e. the list with no elements)"/>] */
    #####: 3837:        if (output_byte(encoder_output, context, 0x45) != 0)
        -: 3838:        {
        -: 3839:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3840:            LogError("Could not output list constructor byte");
    #####: 3841:            result = MU_FAILURE;
        -: 3842:        }
        -: 3843:        else
        -: 3844:        {
        -: 3845:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3846:            result = 0;
        -: 3847:        }
        -: 3848:    }
        -: 3849:    else
        -: 3850:    {
        -: 3851:        uint32_t size;
        -: 3852:
    #####: 3853:        if (amqpvalue_get_encoded_list_size(items, count, &size) != 0)
        -: 3854:        {
        -: 3855:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3856:            result = MU_FAILURE;
        -: 3857:        }
        -: 3858:        else
        -: 3859:        {
    #####: 3860:            if ((count <= 255) && (size < 255))
        -: 3861:            {
        -: 3862:                /* Codes_SRS_AMQPVALUE_01_304: [<encoding name="list8" code="0xc0" category="compound" width="1" label="up to 2^8 - 1 list elements with total size less than 2^8 octets"/>] */
    #####: 3863:                if ((encode_list_constructor(encoder_output, context, true) != 0) ||
    #####: 3864:                    (encode_list_value(encoder_output, context, count, size, items, true) != 0))
        -: 3865:                {
        -: 3866:                    /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3867:                    LogError("Failed encoding small list");
    #####: 3868:                    result = MU_FAILURE;
        -: 3869:                }
        -: 3870:                else
        -: 3871:                {
        -: 3872:                    /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3873:                    result = 0;
        -: 3874:                }
        -: 3875:            }
        -: 3876:            else
        -: 3877:            {
        -: 3878:                /* Codes_SRS_AMQPVALUE_01_305: [<encoding name="list32" code="0xd0" category="compound" width="4" label="up to 2^32 - 1 list elements with total size less than 2^32 octets"/>] */
    #####: 3879:                if ((encode_list_constructor(encoder_output, context, false) != 0) ||
    #####: 3880:                    (encode_list_value(encoder_output, context, count, size, items, false) != 0))
        -: 3881:                {
        -: 3882:                    /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3883:                    LogError("Failed encoding large list");
    #####: 3884:                    result = MU_FAILURE;
        -: 3885:                }
        -: 3886:                else
        -: 3887:                {
        -: 3888:                    /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3889:                    result = 0;
        -: 3890:                }
        -: 3891:            }
        -: 3892:        }
        -: 3893:    }
        -: 3894:
    #####: 3895:    return result;
        -: 3896:}
        -: 3897:
    #####: 3898:static int encode_map_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 3899:{
        -: 3900:    int result;
        -: 3901:
    #####: 3902:    if (use_smallest)
        -: 3903:    {
        -: 3904:        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name="map8" code="0xc1" category="compound" width="1" label="up to 2^8 - 1 octets of encoded map data"/>] */
    #####: 3905:        if (output_byte(encoder_output, context, 0xC1) != 0)
        -: 3906:        {
        -: 3907:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3908:            LogError("Could not encode small map constructor");
    #####: 3909:            result = MU_FAILURE;
        -: 3910:        }
        -: 3911:        else
        -: 3912:        {
        -: 3913:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3914:            result = 0;
        -: 3915:        }
        -: 3916:    }
        -: 3917:    else
        -: 3918:    {
        -: 3919:        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name="map32" code="0xd1" category="compound" width="4" label="up to 2^32 - 1 octets of encoded map data"/>] */
    #####: 3920:        if (output_byte(encoder_output, context, 0xD1) != 0)
        -: 3921:        {
        -: 3922:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 3923:            LogError("Could not encode large map constructor");
    #####: 3924:            result = MU_FAILURE;
        -: 3925:        }
        -: 3926:        else
        -: 3927:        {
        -: 3928:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 3929:            result = 0;
        -: 3930:        }
        -: 3931:    }
        -: 3932:
    #####: 3933:    return result;
        -: 3934:}
        -: 3935:
    #####: 3936:static int amqpvalue_get_encoded_map_size(AMQP_MAP_KEY_VALUE_PAIR* pairs, uint32_t count, uint32_t* encoded_size)
        -: 3937:{
        -: 3938:    size_t i;
        -: 3939:    int result;
        -: 3940:
    #####: 3941:    if (encoded_size == NULL)
        -: 3942:    {
    #####: 3943:        LogError("Bad arguments: encoded_size = %p", encoded_size);
    #####: 3944:        result = MU_FAILURE;
        -: 3945:    }
        -: 3946:    else
        -: 3947:    {
    #####: 3948:        *encoded_size = 0;
        -: 3949:
        -: 3950:        /* Get the size of all items in the map */
    #####: 3951:        for (i = 0; i < count; i++)
        -: 3952:        {
        -: 3953:            size_t item_size;
    #####: 3954:            if (amqpvalue_get_encoded_size(pairs[i].key, &item_size) != 0)
        -: 3955:            {
    #####: 3956:                LogError("Could not get encoded size for key element %u of the map", (unsigned int)i);
    #####: 3957:                break;
        -: 3958:            }
        -: 3959:
    #####: 3960:            if ((item_size > UINT32_MAX) ||
    #####: 3961:                *encoded_size + (uint32_t)item_size < *encoded_size)
        -: 3962:            {
    #####: 3963:                LogError("Encoded data is more than the max size for a map");
    #####: 3964:                break;
        -: 3965:            }
        -: 3966:
    #####: 3967:            *encoded_size = (uint32_t)(*encoded_size + item_size);
        -: 3968:
    #####: 3969:            if (amqpvalue_get_encoded_size(pairs[i].value, &item_size) != 0)
        -: 3970:            {
    #####: 3971:                LogError("Could not get encoded size for value element %u of the map", (unsigned int)i);
    #####: 3972:                break;
        -: 3973:            }
        -: 3974:
    #####: 3975:            if ((item_size > UINT32_MAX) ||
    #####: 3976:                *encoded_size + (uint32_t)item_size < *encoded_size)
        -: 3977:            {
    #####: 3978:                LogError("Encoded data is more than the max size for a map");
    #####: 3979:                break;
        -: 3980:            }
        -: 3981:
    #####: 3982:            *encoded_size = (uint32_t)(*encoded_size + item_size);
        -: 3983:        }
        -: 3984:
    #####: 3985:        if (i < count)
        -: 3986:        {
    #####: 3987:            result = MU_FAILURE;
        -: 3988:        }
        -: 3989:        else
        -: 3990:        {
    #####: 3991:            result = 0;
        -: 3992:        }
        -: 3993:    }
    #####: 3994:    return result;
        -: 3995:}
        -: 3996:
    #####: 3997:static int encode_map_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_MAP_KEY_VALUE_PAIR* pairs, bool use_smallest)
        -: 3998:{
        -: 3999:    int result;
        -: 4000:    size_t i;
        -: 4001:
        -: 4002:    /* Codes_SRS_AMQPVALUE_01_124: [Map encodings MUST contain an even number of items (i.e. an equal number of keys and values).] */
    #####: 4003:    uint32_t elements = count * 2;
        -: 4004:
    #####: 4005:    if (use_smallest)
        -: 4006:    {
    #####: 4007:        size++;
        -: 4008:
        -: 4009:        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name="map8" code="0xc1" category="compound" width="1" label="up to 2^8 - 1 octets of encoded map data"/>] */
    #####: 4010:        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||
    #####: 4011:            (output_byte(encoder_output, context, (elements & 0xFF)) != 0))
        -: 4012:        {
        -: 4013:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4014:            LogError("Could not encode small map header");
    #####: 4015:            result = MU_FAILURE;
        -: 4016:        }
        -: 4017:        else
        -: 4018:        {
        -: 4019:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4020:            result = 0;
        -: 4021:        }
        -: 4022:    }
        -: 4023:    else
        -: 4024:    {
    #####: 4025:        size += 4;
        -: 4026:
        -: 4027:        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name="map32" code="0xd1" category="compound" width="4" label="up to 2^32 - 1 octets of encoded map data"/>] */
    #####: 4028:        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||
    #####: 4029:            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||
    #####: 4030:            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||
    #####: 4031:            (output_byte(encoder_output, context, size & 0xFF) != 0) ||
    #####: 4032:            (output_byte(encoder_output, context, (elements >> 24) & 0xFF) != 0) ||
    #####: 4033:            (output_byte(encoder_output, context, (elements >> 16) & 0xFF) != 0) ||
    #####: 4034:            (output_byte(encoder_output, context, (elements >> 8) & 0xFF) != 0) ||
    #####: 4035:            (output_byte(encoder_output, context, elements & 0xFF) != 0))
        -: 4036:        {
        -: 4037:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4038:            LogError("Could not encode large map header");
    #####: 4039:            result = MU_FAILURE;
        -: 4040:        }
        -: 4041:        else
        -: 4042:        {
        -: 4043:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4044:            result = 0;
        -: 4045:        }
        -: 4046:    }
        -: 4047:
    #####: 4048:    if (result == 0)
        -: 4049:    {
        -: 4050:        /* Codes_SRS_AMQPVALUE_01_123: [A map is encoded as a compound value where the constituent elements form alternating key value pairs.] */
    #####: 4051:        for (i = 0; i < count; i++)
        -: 4052:        {
    #####: 4053:            if ((amqpvalue_encode(pairs[i].key, encoder_output, context) != 0) ||
    #####: 4054:                (amqpvalue_encode(pairs[i].value, encoder_output, context) != 0))
        -: 4055:            {
    #####: 4056:                LogError("Failed encoding map element %u", (unsigned int)i);
    #####: 4057:                break;
        -: 4058:            }
        -: 4059:        }
        -: 4060:
    #####: 4061:        if (i < count)
        -: 4062:        {
    #####: 4063:            LogError("Could not encode map");
    #####: 4064:            result = MU_FAILURE;
        -: 4065:        }
        -: 4066:        else
        -: 4067:        {
    #####: 4068:            result = 0;
        -: 4069:        }
        -: 4070:    }
    #####: 4071:    return result;
        -: 4072:}
        -: 4073:
    #####: 4074:static int encode_map(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_MAP_KEY_VALUE_PAIR* pairs)
        -: 4075:{
        -: 4076:    int result;
        -: 4077:    uint32_t size;
        -: 4078:
        -: 4079:    /* Codes_SRS_AMQPVALUE_01_124: [Map encodings MUST contain an even number of items (i.e. an equal number of keys and values).] */
    #####: 4080:    uint32_t elements = count * 2;
        -: 4081:
    #####: 4082:    if (amqpvalue_get_encoded_map_size(pairs, count, &size) != 0)
        -: 4083:    {
        -: 4084:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4085:        result = MU_FAILURE;
        -: 4086:    }
        -: 4087:    else
        -: 4088:    {
    #####: 4089:        if ((elements <= 255) && (size < 255))
        -: 4090:        {
        -: 4091:            /* Codes_SRS_AMQPVALUE_01_306: [<encoding name="map8" code="0xc1" category="compound" width="1" label="up to 2^8 - 1 octets of encoded map data"/>] */
    #####: 4092:            if ((encode_map_constructor(encoder_output, context, true) != 0) ||
    #####: 4093:                (encode_map_value(encoder_output, context, count, size, pairs, true) != 0))
        -: 4094:            {
        -: 4095:                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4096:                LogError("Could not encode small map");
    #####: 4097:                result = MU_FAILURE;
        -: 4098:            }
        -: 4099:            else
        -: 4100:            {
        -: 4101:                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4102:                result = 0;
        -: 4103:            }
        -: 4104:        }
        -: 4105:        else
        -: 4106:        {
        -: 4107:            /* Codes_SRS_AMQPVALUE_01_307: [<encoding name="map32" code="0xd1" category="compound" width="4" label="up to 2^32 - 1 octets of encoded map data"/>] */
    #####: 4108:            if ((encode_map_constructor(encoder_output, context, false) != 0) ||
    #####: 4109:                (encode_map_value(encoder_output, context, count, size, pairs, false) != 0))
        -: 4110:            {
        -: 4111:                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4112:                LogError("Could not encode large map");
    #####: 4113:                result = MU_FAILURE;
        -: 4114:            }
        -: 4115:            else
        -: 4116:            {
        -: 4117:                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4118:                result = 0;
        -: 4119:            }
        -: 4120:        }
        -: 4121:    }
        -: 4122:
    #####: 4123:    return result;
        -: 4124:}
        -: 4125:
    #####: 4126:static int encode_array_constructor(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, bool use_smallest)
        -: 4127:{
        -: 4128:    int result;
        -: 4129:
    #####: 4130:    if (use_smallest)
        -: 4131:    {
        -: 4132:        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name="map8" code="0xE0" category="compound" width="1" label="up to 2^8 - 1 octets of encoded map data"/>] */
    #####: 4133:        if (output_byte(encoder_output, context, 0xE0) != 0)
        -: 4134:        {
        -: 4135:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4136:            LogError("Could not encode small array constructor");
    #####: 4137:            result = MU_FAILURE;
        -: 4138:        }
        -: 4139:        else
        -: 4140:        {
        -: 4141:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4142:            result = 0;
        -: 4143:        }
        -: 4144:    }
        -: 4145:    else
        -: 4146:    {
        -: 4147:        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name="map32" code="0xF0" category="compound" width="4" label="up to 2^32 - 1 octets of encoded map data"/>] */
    #####: 4148:        if (output_byte(encoder_output, context, 0xF0) != 0)
        -: 4149:        {
        -: 4150:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4151:            LogError("Could not encode large array constructor");
    #####: 4152:            result = MU_FAILURE;
        -: 4153:        }
        -: 4154:        else
        -: 4155:        {
        -: 4156:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4157:            result = 0;
        -: 4158:        }
        -: 4159:    }
        -: 4160:
    #####: 4161:    return result;
        -: 4162:}
        -: 4163:
    #####: 4164:static int amqpvalue_get_encoded_array_size(AMQP_VALUE* items, uint32_t count, uint32_t* encoded_size)
        -: 4165:{
        -: 4166:    size_t i;
        -: 4167:    int result;
        -: 4168:
    #####: 4169:    if (encoded_size == NULL)
        -: 4170:    {
    #####: 4171:        LogError("Bad arguments: encoded_size = %p", encoded_size);
    #####: 4172:        result = MU_FAILURE;
        -: 4173:    }
        -: 4174:    else
        -: 4175:    {
    #####: 4176:        *encoded_size = 0;
        -: 4177:
        -: 4178:        /* Get the size of all items in the array */
    #####: 4179:        for (i = 0; i < count; i++)
        -: 4180:        {
        -: 4181:            size_t item_size;
    #####: 4182:            if (amqpvalue_get_encoded_array_item_size(items[i], &item_size) != 0)
        -: 4183:            {
    #####: 4184:                LogError("Could not get encoded size for element %u of the array", (unsigned int)i);
    #####: 4185:                break;
        -: 4186:            }
        -: 4187:
    #####: 4188:            if ((item_size > UINT32_MAX) ||
    #####: 4189:                *encoded_size + (uint32_t)item_size < *encoded_size)
        -: 4190:            {
    #####: 4191:                LogError("Overflow in array size computation");
    #####: 4192:                break;
        -: 4193:            }
        -: 4194:
    #####: 4195:            *encoded_size = (uint32_t)(*encoded_size + item_size);
        -: 4196:        }
        -: 4197:
    #####: 4198:        if (i < count)
        -: 4199:        {
    #####: 4200:            result = MU_FAILURE;
        -: 4201:        }
        -: 4202:        else
        -: 4203:        {
    #####: 4204:            if (*encoded_size > count)
        -: 4205:            {
        -: 4206:                /* Include a single constructor byte in the size calculation where array items require a constructor. */
    #####: 4207:                (*encoded_size)++;
        -: 4208:            }
    #####: 4209:            result = 0;
        -: 4210:        }
        -: 4211:    }
    #####: 4212:    return result;
        -: 4213:}
        -: 4214:
    #####: 4215:static int encode_array_value(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, uint32_t size, AMQP_VALUE* items, bool use_smallest)
        -: 4216:{
        -: 4217:    int result;
        -: 4218:    size_t i;
        -: 4219:
    #####: 4220:    if (use_smallest)
        -: 4221:    {
    #####: 4222:        size++;
        -: 4223:
        -: 4224:        /* Codes_SRS_AMQPVALUE_01_306: [<encoding name="map8" code="0xE0" category="compound" width="1" label="up to 2^8 - 1 octets of encoded map data"/>] */
    #####: 4225:        if ((output_byte(encoder_output, context, (size & 0xFF)) != 0) ||
    #####: 4226:            (output_byte(encoder_output, context, (count & 0xFF)) != 0))
        -: 4227:        {
        -: 4228:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4229:            LogError("Could not encode small array header");
    #####: 4230:            result = MU_FAILURE;
        -: 4231:        }
        -: 4232:        else
        -: 4233:        {
        -: 4234:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4235:            result = 0;
        -: 4236:        }
        -: 4237:    }
        -: 4238:    else
        -: 4239:    {
    #####: 4240:        size += 4;
        -: 4241:
        -: 4242:        /* Codes_SRS_AMQPVALUE_01_307: [<encoding name="map32" code="0xF0" category="compound" width="4" label="up to 2^32 - 1 octets of encoded map data"/>] */
    #####: 4243:        if ((output_byte(encoder_output, context, (size >> 24) & 0xFF) != 0) ||
    #####: 4244:            (output_byte(encoder_output, context, (size >> 16) & 0xFF) != 0) ||
    #####: 4245:            (output_byte(encoder_output, context, (size >> 8) & 0xFF) != 0) ||
    #####: 4246:            (output_byte(encoder_output, context, size & 0xFF) != 0) ||
    #####: 4247:            (output_byte(encoder_output, context, (count >> 24) & 0xFF) != 0) ||
    #####: 4248:            (output_byte(encoder_output, context, (count >> 16) & 0xFF) != 0) ||
    #####: 4249:            (output_byte(encoder_output, context, (count >> 8) & 0xFF) != 0) ||
    #####: 4250:            (output_byte(encoder_output, context, count & 0xFF) != 0))
        -: 4251:        {
        -: 4252:            /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4253:            LogError("Could not encode large array header");
    #####: 4254:            result = MU_FAILURE;
        -: 4255:        }
        -: 4256:        else
        -: 4257:        {
        -: 4258:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4259:            result = 0;
        -: 4260:        }
        -: 4261:    }
        -: 4262:
    #####: 4263:    if (result == 0)
        -: 4264:    {
    #####: 4265:        bool first_element = true;
        -: 4266:
    #####: 4267:        for (i = 0; i < count; i++)
        -: 4268:        {
    #####: 4269:            if (amqpvalue_encode_array_item(items[i], first_element, encoder_output, context) != 0)
        -: 4270:            {
    #####: 4271:                LogError("Failed encoding element %u of the array", (unsigned int)i);
    #####: 4272:                break;
        -: 4273:            }
    #####: 4274:            first_element = false;
        -: 4275:        }
        -: 4276:
    #####: 4277:        if (i < count)
        -: 4278:        {
    #####: 4279:            LogError("Could not encode array");
    #####: 4280:            result = MU_FAILURE;
        -: 4281:        }
        -: 4282:        else
        -: 4283:        {
    #####: 4284:            result = 0;
        -: 4285:        }
        -: 4286:    }
    #####: 4287:    return result;
        -: 4288:}
        -: 4289:
    #####: 4290:static int encode_array(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context, uint32_t count, AMQP_VALUE* items)
        -: 4291:{
        -: 4292:    int result;
        -: 4293:    uint32_t size;
        -: 4294:
    #####: 4295:    if (amqpvalue_get_encoded_array_size(items, count, &size) != 0)
        -: 4296:    {
        -: 4297:        /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4298:        result = MU_FAILURE;
        -: 4299:    }
        -: 4300:    else
        -: 4301:    {
    #####: 4302:        if ((count <= 255) && (size < 255))
        -: 4303:        {
        -: 4304:            /* Codes_SRS_AMQPVALUE_01_306: [<encoding name="map8" code="0xE0" category="compound" width="1" label="up to 2^8 - 1 octets of encoded map data"/>] */
    #####: 4305:            if ((encode_array_constructor(encoder_output, context, true) != 0) ||
    #####: 4306:                (encode_array_value(encoder_output,context, count, size, items, true) != 0))
        -: 4307:            {
        -: 4308:                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4309:                LogError("Could not encode small array");
    #####: 4310:                result = MU_FAILURE;
        -: 4311:            }
        -: 4312:            else
        -: 4313:            {
        -: 4314:                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4315:                result = 0;
        -: 4316:            }
        -: 4317:        }
        -: 4318:        else
        -: 4319:        {
        -: 4320:            /* Codes_SRS_AMQPVALUE_01_307: [<encoding name="map32" code="0xF0" category="compound" width="4" label="up to 2^32 - 1 octets of encoded map data"/>] */
    #####: 4321:            if ((encode_array_constructor(encoder_output, context, false) != 0) ||
    #####: 4322:                (encode_array_value(encoder_output, context, count, size, items, false) != 0))
        -: 4323:            {
        -: 4324:                /* Codes_SRS_AMQPVALUE_01_274: [When the encoder output function fails, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4325:                LogError("Could not encode large array");
    #####: 4326:                result = MU_FAILURE;
        -: 4327:            }
        -: 4328:            else
        -: 4329:            {
        -: 4330:                /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4331:                result = 0;
        -: 4332:            }
        -: 4333:        }
        -: 4334:    }
        -: 4335:
    #####: 4336:    return result;
        -: 4337:}
        -: 4338:
    #####: 4339:static int encode_descriptor_header(AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 4340:{
        -: 4341:    int result;
        -: 4342:
    #####: 4343:    if (output_byte(encoder_output, context, 0x00) != 0)
        -: 4344:    {
    #####: 4345:        LogError("Failed encoding descriptor header");
    #####: 4346:        result = MU_FAILURE;
        -: 4347:    }
        -: 4348:    else
        -: 4349:    {
    #####: 4350:        result = 0;
        -: 4351:    }
        -: 4352:
    #####: 4353:    return result;
        -: 4354:}
        -: 4355:
        -: 4356:/* Codes_SRS_AMQPVALUE_01_265: [amqpvalue_encode shall encode the value per the ISO.] */
    #####: 4357:int amqpvalue_encode(AMQP_VALUE value, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 4358:{
        -: 4359:    int result;
        -: 4360:
        -: 4361:    /* Codes_SRS_AMQPVALUE_01_269: [If value or encoder_output are NULL, amqpvalue_encode shall fail and return a non-zero value.] */
    #####: 4362:    if ((value == NULL) ||
        -: 4363:        (encoder_output == NULL))
        -: 4364:    {
    #####: 4365:        LogError("Bad arguments: value = %p, encoder_output = %p",
        -: 4366:            value, encoder_output);
    #####: 4367:        result = MU_FAILURE;
        -: 4368:    }
        -: 4369:    else
        -: 4370:    {
    #####: 4371:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 4372:
    #####: 4373:        switch (value_data->type)
        -: 4374:        {
    #####: 4375:        default:
        -: 4376:            /* Codes_SRS_AMQPVALUE_01_271: [If encoding fails due to any error not specifically mentioned here, it shall return a non-zero value.] */
    #####: 4377:            LogError("Invalid type: %d", (int)value_data->type);
    #####: 4378:            result = MU_FAILURE;
    #####: 4379:            break;
        -: 4380:
    #####: 4381:        case AMQP_TYPE_NULL:
        -: 4382:            /* Codes_SRS_AMQPVALUE_01_266: [On success amqpvalue_encode shall return 0.] */
    #####: 4383:            result = encode_null(encoder_output, context);
    #####: 4384:            break;
        -: 4385:
    #####: 4386:        case AMQP_TYPE_BOOL:
    #####: 4387:            result = encode_boolean(encoder_output, context, value_data->value.bool_value);
    #####: 4388:            break;
        -: 4389:
    #####: 4390:        case AMQP_TYPE_UBYTE:
    #####: 4391:            result = encode_ubyte(encoder_output, context, value_data->value.ubyte_value);
    #####: 4392:            break;
        -: 4393:
    #####: 4394:        case AMQP_TYPE_USHORT:
    #####: 4395:            result = encode_ushort(encoder_output, context, value_data->value.ushort_value);
    #####: 4396:            break;
        -: 4397:
    #####: 4398:        case AMQP_TYPE_UINT:
    #####: 4399:            result = encode_uint(encoder_output, context, value_data->value.uint_value);
    #####: 4400:            break;
        -: 4401:
    #####: 4402:        case AMQP_TYPE_ULONG:
    #####: 4403:            result = encode_ulong(encoder_output, context, value_data->value.ulong_value);
    #####: 4404:            break;
        -: 4405:
    #####: 4406:        case AMQP_TYPE_BYTE:
    #####: 4407:            result = encode_byte(encoder_output, context, value_data->value.byte_value);
    #####: 4408:            break;
        -: 4409:
    #####: 4410:        case AMQP_TYPE_SHORT:
    #####: 4411:            result = encode_short(encoder_output, context, value_data->value.short_value);
    #####: 4412:            break;
        -: 4413:
    #####: 4414:        case AMQP_TYPE_INT:
    #####: 4415:            result = encode_int(encoder_output, context, value_data->value.int_value);
    #####: 4416:            break;
        -: 4417:
    #####: 4418:        case AMQP_TYPE_LONG:
    #####: 4419:            result = encode_long(encoder_output, context, value_data->value.long_value);
    #####: 4420:            break;
        -: 4421:
    #####: 4422:        case AMQP_TYPE_FLOAT:
    #####: 4423:            result = encode_float(encoder_output, context, value_data->value.float_value);
    #####: 4424:            break;
        -: 4425:
    #####: 4426:        case AMQP_TYPE_DOUBLE:
    #####: 4427:            result = encode_double(encoder_output, context, value_data->value.double_value);
    #####: 4428:            break;
        -: 4429:
    #####: 4430:        case AMQP_TYPE_TIMESTAMP:
    #####: 4431:            result = encode_timestamp(encoder_output, context, value_data->value.timestamp_value);
    #####: 4432:            break;
        -: 4433:
    #####: 4434:        case AMQP_TYPE_UUID:
    #####: 4435:            result = encode_uuid(encoder_output, context, value_data->value.uuid_value);
    #####: 4436:            break;
        -: 4437:
    #####: 4438:        case AMQP_TYPE_BINARY:
    #####: 4439:            result = encode_binary(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length);
    #####: 4440:            break;
        -: 4441:
    #####: 4442:        case AMQP_TYPE_STRING:
    #####: 4443:            result = encode_string(encoder_output, context, value_data->value.string_value.chars);
    #####: 4444:            break;
        -: 4445:
    #####: 4446:        case AMQP_TYPE_SYMBOL:
    #####: 4447:            result = encode_symbol(encoder_output, context, value_data->value.symbol_value.chars);
    #####: 4448:            break;
        -: 4449:
    #####: 4450:        case AMQP_TYPE_LIST:
    #####: 4451:            result = encode_list(encoder_output, context, value_data->value.list_value.count, value_data->value.list_value.items);
    #####: 4452:            break;
        -: 4453:
    #####: 4454:        case AMQP_TYPE_ARRAY:
    #####: 4455:            result = encode_array(encoder_output, context, value_data->value.array_value.count, value_data->value.array_value.items);
    #####: 4456:            break;
        -: 4457:
    #####: 4458:        case AMQP_TYPE_MAP:
    #####: 4459:            result = encode_map(encoder_output, context, value_data->value.map_value.pair_count, value_data->value.map_value.pairs);
    #####: 4460:            break;
        -: 4461:
    #####: 4462:        case AMQP_TYPE_COMPOSITE:
        -: 4463:        case AMQP_TYPE_DESCRIBED:
        -: 4464:        {
    #####: 4465:            if ((encode_descriptor_header(encoder_output, context) != 0) ||
    #####: 4466:                (amqpvalue_encode(value_data->value.described_value.descriptor, encoder_output, context) != 0) ||
    #####: 4467:                (amqpvalue_encode(value_data->value.described_value.value, encoder_output, context) != 0))
        -: 4468:            {
    #####: 4469:                LogError("Failed encoding described or composite type");
    #####: 4470:                result = MU_FAILURE;
        -: 4471:            }
        -: 4472:            else
        -: 4473:            {
    #####: 4474:                result = 0;
        -: 4475:            }
        -: 4476:
    #####: 4477:            break;
        -: 4478:        }
        -: 4479:        }
        -: 4480:    }
        -: 4481:
    #####: 4482:    return result;
        -: 4483:}
        -: 4484:
    #####: 4485:static int amqpvalue_encode_array_item(AMQP_VALUE item, bool first_element, AMQPVALUE_ENCODER_OUTPUT encoder_output, void* context)
        -: 4486:{
        -: 4487:    int result;
        -: 4488:
    #####: 4489:    if ((item == NULL) ||
        -: 4490:        (encoder_output == NULL))
        -: 4491:    {
    #####: 4492:        LogError("Bad arguments: item = %p, encoder_output = %p", item, encoder_output);
    #####: 4493:        result = MU_FAILURE;
        -: 4494:    }
        -: 4495:    else
        -: 4496:    {
    #####: 4497:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)item;
        -: 4498:
    #####: 4499:        switch (value_data->type)
        -: 4500:        {
    #####: 4501:            default:
    #####: 4502:                LogError("Unsupported array type: %d", (int)value_data->type);
    #####: 4503:                result = MU_FAILURE;
    #####: 4504:                break;
        -: 4505:
    #####: 4506:            case AMQP_TYPE_NULL:
    #####: 4507:                if ((first_element) && (encode_null_constructor(encoder_output, context) != 0))
        -: 4508:                {
    #####: 4509:                    result = MU_FAILURE;
    #####: 4510:                    break;
        -: 4511:                }
    #####: 4512:                result = encode_null_value(encoder_output, context);
    #####: 4513:                break;
        -: 4514:
    #####: 4515:            case AMQP_TYPE_BOOL:
    #####: 4516:                if ((first_element) && (encode_boolean_constructor(encoder_output, context) != 0))
        -: 4517:                {
    #####: 4518:                    result = MU_FAILURE;
    #####: 4519:                    break;
        -: 4520:                }
    #####: 4521:                result = encode_boolean_value(encoder_output, context, value_data->value.bool_value);
    #####: 4522:                break;
        -: 4523:
    #####: 4524:            case AMQP_TYPE_UBYTE:
    #####: 4525:                if ((first_element) && (encode_ubyte_constructor(encoder_output, context) != 0))
        -: 4526:                {
    #####: 4527:                    result = MU_FAILURE;
    #####: 4528:                    break;
        -: 4529:                }
    #####: 4530:                result = encode_ubyte_value(encoder_output, context, value_data->value.ubyte_value);
    #####: 4531:                break;
        -: 4532:
    #####: 4533:            case AMQP_TYPE_USHORT:
    #####: 4534:                if ((first_element) && (encode_ushort_constructor(encoder_output, context) != 0))
        -: 4535:                {
    #####: 4536:                    result = MU_FAILURE;
    #####: 4537:                    break;
        -: 4538:                }
    #####: 4539:                result = encode_ushort_value(encoder_output, context, value_data->value.ushort_value);
    #####: 4540:                break;
        -: 4541:
    #####: 4542:            case AMQP_TYPE_UINT:
    #####: 4543:                if ((first_element) && (encode_uint_constructor(encoder_output, context, false) != 0))
        -: 4544:                {
    #####: 4545:                    result = MU_FAILURE;
    #####: 4546:                    break;
        -: 4547:                }
    #####: 4548:                result = encode_uint_value(encoder_output, context, value_data->value.uint_value, false);
    #####: 4549:                break;
        -: 4550:
    #####: 4551:            case AMQP_TYPE_ULONG:
    #####: 4552:                if ((first_element) && (encode_ulong_constructor(encoder_output, context, false) != 0))
        -: 4553:                {
    #####: 4554:                    result = MU_FAILURE;
    #####: 4555:                    break;
        -: 4556:                }
    #####: 4557:                result = encode_ulong_value(encoder_output, context, value_data->value.ulong_value, false);
    #####: 4558:                break;
        -: 4559:
    #####: 4560:            case AMQP_TYPE_BYTE:
    #####: 4561:                if ((first_element) && (encode_byte_constructor(encoder_output, context) != 0))
        -: 4562:                {
    #####: 4563:                    result = MU_FAILURE;
    #####: 4564:                    break;
        -: 4565:                }
    #####: 4566:                result = encode_byte_value(encoder_output, context, value_data->value.byte_value);
    #####: 4567:                break;
        -: 4568:
    #####: 4569:            case AMQP_TYPE_SHORT:
    #####: 4570:                if ((first_element) && (encode_short_constructor(encoder_output, context) != 0))
        -: 4571:                {
    #####: 4572:                    result = MU_FAILURE;
    #####: 4573:                    break;
        -: 4574:                }
    #####: 4575:                result = encode_short_value(encoder_output, context, value_data->value.short_value);
    #####: 4576:                break;
        -: 4577:
    #####: 4578:            case AMQP_TYPE_INT:
    #####: 4579:                if ((first_element) && (encode_int_constructor(encoder_output, context, false) != 0))
        -: 4580:                {
    #####: 4581:                    result = MU_FAILURE;
    #####: 4582:                    break;
        -: 4583:                }
    #####: 4584:                result = encode_int_value(encoder_output, context, value_data->value.int_value, false);
    #####: 4585:                break;
        -: 4586:
    #####: 4587:            case AMQP_TYPE_LONG:
    #####: 4588:                if ((first_element) && (encode_long_constructor(encoder_output, context, false) != 0))
        -: 4589:                {
    #####: 4590:                    result = MU_FAILURE;
    #####: 4591:                    break;
        -: 4592:                }
    #####: 4593:                result = encode_long_value(encoder_output, context, value_data->value.long_value, false);
    #####: 4594:                break;
        -: 4595:
    #####: 4596:            case AMQP_TYPE_FLOAT:
    #####: 4597:                if ((first_element) && (encode_float_constructor(encoder_output, context) != 0))
        -: 4598:                {
    #####: 4599:                    result = MU_FAILURE;
    #####: 4600:                    break;
        -: 4601:                }
    #####: 4602:                result = encode_float_value(encoder_output, context, value_data->value.float_value);
    #####: 4603:                break;
        -: 4604:
    #####: 4605:            case AMQP_TYPE_DOUBLE:
    #####: 4606:                if ((first_element) && (encode_double_constructor(encoder_output, context) != 0))
        -: 4607:                {
    #####: 4608:                    result = MU_FAILURE;
    #####: 4609:                    break;
        -: 4610:                }
    #####: 4611:                result = encode_double_value(encoder_output, context, value_data->value.double_value);
    #####: 4612:                break;
        -: 4613:
    #####: 4614:            case AMQP_TYPE_TIMESTAMP:
    #####: 4615:                if ((first_element) && (encode_timestamp_constructor(encoder_output, context) != 0))
        -: 4616:                {
    #####: 4617:                    result = MU_FAILURE;
    #####: 4618:                    break;
        -: 4619:                }
    #####: 4620:                result = encode_timestamp_value(encoder_output, context, value_data->value.timestamp_value);
    #####: 4621:                break;
        -: 4622:
    #####: 4623:            case AMQP_TYPE_UUID:
    #####: 4624:                if ((first_element) && (encode_uuid_constructor(encoder_output, context) != 0))
        -: 4625:                {
    #####: 4626:                    result = MU_FAILURE;
    #####: 4627:                    break;
        -: 4628:                }
    #####: 4629:                result = encode_uuid_value(encoder_output, context, value_data->value.uuid_value);
    #####: 4630:                break;
        -: 4631:
    #####: 4632:            case AMQP_TYPE_BINARY:
    #####: 4633:                if ((first_element) && (encode_binary_constructor(encoder_output, context, false) != 0))
        -: 4634:                {
    #####: 4635:                    result = MU_FAILURE;
    #####: 4636:                    break;
        -: 4637:                }
    #####: 4638:                result = encode_binary_value(encoder_output, context, (const unsigned char*)value_data->value.binary_value.bytes, value_data->value.binary_value.length, false);
    #####: 4639:                break;
        -: 4640:
    #####: 4641:            case AMQP_TYPE_STRING:
    #####: 4642:                if ((first_element) && (encode_string_constructor(encoder_output, context, false) != 0))
        -: 4643:                {
    #####: 4644:                    result = MU_FAILURE;
    #####: 4645:                    break;
        -: 4646:                }
    #####: 4647:                result = encode_string_value(encoder_output, context, value_data->value.string_value.chars, strlen(value_data->value.string_value.chars), false);
    #####: 4648:                break;
        -: 4649:
    #####: 4650:            case AMQP_TYPE_SYMBOL:
    #####: 4651:                if ((first_element) && (encode_symbol_constructor(encoder_output, context, false) != 0))
        -: 4652:                {
    #####: 4653:                    result = MU_FAILURE;
    #####: 4654:                    break;
        -: 4655:                }
    #####: 4656:                result = encode_symbol_value(encoder_output, context, value_data->value.symbol_value.chars, strlen(value_data->value.symbol_value.chars), false);
    #####: 4657:                break;
        -: 4658:
    #####: 4659:            case AMQP_TYPE_LIST:
        -: 4660:            {
        -: 4661:                uint32_t list_size;
        -: 4662:
    #####: 4663:                if ((first_element) && (encode_list_constructor(encoder_output, context, false) != 0))
        -: 4664:                {
    #####: 4665:                    result = MU_FAILURE;
        -: 4666:                }
    #####: 4667:                else if (amqpvalue_get_encoded_list_size(value_data->value.list_value.items, value_data->value.list_value.count, &list_size) != 0)
        -: 4668:                {
    #####: 4669:                    result = MU_FAILURE;
        -: 4670:                }
        -: 4671:                else
        -: 4672:                {
    #####: 4673:                    result = encode_list_value(encoder_output, context, value_data->value.list_value.count, list_size, value_data->value.list_value.items, false);
        -: 4674:                }
    #####: 4675:                break;
        -: 4676:            }
        -: 4677:
    #####: 4678:            case AMQP_TYPE_MAP:
        -: 4679:            {
        -: 4680:                uint32_t map_size;
        -: 4681:
    #####: 4682:                if ((first_element) && (encode_map_constructor(encoder_output, context, false) != 0))
        -: 4683:                {
    #####: 4684:                    result = MU_FAILURE;
        -: 4685:                }
    #####: 4686:                else if (amqpvalue_get_encoded_map_size(value_data->value.map_value.pairs, value_data->value.map_value.pair_count, &map_size) != 0)
        -: 4687:                {
    #####: 4688:                    result = MU_FAILURE;
        -: 4689:                }
        -: 4690:                else
        -: 4691:                {
    #####: 4692:                    result = encode_map_value(encoder_output, context, value_data->value.map_value.pair_count, map_size, value_data->value.map_value.pairs, false);
        -: 4693:                }
    #####: 4694:                break;
        -: 4695:            }
        -: 4696:
    #####: 4697:            case AMQP_TYPE_ARRAY:
        -: 4698:            {
        -: 4699:                uint32_t array_size;
        -: 4700:
    #####: 4701:                if ((first_element) && (encode_array_constructor(encoder_output, context, false) != 0))
        -: 4702:                {
    #####: 4703:                    result = MU_FAILURE;
        -: 4704:                }
    #####: 4705:                else if (amqpvalue_get_encoded_array_size(value_data->value.array_value.items, value_data->value.array_value.count, &array_size) != 0)
        -: 4706:                {
    #####: 4707:                    result = MU_FAILURE;
        -: 4708:                }
        -: 4709:                else
        -: 4710:                {
    #####: 4711:                    result = encode_array_value(encoder_output, context, value_data->value.array_value.count, array_size, value_data->value.array_value.items, false);
        -: 4712:                }
    #####: 4713:                break;
        -: 4714:            }
        -: 4715:        }
        -: 4716:    }
    #####: 4717:    return result;
        -: 4718:}
        -: 4719:
    #####: 4720:static int count_bytes(void* context, const unsigned char* bytes, size_t length)
        -: 4721:{
        -: 4722:    size_t* byte_count;
        -: 4723:    (void)bytes;
        -: 4724:
    #####: 4725:    byte_count = (size_t*)context;
    #####: 4726:    *byte_count += length;
        -: 4727:
    #####: 4728:    return 0;
        -: 4729:}
        -: 4730:
        -: 4731:/* Codes_SRS_AMQPVALUE_01_308: [amqpvalue_get_encoded_size shall fill in the encoded_size argument the number of bytes required to encode the given AMQP value.] */
    #####: 4732:int amqpvalue_get_encoded_size(AMQP_VALUE value, size_t* encoded_size)
        -: 4733:{
        -: 4734:    int result;
        -: 4735:
        -: 4736:    /* Codes_SRS_AMQPVALUE_01_309: [If any argument is NULL, amqpvalue_get_encoded_size shall return a non-zero value.] */
    #####: 4737:    if ((value == NULL) ||
        -: 4738:        (encoded_size == NULL))
        -: 4739:    {
    #####: 4740:        LogError("Bad arguments: value = %p, encoded_size = %p",
        -: 4741:            value, encoded_size);
    #####: 4742:        result = MU_FAILURE;
        -: 4743:    }
        -: 4744:    else
        -: 4745:    {
    #####: 4746:        *encoded_size = 0;
    #####: 4747:        result = amqpvalue_encode(value, count_bytes, encoded_size);
        -: 4748:    }
        -: 4749:
    #####: 4750:    return result;
        -: 4751:}
        -: 4752:
    #####: 4753:static int amqpvalue_get_encoded_array_item_size(AMQP_VALUE item, size_t* encoded_size)
        -: 4754:{
        -: 4755:    int result;
        -: 4756:
    #####: 4757:    if ((item == NULL) ||
        -: 4758:        (encoded_size == NULL))
        -: 4759:    {
    #####: 4760:        LogError("Bad arguments: item = %p, encoded_size = %p", item, encoded_size);
    #####: 4761:        result = MU_FAILURE;
        -: 4762:    }
        -: 4763:    else
        -: 4764:    {
    #####: 4765:        *encoded_size = 0;
    #####: 4766:        result = amqpvalue_encode_array_item(item, false, count_bytes, encoded_size);
        -: 4767:    }
        -: 4768:
    #####: 4769:    return result;
        -: 4770:}
        -: 4771:
       85: 4772:static void amqpvalue_clear(AMQP_VALUE_DATA* value_data)
        -: 4773:{
       85: 4774:    switch (value_data->type)
        -: 4775:    {
       28: 4776:    default:
       28: 4777:        break;
        -: 4778:
    #####: 4779:    case AMQP_TYPE_BINARY:
    #####: 4780:        if (value_data->value.binary_value.bytes != NULL)
        -: 4781:        {
    #####: 4782:            free((void*)value_data->value.binary_value.bytes);
        -: 4783:        }
    #####: 4784:        break;
       20: 4785:    case AMQP_TYPE_STRING:
       20: 4786:        if (value_data->value.string_value.chars != NULL)
        -: 4787:        {
       20: 4788:            free(value_data->value.string_value.chars);
        -: 4789:        }
       20: 4790:        break;
    #####: 4791:    case AMQP_TYPE_SYMBOL:
    #####: 4792:        if (value_data->value.symbol_value.chars != NULL)
        -: 4793:        {
    #####: 4794:            free(value_data->value.symbol_value.chars);
        -: 4795:        }
    #####: 4796:        break;
       18: 4797:    case AMQP_TYPE_LIST:
        -: 4798:    {
        -: 4799:        size_t i;
       36: 4800:        for (i = 0; i < value_data->value.list_value.count; i++)
        -: 4801:        {
       18: 4802:            amqpvalue_destroy(value_data->value.list_value.items[i]);
        -: 4803:        }
        -: 4804:
       18: 4805:        free(value_data->value.list_value.items);
       18: 4806:        value_data->value.list_value.items = NULL;
       18: 4807:        break;
        -: 4808:    }
        1: 4809:    case AMQP_TYPE_MAP:
        -: 4810:    {
        -: 4811:        size_t i;
        2: 4812:        for (i = 0; i < value_data->value.map_value.pair_count; i++)
        -: 4813:        {
        1: 4814:            amqpvalue_destroy(value_data->value.map_value.pairs[i].key);
        1: 4815:            amqpvalue_destroy(value_data->value.map_value.pairs[i].value);
        -: 4816:        }
        -: 4817:
        1: 4818:        free(value_data->value.map_value.pairs);
        1: 4819:        value_data->value.map_value.pairs = NULL;
        1: 4820:        break;
        -: 4821:    }
    #####: 4822:    case AMQP_TYPE_ARRAY:
        -: 4823:    {
        -: 4824:        size_t i;
    #####: 4825:        for (i = 0; i < value_data->value.array_value.count; i++)
        -: 4826:        {
    #####: 4827:            amqpvalue_destroy(value_data->value.array_value.items[i]);
        -: 4828:        }
        -: 4829:
    #####: 4830:        free(value_data->value.array_value.items);
    #####: 4831:        value_data->value.array_value.items = NULL;
    #####: 4832:        break;
        -: 4833:    }
       18: 4834:    case AMQP_TYPE_COMPOSITE:
        -: 4835:    case AMQP_TYPE_DESCRIBED:
       18: 4836:        amqpvalue_destroy(value_data->value.described_value.descriptor);
       18: 4837:        amqpvalue_destroy(value_data->value.described_value.value);
       18: 4838:        break;
        -: 4839:    }
        -: 4840:
       85: 4841:    value_data->type = AMQP_TYPE_UNKNOWN;
       85: 4842:}
        -: 4843:
      166: 4844:void amqpvalue_destroy(AMQP_VALUE value)
        -: 4845:{
        -: 4846:    /* Codes_SRS_AMQPVALUE_01_315: [If the value argument is NULL, amqpvalue_destroy shall do nothing.] */
      166: 4847:    if (value == NULL)
        -: 4848:    {
    #####: 4849:        LogError("NULL value");
        -: 4850:    }
        -: 4851:    else
        -: 4852:    {
      166: 4853:        if (DEC_REF(AMQP_VALUE_DATA, value) == DEC_RETURN_ZERO)
        -: 4854:        {
        -: 4855:            /* Codes_SRS_AMQPVALUE_01_314: [amqpvalue_destroy shall free all resources allocated by any of the amqpvalue_create_xxx functions or amqpvalue_clone.] */
       85: 4856:            AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
       85: 4857:            amqpvalue_clear(value_data);
       85: 4858:            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, value);
        -: 4859:        }
        -: 4860:    }
      166: 4861:}
        -: 4862:
       11: 4863:static INTERNAL_DECODER_DATA* internal_decoder_create(ON_VALUE_DECODED on_value_decoded, void* callback_context, AMQP_VALUE_DATA* value_data, bool is_internal)
        -: 4864:{
       11: 4865:    INTERNAL_DECODER_DATA* internal_decoder_data = (INTERNAL_DECODER_DATA*)malloc(sizeof(INTERNAL_DECODER_DATA));
       11: 4866:    if (internal_decoder_data == NULL)
        -: 4867:    {
    #####: 4868:        LogError("Cannot allocate memory for internal decoder structure");
        -: 4869:    }
        -: 4870:    else
        -: 4871:    {
       11: 4872:        internal_decoder_data->is_internal = is_internal;
       11: 4873:        internal_decoder_data->on_value_decoded = on_value_decoded;
       11: 4874:        internal_decoder_data->on_value_decoded_context = callback_context;
       11: 4875:        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
       11: 4876:        internal_decoder_data->inner_decoder = NULL;
       11: 4877:        internal_decoder_data->decode_to_value = value_data;
        -: 4878:    }
        -: 4879:
       11: 4880:    return internal_decoder_data;
        -: 4881:}
        -: 4882:
       20: 4883:static void internal_decoder_destroy(INTERNAL_DECODER_DATA* internal_decoder)
        -: 4884:{
       20: 4885:    if (internal_decoder != NULL)
        -: 4886:    {
       10: 4887:        internal_decoder_destroy(internal_decoder->inner_decoder);
       10: 4888:        free(internal_decoder);
        -: 4889:    }
       20: 4890:}
        -: 4891:
    #####: 4892:static void inner_decoder_callback(void* context, AMQP_VALUE decoded_value)
        -: 4893:{
        -: 4894:    /* API issue: the decoded_value should be removed completely:
        -: 4895:    TODO: uAMQP: inner_decoder_callback in amqpvalue.c could probably do without the decoded_value ... */
    #####: 4896:    INTERNAL_DECODER_DATA* internal_decoder_data = (INTERNAL_DECODER_DATA*)context;
    #####: 4897:    INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;
        -: 4898:    (void)decoded_value;
    #####: 4899:    inner_decoder->decoder_state = DECODER_STATE_DONE;
    #####: 4900:}
        -: 4901:
    #####: 4902:static int internal_decoder_decode_bytes(INTERNAL_DECODER_DATA* internal_decoder_data, const unsigned char* buffer, size_t size, size_t* used_bytes)
        -: 4903:{
        -: 4904:    int result;
    #####: 4905:    size_t initial_size = size;
        -: 4906:
    #####: 4907:    if (internal_decoder_data == NULL)
        -: 4908:    {
        -: 4909:        /* TODO: investigate if this check is even needed */
    #####: 4910:        LogError("NULL internal_decoder_data");
    #####: 4911:        result = MU_FAILURE;
        -: 4912:    }
        -: 4913:    else
        -: 4914:    {
    #####: 4915:        result = 0;
        -: 4916:        /* Codes_SRS_AMQPVALUE_01_322: [amqpvalue_decode_bytes shall process the bytes byte by byte, as a stream.] */
    #####: 4917:        while ((size > 0) && (internal_decoder_data->decoder_state != DECODER_STATE_DONE))
        -: 4918:        {
    #####: 4919:            switch (internal_decoder_data->decoder_state)
        -: 4920:            {
    #####: 4921:            default:
    #####: 4922:                LogError("Invalid decoder state: %d", (int)internal_decoder_data->decoder_state);
    #####: 4923:                result = MU_FAILURE;
    #####: 4924:                break;
        -: 4925:
    #####: 4926:            case DECODER_STATE_CONSTRUCTOR:
        -: 4927:            {
    #####: 4928:                if ((internal_decoder_data->decode_to_value != NULL) && (!internal_decoder_data->is_internal))
        -: 4929:                {
    #####: 4930:                    amqpvalue_destroy(internal_decoder_data->decode_to_value);
    #####: 4931:                    internal_decoder_data->decode_to_value = NULL;
        -: 4932:                }
        -: 4933:
    #####: 4934:                if (internal_decoder_data->decode_to_value == NULL)
        -: 4935:                {
    #####: 4936:                    internal_decoder_data->decode_to_value = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
        -: 4937:                }
        -: 4938:
    #####: 4939:                if (internal_decoder_data->decode_to_value == NULL)
        -: 4940:                {
    #####: 4941:                    LogError("Cannot allocate decode value");
    #####: 4942:                    result = MU_FAILURE;
    #####: 4943:                    break;
        -: 4944:                }
        -: 4945:
    #####: 4946:                internal_decoder_data->constructor_byte = buffer[0];
    #####: 4947:                buffer++;
    #####: 4948:                size--;
        -: 4949:
    #####: 4950:                switch (internal_decoder_data->constructor_byte)
        -: 4951:                {
    #####: 4952:                default:
    #####: 4953:                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 4954:                    LogError("Invalid constructor byte: 0x%02x", internal_decoder_data->constructor_byte);
    #####: 4955:                    result = MU_FAILURE;
    #####: 4956:                    break;
        -: 4957:
    #####: 4958:                case 0x00: /* descriptor */
        -: 4959:                {
        -: 4960:                    AMQP_VALUE_DATA* descriptor;
    #####: 4961:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_DESCRIBED;
    #####: 4962:                    descriptor = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 4963:                    if (descriptor == NULL)
        -: 4964:                    {
    #####: 4965:                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 4966:                        LogError("Could not allocate memory for descriptor");
    #####: 4967:                        result = MU_FAILURE;
        -: 4968:                    }
        -: 4969:                    else
        -: 4970:                    {
    #####: 4971:                        descriptor->type = AMQP_TYPE_UNKNOWN;
    #####: 4972:                        internal_decoder_data->decode_to_value->value.described_value.descriptor = descriptor;
    #####: 4973:                        internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, descriptor, true);
    #####: 4974:                        if (internal_decoder_data->inner_decoder == NULL)
        -: 4975:                        {
    #####: 4976:                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 4977:                            LogError("Could not create inner decoder for descriptor");
    #####: 4978:                            result = MU_FAILURE;
        -: 4979:                        }
        -: 4980:                        else
        -: 4981:                        {
    #####: 4982:                            internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 4983:                            internal_decoder_data->decode_value_state.described_value_state.described_value_state = DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR;
    #####: 4984:                            result = 0;
        -: 4985:                        }
        -: 4986:                    }
        -: 4987:
    #####: 4988:                    break;
        -: 4989:                }
        -: 4990:
        -: 4991:                /* Codes_SRS_AMQPVALUE_01_329: [<encoding code="0x40" category="fixed" width="0" label="the null value"/>] */
    #####: 4992:                case 0x40:
        -: 4993:                {
        -: 4994:                    /* Codes_SRS_AMQPVALUE_01_328: [1.6.1 null Indicates an empty value.] */
    #####: 4995:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_NULL;
    #####: 4996:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 4997:
        -: 4998:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 4999:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5000:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5001:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5002:                    result = 0;
        -: 5003:
    #####: 5004:                    break;
        -: 5005:                }
        -: 5006:
        -: 5007:                /* Codes_SRS_AMQPVALUE_01_331: [<encoding code="0x56" category="fixed" width="1" label="boolean with the octet 0x00 being false and octet 0x01 being true"/>] */
    #####: 5008:                case 0x56:
        -: 5009:                {
        -: 5010:                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */
    #####: 5011:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;
    #####: 5012:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5013:                    internal_decoder_data->bytes_decoded = 0;
        -: 5014:
        -: 5015:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5016:                    result = 0;
    #####: 5017:                    break;
        -: 5018:                }
        -: 5019:                /* Codes_SRS_AMQPVALUE_01_332: [<encoding name="true" code="0x41" category="fixed" width="0" label="the boolean value true"/>] */
    #####: 5020:                case 0x41:
        -: 5021:                {
        -: 5022:                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */
    #####: 5023:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;
    #####: 5024:                    internal_decoder_data->decode_to_value->value.bool_value = true;
    #####: 5025:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5026:
        -: 5027:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5028:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5029:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5030:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5031:                    result = 0;
    #####: 5032:                    break;
        -: 5033:                }
        -: 5034:                /* Codes_SRS_AMQPVALUE_01_333: [<encoding name="false" code="0x42" category="fixed" width="0" label="the boolean value false"/>] */
    #####: 5035:                case 0x42:
        -: 5036:                {
        -: 5037:                    /* Codes_SRS_AMQPVALUE_01_330: [1.6.2 boolean Represents a true or false value.] */
    #####: 5038:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BOOL;
    #####: 5039:                    internal_decoder_data->decode_to_value->value.bool_value = false;
    #####: 5040:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5041:
        -: 5042:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5043:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5044:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5045:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5046:                    result = 0;
    #####: 5047:                    break;
        -: 5048:                }
        -: 5049:                /* Codes_SRS_AMQPVALUE_01_335: [<encoding code="0x50" category="fixed" width="1" label="8-bit unsigned integer"/>] */
    #####: 5050:                case 0x50:
        -: 5051:                {
        -: 5052:                    /* Codes_SRS_AMQPVALUE_01_334: [1.6.3 ubyte Integer in the range 0 to 28 - 1 inclusive.] */
    #####: 5053:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UBYTE;
    #####: 5054:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5055:                    internal_decoder_data->decode_to_value->value.ubyte_value = 0;
        -: 5056:
        -: 5057:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5058:                    result = 0;
    #####: 5059:                    break;
        -: 5060:                }
        -: 5061:                /* Codes_SRS_AMQPVALUE_01_337: [<encoding code="0x60" category="fixed" width="2" label="16-bit unsigned integer in network byte order"/>] */
    #####: 5062:                case 0x60:
        -: 5063:                {
        -: 5064:                    /* Codes_SRS_AMQPVALUE_01_336: [1.6.4 ushort Integer in the range 0 to 216 - 1 inclusive.] */
    #####: 5065:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_USHORT;
    #####: 5066:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5067:                    internal_decoder_data->decode_to_value->value.ushort_value = 0;
    #####: 5068:                    internal_decoder_data->bytes_decoded = 0;
        -: 5069:
        -: 5070:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5071:                    result = 0;
    #####: 5072:                    break;
        -: 5073:                }
        -: 5074:                /* Codes_SRS_AMQPVALUE_01_339: [<encoding code="0x70" category="fixed" width="4" label="32-bit unsigned integer in network byte order"/>] */
    #####: 5075:                case 0x70:
        -: 5076:                /* Codes_SRS_AMQPVALUE_01_340: [<encoding name="smalluint" code="0x52" category="fixed" width="1" label="unsigned integer value in the range 0 to 255 inclusive"/>] */
        -: 5077:                case 0x52:
        -: 5078:                {
    #####: 5079:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UINT;
    #####: 5080:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5081:                    internal_decoder_data->decode_to_value->value.uint_value = 0;
    #####: 5082:                    internal_decoder_data->bytes_decoded = 0;
        -: 5083:
        -: 5084:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5085:                    result = 0;
    #####: 5086:                    break;
        -: 5087:                }
        -: 5088:                /* Codes_SRS_AMQPVALUE_01_341: [<encoding name="uint0" code="0x43" category="fixed" width="0" label="the uint value 0"/>] */
    #####: 5089:                case 0x43:
        -: 5090:                {
        -: 5091:                    /* Codes_SRS_AMQPVALUE_01_338: [1.6.5 uint Integer in the range 0 to 232 - 1 inclusive.] */
    #####: 5092:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UINT;
    #####: 5093:                    internal_decoder_data->decode_to_value->value.uint_value = 0;
    #####: 5094:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5095:
        -: 5096:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5097:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5098:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5099:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5100:                    result = 0;
    #####: 5101:                    break;
        -: 5102:                }
        -: 5103:                /* Codes_SRS_AMQPVALUE_01_343: [<encoding code="0x80" category="fixed" width="8" label="64-bit unsigned integer in network byte order"/>] */
    #####: 5104:                case 0x80:
        -: 5105:                {
        -: 5106:                    /* Codes_SRS_AMQPVALUE_01_342: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */
    #####: 5107:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;
    #####: 5108:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5109:                    internal_decoder_data->decode_to_value->value.ulong_value = 0;
        -: 5110:
        -: 5111:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5112:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5113:                    result = 0;
    #####: 5114:                    break;
        -: 5115:                }
        -: 5116:                /* Codes_SRS_AMQPVALUE_01_344: [<encoding name="smallulong" code="0x53" category="fixed" width="1" label="unsigned long value in the range 0 to 255 inclusive"/>] */
    #####: 5117:                case 0x53:
        -: 5118:                {
    #####: 5119:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;
    #####: 5120:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5121:                    internal_decoder_data->decode_to_value->value.ulong_value = 0;
        -: 5122:
        -: 5123:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5124:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5125:                    result = 0;
    #####: 5126:                    break;
        -: 5127:                }
        -: 5128:                /* Codes_SRS_AMQPVALUE_01_345: [<encoding name="ulong0" code="0x44" category="fixed" width="0" label="the ulong value 0"/>] */
    #####: 5129:                case 0x44:
        -: 5130:                {
        -: 5131:                    /* Codes_SRS_AMQPVALUE_01_342: [1.6.6 ulong Integer in the range 0 to 264 - 1 inclusive.] */
    #####: 5132:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ULONG;
    #####: 5133:                    internal_decoder_data->decode_to_value->value.ulong_value = 0;
    #####: 5134:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5135:
        -: 5136:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5137:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5138:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5139:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5140:                    result = 0;
    #####: 5141:                    break;
        -: 5142:                }
        -: 5143:                /* Codes_SRS_AMQPVALUE_01_347: [<encoding code="0x51" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 5144:                case 0x51:
        -: 5145:                {
        -: 5146:                    /* Codes_SRS_AMQPVALUE_01_346: [1.6.7 byte Integer in the range -(27) to 27 - 1 inclusive.] */
    #####: 5147:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BYTE;
    #####: 5148:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5149:                    internal_decoder_data->decode_to_value->value.byte_value = 0;
    #####: 5150:                    internal_decoder_data->bytes_decoded = 0;
        -: 5151:
        -: 5152:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5153:                    result = 0;
    #####: 5154:                    break;
        -: 5155:                }
        -: 5156:                /* Codes_SRS_AMQPVALUE_01_349: [<encoding code="0x61" category="fixed" width="2" label="16-bit two's-complement integer in network byte order"/>] */
    #####: 5157:                case 0x61:
        -: 5158:                {
        -: 5159:                    /* Codes_SRS_AMQPVALUE_01_348: [1.6.8 short Integer in the range -(215) to 215 - 1 inclusive.] */
    #####: 5160:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_SHORT;
    #####: 5161:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5162:                    internal_decoder_data->decode_to_value->value.short_value = 0;
    #####: 5163:                    internal_decoder_data->bytes_decoded = 0;
        -: 5164:
        -: 5165:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5166:                    result = 0;
    #####: 5167:                    break;
        -: 5168:                }
        -: 5169:                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code="0x71" category="fixed" width="4" label="32-bit two's-complement integer in network byte order"/>] */
    #####: 5170:                case 0x71:
        -: 5171:                {
        -: 5172:                    /* Codes_SRS_AMQPVALUE_01_350: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */
    #####: 5173:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_INT;
    #####: 5174:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5175:                    internal_decoder_data->decode_to_value->value.int_value = 0;
    #####: 5176:                    internal_decoder_data->bytes_decoded = 0;
        -: 5177:
        -: 5178:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5179:                    result = 0;
    #####: 5180:                    break;
        -: 5181:                }
        -: 5182:                /* Codes_SRS_AMQPVALUE_01_352: [<encoding name="smallint" code="0x54" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 5183:                case 0x54:
        -: 5184:                {
        -: 5185:                    /* Codes_SRS_AMQPVALUE_01_350: [1.6.9 int Integer in the range -(231) to 231 - 1 inclusive.] */
    #####: 5186:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_INT;
    #####: 5187:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5188:                    internal_decoder_data->decode_to_value->value.int_value = 0;
        -: 5189:
        -: 5190:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5191:                    result = 0;
    #####: 5192:                    break;
        -: 5193:                }
        -: 5194:                /* Codes_SRS_AMQPVALUE_01_354: [<encoding code="0x81" category="fixed" width="8" label="64-bit two's-complement integer in network byte order"/>] */
    #####: 5195:                case 0x81:
        -: 5196:                {
        -: 5197:                    /* Codes_SRS_AMQPVALUE_01_353: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */
    #####: 5198:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LONG;
    #####: 5199:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5200:                    internal_decoder_data->decode_to_value->value.long_value = 0;
    #####: 5201:                    internal_decoder_data->bytes_decoded = 0;
        -: 5202:
        -: 5203:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5204:                    result = 0;
    #####: 5205:                    break;
        -: 5206:                }
        -: 5207:                /* Codes_SRS_AMQPVALUE_01_355: [<encoding name="smalllong" code="0x55" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 5208:                case 0x55:
        -: 5209:                {
        -: 5210:                    /* Codes_SRS_AMQPVALUE_01_353: [1.6.10 long Integer in the range -(263) to 263 - 1 inclusive.] */
    #####: 5211:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LONG;
    #####: 5212:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5213:                    internal_decoder_data->decode_to_value->value.long_value = 0;
        -: 5214:
        -: 5215:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5216:                    result = 0;
    #####: 5217:                    break;
        -: 5218:                }
        -: 5219:                /* Codes_SRS_AMQPVALUE_01_289: [\<encoding name="ieee-754" code="0x72" category="fixed" width="4" label="IEEE 754-2008 binary32"/>] */
    #####: 5220:                case 0x72:
        -: 5221:                {
        -: 5222:                    /* Codes_SRS_AMQPVALUE_01_019: [1.6.11 float 32-bit floating point number (IEEE 754-2008 binary32).] */
    #####: 5223:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_FLOAT;
    #####: 5224:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5225:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5226:                    *((uint32_t*)&internal_decoder_data->decode_to_value->value.float_value) = 0;
        -: 5227:
        -: 5228:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5229:                    result = 0;
    #####: 5230:                    break;
        -: 5231:                }
        -: 5232:                /* Codes_SRS_AMQPVALUE_01_290: [\<encoding name="ieee-754" code="0x82" category="fixed" width="8" label="IEEE 754-2008 binary64"/>] */
    #####: 5233:                case 0x82:
        -: 5234:                {
        -: 5235:                    /* Codes_SRS_AMQPVALUE_01_020: [1.6.12 double 64-bit floating point number (IEEE 754-2008 binary64).] */
    #####: 5236:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_DOUBLE;
    #####: 5237:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5238:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5239:                    *((uint64_t*)&internal_decoder_data->decode_to_value->value.double_value) = 0;
        -: 5240:
        -: 5241:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5242:                    result = 0;
    #####: 5243:                    break;
        -: 5244:                }
        -: 5245:                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name="ms64" code="0x83" category="fixed" width="8" label="64-bit two's-complement integer representing milliseconds since the unix epoch"/>] */
    #####: 5246:                case 0x83:
        -: 5247:                {
        -: 5248:                    /* Codes_SRS_AMQPVALUE_01_368: [1.6.17 timestamp An absolute point in time.] */
    #####: 5249:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_TIMESTAMP;
    #####: 5250:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5251:                    internal_decoder_data->decode_to_value->value.timestamp_value = 0;
    #####: 5252:                    internal_decoder_data->bytes_decoded = 0;
        -: 5253:
        -: 5254:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5255:                    result = 0;
    #####: 5256:                    break;
        -: 5257:                }
        -: 5258:                /* Codes_SRS_AMQPVALUE_01_371: [<encoding code="0x98" category="fixed" width="16" label="UUID as defined in section 4.1.2 of RFC-4122"/>] */
    #####: 5259:                case 0x98:
        -: 5260:                {
        -: 5261:                    /* Codes_SRS_AMQPVALUE_01_370: [1.6.18 uuid A universally unique identifier as defined by RFC-4122 section 4.1.2 .] */
    #####: 5262:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_UUID;
    #####: 5263:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5264:                    internal_decoder_data->decode_to_value->value.timestamp_value = 0;
    #####: 5265:                    internal_decoder_data->bytes_decoded = 0;
        -: 5266:
        -: 5267:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5268:                    result = 0;
    #####: 5269:                    break;
        -: 5270:                }
        -: 5271:                /* Codes_SRS_AMQPVALUE_01_373: [<encoding name="vbin8" code="0xa0" category="variable" width="1" label="up to 2^8 - 1 octets of binary data"/>] */
    #####: 5272:                case 0xA0:
        -: 5273:                /* Codes_SRS_AMQPVALUE_01_374: [<encoding name="vbin32" code="0xb0" category="variable" width="4" label="up to 2^32 - 1 octets of binary data"/>] */
        -: 5274:                case 0xB0:
        -: 5275:                {
        -: 5276:                    /* Codes_SRS_AMQPVALUE_01_372: [1.6.19 binary A sequence of octets.] */
    #####: 5277:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_BINARY;
    #####: 5278:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5279:                    internal_decoder_data->decode_to_value->value.binary_value.length = 0;
    #####: 5280:                    internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;
    #####: 5281:                    internal_decoder_data->bytes_decoded = 0;
        -: 5282:
        -: 5283:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5284:                    result = 0;
    #####: 5285:                    break;
        -: 5286:                }
        -: 5287:                /* Codes_SRS_AMQPVALUE_01_376: [<encoding name="str8-utf8" code="0xa1" category="variable" width="1" label="up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 5288:                case 0xA1:
        -: 5289:                /* Codes_SRS_AMQPVALUE_01_377: [<encoding name="str32-utf8" code="0xb1" category="variable" width="4" label="up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
        -: 5290:                case 0xB1:
        -: 5291:                {
        -: 5292:                    /* Codes_SRS_AMQPVALUE_01_375: [1.6.20 string A sequence of Unicode characters.] */
    #####: 5293:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_STRING;
    #####: 5294:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5295:                    internal_decoder_data->decode_to_value->value.string_value.chars = NULL;
    #####: 5296:                    internal_decoder_data->decode_value_state.string_value_state.length = 0;
    #####: 5297:                    internal_decoder_data->bytes_decoded = 0;
        -: 5298:
        -: 5299:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5300:                    result = 0;
    #####: 5301:                    break;
        -: 5302:                }
        -: 5303:                /* Codes_SRS_AMQPVALUE_01_379: [<encoding name="sym8" code="0xa3" category="variable" width="1" label="up to 2^8 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 5304:                case 0xA3:
        -: 5305:                /* Codes_SRS_AMQPVALUE_01_380: [<encoding name="sym32" code="0xb3" category="variable" width="4" label="up to 2^32 - 1 seven bit ASCII characters representing a symbolic value"/>] */
        -: 5306:                case 0xB3:
        -: 5307:                {
        -: 5308:                    /* Codes_SRS_AMQPVALUE_01_378: [1.6.21 symbol Symbolic values from a constrained domain.] */
    #####: 5309:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_SYMBOL;
    #####: 5310:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5311:                    internal_decoder_data->decode_to_value->value.symbol_value.chars = NULL;
    #####: 5312:                    internal_decoder_data->decode_value_state.symbol_value_state.length = 0;
    #####: 5313:                    internal_decoder_data->bytes_decoded = 0;
        -: 5314:
        -: 5315:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5316:                    result = 0;
    #####: 5317:                    break;
        -: 5318:                }
        -: 5319:                /* Codes_SRS_AMQPVALUE_01_384: [<encoding name="list0" code="0x45" category="fixed" width="0" label="the empty list (i.e. the list with no elements)"/>] */
    #####: 5320:                case 0x45:
        -: 5321:                    /* Codes_SRS_AMQPVALUE_01_383: [1.6.22 list A sequence of polymorphic values.] */
    #####: 5322:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LIST;
    #####: 5323:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
    #####: 5324:                    internal_decoder_data->decode_to_value->value.list_value.count = 0;
    #####: 5325:                    internal_decoder_data->decode_to_value->value.list_value.items = NULL;
        -: 5326:
        -: 5327:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5328:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5329:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5330:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5331:                    result = 0;
    #####: 5332:                    break;
        -: 5333:
        -: 5334:                /* Codes_SRS_AMQPVALUE_01_385: [<encoding name="list8" code="0xc0" category="compound" width="1" label="up to 2^8 - 1 list elements with total size less than 2^8 octets"/>] */
    #####: 5335:                case 0xC0:
        -: 5336:                case 0xD0:
    #####: 5337:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_LIST;
    #####: 5338:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5339:                    internal_decoder_data->decode_to_value->value.list_value.count = 0;
    #####: 5340:                    internal_decoder_data->decode_to_value->value.list_value.items = NULL;
    #####: 5341:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5342:                    internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_SIZE;
        -: 5343:
        -: 5344:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5345:                    result = 0;
    #####: 5346:                    break;
        -: 5347:
    #####: 5348:                case 0xC1:
        -: 5349:                case 0xD1:
    #####: 5350:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_MAP;
    #####: 5351:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5352:                    internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;
    #####: 5353:                    internal_decoder_data->decode_to_value->value.map_value.pairs = NULL;
    #####: 5354:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5355:                    internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_SIZE;
        -: 5356:
    #####: 5357:                    result = 0;
    #####: 5358:                    break;
        -: 5359:
    #####: 5360:                case 0xE0:
        -: 5361:                case 0xF0:
    #####: 5362:                    internal_decoder_data->decode_to_value->type = AMQP_TYPE_ARRAY;
    #####: 5363:                    internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
    #####: 5364:                    internal_decoder_data->decode_to_value->value.array_value.count = 0;
    #####: 5365:                    internal_decoder_data->decode_to_value->value.array_value.items = NULL;
    #####: 5366:                    internal_decoder_data->bytes_decoded = 0;
    #####: 5367:                    internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_SIZE;
        -: 5368:
    #####: 5369:                    result = 0;
    #####: 5370:                    break;
        -: 5371:                }
    #####: 5372:                break;
        -: 5373:            }
        -: 5374:
    #####: 5375:            case DECODER_STATE_TYPE_DATA:
        -: 5376:            {
    #####: 5377:                switch (internal_decoder_data->constructor_byte)
        -: 5378:                {
    #####: 5379:                default:
    #####: 5380:                    LogError("Invalid constructor byte: 0x%02x", internal_decoder_data->constructor_byte);
    #####: 5381:                    result = MU_FAILURE;
    #####: 5382:                    break;
        -: 5383:
    #####: 5384:                case 0x00: /* descriptor */
        -: 5385:                {
    #####: 5386:                    DECODE_DESCRIBED_VALUE_STEP step = internal_decoder_data->decode_value_state.described_value_state.described_value_state;
        -: 5387:                    switch (step)
        -: 5388:                    {
    #####: 5389:                    default:
    #####: 5390:                        LogError("Invalid described value decode step: %d", step);
    #####: 5391:                        result = MU_FAILURE;
    #####: 5392:                        break;
        -: 5393:
    #####: 5394:                    case DECODE_DESCRIBED_VALUE_STEP_DESCRIPTOR:
        -: 5395:                    {
        -: 5396:                        size_t inner_used_bytes;
    #####: 5397:                        if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)
        -: 5398:                        {
    #####: 5399:                            LogError("Decoding bytes for described value failed");
    #####: 5400:                            result = MU_FAILURE;
        -: 5401:                        }
        -: 5402:                        else
        -: 5403:                        {
    #####: 5404:                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;
    #####: 5405:                            buffer += inner_used_bytes;
    #####: 5406:                            size -= inner_used_bytes;
        -: 5407:
    #####: 5408:                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)
        -: 5409:                            {
        -: 5410:                                AMQP_VALUE described_value;
    #####: 5411:                                internal_decoder_destroy(inner_decoder);
        -: 5412:
    #####: 5413:                                described_value = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 5414:                                if (described_value == NULL)
        -: 5415:                                {
    #####: 5416:                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 5417:                                    LogError("Could not allocate memory for AMQP value");
    #####: 5418:                                    result = MU_FAILURE;
        -: 5419:                                }
        -: 5420:                                else
        -: 5421:                                {
    #####: 5422:                                    described_value->type = AMQP_TYPE_UNKNOWN;
    #####: 5423:                                    internal_decoder_data->decode_to_value->value.described_value.value = (AMQP_VALUE)described_value;
    #####: 5424:                                    internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, described_value, true);
    #####: 5425:                                    if (internal_decoder_data->inner_decoder == NULL)
        -: 5426:                                    {
    #####: 5427:                                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 5428:                                        LogError("Could not create inner decoder");
    #####: 5429:                                        result = MU_FAILURE;
        -: 5430:                                    }
        -: 5431:                                    else
        -: 5432:                                    {
    #####: 5433:                                        internal_decoder_data->decode_value_state.described_value_state.described_value_state = DECODE_DESCRIBED_VALUE_STEP_VALUE;
    #####: 5434:                                        result = 0;
        -: 5435:                                    }
        -: 5436:                                }
        -: 5437:                            }
        -: 5438:                            else
        -: 5439:                            {
    #####: 5440:                                result = 0;
        -: 5441:                            }
        -: 5442:                        }
    #####: 5443:                        break;
        -: 5444:                    }
    #####: 5445:                    case DECODE_DESCRIBED_VALUE_STEP_VALUE:
        -: 5446:                    {
        -: 5447:                        size_t inner_used_bytes;
    #####: 5448:                        if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)
        -: 5449:                        {
    #####: 5450:                            LogError("Decoding bytes for described value failed");
    #####: 5451:                            result = MU_FAILURE;
        -: 5452:                        }
        -: 5453:                        else
        -: 5454:                        {
    #####: 5455:                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;
    #####: 5456:                            buffer += inner_used_bytes;
    #####: 5457:                            size -= inner_used_bytes;
        -: 5458:
    #####: 5459:                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)
        -: 5460:                            {
    #####: 5461:                                internal_decoder_destroy(inner_decoder);
    #####: 5462:                                internal_decoder_data->inner_decoder = NULL;
        -: 5463:
    #####: 5464:                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
    #####: 5465:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5466:                            }
        -: 5467:
    #####: 5468:                            result = 0;
        -: 5469:                        }
    #####: 5470:                        break;
        -: 5471:                    }
        -: 5472:                    }
    #####: 5473:                    break;
        -: 5474:                }
    #####: 5475:                case 0x56:
        -: 5476:                {
        -: 5477:                    /* Codes_SRS_AMQPVALUE_01_331: [<encoding code="0x56" category="fixed" width="1" label="boolean with the octet 0x00 being false and octet 0x01 being true"/>] */
    #####: 5478:                    if (buffer[0] >= 2)
        -: 5479:                    {
    #####: 5480:                        LogError("Bad boolean value: %02X", buffer[0]);
    #####: 5481:                        result = MU_FAILURE;
        -: 5482:                    }
        -: 5483:                    else
        -: 5484:                    {
    #####: 5485:                        internal_decoder_data->decode_to_value->value.bool_value = (buffer[0] == 0) ? false : true;
        -: 5486:
    #####: 5487:                        buffer++;
    #####: 5488:                        size--;
    #####: 5489:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5490:
        -: 5491:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5492:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5493:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5494:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5495:                        result = 0;
        -: 5496:                    }
        -: 5497:
    #####: 5498:                    break;
        -: 5499:                }
        -: 5500:                /* Codes_SRS_AMQPVALUE_01_335: [<encoding code="0x50" category="fixed" width="1" label="8-bit unsigned integer"/>] */
    #####: 5501:                case 0x50:
        -: 5502:                {
    #####: 5503:                    internal_decoder_data->decode_to_value->value.ubyte_value = buffer[0];
    #####: 5504:                    buffer++;
    #####: 5505:                    size--;
    #####: 5506:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5507:
        -: 5508:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5509:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5510:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5511:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5512:                    result = 0;
    #####: 5513:                    break;
        -: 5514:                }
        -: 5515:                /* Codes_SRS_AMQPVALUE_01_337: [<encoding code="0x60" category="fixed" width="2" label="16-bit unsigned integer in network byte order"/>] */
    #####: 5516:                case 0x60:
        -: 5517:                {
    #####: 5518:                    internal_decoder_data->decode_to_value->value.ushort_value += ((uint16_t)buffer[0]) << ((1 - internal_decoder_data->bytes_decoded) * 8);
    #####: 5519:                    internal_decoder_data->bytes_decoded++;
    #####: 5520:                    buffer++;
    #####: 5521:                    size--;
    #####: 5522:                    if (internal_decoder_data->bytes_decoded == 2)
        -: 5523:                    {
    #####: 5524:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5525:
        -: 5526:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5527:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5528:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5529:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5530:                    }
        -: 5531:
    #####: 5532:                    result = 0;
    #####: 5533:                    break;
        -: 5534:                }
        -: 5535:                /* Codes_SRS_AMQPVALUE_01_339: [<encoding code="0x70" category="fixed" width="4" label="32-bit unsigned integer in network byte order"/>] */
    #####: 5536:                case 0x70:
        -: 5537:                {
    #####: 5538:                    internal_decoder_data->decode_to_value->value.uint_value += ((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8);
    #####: 5539:                    internal_decoder_data->bytes_decoded++;
    #####: 5540:                    buffer++;
    #####: 5541:                    size--;
        -: 5542:
        -: 5543:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5544:                    if (internal_decoder_data->bytes_decoded == 4)
        -: 5545:                    {
    #####: 5546:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5547:
        -: 5548:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5549:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5550:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5551:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5552:                    }
        -: 5553:
    #####: 5554:                    result = 0;
    #####: 5555:                    break;
        -: 5556:                }
        -: 5557:                /* Codes_SRS_AMQPVALUE_01_340: [<encoding name="smalluint" code="0x52" category="fixed" width="1" label="unsigned integer value in the range 0 to 255 inclusive"/>] */
    #####: 5558:                case 0x52:
        -: 5559:                {
    #####: 5560:                    internal_decoder_data->decode_to_value->value.uint_value = buffer[0];
    #####: 5561:                    buffer++;
    #####: 5562:                    size--;
    #####: 5563:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5564:
        -: 5565:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5566:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5567:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5568:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5569:                    result = 0;
    #####: 5570:                    break;
        -: 5571:                }
        -: 5572:                /* Codes_SRS_AMQPVALUE_01_343: [<encoding code="0x80" category="fixed" width="8" label="64-bit unsigned integer in network byte order"/>] */
    #####: 5573:                case 0x80:
        -: 5574:                {
    #####: 5575:                    internal_decoder_data->decode_to_value->value.ulong_value += ((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8);
    #####: 5576:                    internal_decoder_data->bytes_decoded++;
    #####: 5577:                    buffer++;
    #####: 5578:                    size--;
        -: 5579:
        -: 5580:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5581:                    if (internal_decoder_data->bytes_decoded == 8)
        -: 5582:                    {
    #####: 5583:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5584:
        -: 5585:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5586:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5587:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5588:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5589:                    }
        -: 5590:
    #####: 5591:                    result = 0;
    #####: 5592:                    break;
        -: 5593:                }
        -: 5594:                /* Codes_SRS_AMQPVALUE_01_344: [<encoding name="smallulong" code="0x53" category="fixed" width="1" label="unsigned long value in the range 0 to 255 inclusive"/>] */
    #####: 5595:                case 0x53:
        -: 5596:                {
    #####: 5597:                    internal_decoder_data->decode_to_value->value.ulong_value = buffer[0];
    #####: 5598:                    buffer++;
    #####: 5599:                    size--;
    #####: 5600:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5601:
        -: 5602:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5603:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5604:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5605:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5606:                    result = 0;
    #####: 5607:                    break;
        -: 5608:                }
        -: 5609:                /* Codes_SRS_AMQPVALUE_01_347: [<encoding code="0x51" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 5610:                case 0x51:
        -: 5611:                {
    #####: 5612:                    internal_decoder_data->decode_to_value->value.byte_value = buffer[0];
    #####: 5613:                    buffer++;
    #####: 5614:                    size--;
    #####: 5615:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5616:
        -: 5617:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5618:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5619:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5620:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5621:                    result = 0;
    #####: 5622:                    break;
        -: 5623:                }
        -: 5624:                /* Codes_SRS_AMQPVALUE_01_349: [<encoding code="0x61" category="fixed" width="2" label="16-bit two's-complement integer in network byte order"/>] */
    #####: 5625:                case 0x61:
        -: 5626:                {
    #####: 5627:                    internal_decoder_data->decode_to_value->value.short_value = (int16_t)((uint16_t)internal_decoder_data->decode_to_value->value.short_value + (((uint16_t)buffer[0]) << ((1 - internal_decoder_data->bytes_decoded) * 8)));
    #####: 5628:                    internal_decoder_data->bytes_decoded++;
    #####: 5629:                    buffer++;
    #####: 5630:                    size--;
        -: 5631:
        -: 5632:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5633:                    if (internal_decoder_data->bytes_decoded == 2)
        -: 5634:                    {
    #####: 5635:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5636:
        -: 5637:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5638:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5639:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5640:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5641:                    }
        -: 5642:
    #####: 5643:                    result = 0;
    #####: 5644:                    break;
        -: 5645:                }
        -: 5646:                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code="0x71" category="fixed" width="4" label="32-bit two's-complement integer in network byte order"/>] */
    #####: 5647:                case 0x71:
        -: 5648:                {
    #####: 5649:                    internal_decoder_data->decode_to_value->value.int_value = (int32_t)((uint32_t)internal_decoder_data->decode_to_value->value.int_value + (((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8)));
    #####: 5650:                    internal_decoder_data->bytes_decoded++;
    #####: 5651:                    buffer++;
    #####: 5652:                    size--;
        -: 5653:
        -: 5654:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5655:                    if (internal_decoder_data->bytes_decoded == 4)
        -: 5656:                    {
    #####: 5657:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5658:
        -: 5659:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5660:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5661:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5662:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5663:                    }
        -: 5664:
    #####: 5665:                    result = 0;
    #####: 5666:                    break;
        -: 5667:                }
        -: 5668:                /* Codes_SRS_AMQPVALUE_01_351: [<encoding code="0x71" category="fixed" width="4" label="32-bit two's-complement integer in network byte order"/>] */
    #####: 5669:                case 0x54:
        -: 5670:                {
    #####: 5671:                    internal_decoder_data->decode_to_value->value.int_value = (int32_t)((int8_t)(buffer[0]));
    #####: 5672:                    buffer++;
    #####: 5673:                    size--;
    #####: 5674:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5675:
        -: 5676:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5677:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5678:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5679:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5680:                    result = 0;
    #####: 5681:                    break;
        -: 5682:                }
        -: 5683:                /* Codes_SRS_AMQPVALUE_01_354: [<encoding code="0x81" category="fixed" width="8" label="64-bit two's-complement integer in network byte order"/>] */
    #####: 5684:                case 0x81:
        -: 5685:                {
    #####: 5686:                    internal_decoder_data->decode_to_value->value.long_value = (int64_t)((uint64_t)internal_decoder_data->decode_to_value->value.long_value + (((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8)));
    #####: 5687:                    internal_decoder_data->bytes_decoded++;
    #####: 5688:                    buffer++;
    #####: 5689:                    size--;
        -: 5690:
        -: 5691:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5692:                    if (internal_decoder_data->bytes_decoded == 8)
        -: 5693:                    {
    #####: 5694:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5695:
        -: 5696:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5697:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5698:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5699:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5700:                    }
        -: 5701:
    #####: 5702:                    result = 0;
    #####: 5703:                    break;
        -: 5704:                }
        -: 5705:                /* Codes_SRS_AMQPVALUE_01_355: [<encoding name="smalllong" code="0x55" category="fixed" width="1" label="8-bit two's-complement integer"/>] */
    #####: 5706:                case 0x55:
        -: 5707:                {
    #####: 5708:                    internal_decoder_data->decode_to_value->value.long_value = (int64_t)((int8_t)buffer[0]);
    #####: 5709:                    buffer++;
    #####: 5710:                    size--;
    #####: 5711:                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5712:
        -: 5713:                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5714:                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5715:                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5716:                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5717:                    result = 0;
    #####: 5718:                    break;
        -: 5719:                }
        -: 5720:                /* Codes_SRS_AMQPVALUE_01_289: [\<encoding name="ieee-754" code="0x72" category="fixed" width="4" label="IEEE 754-2008 binary32"/>] */
    #####: 5721:                case 0x72:
        -: 5722:                {
    #####: 5723:                    *((uint32_t*)&internal_decoder_data->decode_to_value->value.float_value) += ((uint32_t)buffer[0]) << ((3 - internal_decoder_data->bytes_decoded) * 8);
    #####: 5724:                    internal_decoder_data->bytes_decoded++;
    #####: 5725:                    buffer++;
    #####: 5726:                    size--;
        -: 5727:
        -: 5728:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5729:                    if (internal_decoder_data->bytes_decoded == 4)
        -: 5730:                    {
    #####: 5731:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5732:
        -: 5733:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5734:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5735:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5736:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5737:                    }
        -: 5738:
    #####: 5739:                    result = 0;
    #####: 5740:                    break;
        -: 5741:                }
        -: 5742:                /* Codes_SRS_AMQPVALUE_01_290: [\<encoding name="ieee-754" code="0x82" category="fixed" width="8" label="IEEE 754-2008 binary64"/>]*/
    #####: 5743:                case 0x82:
        -: 5744:                {
    #####: 5745:                    *((uint64_t*)&internal_decoder_data->decode_to_value->value.double_value) += ((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8);
    #####: 5746:                    internal_decoder_data->bytes_decoded++;
    #####: 5747:                    buffer++;
    #####: 5748:                    size--;
        -: 5749:
        -: 5750:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5751:                    if (internal_decoder_data->bytes_decoded == 8)
        -: 5752:                    {
    #####: 5753:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5754:
        -: 5755:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5756:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5757:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5758:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5759:                    }
        -: 5760:
    #####: 5761:                    result = 0;
    #####: 5762:                    break;
        -: 5763:                }
        -: 5764:                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name="ms64" code="0x83" category="fixed" width="8" label="64-bit two's-complement integer representing milliseconds since the unix epoch"/>] */
    #####: 5765:                case 0x83:
        -: 5766:                {
    #####: 5767:                    internal_decoder_data->decode_to_value->value.timestamp_value = (int64_t)((uint64_t)internal_decoder_data->decode_to_value->value.timestamp_value + (((uint64_t)buffer[0]) << ((7 - internal_decoder_data->bytes_decoded) * 8)));
    #####: 5768:                    internal_decoder_data->bytes_decoded++;
    #####: 5769:                    buffer++;
    #####: 5770:                    size--;
        -: 5771:
        -: 5772:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5773:                    if (internal_decoder_data->bytes_decoded == 8)
        -: 5774:                    {
    #####: 5775:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5776:
        -: 5777:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5778:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5779:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5780:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5781:                    }
        -: 5782:
    #####: 5783:                    result = 0;
    #####: 5784:                    break;
        -: 5785:                }
        -: 5786:                /* Codes_SRS_AMQPVALUE_01_369: [<encoding name="ms64" code="0x83" category="fixed" width="8" label="64-bit two's-complement integer representing milliseconds since the unix epoch"/>] */
    #####: 5787:                case 0x98:
        -: 5788:                {
    #####: 5789:                    size_t to_copy = 16 - internal_decoder_data->bytes_decoded;
    #####: 5790:                    if (to_copy > size)
        -: 5791:                    {
    #####: 5792:                        to_copy = size;
        -: 5793:                    }
        -: 5794:
    #####: 5795:                    (void)memcpy(&internal_decoder_data->decode_to_value->value.uuid_value[internal_decoder_data->bytes_decoded], buffer, to_copy);
    #####: 5796:                    internal_decoder_data->bytes_decoded += to_copy;
    #####: 5797:                    buffer += to_copy;
    #####: 5798:                    size -= to_copy;
        -: 5799:
        -: 5800:                    /* Codes_SRS_AMQPVALUE_01_327: [If not enough bytes have accumulated to decode a value, the on_value_decoded shall not be called.] */
    #####: 5801:                    if (internal_decoder_data->bytes_decoded == 16)
        -: 5802:                    {
    #####: 5803:                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5804:
        -: 5805:                        /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5806:                        /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5807:                        /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5808:                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5809:                    }
        -: 5810:
    #####: 5811:                    result = 0;
    #####: 5812:                    break;
        -: 5813:                }
        -: 5814:                /* Codes_SRS_AMQPVALUE_01_373: [<encoding name="vbin8" code="0xa0" category="variable" width="1" label="up to 2^8 - 1 octets of binary data"/>] */
    #####: 5815:                case 0xA0:
        -: 5816:                {
    #####: 5817:                    if (internal_decoder_data->bytes_decoded == 0)
        -: 5818:                    {
    #####: 5819:                        internal_decoder_data->decode_to_value->value.binary_value.length = buffer[0];
    #####: 5820:                        internal_decoder_data->bytes_decoded++;
    #####: 5821:                        buffer++;
    #####: 5822:                        size--;
        -: 5823:
    #####: 5824:                        if (internal_decoder_data->decode_to_value->value.binary_value.length == 0)
        -: 5825:                        {
    #####: 5826:                            internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;
        -: 5827:
        -: 5828:                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5829:                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5830:                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5831:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5832:                            result = 0;
        -: 5833:                        }
        -: 5834:                        else
        -: 5835:                        {
    #####: 5836:                            internal_decoder_data->decode_to_value->value.binary_value.bytes = (unsigned char*)malloc(internal_decoder_data->decode_to_value->value.binary_value.length);
    #####: 5837:                            if (internal_decoder_data->decode_to_value->value.binary_value.bytes == NULL)
        -: 5838:                            {
        -: 5839:                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */
    #####: 5840:                                LogError("Cannot allocate memory for decoded binary value");
    #####: 5841:                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 5842:                                result = MU_FAILURE;
        -: 5843:                            }
        -: 5844:                            else
        -: 5845:                            {
    #####: 5846:                                result = 0;
        -: 5847:                            }
        -: 5848:                        }
        -: 5849:                    }
        -: 5850:                    else
        -: 5851:                    {
    #####: 5852:                        size_t to_copy = internal_decoder_data->decode_to_value->value.binary_value.length - (internal_decoder_data->bytes_decoded - 1);
    #####: 5853:                        if (to_copy > size)
        -: 5854:                        {
    #####: 5855:                            to_copy = size;
        -: 5856:                        }
        -: 5857:
    #####: 5858:                        (void)memcpy((unsigned char*)(internal_decoder_data->decode_to_value->value.binary_value.bytes) + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);
        -: 5859:
    #####: 5860:                        buffer += to_copy;
    #####: 5861:                        size -= to_copy;
    #####: 5862:                        internal_decoder_data->bytes_decoded += to_copy;
        -: 5863:
    #####: 5864:                        if (internal_decoder_data->bytes_decoded == internal_decoder_data->decode_to_value->value.binary_value.length + 1)
        -: 5865:                        {
    #####: 5866:                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5867:
        -: 5868:                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5869:                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5870:                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5871:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5872:                        }
        -: 5873:
    #####: 5874:                        result = 0;
        -: 5875:                    }
        -: 5876:
    #####: 5877:                    break;
        -: 5878:                }
        -: 5879:                /* Codes_SRS_AMQPVALUE_01_374: [<encoding name="vbin32" code="0xb0" category="variable" width="4" label="up to 2^32 - 1 octets of binary data"/>] */
    #####: 5880:                case 0xB0:
        -: 5881:                {
    #####: 5882:                    if (internal_decoder_data->bytes_decoded < 4)
        -: 5883:                    {
    #####: 5884:                        internal_decoder_data->decode_to_value->value.binary_value.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);
    #####: 5885:                        internal_decoder_data->bytes_decoded++;
    #####: 5886:                        buffer++;
    #####: 5887:                        size--;
        -: 5888:
    #####: 5889:                        if (internal_decoder_data->bytes_decoded == 4)
        -: 5890:                        {
    #####: 5891:                            if (internal_decoder_data->decode_to_value->value.binary_value.length == 0)
        -: 5892:                            {
    #####: 5893:                                internal_decoder_data->decode_to_value->value.binary_value.bytes = NULL;
        -: 5894:
        -: 5895:                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5896:                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5897:                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5898:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 5899:                                result = 0;
        -: 5900:                            }
        -: 5901:                            else
        -: 5902:                            {
    #####: 5903:                                internal_decoder_data->decode_to_value->value.binary_value.bytes = (unsigned char*)malloc(internal_decoder_data->decode_to_value->value.binary_value.length + 1);
    #####: 5904:                                if (internal_decoder_data->decode_to_value->value.binary_value.bytes == NULL)
        -: 5905:                                {
        -: 5906:                                    /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */
    #####: 5907:                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 5908:                                    LogError("Cannot allocate memory for decoded binary value");
    #####: 5909:                                    result = MU_FAILURE;
        -: 5910:                                }
        -: 5911:                                else
        -: 5912:                                {
    #####: 5913:                                    result = 0;
        -: 5914:                                }
        -: 5915:                            }
        -: 5916:                        }
        -: 5917:                        else
        -: 5918:                        {
    #####: 5919:                            result = 0;
        -: 5920:                        }
        -: 5921:                    }
        -: 5922:                    else
        -: 5923:                    {
    #####: 5924:                        size_t to_copy = internal_decoder_data->decode_to_value->value.binary_value.length - (internal_decoder_data->bytes_decoded - 4);
    #####: 5925:                        if (to_copy > size)
        -: 5926:                        {
    #####: 5927:                            to_copy = size;
        -: 5928:                        }
        -: 5929:
    #####: 5930:                        (void)memcpy((unsigned char*)(internal_decoder_data->decode_to_value->value.binary_value.bytes) + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);
    #####: 5931:                        buffer += to_copy;
    #####: 5932:                        size -= to_copy;
    #####: 5933:                        internal_decoder_data->bytes_decoded += to_copy;
        -: 5934:
    #####: 5935:                        if (internal_decoder_data->bytes_decoded == internal_decoder_data->decode_to_value->value.binary_value.length + 4)
        -: 5936:                        {
    #####: 5937:                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
    #####: 5938:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5939:                        }
        -: 5940:
    #####: 5941:                        result = 0;
        -: 5942:                    }
        -: 5943:
    #####: 5944:                    break;
        -: 5945:                }
        -: 5946:                /* Codes_SRS_AMQPVALUE_01_376: [<encoding name="str8-utf8" code="0xa1" category="variable" width="1" label="up to 2^8 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 5947:                case 0xA1:
        -: 5948:                {
    #####: 5949:                    if (internal_decoder_data->bytes_decoded == 0)
        -: 5950:                    {
    #####: 5951:                        internal_decoder_data->decode_value_state.string_value_state.length = buffer[0];
    #####: 5952:                        internal_decoder_data->bytes_decoded++;
    #####: 5953:                        buffer++;
    #####: 5954:                        size--;
        -: 5955:
    #####: 5956:                        internal_decoder_data->decode_to_value->value.string_value.chars = (char*)malloc(internal_decoder_data->decode_value_state.string_value_state.length + 1);
    #####: 5957:                        if (internal_decoder_data->decode_to_value->value.string_value.chars == NULL)
        -: 5958:                        {
        -: 5959:                            /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */
    #####: 5960:                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 5961:                            LogError("Could not allocate memory for decoded string value");
    #####: 5962:                            result = MU_FAILURE;
        -: 5963:                        }
        -: 5964:                        else
        -: 5965:                        {
    #####: 5966:                            if (internal_decoder_data->decode_value_state.string_value_state.length == 0)
        -: 5967:                            {
    #####: 5968:                                internal_decoder_data->decode_to_value->value.string_value.chars[0] = '\0';
        -: 5969:
        -: 5970:                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5971:                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5972:                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 5973:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 5974:                            }
        -: 5975:
    #####: 5976:                            result = 0;
        -: 5977:                        }
        -: 5978:                    }
        -: 5979:                    else
        -: 5980:                    {
    #####: 5981:                        size_t to_copy = internal_decoder_data->decode_value_state.string_value_state.length - (internal_decoder_data->bytes_decoded - 1);
    #####: 5982:                        if (to_copy > size)
        -: 5983:                        {
    #####: 5984:                            to_copy = size;
        -: 5985:                        }
        -: 5986:
    #####: 5987:                        (void)memcpy(internal_decoder_data->decode_to_value->value.string_value.chars + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);
    #####: 5988:                        buffer += to_copy;
    #####: 5989:                        size -= to_copy;
    #####: 5990:                        internal_decoder_data->bytes_decoded += to_copy;
        -: 5991:
    #####: 5992:                        if (internal_decoder_data->bytes_decoded == internal_decoder_data->decode_value_state.string_value_state.length + 1)
        -: 5993:                        {
    #####: 5994:                            internal_decoder_data->decode_to_value->value.string_value.chars[internal_decoder_data->decode_value_state.string_value_state.length] = 0;
    #####: 5995:                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 5996:
        -: 5997:                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 5998:                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 5999:                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6000:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6001:                        }
        -: 6002:
    #####: 6003:                        result = 0;
        -: 6004:                    }
    #####: 6005:                    break;
        -: 6006:                }
        -: 6007:                /* Codes_SRS_AMQPVALUE_01_377: [<encoding name="str32-utf8" code="0xb1" category="variable" width="4" label="up to 2^32 - 1 octets worth of UTF-8 Unicode (with no byte order mark)"/>] */
    #####: 6008:                case 0xB1:
        -: 6009:                {
    #####: 6010:                    if (internal_decoder_data->bytes_decoded < 4)
        -: 6011:                    {
    #####: 6012:                        internal_decoder_data->decode_value_state.string_value_state.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);
    #####: 6013:                        internal_decoder_data->bytes_decoded++;
    #####: 6014:                        buffer++;
    #####: 6015:                        size--;
        -: 6016:
    #####: 6017:                        if (internal_decoder_data->bytes_decoded == 4)
        -: 6018:                        {
    #####: 6019:                            internal_decoder_data->decode_to_value->value.string_value.chars = (char*)malloc(internal_decoder_data->decode_value_state.string_value_state.length + 1);
    #####: 6020:                            if (internal_decoder_data->decode_to_value->value.string_value.chars == NULL)
        -: 6021:                            {
        -: 6022:                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */
    #####: 6023:                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6024:                                LogError("Could not allocate memory for decoded string value");
    #####: 6025:                                result = MU_FAILURE;
        -: 6026:                            }
        -: 6027:                            else
        -: 6028:                            {
    #####: 6029:                                if (internal_decoder_data->decode_value_state.string_value_state.length == 0)
        -: 6030:                                {
    #####: 6031:                                    internal_decoder_data->decode_to_value->value.string_value.chars[0] = '\0';
        -: 6032:
        -: 6033:                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6034:                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6035:                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6036:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6037:                                }
        -: 6038:
    #####: 6039:                                result = 0;
        -: 6040:                            }
        -: 6041:                        }
        -: 6042:                        else
        -: 6043:                        {
    #####: 6044:                            result = 0;
        -: 6045:                        }
        -: 6046:                    }
        -: 6047:                    else
        -: 6048:                    {
    #####: 6049:                        size_t to_copy = internal_decoder_data->decode_value_state.string_value_state.length - (internal_decoder_data->bytes_decoded - 4);
    #####: 6050:                        if (to_copy > size)
        -: 6051:                        {
    #####: 6052:                            to_copy = size;
        -: 6053:                        }
        -: 6054:
    #####: 6055:                        (void)memcpy(internal_decoder_data->decode_to_value->value.string_value.chars + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);
    #####: 6056:                        buffer += to_copy;
    #####: 6057:                        size -= to_copy;
    #####: 6058:                        internal_decoder_data->bytes_decoded += to_copy;
        -: 6059:
    #####: 6060:                        if (internal_decoder_data->bytes_decoded == internal_decoder_data->decode_value_state.string_value_state.length + 4)
        -: 6061:                        {
    #####: 6062:                            internal_decoder_data->decode_to_value->value.string_value.chars[internal_decoder_data->decode_value_state.string_value_state.length] = '\0';
    #####: 6063:                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6064:
        -: 6065:                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6066:                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6067:                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6068:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6069:                        }
        -: 6070:
    #####: 6071:                        result = 0;
        -: 6072:                    }
    #####: 6073:                    break;
        -: 6074:                }
        -: 6075:                /* Codes_SRS_AMQPVALUE_01_379: [<encoding name="sym8" code="0xa3" category="variable" width="1" label="up to 2^8 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 6076:                case 0xA3:
        -: 6077:                {
    #####: 6078:                    if (internal_decoder_data->bytes_decoded == 0)
        -: 6079:                    {
    #####: 6080:                        internal_decoder_data->decode_value_state.symbol_value_state.length = buffer[0];
    #####: 6081:                        internal_decoder_data->bytes_decoded++;
    #####: 6082:                        buffer++;
    #####: 6083:                        size--;
        -: 6084:
    #####: 6085:                        internal_decoder_data->decode_to_value->value.symbol_value.chars = (char*)malloc(internal_decoder_data->decode_value_state.symbol_value_state.length + 1);
    #####: 6086:                        if (internal_decoder_data->decode_to_value->value.symbol_value.chars == NULL)
        -: 6087:                        {
        -: 6088:                            /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */
    #####: 6089:                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6090:                            LogError("Could not allocate memory for decoded symbol value");
    #####: 6091:                            result = MU_FAILURE;
        -: 6092:                        }
        -: 6093:                        else
        -: 6094:                        {
    #####: 6095:                            if (internal_decoder_data->decode_value_state.symbol_value_state.length == 0)
        -: 6096:                            {
    #####: 6097:                                internal_decoder_data->decode_to_value->value.symbol_value.chars[0] = '\0';
        -: 6098:
        -: 6099:                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6100:                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6101:                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6102:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6103:                            }
        -: 6104:
    #####: 6105:                            result = 0;
        -: 6106:                        }
        -: 6107:                    }
        -: 6108:                    else
        -: 6109:                    {
    #####: 6110:                        size_t to_copy = internal_decoder_data->decode_value_state.symbol_value_state.length - (internal_decoder_data->bytes_decoded - 1);
    #####: 6111:                        if (to_copy > size)
        -: 6112:                        {
    #####: 6113:                            to_copy = size;
        -: 6114:                        }
        -: 6115:
    #####: 6116:                        (void)memcpy(internal_decoder_data->decode_to_value->value.symbol_value.chars + (internal_decoder_data->bytes_decoded - 1), buffer, to_copy);
    #####: 6117:                        buffer += to_copy;
    #####: 6118:                        size -= to_copy;
    #####: 6119:                        internal_decoder_data->bytes_decoded += to_copy;
        -: 6120:
    #####: 6121:                        if (internal_decoder_data->bytes_decoded == internal_decoder_data->decode_value_state.symbol_value_state.length + 1)
        -: 6122:                        {
    #####: 6123:                            internal_decoder_data->decode_to_value->value.symbol_value.chars[internal_decoder_data->decode_value_state.symbol_value_state.length] = 0;
    #####: 6124:                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6125:
        -: 6126:                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6127:                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6128:                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6129:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6130:                        }
        -: 6131:
    #####: 6132:                        result = 0;
        -: 6133:                    }
    #####: 6134:                    break;
        -: 6135:                }
        -: 6136:                /* Codes_SRS_AMQPVALUE_01_380: [<encoding name="sym32" code="0xb3" category="variable" width="4" label="up to 2^32 - 1 seven bit ASCII characters representing a symbolic value"/>] */
    #####: 6137:                case 0xB3:
        -: 6138:                {
    #####: 6139:                    if (internal_decoder_data->bytes_decoded < 4)
        -: 6140:                    {
    #####: 6141:                        internal_decoder_data->decode_value_state.symbol_value_state.length += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);
    #####: 6142:                        internal_decoder_data->bytes_decoded++;
    #####: 6143:                        buffer++;
    #####: 6144:                        size--;
        -: 6145:
    #####: 6146:                        if (internal_decoder_data->bytes_decoded == 4)
        -: 6147:                        {
    #####: 6148:                            internal_decoder_data->decode_to_value->value.symbol_value.chars = (char*)malloc(internal_decoder_data->decode_value_state.symbol_value_state.length + 1);
    #####: 6149:                            if (internal_decoder_data->decode_to_value->value.symbol_value.chars == NULL)
        -: 6150:                            {
        -: 6151:                                /* Codes_SRS_AMQPVALUE_01_326: [If any allocation failure occurs during decoding, amqpvalue_decode_bytes shall fail and return a non-zero value.] */
    #####: 6152:                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6153:                                LogError("Could not allocate memory for decoded symbol value");
    #####: 6154:                                result = MU_FAILURE;
        -: 6155:                            }
        -: 6156:                            else
        -: 6157:                            {
    #####: 6158:                                if (internal_decoder_data->decode_value_state.symbol_value_state.length == 0)
        -: 6159:                                {
    #####: 6160:                                    internal_decoder_data->decode_to_value->value.symbol_value.chars[0] = '\0';
        -: 6161:
        -: 6162:                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6163:                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6164:                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6165:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6166:                                }
        -: 6167:
    #####: 6168:                                result = 0;
        -: 6169:                            }
        -: 6170:                        }
        -: 6171:                        else
        -: 6172:                        {
    #####: 6173:                            result = 0;
        -: 6174:                        }
        -: 6175:                    }
        -: 6176:                    else
        -: 6177:                    {
    #####: 6178:                        size_t to_copy = internal_decoder_data->decode_value_state.symbol_value_state.length - (internal_decoder_data->bytes_decoded - 4);
    #####: 6179:                        if (to_copy > size)
        -: 6180:                        {
    #####: 6181:                            to_copy = size;
        -: 6182:                        }
        -: 6183:
    #####: 6184:                        (void)memcpy(internal_decoder_data->decode_to_value->value.symbol_value.chars + (internal_decoder_data->bytes_decoded - 4), buffer, to_copy);
    #####: 6185:                        buffer += to_copy;
    #####: 6186:                        size -= to_copy;
    #####: 6187:                        internal_decoder_data->bytes_decoded += to_copy;
        -: 6188:
    #####: 6189:                        if (internal_decoder_data->bytes_decoded == internal_decoder_data->decode_value_state.symbol_value_state.length + 4)
        -: 6190:                        {
    #####: 6191:                            internal_decoder_data->decode_to_value->value.symbol_value.chars[internal_decoder_data->decode_value_state.symbol_value_state.length] = '\0';
    #####: 6192:                            internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6193:
        -: 6194:                            /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6195:                            /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6196:                            /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6197:                            internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6198:                        }
        -: 6199:
    #####: 6200:                        result = 0;
        -: 6201:                    }
    #####: 6202:                    break;
        -: 6203:                }
        -: 6204:                /* Codes_SRS_AMQPVALUE_01_385: [<encoding name="list8" code="0xc0" category="compound" width="1" label="up to 2^8 - 1 list elements with total size less than 2^8 octets"/>] */
    #####: 6205:                case 0xC0:
        -: 6206:                /* Codes_SRS_AMQPVALUE_01_386: [<encoding name="list32" code="0xd0" category="compound" width="4" label="up to 2^32 - 1 list elements with total size less than 2^32 octets"/>] */
        -: 6207:                case 0xD0:
        -: 6208:                {
    #####: 6209:                    DECODE_LIST_STEP step = internal_decoder_data->decode_value_state.list_value_state.list_value_state;
        -: 6210:
        -: 6211:                    switch (step)
        -: 6212:                    {
    #####: 6213:                    default:
    #####: 6214:                        LogError("Invalid step in decoding list value: %d", step);
    #####: 6215:                        result = MU_FAILURE;
    #####: 6216:                        break;
        -: 6217:
    #####: 6218:                    case DECODE_LIST_STEP_SIZE:
    #####: 6219:                        internal_decoder_data->bytes_decoded++;
    #####: 6220:                        buffer++;
    #####: 6221:                        size--;
        -: 6222:
    #####: 6223:                        if (internal_decoder_data->constructor_byte == 0xC0)
        -: 6224:                        {
    #####: 6225:                            internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_COUNT;
    #####: 6226:                            internal_decoder_data->bytes_decoded = 0;
    #####: 6227:                            internal_decoder_data->decode_to_value->value.list_value.count = 0;
    #####: 6228:                            result = 0;
        -: 6229:                        }
        -: 6230:                        else
        -: 6231:                        {
    #####: 6232:                            if (internal_decoder_data->bytes_decoded == 4)
        -: 6233:                            {
    #####: 6234:                                internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_COUNT;
    #####: 6235:                                internal_decoder_data->bytes_decoded = 0;
    #####: 6236:                                internal_decoder_data->decode_to_value->value.list_value.count = 0;
        -: 6237:                            }
        -: 6238:
    #####: 6239:                            result = 0;
        -: 6240:                        }
        -: 6241:
    #####: 6242:                        break;
        -: 6243:
    #####: 6244:                    case DECODE_LIST_STEP_COUNT:
    #####: 6245:                        if (internal_decoder_data->constructor_byte == 0xC0)
        -: 6246:                        {
    #####: 6247:                            internal_decoder_data->decode_to_value->value.list_value.count = buffer[0];
        -: 6248:                        }
        -: 6249:                        else
        -: 6250:                        {
    #####: 6251:                            internal_decoder_data->decode_to_value->value.list_value.count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);
        -: 6252:                        }
        -: 6253:
    #####: 6254:                        internal_decoder_data->bytes_decoded++;
    #####: 6255:                        buffer++;
    #####: 6256:                        size--;
        -: 6257:
    #####: 6258:                        if (internal_decoder_data->constructor_byte == 0xC0)
        -: 6259:                        {
    #####: 6260:                            if (internal_decoder_data->decode_to_value->value.list_value.count == 0)
        -: 6261:                            {
    #####: 6262:                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6263:
        -: 6264:                                /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6265:                                /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6266:                                /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6267:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 6268:                                result = 0;
        -: 6269:                            }
        -: 6270:                            else
        -: 6271:                            {
        -: 6272:                                uint32_t i;
    #####: 6273:                                internal_decoder_data->decode_to_value->value.list_value.items = (AMQP_VALUE*)malloc(sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.list_value.count);
    #####: 6274:                                if (internal_decoder_data->decode_to_value->value.list_value.items == NULL)
        -: 6275:                                {
    #####: 6276:                                    LogError("Could not allocate memory for decoded list value");
    #####: 6277:                                    result = MU_FAILURE;
        -: 6278:                                }
        -: 6279:                                else
        -: 6280:                                {
    #####: 6281:                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.list_value.count; i++)
        -: 6282:                                    {
    #####: 6283:                                        internal_decoder_data->decode_to_value->value.list_value.items[i] = NULL;
        -: 6284:                                    }
        -: 6285:
    #####: 6286:                                    internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_ITEMS;
    #####: 6287:                                    internal_decoder_data->bytes_decoded = 0;
    #####: 6288:                                    internal_decoder_data->inner_decoder = NULL;
    #####: 6289:                                    internal_decoder_data->decode_value_state.list_value_state.item = 0;
    #####: 6290:                                    result = 0;
        -: 6291:                                }
        -: 6292:                            }
        -: 6293:                        }
        -: 6294:                        else
        -: 6295:                        {
    #####: 6296:                            if (internal_decoder_data->bytes_decoded == 4)
        -: 6297:                            {
    #####: 6298:                                if (internal_decoder_data->decode_to_value->value.list_value.count == 0)
        -: 6299:                                {
    #####: 6300:                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6301:
        -: 6302:                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6303:                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6304:                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6305:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 6306:                                    result = 0;
        -: 6307:                                }
        -: 6308:                                else
        -: 6309:                                {
        -: 6310:                                    uint32_t i;
        -: 6311:
    #####: 6312:                                    internal_decoder_data->decode_to_value->value.list_value.items = (AMQP_VALUE*)malloc(sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.list_value.count);
    #####: 6313:                                    if (internal_decoder_data->decode_to_value->value.list_value.items == NULL)
        -: 6314:                                    {
    #####: 6315:                                        LogError("Could not allocate memory for decoded list value");
    #####: 6316:                                        result = MU_FAILURE;
        -: 6317:                                    }
        -: 6318:                                    else
        -: 6319:                                    {
    #####: 6320:                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.list_value.count; i++)
        -: 6321:                                        {
    #####: 6322:                                            internal_decoder_data->decode_to_value->value.list_value.items[i] = NULL;
        -: 6323:                                        }
        -: 6324:
    #####: 6325:                                        internal_decoder_data->decode_value_state.list_value_state.list_value_state = DECODE_LIST_STEP_ITEMS;
    #####: 6326:                                        internal_decoder_data->bytes_decoded = 0;
    #####: 6327:                                        internal_decoder_data->inner_decoder = NULL;
    #####: 6328:                                        internal_decoder_data->decode_value_state.list_value_state.item = 0;
    #####: 6329:                                        result = 0;
        -: 6330:                                    }
        -: 6331:                                }
        -: 6332:                            }
        -: 6333:                            else
        -: 6334:                            {
    #####: 6335:                                result = 0;
        -: 6336:                            }
        -: 6337:                        }
    #####: 6338:                        break;
        -: 6339:
    #####: 6340:                    case DECODE_LIST_STEP_ITEMS:
        -: 6341:                    {
        -: 6342:                        size_t inner_used_bytes;
        -: 6343:
    #####: 6344:                        if (internal_decoder_data->bytes_decoded == 0)
        -: 6345:                        {
    #####: 6346:                            AMQP_VALUE_DATA* list_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 6347:                            if (list_item == NULL)
        -: 6348:                            {
    #####: 6349:                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6350:                                result = MU_FAILURE;
        -: 6351:                            }
        -: 6352:                            else
        -: 6353:                            {
    #####: 6354:                                list_item->type = AMQP_TYPE_UNKNOWN;
    #####: 6355:                                internal_decoder_data->decode_to_value->value.list_value.items[internal_decoder_data->decode_value_state.list_value_state.item] = list_item;
    #####: 6356:                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, list_item, true);
    #####: 6357:                                if (internal_decoder_data->inner_decoder == NULL)
        -: 6358:                                {
    #####: 6359:                                    LogError("Could not create inner decoder for list items");
    #####: 6360:                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6361:                                    result = MU_FAILURE;
        -: 6362:                                }
        -: 6363:                                else
        -: 6364:                                {
    #####: 6365:                                    result = 0;
        -: 6366:                                }
        -: 6367:                            }
        -: 6368:                        }
        -: 6369:
    #####: 6370:                        if (internal_decoder_data->inner_decoder == NULL)
        -: 6371:                        {
    #####: 6372:                            LogError("NULL inner decoder. This should not happen under normal circumstances");
    #####: 6373:                            result = MU_FAILURE;
        -: 6374:                        }
    #####: 6375:                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)
        -: 6376:                        {
    #####: 6377:                            LogError("Decoding list items failed");
    #####: 6378:                            result = MU_FAILURE;
        -: 6379:                        }
        -: 6380:                        else
        -: 6381:                        {
    #####: 6382:                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;
    #####: 6383:                            internal_decoder_data->bytes_decoded += inner_used_bytes;
    #####: 6384:                            buffer += inner_used_bytes;
    #####: 6385:                            size -= inner_used_bytes;
        -: 6386:
    #####: 6387:                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)
        -: 6388:                            {
    #####: 6389:                                internal_decoder_destroy(inner_decoder);
    #####: 6390:                                internal_decoder_data->inner_decoder = NULL;
    #####: 6391:                                internal_decoder_data->bytes_decoded = 0;
        -: 6392:
    #####: 6393:                                internal_decoder_data->decode_value_state.list_value_state.item++;
    #####: 6394:                                if (internal_decoder_data->decode_value_state.list_value_state.item == internal_decoder_data->decode_to_value->value.list_value.count)
        -: 6395:                                {
    #####: 6396:                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6397:
        -: 6398:                                    /* Codes_SRS_AMQPVALUE_01_323: [When enough bytes have been processed for a valid amqp value, the on_value_decoded passed in amqpvalue_decoder_create shall be called.] */
        -: 6399:                                    /* Codes_SRS_AMQPVALUE_01_324: [The decoded amqp value shall be passed to on_value_decoded.] */
        -: 6400:                                    /* Codes_SRS_AMQPVALUE_01_325: [Also the context stored in amqpvalue_decoder_create shall be passed to the on_value_decoded callback.] */
    #####: 6401:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6402:                                }
        -: 6403:
        -: 6404:                            }
        -: 6405:
    #####: 6406:                            result = 0;
        -: 6407:                        }
        -: 6408:
    #####: 6409:                        break;
        -: 6410:                    }
        -: 6411:                    }
        -: 6412:
    #####: 6413:                    break;
        -: 6414:                }
    #####: 6415:                case 0xC1:
        -: 6416:                case 0xD1:
        -: 6417:                {
    #####: 6418:                    DECODE_MAP_STEP step = internal_decoder_data->decode_value_state.map_value_state.map_value_state;
        -: 6419:
        -: 6420:                    switch (step)
        -: 6421:                    {
    #####: 6422:                    default:
    #####: 6423:                        LogError("Invalid step in decoding map value: %d", step);
    #####: 6424:                        result = MU_FAILURE;
    #####: 6425:                        break;
        -: 6426:
    #####: 6427:                    case DECODE_MAP_STEP_SIZE:
    #####: 6428:                        internal_decoder_data->bytes_decoded++;
    #####: 6429:                        buffer++;
    #####: 6430:                        size--;
        -: 6431:
    #####: 6432:                        if (internal_decoder_data->constructor_byte == 0xC1)
        -: 6433:                        {
    #####: 6434:                            internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_COUNT;
    #####: 6435:                            internal_decoder_data->bytes_decoded = 0;
    #####: 6436:                            internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;
    #####: 6437:                            result = 0;
        -: 6438:                        }
        -: 6439:                        else
        -: 6440:                        {
    #####: 6441:                            if (internal_decoder_data->bytes_decoded == 4)
        -: 6442:                            {
    #####: 6443:                                internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_COUNT;
    #####: 6444:                                internal_decoder_data->bytes_decoded = 0;
    #####: 6445:                                internal_decoder_data->decode_to_value->value.map_value.pair_count = 0;
        -: 6446:                            }
    #####: 6447:                            result = 0;
        -: 6448:                        }
        -: 6449:
    #####: 6450:                        break;
        -: 6451:
    #####: 6452:                    case DECODE_MAP_STEP_COUNT:
    #####: 6453:                        if (internal_decoder_data->constructor_byte == 0xC1)
        -: 6454:                        {
    #####: 6455:                            internal_decoder_data->decode_to_value->value.map_value.pair_count = buffer[0];
        -: 6456:                        }
        -: 6457:                        else
        -: 6458:                        {
    #####: 6459:                            internal_decoder_data->decode_to_value->value.map_value.pair_count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);
        -: 6460:                        }
    #####: 6461:                        internal_decoder_data->bytes_decoded++;
    #####: 6462:                        buffer++;
    #####: 6463:                        size--;
        -: 6464:
    #####: 6465:                        if (internal_decoder_data->constructor_byte == 0xC1)
        -: 6466:                        {
    #####: 6467:                            if (internal_decoder_data->decode_to_value->value.map_value.pair_count == 0)
        -: 6468:                            {
    #####: 6469:                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6470:
    #####: 6471:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 6472:                                result = 0;
        -: 6473:                            }
        -: 6474:                            else
        -: 6475:                            {
        -: 6476:                                uint32_t i;
        -: 6477:
    #####: 6478:                                internal_decoder_data->decode_to_value->value.map_value.pair_count /= 2;
        -: 6479:
    #####: 6480:                                internal_decoder_data->decode_to_value->value.map_value.pairs = (AMQP_MAP_KEY_VALUE_PAIR*)malloc(sizeof(AMQP_MAP_KEY_VALUE_PAIR) * (internal_decoder_data->decode_to_value->value.map_value.pair_count * 2));
    #####: 6481:                                if (internal_decoder_data->decode_to_value->value.map_value.pairs == NULL)
        -: 6482:                                {
    #####: 6483:                                    LogError("Could not allocate memory for map value items");
    #####: 6484:                                    result = MU_FAILURE;
        -: 6485:                                }
        -: 6486:                                else
        -: 6487:                                {
    #####: 6488:                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.map_value.pair_count; i++)
        -: 6489:                                    {
    #####: 6490:                                        internal_decoder_data->decode_to_value->value.map_value.pairs[i].key = NULL;
    #####: 6491:                                        internal_decoder_data->decode_to_value->value.map_value.pairs[i].value = NULL;
        -: 6492:                                    }
        -: 6493:
    #####: 6494:                                    internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_PAIRS;
    #####: 6495:                                    internal_decoder_data->bytes_decoded = 0;
    #####: 6496:                                    internal_decoder_data->inner_decoder = NULL;
    #####: 6497:                                    internal_decoder_data->decode_value_state.map_value_state.item = 0;
    #####: 6498:                                    result = 0;
        -: 6499:                                }
        -: 6500:                            }
        -: 6501:                        }
        -: 6502:                        else
        -: 6503:                        {
    #####: 6504:                            if (internal_decoder_data->bytes_decoded == 4)
        -: 6505:                            {
    #####: 6506:                                if (internal_decoder_data->decode_to_value->value.map_value.pair_count == 0)
        -: 6507:                                {
    #####: 6508:                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6509:
    #####: 6510:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 6511:                                    result = 0;
        -: 6512:                                }
        -: 6513:                                else
        -: 6514:                                {
        -: 6515:                                    uint32_t i;
        -: 6516:
    #####: 6517:                                    internal_decoder_data->decode_to_value->value.map_value.pair_count /= 2;
        -: 6518:
    #####: 6519:                                    internal_decoder_data->decode_to_value->value.map_value.pairs = (AMQP_MAP_KEY_VALUE_PAIR*)malloc(sizeof(AMQP_MAP_KEY_VALUE_PAIR) * (internal_decoder_data->decode_to_value->value.map_value.pair_count * 2));
    #####: 6520:                                    if (internal_decoder_data->decode_to_value->value.map_value.pairs == NULL)
        -: 6521:                                    {
    #####: 6522:                                        LogError("Could not allocate memory for map value items");
    #####: 6523:                                        result = MU_FAILURE;
        -: 6524:                                    }
        -: 6525:                                    else
        -: 6526:                                    {
    #####: 6527:                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.map_value.pair_count; i++)
        -: 6528:                                        {
    #####: 6529:                                            internal_decoder_data->decode_to_value->value.map_value.pairs[i].key = NULL;
    #####: 6530:                                            internal_decoder_data->decode_to_value->value.map_value.pairs[i].value = NULL;
        -: 6531:                                        }
        -: 6532:
    #####: 6533:                                        internal_decoder_data->decode_value_state.map_value_state.map_value_state = DECODE_MAP_STEP_PAIRS;
    #####: 6534:                                        internal_decoder_data->bytes_decoded = 0;
    #####: 6535:                                        internal_decoder_data->inner_decoder = NULL;
    #####: 6536:                                        internal_decoder_data->decode_value_state.map_value_state.item = 0;
    #####: 6537:                                        result = 0;
        -: 6538:                                    }
        -: 6539:                                }
        -: 6540:                            }
        -: 6541:                            else
        -: 6542:                            {
    #####: 6543:                                result = 0;
        -: 6544:                            }
        -: 6545:                        }
    #####: 6546:                        break;
        -: 6547:
    #####: 6548:                    case DECODE_MAP_STEP_PAIRS:
        -: 6549:                    {
        -: 6550:                        size_t inner_used_bytes;
        -: 6551:
    #####: 6552:                        if (internal_decoder_data->bytes_decoded == 0)
        -: 6553:                        {
    #####: 6554:                            AMQP_VALUE_DATA* map_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 6555:                            if (map_item == NULL)
        -: 6556:                            {
    #####: 6557:                                LogError("Could not allocate memory for map item");
    #####: 6558:                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6559:                                result = MU_FAILURE;
        -: 6560:                            }
        -: 6561:                            else
        -: 6562:                            {
    #####: 6563:                                map_item->type = AMQP_TYPE_UNKNOWN;
    #####: 6564:                                if (internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].key == NULL)
        -: 6565:                                {
    #####: 6566:                                    internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].key = map_item;
        -: 6567:                                }
        -: 6568:                                else
        -: 6569:                                {
    #####: 6570:                                    internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].value = map_item;
        -: 6571:                                }
    #####: 6572:                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, map_item, true);
    #####: 6573:                                if (internal_decoder_data->inner_decoder == NULL)
        -: 6574:                                {
    #####: 6575:                                    LogError("Could not create inner decoder for map item");
    #####: 6576:                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6577:                                    result = MU_FAILURE;
        -: 6578:                                }
        -: 6579:                                else
        -: 6580:                                {
    #####: 6581:                                    result = 0;
        -: 6582:                                }
        -: 6583:                            }
        -: 6584:                        }
        -: 6585:
    #####: 6586:                        if (internal_decoder_data->inner_decoder == NULL)
        -: 6587:                        {
    #####: 6588:                            LogError("NULL inner decoder. This should not happen under normal circumstances");
    #####: 6589:                            result = MU_FAILURE;
        -: 6590:                        }
    #####: 6591:                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)
        -: 6592:                        {
    #####: 6593:                            LogError("Could not decode map item");
    #####: 6594:                            result = MU_FAILURE;
        -: 6595:                        }
        -: 6596:                        else
        -: 6597:                        {
    #####: 6598:                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;
    #####: 6599:                            internal_decoder_data->bytes_decoded += inner_used_bytes;
    #####: 6600:                            buffer += inner_used_bytes;
    #####: 6601:                            size -= inner_used_bytes;
        -: 6602:
    #####: 6603:                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)
        -: 6604:                            {
    #####: 6605:                                internal_decoder_destroy(inner_decoder);
    #####: 6606:                                internal_decoder_data->inner_decoder = NULL;
    #####: 6607:                                internal_decoder_data->bytes_decoded = 0;
        -: 6608:
    #####: 6609:                                if (internal_decoder_data->decode_to_value->value.map_value.pairs[internal_decoder_data->decode_value_state.map_value_state.item].value != NULL)
        -: 6610:                                {
    #####: 6611:                                    internal_decoder_data->decode_value_state.map_value_state.item++;
    #####: 6612:                                    if (internal_decoder_data->decode_value_state.map_value_state.item == internal_decoder_data->decode_to_value->value.map_value.pair_count)
        -: 6613:                                    {
    #####: 6614:                                        internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6615:
    #####: 6616:                                        internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6617:                                    }
        -: 6618:                                }
        -: 6619:                            }
        -: 6620:
    #####: 6621:                            result = 0;
        -: 6622:                        }
        -: 6623:
    #####: 6624:                        break;
        -: 6625:                    }
        -: 6626:                    }
        -: 6627:
    #####: 6628:                    break;
        -: 6629:                }
    #####: 6630:                case 0xE0:
        -: 6631:                case 0xF0:
        -: 6632:                {
    #####: 6633:                    DECODE_ARRAY_STEP step = internal_decoder_data->decode_value_state.array_value_state.array_value_state;
        -: 6634:
        -: 6635:                    switch (step)
        -: 6636:                    {
    #####: 6637:                    default:
    #####: 6638:                        LogError("Invalid step in decoding array value: %d", step);
    #####: 6639:                        result = MU_FAILURE;
    #####: 6640:                        break;
        -: 6641:
    #####: 6642:                    case DECODE_ARRAY_STEP_SIZE:
    #####: 6643:                        internal_decoder_data->bytes_decoded++;
    #####: 6644:                        buffer++;
    #####: 6645:                        size--;
        -: 6646:
    #####: 6647:                        if (internal_decoder_data->constructor_byte == 0xE0)
        -: 6648:                        {
    #####: 6649:                            internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_COUNT;
    #####: 6650:                            internal_decoder_data->bytes_decoded = 0;
    #####: 6651:                            internal_decoder_data->decode_to_value->value.array_value.count = 0;
    #####: 6652:                            result = 0;
        -: 6653:                        }
        -: 6654:                        else
        -: 6655:                        {
    #####: 6656:                            if (internal_decoder_data->bytes_decoded == 4)
        -: 6657:                            {
    #####: 6658:                                internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_COUNT;
    #####: 6659:                                internal_decoder_data->bytes_decoded = 0;
    #####: 6660:                                internal_decoder_data->decode_to_value->value.array_value.count = 0;
        -: 6661:                            }
    #####: 6662:                            result = 0;
        -: 6663:                        }
        -: 6664:
    #####: 6665:                        break;
        -: 6666:
    #####: 6667:                    case DECODE_ARRAY_STEP_COUNT:
    #####: 6668:                        if (internal_decoder_data->constructor_byte == 0xE0)
        -: 6669:                        {
    #####: 6670:                            internal_decoder_data->decode_to_value->value.array_value.count = buffer[0];
        -: 6671:                        }
        -: 6672:                        else
        -: 6673:                        {
    #####: 6674:                            internal_decoder_data->decode_to_value->value.array_value.count += buffer[0] << ((3 - internal_decoder_data->bytes_decoded) * 8);
        -: 6675:                        }
        -: 6676:
    #####: 6677:                        internal_decoder_data->bytes_decoded++;
    #####: 6678:                        buffer++;
    #####: 6679:                        size--;
        -: 6680:
    #####: 6681:                        if (internal_decoder_data->constructor_byte == 0xE0)
        -: 6682:                        {
    #####: 6683:                            if (internal_decoder_data->decode_to_value->value.array_value.count == 0)
        -: 6684:                            {
    #####: 6685:                                internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
        -: 6686:
    #####: 6687:                                internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 6688:                                result = 0;
        -: 6689:                            }
        -: 6690:                            else
        -: 6691:                            {
        -: 6692:                                uint32_t i;
    #####: 6693:                                internal_decoder_data->decode_to_value->value.array_value.items = (AMQP_VALUE*)malloc(sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.array_value.count);
    #####: 6694:                                if (internal_decoder_data->decode_to_value->value.array_value.items == NULL)
        -: 6695:                                {
    #####: 6696:                                    LogError("Could not allocate memory for array items");
    #####: 6697:                                    result = MU_FAILURE;
        -: 6698:                                }
        -: 6699:                                else
        -: 6700:                                {
    #####: 6701:                                    for (i = 0; i < internal_decoder_data->decode_to_value->value.array_value.count; i++)
        -: 6702:                                    {
    #####: 6703:                                        internal_decoder_data->decode_to_value->value.array_value.items[i] = NULL;
        -: 6704:                                    }
        -: 6705:
    #####: 6706:                                    internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_ITEMS;
    #####: 6707:                                    internal_decoder_data->bytes_decoded = 0;
    #####: 6708:                                    internal_decoder_data->inner_decoder = NULL;
    #####: 6709:                                    internal_decoder_data->decode_value_state.array_value_state.item = 0;
    #####: 6710:                                    result = 0;
        -: 6711:                                }
        -: 6712:                            }
        -: 6713:                        }
        -: 6714:                        else
        -: 6715:                        {
    #####: 6716:                            if (internal_decoder_data->bytes_decoded == 4)
        -: 6717:                            {
    #####: 6718:                                if (internal_decoder_data->decode_to_value->value.array_value.count == 0)
        -: 6719:                                {
    #####: 6720:                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
    #####: 6721:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
    #####: 6722:                                    result = 0;
        -: 6723:                                }
        -: 6724:                                else
        -: 6725:                                {
        -: 6726:                                    uint32_t i;
    #####: 6727:                                    internal_decoder_data->decode_to_value->value.array_value.items = (AMQP_VALUE*)malloc(sizeof(AMQP_VALUE) * internal_decoder_data->decode_to_value->value.array_value.count);
    #####: 6728:                                    if (internal_decoder_data->decode_to_value->value.array_value.items == NULL)
        -: 6729:                                    {
    #####: 6730:                                        LogError("Could not allocate memory for array items");
    #####: 6731:                                        result = MU_FAILURE;
        -: 6732:                                    }
        -: 6733:                                    else
        -: 6734:                                    {
    #####: 6735:                                        for (i = 0; i < internal_decoder_data->decode_to_value->value.array_value.count; i++)
        -: 6736:                                        {
    #####: 6737:                                            internal_decoder_data->decode_to_value->value.array_value.items[i] = NULL;
        -: 6738:                                        }
    #####: 6739:                                        internal_decoder_data->decode_value_state.array_value_state.array_value_state = DECODE_ARRAY_STEP_ITEMS;
    #####: 6740:                                        internal_decoder_data->bytes_decoded = 0;
    #####: 6741:                                        internal_decoder_data->inner_decoder = NULL;
    #####: 6742:                                        internal_decoder_data->decode_value_state.array_value_state.item = 0;
    #####: 6743:                                        result = 0;
        -: 6744:                                    }
        -: 6745:                                }
        -: 6746:                            }
        -: 6747:                            else
        -: 6748:                            {
    #####: 6749:                                result = 0;
        -: 6750:                            }
        -: 6751:                        }
    #####: 6752:                        break;
        -: 6753:
    #####: 6754:                    case DECODE_ARRAY_STEP_ITEMS:
        -: 6755:                    {
        -: 6756:                        size_t inner_used_bytes;
        -: 6757:
    #####: 6758:                        if (internal_decoder_data->bytes_decoded == 0)
        -: 6759:                        {
        -: 6760:                            AMQP_VALUE_DATA* array_item;
    #####: 6761:                            internal_decoder_data->decode_value_state.array_value_state.constructor_byte = buffer[0];
        -: 6762:
    #####: 6763:                            array_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 6764:                            if (array_item == NULL)
        -: 6765:                            {
    #####: 6766:                                LogError("Could not allocate memory for array item to be decoded");
    #####: 6767:                                internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6768:                                result = MU_FAILURE;
        -: 6769:                            }
        -: 6770:                            else
        -: 6771:                            {
    #####: 6772:                                array_item->type = AMQP_TYPE_UNKNOWN;
    #####: 6773:                                internal_decoder_data->decode_to_value->value.array_value.items[internal_decoder_data->decode_value_state.array_value_state.item] = array_item;
    #####: 6774:                                internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, array_item, true);
    #####: 6775:                                if (internal_decoder_data->inner_decoder == NULL)
        -: 6776:                                {
    #####: 6777:                                    internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6778:                                    LogError("Could not create inner decoder for array items");
    #####: 6779:                                    result = MU_FAILURE;
        -: 6780:                                }
        -: 6781:                                else
        -: 6782:                                {
    #####: 6783:                                    result = 0;
        -: 6784:                                }
        -: 6785:                            }
        -: 6786:                        }
        -: 6787:
    #####: 6788:                        if (internal_decoder_data->inner_decoder == NULL)
        -: 6789:                        {
    #####: 6790:                            LogError("NULL inner decoder. This should not happen under normal circumstances");
    #####: 6791:                            result = MU_FAILURE;
        -: 6792:                        }
    #####: 6793:                        else if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, buffer, size, &inner_used_bytes) != 0)
        -: 6794:                        {
    #####: 6795:                            LogError("Could not decode array item");
    #####: 6796:                            result = MU_FAILURE;
        -: 6797:                        }
        -: 6798:                        else
        -: 6799:                        {
    #####: 6800:                            INTERNAL_DECODER_DATA* inner_decoder = (INTERNAL_DECODER_DATA*)internal_decoder_data->inner_decoder;
    #####: 6801:                            internal_decoder_data->bytes_decoded += inner_used_bytes;
    #####: 6802:                            size -= inner_used_bytes;
        -: 6803:
    #####: 6804:                            if (inner_decoder->decoder_state == DECODER_STATE_DONE)
        -: 6805:                            {
    #####: 6806:                                internal_decoder_destroy(inner_decoder);
    #####: 6807:                                internal_decoder_data->inner_decoder = NULL;
        -: 6808:
    #####: 6809:                                internal_decoder_data->decode_value_state.array_value_state.item++;
    #####: 6810:                                if (internal_decoder_data->decode_value_state.array_value_state.item == internal_decoder_data->decode_to_value->value.array_value.count)
        -: 6811:                                {
    #####: 6812:                                    buffer += inner_used_bytes;
    #####: 6813:                                    internal_decoder_data->decoder_state = DECODER_STATE_CONSTRUCTOR;
    #####: 6814:                                    internal_decoder_data->on_value_decoded(internal_decoder_data->on_value_decoded_context, internal_decoder_data->decode_to_value);
        -: 6815:
    #####: 6816:                                    result = 0;
        -: 6817:                                }
        -: 6818:                                else
        -: 6819:                                {
        -: 6820:                                    AMQP_VALUE_DATA* array_item;
        -: 6821:
    #####: 6822:                                    if ((internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x40) ||
    #####: 6823:                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x41) ||
    #####: 6824:                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x42) ||
    #####: 6825:                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x43) ||
    #####: 6826:                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x44) ||
    #####: 6827:                                        (internal_decoder_data->decode_value_state.array_value_state.constructor_byte == 0x45))
        -: 6828:                                    {
        -: 6829:                                        /* Array items are constructor-only, e.g. NULL Don't increment buffer to account for implied data. */
    #####: 6830:                                        size += inner_used_bytes;
    #####: 6831:                                        internal_decoder_data->decoder_state = DECODER_STATE_TYPE_DATA;
        -: 6832:                                    }
        -: 6833:                                    else
        -: 6834:                                    {
    #####: 6835:                                        buffer += inner_used_bytes;
        -: 6836:                                    }
        -: 6837:
    #####: 6838:                                    array_item = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 6839:                                    if (array_item == NULL)
        -: 6840:                                    {
    #####: 6841:                                        LogError("Could not allocate memory for array item");
    #####: 6842:                                        internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6843:                                        result = MU_FAILURE;
        -: 6844:                                    }
        -: 6845:                                    else
        -: 6846:                                    {
    #####: 6847:                                        array_item->type = AMQP_TYPE_UNKNOWN;
    #####: 6848:                                        internal_decoder_data->decode_to_value->value.array_value.items[internal_decoder_data->decode_value_state.array_value_state.item] = array_item;
    #####: 6849:                                        internal_decoder_data->inner_decoder = internal_decoder_create(inner_decoder_callback, internal_decoder_data, array_item, true);
    #####: 6850:                                        if (internal_decoder_data->inner_decoder == NULL)
        -: 6851:                                        {
    #####: 6852:                                            LogError("Could not create inner decoder for array item");
    #####: 6853:                                            internal_decoder_data->decoder_state = DECODER_STATE_ERROR;
    #####: 6854:                                            result = MU_FAILURE;
        -: 6855:                                        }
        -: 6856:                                        else
        -: 6857:                                        {
    #####: 6858:                                            if (internal_decoder_decode_bytes(internal_decoder_data->inner_decoder, &internal_decoder_data->decode_value_state.array_value_state.constructor_byte, 1, NULL) != 0)
        -: 6859:                                            {
    #####: 6860:                                                LogError("Could not decode array item data");
    #####: 6861:                                                result = MU_FAILURE;
        -: 6862:                                            }
        -: 6863:                                            else
        -: 6864:                                            {
    #####: 6865:                                                result = 0;
        -: 6866:                                            }
        -: 6867:                                        }
        -: 6868:                                    }
        -: 6869:                                }
        -: 6870:                            }
        -: 6871:                            else
        -: 6872:                            {
    #####: 6873:                                buffer += inner_used_bytes;
    #####: 6874:                                result = 0;
        -: 6875:                            }
        -: 6876:                        }
        -: 6877:
    #####: 6878:                        break;
        -: 6879:                    }
        -: 6880:                    }
        -: 6881:
    #####: 6882:                    break;
        -: 6883:                }
        -: 6884:                }
    #####: 6885:                break;
        -: 6886:            }
        -: 6887:            }
        -: 6888:
    #####: 6889:            if (result != 0)
        -: 6890:            {
    #####: 6891:                break;
        -: 6892:            }
        -: 6893:        }
        -: 6894:    }
        -: 6895:
    #####: 6896:    if (used_bytes != NULL)
        -: 6897:    {
    #####: 6898:        *used_bytes = initial_size - size;
        -: 6899:    }
        -: 6900:
    #####: 6901:    return result;
        -: 6902:}
        -: 6903:
       11: 6904:AMQPVALUE_DECODER_HANDLE amqpvalue_decoder_create(ON_VALUE_DECODED on_value_decoded, void* callback_context)
        -: 6905:{
        -: 6906:    AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance;
        -: 6907:
        -: 6908:    /* Codes_SRS_AMQPVALUE_01_312: [If the on_value_decoded argument is NULL, amqpvalue_decoder_create shall return NULL.] */
       11: 6909:    if (on_value_decoded == NULL)
        -: 6910:    {
    #####: 6911:        LogError("NULL on_value_decoded");
    #####: 6912:        decoder_instance = NULL;
        -: 6913:    }
        -: 6914:    else
        -: 6915:    {
       11: 6916:        decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)malloc(sizeof(AMQPVALUE_DECODER_HANDLE_DATA));
        -: 6917:        /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */
       11: 6918:        if (decoder_instance == NULL)
        -: 6919:        {
    #####: 6920:            LogError("Could not allocate memory for AMQP value decoder");
        -: 6921:        }
        -: 6922:        else
        -: 6923:        {
       11: 6924:            decoder_instance->decode_to_value = REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
       11: 6925:            if (decoder_instance->decode_to_value == NULL)
        -: 6926:            {
        -: 6927:                /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */
    #####: 6928:                LogError("Could not allocate memory for decoded AMQP value");
    #####: 6929:                free(decoder_instance);
    #####: 6930:                decoder_instance = NULL;
        -: 6931:            }
        -: 6932:            else
        -: 6933:            {
       11: 6934:                decoder_instance->decode_to_value->type = AMQP_TYPE_UNKNOWN;
       11: 6935:                decoder_instance->internal_decoder = internal_decoder_create(on_value_decoded, callback_context, decoder_instance->decode_to_value, false);
       11: 6936:                if (decoder_instance->internal_decoder == NULL)
        -: 6937:                {
        -: 6938:                    /* Codes_SRS_AMQPVALUE_01_313: [If creating the decoder fails, amqpvalue_decoder_create shall return NULL.] */
    #####: 6939:                    LogError("Could not create the internal decoder");
    #####: 6940:                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, decoder_instance->decode_to_value);
    #####: 6941:                    free(decoder_instance);
    #####: 6942:                    decoder_instance = NULL;
        -: 6943:                }
        -: 6944:            }
        -: 6945:        }
        -: 6946:    }
        -: 6947:
        -: 6948:    /* Codes_SRS_AMQPVALUE_01_311: [amqpvalue_decoder_create shall create a new amqp value decoder and return a non-NULL handle to it.] */
       11: 6949:    return decoder_instance;
        -: 6950:}
        -: 6951:
       10: 6952:void amqpvalue_decoder_destroy(AMQPVALUE_DECODER_HANDLE handle)
        -: 6953:{
       10: 6954:    if (handle == NULL)
        -: 6955:    {
        -: 6956:        /* Codes_SRS_AMQPVALUE_01_317: [If handle is NULL, amqpvalue_decoder_destroy shall do nothing.] */
    #####: 6957:        LogError("NULL handle");
        -: 6958:    }
        -: 6959:    else
        -: 6960:    {
       10: 6961:        AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)handle;
        -: 6962:        /* Codes_SRS_AMQPVALUE_01_316: [amqpvalue_decoder_destroy shall free all resources associated with the amqpvalue_decoder.] */
       10: 6963:        amqpvalue_destroy(decoder_instance->internal_decoder->decode_to_value);
       10: 6964:        internal_decoder_destroy(decoder_instance->internal_decoder);
       10: 6965:        free(handle);
        -: 6966:    }
       10: 6967:}
        -: 6968:
        -: 6969:/* Codes_SRS_AMQPVALUE_01_318: [amqpvalue_decode_bytes shall decode size bytes that are passed in the buffer argument.] */
    #####: 6970:int amqpvalue_decode_bytes(AMQPVALUE_DECODER_HANDLE handle, const unsigned char* buffer, size_t size)
        -: 6971:{
        -: 6972:    int result;
        -: 6973:
    #####: 6974:    AMQPVALUE_DECODER_HANDLE_DATA* decoder_instance = (AMQPVALUE_DECODER_HANDLE_DATA*)handle;
        -: 6975:    /* Codes_SRS_AMQPVALUE_01_320: [If handle or buffer are NULL, amqpvalue_decode_bytes shall return a non-zero value.] */
    #####: 6976:    if ((decoder_instance == NULL) ||
    #####: 6977:        (buffer == NULL) ||
        -: 6978:        /* Codes_SRS_AMQPVALUE_01_321: [If size is 0, amqpvalue_decode_bytes shall return a non-zero value.] */
        -: 6979:        (size == 0))
        -: 6980:    {
    #####: 6981:        LogError("Bad arguments: decoder_instance = %p, buffer = %p, size = %lu",
        -: 6982:            decoder_instance, buffer, (unsigned long)size);
    #####: 6983:        result = MU_FAILURE;
        -: 6984:    }
        -: 6985:    else
        -: 6986:    {
        -: 6987:        size_t used_bytes;
        -: 6988:
        -: 6989:        /* Codes_SRS_AMQPVALUE_01_318: [amqpvalue_decode_bytes shall decode size bytes that are passed in the buffer argument.] */
    #####: 6990:        if (internal_decoder_decode_bytes(decoder_instance->internal_decoder, buffer, size, &used_bytes) != 0)
        -: 6991:        {
    #####: 6992:            LogError("Failed decoding bytes");
    #####: 6993:            result = MU_FAILURE;
        -: 6994:        }
        -: 6995:        else
        -: 6996:        {
        -: 6997:            /* Codes_SRS_AMQPVALUE_01_319: [On success, amqpvalue_decode_bytes shall return 0.] */
    #####: 6998:            result = 0;
        -: 6999:        }
        -: 7000:    }
        -: 7001:
    #####: 7002:    return result;
        -: 7003:}
        -: 7004:
    #####: 7005:AMQP_VALUE amqpvalue_get_inplace_descriptor(AMQP_VALUE value)
        -: 7006:{
        -: 7007:    AMQP_VALUE result;
        -: 7008:
    #####: 7009:    if (value == NULL)
        -: 7010:    {
    #####: 7011:        LogError("NULL value");
    #####: 7012:        result = NULL;
        -: 7013:    }
        -: 7014:    else
        -: 7015:    {
    #####: 7016:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 7017:        if ((value_data->type != AMQP_TYPE_DESCRIBED) &&
    #####: 7018:            (value_data->type != AMQP_TYPE_COMPOSITE))
        -: 7019:        {
    #####: 7020:            LogError("Type is not described or composite");
    #####: 7021:            result = NULL;
        -: 7022:        }
        -: 7023:        else
        -: 7024:        {
    #####: 7025:            result = value_data->value.described_value.descriptor;
        -: 7026:        }
        -: 7027:    }
        -: 7028:
    #####: 7029:    return result;
        -: 7030:}
        -: 7031:
    #####: 7032:AMQP_VALUE amqpvalue_get_inplace_described_value(AMQP_VALUE value)
        -: 7033:{
        -: 7034:    AMQP_VALUE result;
        -: 7035:
    #####: 7036:    if (value == NULL)
        -: 7037:    {
    #####: 7038:        LogError("NULL value");
    #####: 7039:        result = NULL;
        -: 7040:    }
        -: 7041:    else
        -: 7042:    {
    #####: 7043:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 7044:        if ((value_data->type != AMQP_TYPE_DESCRIBED) &&
    #####: 7045:            (value_data->type != AMQP_TYPE_COMPOSITE))
        -: 7046:        {
    #####: 7047:            LogError("Type is not described or composite");
    #####: 7048:            result = NULL;
        -: 7049:        }
        -: 7050:        else
        -: 7051:        {
    #####: 7052:            result = value_data->value.described_value.value;
        -: 7053:        }
        -: 7054:    }
        -: 7055:
    #####: 7056:    return result;
        -: 7057:}
        -: 7058:
    #####: 7059:AMQP_VALUE amqpvalue_create_described(AMQP_VALUE descriptor, AMQP_VALUE value)
        -: 7060:{
    #####: 7061:    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 7062:    if (result == NULL)
        -: 7063:    {
    #####: 7064:        LogError("Cannot allocate memory for described type");
        -: 7065:    }
        -: 7066:    else
        -: 7067:    {
    #####: 7068:        result->type = AMQP_TYPE_DESCRIBED;
    #####: 7069:        result->value.described_value.descriptor = descriptor;
    #####: 7070:        result->value.described_value.value = value;
        -: 7071:    }
        -: 7072:
    #####: 7073:    return result;
        -: 7074:}
        -: 7075:
    #####: 7076:AMQP_VALUE amqpvalue_create_composite(AMQP_VALUE descriptor, uint32_t list_size)
        -: 7077:{
    #####: 7078:    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
    #####: 7079:    if (result == NULL)
        -: 7080:    {
    #####: 7081:        LogError("Cannot allocate memory for composite type");
        -: 7082:    }
        -: 7083:    else
        -: 7084:    {
    #####: 7085:        result->type = AMQP_TYPE_COMPOSITE;
    #####: 7086:        result->value.described_value.descriptor = amqpvalue_clone(descriptor);
    #####: 7087:        if (result->value.described_value.descriptor == NULL)
        -: 7088:        {
    #####: 7089:            LogError("Cannot clone descriptor for composite type");
    #####: 7090:            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 7091:            result = NULL;
        -: 7092:        }
        -: 7093:        else
        -: 7094:        {
    #####: 7095:            result->value.described_value.value = amqpvalue_create_list();
    #####: 7096:            if (result->value.described_value.value == NULL)
        -: 7097:            {
    #####: 7098:                LogError("Cannot create list for composite type");
    #####: 7099:                amqpvalue_destroy(result->value.described_value.descriptor);
    #####: 7100:                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 7101:                result = NULL;
        -: 7102:            }
        -: 7103:            else
        -: 7104:            {
    #####: 7105:                if (amqpvalue_set_list_item_count(result->value.described_value.value, list_size) != 0)
        -: 7106:                {
    #####: 7107:                    LogError("Cannot set list item count for composite type");
    #####: 7108:                    amqpvalue_destroy(result->value.described_value.descriptor);
    #####: 7109:                    amqpvalue_destroy(result->value.described_value.value);
    #####: 7110:                    REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 7111:                    result = NULL;
        -: 7112:                }
        -: 7113:            }
        -: 7114:        }
        -: 7115:    }
        -: 7116:
    #####: 7117:    return result;
        -: 7118:}
        -: 7119:
       18: 7120:AMQP_VALUE amqpvalue_create_composite_with_ulong_descriptor(uint64_t descriptor)
        -: 7121:{
       18: 7122:    AMQP_VALUE_DATA* result = (AMQP_VALUE_DATA*)REFCOUNT_TYPE_CREATE(AMQP_VALUE_DATA);
       18: 7123:    if (result == NULL)
        -: 7124:    {
    #####: 7125:        LogError("Cannot allocate memory for composite type");
        -: 7126:    }
        -: 7127:    else
        -: 7128:    {
       18: 7129:        AMQP_VALUE descriptor_ulong_value = amqpvalue_create_ulong(descriptor);
       18: 7130:        if (descriptor_ulong_value == NULL)
        -: 7131:        {
    #####: 7132:            LogError("Cannot create ulong descriptor for composite type");
    #####: 7133:            REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 7134:            result = NULL;
        -: 7135:        }
        -: 7136:        else
        -: 7137:        {
       18: 7138:            result->type = AMQP_TYPE_COMPOSITE;
       18: 7139:            result->value.described_value.descriptor = descriptor_ulong_value;
       18: 7140:            result->value.described_value.value = amqpvalue_create_list();
       18: 7141:            if (result->value.described_value.value == NULL)
        -: 7142:            {
    #####: 7143:                LogError("Cannot create list for composite type");
    #####: 7144:                amqpvalue_destroy(descriptor_ulong_value);
    #####: 7145:                REFCOUNT_TYPE_DESTROY(AMQP_VALUE_DATA, result);
    #####: 7146:                result = NULL;
        -: 7147:            }
        -: 7148:        }
        -: 7149:    }
        -: 7150:
       18: 7151:    return result;
        -: 7152:}
        -: 7153:
       18: 7154:int amqpvalue_set_composite_item(AMQP_VALUE value, uint32_t index, AMQP_VALUE item_value)
        -: 7155:{
        -: 7156:    int result;
        -: 7157:
       18: 7158:    if (value == NULL)
        -: 7159:    {
    #####: 7160:        LogError("NULL value");
    #####: 7161:        result = MU_FAILURE;
        -: 7162:    }
        -: 7163:    else
        -: 7164:    {
       18: 7165:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
      18*: 7166:        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&
    #####: 7167:            (value_data->type != AMQP_TYPE_DESCRIBED))
        -: 7168:        {
    #####: 7169:            LogError("Attempt to set composite item on a non-composite type");
    #####: 7170:            result = MU_FAILURE;
        -: 7171:        }
        -: 7172:        else
        -: 7173:        {
       18: 7174:            if (amqpvalue_set_list_item(value_data->value.described_value.value, index, item_value) != 0)
        -: 7175:            {
    #####: 7176:                LogError("amqpvalue_set_list_item failed for composite item");
    #####: 7177:                result = MU_FAILURE;
        -: 7178:            }
        -: 7179:            else
        -: 7180:            {
       18: 7181:                result = 0;
        -: 7182:            }
        -: 7183:        }
        -: 7184:    }
        -: 7185:
       18: 7186:    return result;
        -: 7187:}
        -: 7188:
    #####: 7189:AMQP_VALUE amqpvalue_get_composite_item(AMQP_VALUE value, size_t index)
        -: 7190:{
        -: 7191:    AMQP_VALUE result;
        -: 7192:
    #####: 7193:    if (value == NULL)
        -: 7194:    {
    #####: 7195:        LogError("NULL value");
    #####: 7196:        result = NULL;
        -: 7197:    }
        -: 7198:    else
        -: 7199:    {
    #####: 7200:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 7201:        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&
    #####: 7202:            (value_data->type != AMQP_TYPE_DESCRIBED))
        -: 7203:        {
    #####: 7204:            LogError("Attempt to get composite item on a non-composite type");
    #####: 7205:            result = NULL;
        -: 7206:        }
        -: 7207:        else
        -: 7208:        {
    #####: 7209:            result = amqpvalue_get_list_item(value_data->value.described_value.value, index);
    #####: 7210:            if (result == NULL)
        -: 7211:            {
    #####: 7212:                LogError("amqpvalue_get_list_item failed for composite item");
        -: 7213:            }
        -: 7214:        }
        -: 7215:    }
        -: 7216:
    #####: 7217:    return result;
        -: 7218:}
        -: 7219:
    #####: 7220:AMQP_VALUE amqpvalue_get_composite_item_in_place(AMQP_VALUE value, size_t index)
        -: 7221:{
        -: 7222:    AMQP_VALUE result;
        -: 7223:
    #####: 7224:    if (value == NULL)
        -: 7225:    {
    #####: 7226:        LogError("NULL value");
    #####: 7227:        result = NULL;
        -: 7228:    }
        -: 7229:    else
        -: 7230:    {
    #####: 7231:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 7232:        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&
    #####: 7233:            (value_data->type != AMQP_TYPE_DESCRIBED))
        -: 7234:        {
    #####: 7235:            LogError("Attempt to get composite item in place on a non-composite type");
    #####: 7236:            result = NULL;
        -: 7237:        }
        -: 7238:        else
        -: 7239:        {
    #####: 7240:            result = amqpvalue_get_list_item_in_place(value_data->value.described_value.value, index);
    #####: 7241:            if (result == NULL)
        -: 7242:            {
    #####: 7243:                LogError("amqpvalue_get_list_item_in_place failed for composite item");
        -: 7244:            }
        -: 7245:        }
        -: 7246:    }
        -: 7247:
    #####: 7248:    return result;
        -: 7249:}
        -: 7250:
    #####: 7251:int amqpvalue_get_composite_item_count(AMQP_VALUE value, uint32_t* item_count)
        -: 7252:{
        -: 7253:    int result;
        -: 7254:
    #####: 7255:    if (value == NULL)
        -: 7256:    {
    #####: 7257:        LogError("NULL value");
    #####: 7258:        result = MU_FAILURE;
        -: 7259:    }
        -: 7260:    else
        -: 7261:    {
    #####: 7262:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
    #####: 7263:        if ((value_data->type != AMQP_TYPE_COMPOSITE) &&
    #####: 7264:            (value_data->type != AMQP_TYPE_DESCRIBED))
        -: 7265:        {
    #####: 7266:            LogError("Attempt to get composite item in place on a non-composite type");
    #####: 7267:            result = MU_FAILURE;
        -: 7268:        }
        -: 7269:        else
        -: 7270:        {
    #####: 7271:            if (amqpvalue_get_list_item_count(value_data->value.described_value.value, item_count) != 0)
        -: 7272:            {
    #####: 7273:                LogError("amqpvalue_get_list_item_in_place failed for composite item");
    #####: 7274:                result = MU_FAILURE;
        -: 7275:            }
        -: 7276:            else
        -: 7277:            {
    #####: 7278:                result = 0;
        -: 7279:            }
        -: 7280:        }
        -: 7281:    }
        -: 7282:
    #####: 7283:    return result;
        -: 7284:}
        -: 7285:
    #####: 7286:AMQP_VALUE amqpvalue_get_list_item_in_place(AMQP_VALUE value, size_t index)
        -: 7287:{
        -: 7288:    AMQP_VALUE result;
        -: 7289:
    #####: 7290:    if (value == NULL)
        -: 7291:    {
    #####: 7292:        LogError("NULL value");
    #####: 7293:        result = NULL;
        -: 7294:    }
        -: 7295:    else
        -: 7296:    {
    #####: 7297:        AMQP_VALUE_DATA* value_data = (AMQP_VALUE_DATA*)value;
        -: 7298:
    #####: 7299:        if ((value_data->type != AMQP_TYPE_LIST) ||
    #####: 7300:            (value_data->value.list_value.count <= index))
        -: 7301:        {
    #####: 7302:            LogError("Attempt to get list item in place on a non-list type");
    #####: 7303:            result = NULL;
        -: 7304:        }
        -: 7305:        else
        -: 7306:        {
    #####: 7307:            result = value_data->value.list_value.items[index];
        -: 7308:        }
        -: 7309:    }
        -: 7310:
    #####: 7311:    return result;
        -: 7312:}
