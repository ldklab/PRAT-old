        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/src/session.c
        -:    0:Programs:101
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include "azure_macro_utils/macro_utils.h"
        -:    7:#include "azure_c_shared_utility/gballoc.h"
        -:    8:#include "azure_uamqp_c/session.h"
        -:    9:#include "azure_uamqp_c/connection.h"
        -:   10:#include "azure_uamqp_c/amqp_definitions.h"
        -:   11:
        -:   12:typedef enum LINK_ENDPOINT_STATE_TAG
        -:   13:{
        -:   14:    LINK_ENDPOINT_STATE_NOT_ATTACHED,
        -:   15:    LINK_ENDPOINT_STATE_ATTACHED,
        -:   16:    LINK_ENDPOINT_STATE_DETACHING
        -:   17:} LINK_ENDPOINT_STATE;
        -:   18:
        -:   19:typedef struct LINK_ENDPOINT_INSTANCE_TAG
        -:   20:{
        -:   21:    char* name;
        -:   22:    handle input_handle;
        -:   23:    handle output_handle;
        -:   24:    ON_ENDPOINT_FRAME_RECEIVED frame_received_callback;
        -:   25:    ON_SESSION_STATE_CHANGED on_session_state_changed;
        -:   26:    ON_SESSION_FLOW_ON on_session_flow_on;
        -:   27:    void* callback_context;
        -:   28:    SESSION_HANDLE session;
        -:   29:    LINK_ENDPOINT_STATE link_endpoint_state;
        -:   30:} LINK_ENDPOINT_INSTANCE;
        -:   31:
        -:   32:typedef struct SESSION_INSTANCE_TAG
        -:   33:{
        -:   34:    ON_ENDPOINT_FRAME_RECEIVED frame_received_callback;
        -:   35:    void* frame_received_callback_context;
        -:   36:    SESSION_STATE session_state;
        -:   37:    SESSION_STATE previous_session_state;
        -:   38:    CONNECTION_HANDLE connection;
        -:   39:    ENDPOINT_HANDLE endpoint;
        -:   40:    LINK_ENDPOINT_INSTANCE** link_endpoints;
        -:   41:    uint32_t link_endpoint_count;
        -:   42:
        -:   43:    ON_LINK_ATTACHED on_link_attached;
        -:   44:    void* on_link_attached_callback_context;
        -:   45:
        -:   46:    /* Codes_S_R_S_SESSION_01_016: [next-outgoing-id The next-outgoing-id is the transfer-id to assign to the next transfer frame.] */
        -:   47:    transfer_number next_outgoing_id;
        -:   48:    transfer_number next_incoming_id;
        -:   49:    uint32_t desired_incoming_window;
        -:   50:    uint32_t incoming_window;
        -:   51:    uint32_t outgoing_window;
        -:   52:    handle handle_max;
        -:   53:    uint32_t remote_incoming_window;
        -:   54:    uint32_t remote_outgoing_window;
        -:   55:    unsigned int is_underlying_connection_open : 1;
        -:   56:} SESSION_INSTANCE;
        -:   57:
        -:   58:#define UNDERLYING_CONNECTION_NOT_OPEN 0
        -:   59:#define UNDERLYING_CONNECTION_OPEN 1
        -:   60:
       12:   61:static void remove_link_endpoint(LINK_ENDPOINT_HANDLE link_endpoint)
        -:   62:{
       12:   63:    if (link_endpoint != NULL)
        -:   64:    {
       12:   65:        LINK_ENDPOINT_INSTANCE* endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
       12:   66:        SESSION_INSTANCE* session_instance = endpoint_instance->session;
        -:   67:        uint32_t i;
        -:   68:
      12*:   69:        for (i = 0; i < session_instance->link_endpoint_count; i++)
        -:   70:        {
       12:   71:            if (session_instance->link_endpoints[i] == link_endpoint)
        -:   72:            {
       12:   73:                break;
        -:   74:            }
        -:   75:        }
        -:   76:
       12:   77:        if (i < session_instance->link_endpoint_count)
        -:   78:        {
        -:   79:            LINK_ENDPOINT_INSTANCE** new_endpoints;
        -:   80:
       12:   81:            if (i < (session_instance->link_endpoint_count - 1))
        -:   82:            {
        6:   83:                (void)memmove(&session_instance->link_endpoints[i], &session_instance->link_endpoints[i + 1], (session_instance->link_endpoint_count - (uint32_t)i - 1) * sizeof(LINK_ENDPOINT_INSTANCE*));
        -:   84:            }
        -:   85:
       12:   86:            session_instance->link_endpoint_count--;
        -:   87:
       12:   88:            if (session_instance->link_endpoint_count == 0)
        -:   89:            {
        6:   90:                free(session_instance->link_endpoints);
        6:   91:                session_instance->link_endpoints = NULL;
        -:   92:            }
        -:   93:            else
        -:   94:            {
        6:   95:                new_endpoints = (LINK_ENDPOINT_INSTANCE**)realloc(session_instance->link_endpoints, sizeof(LINK_ENDPOINT_INSTANCE*) * session_instance->link_endpoint_count);
        6:   96:                if (new_endpoints != NULL)
        -:   97:                {
        6:   98:                    session_instance->link_endpoints = new_endpoints;
        -:   99:                }
        -:  100:            }
        -:  101:        }
        -:  102:    }
       12:  103:}
        -:  104:
       12:  105:static void free_link_endpoint(LINK_ENDPOINT_HANDLE link_endpoint)
        -:  106:{
       12:  107:    if (link_endpoint->name != NULL)
        -:  108:    {
       12:  109:        free(link_endpoint->name);
        -:  110:    }
        -:  111:
       12:  112:    free(link_endpoint);
       12:  113:}
        -:  114:
       18:  115:static void session_set_state(SESSION_INSTANCE* session_instance, SESSION_STATE session_state)
        -:  116:{
        -:  117:    uint32_t i;
        -:  118:
       18:  119:    session_instance->previous_session_state = session_instance->session_state;
       18:  120:    session_instance->session_state = session_state;
        -:  121:
       42:  122:    for (i = 0; i < session_instance->link_endpoint_count; i++)
        -:  123:    {
       24:  124:        if (session_instance->link_endpoints[i]->on_session_state_changed != NULL)
        -:  125:        {
    #####:  126:            if (session_instance->link_endpoints[i]->link_endpoint_state != LINK_ENDPOINT_STATE_DETACHING)
        -:  127:            {
    #####:  128:                session_instance->link_endpoints[i]->on_session_state_changed(session_instance->link_endpoints[i]->callback_context, session_state, session_instance->previous_session_state);
        -:  129:            }
        -:  130:        }
        -:  131:    }
       18:  132:}
        -:  133:
    #####:  134:static int send_end_frame(SESSION_INSTANCE* session_instance, ERROR_HANDLE error_handle)
        -:  135:{
        -:  136:    int result;
        -:  137:    END_HANDLE end_performative;
        -:  138:
    #####:  139:    end_performative = end_create();
    #####:  140:    if (end_performative == NULL)
        -:  141:    {
    #####:  142:        result = MU_FAILURE;
        -:  143:    }
        -:  144:    else
        -:  145:    {
    #####:  146:        if ((error_handle != NULL) &&
    #####:  147:            (end_set_error(end_performative, error_handle) != 0))
        -:  148:        {
    #####:  149:            result = MU_FAILURE;
        -:  150:        }
        -:  151:        else
        -:  152:        {
    #####:  153:            AMQP_VALUE end_performative_value = amqpvalue_create_end(end_performative);
    #####:  154:            if (end_performative_value == NULL)
        -:  155:            {
    #####:  156:                result = MU_FAILURE;
        -:  157:            }
        -:  158:            else
        -:  159:            {
    #####:  160:                if (connection_encode_frame(session_instance->endpoint, end_performative_value, NULL, 0, NULL, NULL) != 0)
        -:  161:                {
    #####:  162:                    result = MU_FAILURE;
        -:  163:                }
        -:  164:                else
        -:  165:                {
    #####:  166:                    result = 0;
        -:  167:                }
        -:  168:
    #####:  169:                amqpvalue_destroy(end_performative_value);
        -:  170:            }
        -:  171:        }
        -:  172:
    #####:  173:        end_destroy(end_performative);
        -:  174:    }
        -:  175:
    #####:  176:    return result;
        -:  177:}
        -:  178:
    #####:  179:static void end_session_with_error(SESSION_INSTANCE* session_instance, const char* condition_value, const char* description)
        -:  180:{
    #####:  181:    ERROR_HANDLE error_handle = error_create(condition_value);
    #####:  182:    if (error_handle == NULL)
        -:  183:    {
        -:  184:        /* fatal error */
    #####:  185:        session_set_state(session_instance, SESSION_STATE_DISCARDING);
    #####:  186:        (void)connection_close(session_instance->connection, "amqp:internal-error", "Cannot allocate error handle to end session", NULL);
        -:  187:    }
        -:  188:    else
        -:  189:    {
    #####:  190:        if ((error_set_description(error_handle, description) != 0) ||
    #####:  191:            (send_end_frame(session_instance, error_handle) != 0))
        -:  192:        {
        -:  193:            /* fatal error */
    #####:  194:            session_set_state(session_instance, SESSION_STATE_DISCARDING);
    #####:  195:            (void)connection_close(session_instance->connection, "amqp:internal-error", "Cannot allocate error handle to end session", NULL);
        -:  196:        }
        -:  197:        else
        -:  198:        {
    #####:  199:            session_set_state(session_instance, SESSION_STATE_DISCARDING);
        -:  200:        }
        -:  201:
    #####:  202:        error_destroy(error_handle);
        -:  203:    }
    #####:  204:}
        -:  205:
    #####:  206:static int send_begin(SESSION_INSTANCE* session_instance)
        -:  207:{
        -:  208:    int result;
    #####:  209:    BEGIN_HANDLE begin = begin_create(session_instance->next_outgoing_id, session_instance->incoming_window, session_instance->outgoing_window);
        -:  210:
    #####:  211:    if (begin == NULL)
        -:  212:    {
    #####:  213:        result = MU_FAILURE;
        -:  214:    }
        -:  215:    else
        -:  216:    {
        -:  217:        uint16_t remote_channel;
    #####:  218:        if (begin_set_handle_max(begin, session_instance->handle_max) != 0)
        -:  219:        {
    #####:  220:            result = MU_FAILURE;
        -:  221:        }
    #####:  222:        else if ((session_instance->session_state == SESSION_STATE_BEGIN_RCVD) &&
    #####:  223:            ((connection_endpoint_get_incoming_channel(session_instance->endpoint, &remote_channel) != 0) ||
    #####:  224:            (begin_set_remote_channel(begin, remote_channel) != 0)))
        -:  225:        {
    #####:  226:            result = MU_FAILURE;
        -:  227:        }
        -:  228:        else
        -:  229:        {
    #####:  230:            AMQP_VALUE begin_performative_value = amqpvalue_create_begin(begin);
    #####:  231:            if (begin_performative_value == NULL)
        -:  232:            {
    #####:  233:                result = MU_FAILURE;
        -:  234:            }
        -:  235:            else
        -:  236:            {
    #####:  237:                if (connection_encode_frame(session_instance->endpoint, begin_performative_value, NULL, 0, NULL, NULL) != 0)
        -:  238:                {
    #####:  239:                    result = MU_FAILURE;
        -:  240:                }
        -:  241:                else
        -:  242:                {
    #####:  243:                    result = 0;
        -:  244:                }
        -:  245:
    #####:  246:                amqpvalue_destroy(begin_performative_value);
        -:  247:            }
        -:  248:        }
        -:  249:
    #####:  250:        begin_destroy(begin);
        -:  251:    }
        -:  252:
    #####:  253:    return result;
        -:  254:}
        -:  255:
    #####:  256:static int send_flow(SESSION_INSTANCE* session)
        -:  257:{
        -:  258:    int result;
    #####:  259:    if (session == NULL)
        -:  260:    {
    #####:  261:        result = MU_FAILURE;
        -:  262:    }
        -:  263:    else
        -:  264:    {
    #####:  265:        FLOW_HANDLE flow = flow_create(session->incoming_window, session->next_outgoing_id, session->outgoing_window);
        -:  266:
    #####:  267:        if (flow == NULL)
        -:  268:        {
    #####:  269:            result = MU_FAILURE;
        -:  270:        }
        -:  271:        else
        -:  272:        {
    #####:  273:            if (flow_set_next_incoming_id(flow, session->next_incoming_id) != 0)
        -:  274:            {
    #####:  275:                result = MU_FAILURE;
        -:  276:            }
        -:  277:            else
        -:  278:            {
    #####:  279:                AMQP_VALUE flow_performative_value = amqpvalue_create_flow(flow);
    #####:  280:                if (flow_performative_value == NULL)
        -:  281:                {
    #####:  282:                    result = MU_FAILURE;
        -:  283:                }
        -:  284:                else
        -:  285:                {
    #####:  286:                    if (connection_encode_frame(session->endpoint, flow_performative_value, NULL, 0, NULL, NULL) != 0)
        -:  287:                    {
    #####:  288:                        result = MU_FAILURE;
        -:  289:                    }
        -:  290:                    else
        -:  291:                    {
    #####:  292:                        result = 0;
        -:  293:                    }
        -:  294:
    #####:  295:                    amqpvalue_destroy(flow_performative_value);
        -:  296:                }
        -:  297:            }
        -:  298:
    #####:  299:            flow_destroy(flow);
        -:  300:        }
        -:  301:    }
        -:  302:
    #####:  303:    return result;
        -:  304:}
        -:  305:
    #####:  306:static LINK_ENDPOINT_INSTANCE* find_link_endpoint_by_name(SESSION_INSTANCE* session, const char* name)
        -:  307:{
        -:  308:    uint32_t i;
        -:  309:    LINK_ENDPOINT_INSTANCE* result;
        -:  310:
    #####:  311:    for (i = 0; i < session->link_endpoint_count; i++)
        -:  312:    {
    #####:  313:        if (strcmp(session->link_endpoints[i]->name, name) == 0)
        -:  314:        {
    #####:  315:            break;
        -:  316:        }
        -:  317:    }
        -:  318:
    #####:  319:    if (i == session->link_endpoint_count)
        -:  320:    {
    #####:  321:        result = NULL;
        -:  322:    }
        -:  323:    else
        -:  324:    {
    #####:  325:        result = session->link_endpoints[i];
        -:  326:    }
        -:  327:
    #####:  328:    return result;
        -:  329:}
        -:  330:
    #####:  331:static LINK_ENDPOINT_INSTANCE* find_link_endpoint_by_input_handle(SESSION_INSTANCE* session, handle input_handle)
        -:  332:{
        -:  333:    uint32_t i;
        -:  334:    LINK_ENDPOINT_INSTANCE* result;
        -:  335:
    #####:  336:    for (i = 0; i < session->link_endpoint_count; i++)
        -:  337:    {
    #####:  338:        if (session->link_endpoints[i]->input_handle == input_handle)
        -:  339:        {
    #####:  340:            break;
        -:  341:        }
        -:  342:    }
        -:  343:
    #####:  344:    if (i == session->link_endpoint_count)
        -:  345:    {
    #####:  346:        result = NULL;
        -:  347:    }
        -:  348:    else
        -:  349:    {
    #####:  350:        result = session->link_endpoints[i];
        -:  351:    }
        -:  352:
    #####:  353:    return result;
        -:  354:}
        -:  355:
       12:  356:static void on_connection_state_changed(void* context, CONNECTION_STATE new_connection_state, CONNECTION_STATE previous_connection_state)
        -:  357:{
       12:  358:    SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)context;
        -:  359:
        -:  360:    /* Codes_S_R_S_SESSION_01_060: [If the previous connection state is not OPENED and the new connection state is OPENED, the BEGIN frame shall be sent out and the state shall be switched to BEGIN_SENT.] */
      12*:  361:    if ((new_connection_state == CONNECTION_STATE_OPENED) && (previous_connection_state != CONNECTION_STATE_OPENED) && (session_instance->session_state == SESSION_STATE_UNMAPPED))
        -:  362:    {
    #####:  363:        if (send_begin(session_instance) == 0)
        -:  364:        {
    #####:  365:            session_set_state(session_instance, SESSION_STATE_BEGIN_SENT);
        -:  366:        }
        -:  367:    }
        -:  368:    /* Codes_S_R_S_SESSION_01_061: [If the previous connection state is OPENED and the new connection state is not OPENED anymore, the state shall be switched to DISCARDING.] */
       12:  369:    else if ((new_connection_state == CONNECTION_STATE_CLOSE_RCVD) || (new_connection_state == CONNECTION_STATE_END))
        -:  370:    {
       12:  371:        session_set_state(session_instance, SESSION_STATE_DISCARDING);
        -:  372:    }
        -:  373:    /* Codes_S_R_S_SESSION_09_001: [If the new connection state is ERROR, the state shall be switched to ERROR.] */
    #####:  374:    else if (new_connection_state == CONNECTION_STATE_ERROR)
        -:  375:    {
    #####:  376:        session_set_state(session_instance, SESSION_STATE_ERROR);
        -:  377:    }
       12:  378:}
        -:  379:
    #####:  380:static void on_frame_received(void* context, AMQP_VALUE performative, uint32_t payload_size, const unsigned char* payload_bytes)
        -:  381:{
    #####:  382:    SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)context;
    #####:  383:    AMQP_VALUE descriptor = amqpvalue_get_inplace_descriptor(performative);
        -:  384:
    #####:  385:    if (is_begin_type_by_descriptor(descriptor))
        -:  386:    {
        -:  387:        BEGIN_HANDLE begin_handle;
        -:  388:
    #####:  389:        if (amqpvalue_get_begin(performative, &begin_handle) != 0)
        -:  390:        {
    #####:  391:            connection_close(session_instance->connection, "amqp:decode-error", "Cannot decode BEGIN frame", NULL);
        -:  392:        }
        -:  393:        else
        -:  394:        {
    #####:  395:            if ((begin_get_incoming_window(begin_handle, &session_instance->remote_incoming_window) != 0) ||
    #####:  396:                (begin_get_next_outgoing_id(begin_handle, &session_instance->next_incoming_id) != 0))
        -:  397:            {
        -:  398:                /* error */
    #####:  399:                begin_destroy(begin_handle);
    #####:  400:                session_set_state(session_instance, SESSION_STATE_DISCARDING);
    #####:  401:                connection_close(session_instance->connection, "amqp:decode-error", "Cannot get incoming windows and next outgoing id", NULL);
        -:  402:            }
        -:  403:            else
        -:  404:            {
    #####:  405:                begin_destroy(begin_handle);
        -:  406:
    #####:  407:                if (session_instance->session_state == SESSION_STATE_BEGIN_SENT)
        -:  408:                {
    #####:  409:                    session_set_state(session_instance, SESSION_STATE_MAPPED);
        -:  410:                }
    #####:  411:                else if(session_instance->session_state == SESSION_STATE_UNMAPPED)
        -:  412:                {
    #####:  413:                    session_set_state(session_instance, SESSION_STATE_BEGIN_RCVD);
    #####:  414:                    if (send_begin(session_instance) != 0)
        -:  415:                    {
    #####:  416:                        connection_close(session_instance->connection, "amqp:internal-error", "Failed sending BEGIN frame", NULL);
    #####:  417:                        session_set_state(session_instance, SESSION_STATE_DISCARDING);
        -:  418:                    }
        -:  419:                    else
        -:  420:                    {
    #####:  421:                        session_set_state(session_instance, SESSION_STATE_MAPPED);
        -:  422:                    }
        -:  423:                }
        -:  424:            }
        -:  425:        }
        -:  426:    }
    #####:  427:    else if (is_attach_type_by_descriptor(descriptor))
        -:  428:    {
    #####:  429:        const char* name = NULL;
        -:  430:        ATTACH_HANDLE attach_handle;
        -:  431:
    #####:  432:        if (amqpvalue_get_attach(performative, &attach_handle) != 0)
        -:  433:        {
    #####:  434:            end_session_with_error(session_instance, "amqp:decode-error", "Cannot decode ATTACH frame");
        -:  435:        }
        -:  436:        else
        -:  437:        {
        -:  438:            role role;
        -:  439:            AMQP_VALUE source;
        -:  440:            AMQP_VALUE target;
        -:  441:            fields properties;
        -:  442:
    #####:  443:            if (attach_get_name(attach_handle, &name) != 0)
        -:  444:            {
    #####:  445:                end_session_with_error(session_instance, "amqp:decode-error", "Cannot get link name from ATTACH frame");
        -:  446:            }
    #####:  447:            else if (attach_get_role(attach_handle, &role) != 0)
        -:  448:            {
    #####:  449:                end_session_with_error(session_instance, "amqp:decode-error", "Cannot get link role from ATTACH frame");
        -:  450:            }
        -:  451:            else
        -:  452:            {
        -:  453:                LINK_ENDPOINT_INSTANCE* link_endpoint;
        -:  454:
    #####:  455:                if (attach_get_source(attach_handle, &source) != 0)
        -:  456:                {
    #####:  457:                    source = NULL;
        -:  458:                }
    #####:  459:                if (attach_get_target(attach_handle, &target) != 0)
        -:  460:                {
    #####:  461:                    target = NULL;
        -:  462:                }
    #####:  463:                if (attach_get_properties(attach_handle, &properties) != 0)
        -:  464:                {
    #####:  465:                    properties = NULL;
        -:  466:                }
        -:  467:
    #####:  468:                link_endpoint = find_link_endpoint_by_name(session_instance, name);
    #####:  469:                if (link_endpoint == NULL)
        -:  470:                {
        -:  471:                    /* new link attach */
    #####:  472:                    if (session_instance->on_link_attached != NULL)
        -:  473:                    {
    #####:  474:                        LINK_ENDPOINT_HANDLE new_link_endpoint = session_create_link_endpoint(session_instance, name);
    #####:  475:                        if (new_link_endpoint == NULL)
        -:  476:                        {
    #####:  477:                            end_session_with_error(session_instance, "amqp:internal-error", "Cannot create link endpoint");
        -:  478:                        }
    #####:  479:                        else if (attach_get_handle(attach_handle, &new_link_endpoint->input_handle) != 0)
        -:  480:                        {
    #####:  481:                            end_session_with_error(session_instance, "amqp:decode-error", "Cannot get input handle from ATTACH frame");
        -:  482:                        }
        -:  483:                        else
        -:  484:                        {
    #####:  485:                            new_link_endpoint->link_endpoint_state = LINK_ENDPOINT_STATE_ATTACHED;
        -:  486:
    #####:  487:                            if (!session_instance->on_link_attached(session_instance->on_link_attached_callback_context, new_link_endpoint, name, role, source, target, properties))
        -:  488:                            {
    #####:  489:                                remove_link_endpoint(new_link_endpoint);
    #####:  490:                                free_link_endpoint(new_link_endpoint);
    #####:  491:                                new_link_endpoint = NULL;
        -:  492:                            }
        -:  493:                            else
        -:  494:                            {
    #####:  495:                                if (new_link_endpoint->frame_received_callback != NULL)
        -:  496:                                {
    #####:  497:                                    new_link_endpoint->frame_received_callback(new_link_endpoint->callback_context, performative, payload_size, payload_bytes);
        -:  498:                                }
        -:  499:                            }
        -:  500:                        }
        -:  501:                    }
        -:  502:                }
        -:  503:                else
        -:  504:                {
    #####:  505:                    if (attach_get_handle(attach_handle, &link_endpoint->input_handle) != 0)
        -:  506:                    {
    #####:  507:                        end_session_with_error(session_instance, "amqp:decode-error", "Cannot get input handle from ATTACH frame");
        -:  508:                    }
        -:  509:                    else
        -:  510:                    {
    #####:  511:                        link_endpoint->link_endpoint_state = LINK_ENDPOINT_STATE_ATTACHED;
        -:  512:
    #####:  513:                        if (session_instance->on_link_attached != NULL)
        -:  514:                        {
    #####:  515:                            if (!session_instance->on_link_attached(session_instance->on_link_attached_callback_context, link_endpoint, name, role, source, target, properties))
        -:  516:                            {
    #####:  517:                                link_endpoint->link_endpoint_state = LINK_ENDPOINT_STATE_DETACHING;
        -:  518:                            }
        -:  519:                        }
        -:  520:
    #####:  521:                        link_endpoint->frame_received_callback(link_endpoint->callback_context, performative, payload_size, payload_bytes);
        -:  522:                    }
        -:  523:                }
        -:  524:            }
        -:  525:
    #####:  526:            attach_destroy(attach_handle);
        -:  527:        }
        -:  528:    }
    #####:  529:    else if (is_detach_type_by_descriptor(descriptor))
        -:  530:    {
        -:  531:        DETACH_HANDLE detach_handle;
        -:  532:
    #####:  533:        if (amqpvalue_get_detach(performative, &detach_handle) != 0)
        -:  534:        {
    #####:  535:            end_session_with_error(session_instance, "amqp:decode-error", "Cannot decode DETACH frame");
        -:  536:        }
        -:  537:        else
        -:  538:        {
        -:  539:            uint32_t remote_handle;
    #####:  540:            if (detach_get_handle(detach_handle, &remote_handle) != 0)
        -:  541:            {
    #####:  542:                end_session_with_error(session_instance, "amqp:decode-error", "Cannot get handle from DETACH frame");
        -:  543:
    #####:  544:                detach_destroy(detach_handle);
        -:  545:            }
        -:  546:            else
        -:  547:            {
        -:  548:                LINK_ENDPOINT_INSTANCE* link_endpoint;
    #####:  549:                detach_destroy(detach_handle);
        -:  550:
    #####:  551:                link_endpoint = find_link_endpoint_by_input_handle(session_instance, remote_handle);
    #####:  552:                if (link_endpoint == NULL)
        -:  553:                {
    #####:  554:                    end_session_with_error(session_instance, "amqp:session:unattached-handle", "");
        -:  555:                }
        -:  556:                else
        -:  557:                {
    #####:  558:                    if (link_endpoint->link_endpoint_state != LINK_ENDPOINT_STATE_DETACHING)
        -:  559:                    {
    #####:  560:                        link_endpoint->link_endpoint_state = LINK_ENDPOINT_STATE_DETACHING;
    #####:  561:                        link_endpoint->frame_received_callback(link_endpoint->callback_context, performative, payload_size, payload_bytes);
        -:  562:                    }
        -:  563:                    else
        -:  564:                    {
        -:  565:                        /* remove the link endpoint */
    #####:  566:                        remove_link_endpoint(link_endpoint);
    #####:  567:                        free_link_endpoint(link_endpoint);
        -:  568:                    }
        -:  569:                }
        -:  570:            }
        -:  571:        }
        -:  572:    }
    #####:  573:    else if (is_flow_type_by_descriptor(descriptor))
        -:  574:    {
        -:  575:        FLOW_HANDLE flow_handle;
        -:  576:
    #####:  577:        if (amqpvalue_get_flow(performative, &flow_handle) != 0)
        -:  578:        {
    #####:  579:            end_session_with_error(session_instance, "amqp:decode-error", "Cannot decode FLOW frame");
        -:  580:        }
        -:  581:        else
        -:  582:        {
        -:  583:            uint32_t remote_handle;
        -:  584:            transfer_number flow_next_incoming_id;
        -:  585:            uint32_t flow_incoming_window;
        -:  586:
    #####:  587:            if (flow_get_next_incoming_id(flow_handle, &flow_next_incoming_id) != 0)
        -:  588:            {
        -:  589:                /*
        -:  590:                If the next-incoming-id field of the flow frame is not set,
        -:  591:                then remote-incomingwindow is computed as follows:
        -:  592:                initial-outgoing-id(endpoint) + incoming-window(flow) - next-outgoing-id(endpoint)
        -:  593:                */
    #####:  594:                flow_next_incoming_id = session_instance->next_outgoing_id;
        -:  595:            }
        -:  596:
    #####:  597:            if ((flow_get_next_outgoing_id(flow_handle, &session_instance->next_incoming_id) != 0) ||
    #####:  598:                (flow_get_incoming_window(flow_handle, &flow_incoming_window) != 0))
        -:  599:            {
    #####:  600:                flow_destroy(flow_handle);
        -:  601:
    #####:  602:                end_session_with_error(session_instance, "amqp:decode-error", "Cannot decode FLOW frame");
        -:  603:            }
        -:  604:            else
        -:  605:            {
    #####:  606:                LINK_ENDPOINT_INSTANCE* link_endpoint_instance = NULL;
        -:  607:                size_t i;
        -:  608:
    #####:  609:                session_instance->remote_incoming_window = flow_next_incoming_id + flow_incoming_window - session_instance->next_outgoing_id;
        -:  610:
    #####:  611:                if (flow_get_handle(flow_handle, &remote_handle) == 0)
        -:  612:                {
    #####:  613:                    link_endpoint_instance = find_link_endpoint_by_input_handle(session_instance, remote_handle);
        -:  614:                }
        -:  615:
    #####:  616:                flow_destroy(flow_handle);
        -:  617:
    #####:  618:                if (link_endpoint_instance != NULL)
        -:  619:                {
    #####:  620:                    if (link_endpoint_instance->link_endpoint_state != LINK_ENDPOINT_STATE_DETACHING)
        -:  621:                    {
    #####:  622:                        link_endpoint_instance->frame_received_callback(link_endpoint_instance->callback_context, performative, payload_size, payload_bytes);
        -:  623:                    }
        -:  624:                }
        -:  625:
    #####:  626:                i = 0;
    #####:  627:                while ((session_instance->remote_incoming_window > 0) && (i < session_instance->link_endpoint_count))
        -:  628:                {
        -:  629:                    /* notify the caller that it can send here */
    #####:  630:                    if (session_instance->link_endpoints[i]->on_session_flow_on != NULL)
        -:  631:                    {
    #####:  632:                        session_instance->link_endpoints[i]->on_session_flow_on(session_instance->link_endpoints[i]->callback_context);
        -:  633:                    }
        -:  634:
    #####:  635:                    i++;
        -:  636:                }
        -:  637:            }
        -:  638:        }
        -:  639:    }
    #####:  640:    else if (is_transfer_type_by_descriptor(descriptor))
        -:  641:    {
        -:  642:        TRANSFER_HANDLE transfer_handle;
        -:  643:
    #####:  644:        if (amqpvalue_get_transfer(performative, &transfer_handle) != 0)
        -:  645:        {
    #####:  646:            end_session_with_error(session_instance, "amqp:decode-error", "Cannot decode TRANSFER frame");
        -:  647:        }
        -:  648:        else
        -:  649:        {
        -:  650:            uint32_t remote_handle;
        -:  651:            delivery_number delivery_id;
        -:  652:
    #####:  653:            transfer_get_delivery_id(transfer_handle, &delivery_id);
    #####:  654:            if (transfer_get_handle(transfer_handle, &remote_handle) != 0)
        -:  655:            {
    #####:  656:                transfer_destroy(transfer_handle);
    #####:  657:                end_session_with_error(session_instance, "amqp:decode-error", "Cannot get handle from TRANSFER frame");
        -:  658:            }
        -:  659:            else
        -:  660:            {
        -:  661:                LINK_ENDPOINT_INSTANCE* link_endpoint;
    #####:  662:                transfer_destroy(transfer_handle);
        -:  663:
    #####:  664:                session_instance->next_incoming_id++;
    #####:  665:                session_instance->remote_outgoing_window--;
    #####:  666:                session_instance->incoming_window--;
        -:  667:
    #####:  668:                link_endpoint = find_link_endpoint_by_input_handle(session_instance, remote_handle);
    #####:  669:                if (link_endpoint == NULL)
        -:  670:                {
    #####:  671:                    end_session_with_error(session_instance, "amqp:session:unattached-handle", "");
        -:  672:                }
        -:  673:                else
        -:  674:                {
    #####:  675:                    if (link_endpoint->link_endpoint_state != LINK_ENDPOINT_STATE_DETACHING)
        -:  676:                    {
    #####:  677:                        link_endpoint->frame_received_callback(link_endpoint->callback_context, performative, payload_size, payload_bytes);
        -:  678:                    }
        -:  679:                }
        -:  680:
    #####:  681:                if (session_instance->incoming_window == 0)
        -:  682:                {
    #####:  683:                    session_instance->incoming_window = session_instance->desired_incoming_window;
    #####:  684:                    send_flow(session_instance);
        -:  685:                }
        -:  686:            }
        -:  687:        }
        -:  688:    }
    #####:  689:    else if (is_disposition_type_by_descriptor(descriptor))
        -:  690:    {
        -:  691:        uint32_t i;
        -:  692:
    #####:  693:        for (i = 0; i < session_instance->link_endpoint_count; i++)
        -:  694:        {
    #####:  695:            LINK_ENDPOINT_INSTANCE* link_endpoint = session_instance->link_endpoints[i];
    #####:  696:            if (link_endpoint->link_endpoint_state != LINK_ENDPOINT_STATE_DETACHING)
        -:  697:            {
    #####:  698:                link_endpoint->frame_received_callback(link_endpoint->callback_context, performative, payload_size, payload_bytes);
        -:  699:            }
        -:  700:        }
        -:  701:    }
    #####:  702:    else if (is_end_type_by_descriptor(descriptor))
        -:  703:    {
        -:  704:        END_HANDLE end_handle;
        -:  705:
    #####:  706:        if (amqpvalue_get_end(performative, &end_handle) != 0)
        -:  707:        {
    #####:  708:            end_session_with_error(session_instance, "amqp:decode-error", "Cannot decode END frame");
        -:  709:        }
        -:  710:        else
        -:  711:        {
    #####:  712:            end_destroy(end_handle);
    #####:  713:            if ((session_instance->session_state != SESSION_STATE_END_RCVD) &&
    #####:  714:                (session_instance->session_state != SESSION_STATE_DISCARDING))
        -:  715:            {
    #####:  716:                session_set_state(session_instance, SESSION_STATE_END_RCVD);
    #####:  717:                if (send_end_frame(session_instance, NULL) != 0)
        -:  718:                {
        -:  719:                    /* fatal error */
    #####:  720:                    (void)connection_close(session_instance->connection, "amqp:internal-error", "Cannot send END frame.", NULL);
        -:  721:                }
        -:  722:
    #####:  723:                session_set_state(session_instance, SESSION_STATE_DISCARDING);
        -:  724:            }
        -:  725:        }
        -:  726:    }
    #####:  727:}
        -:  728:
        6:  729:SESSION_HANDLE session_create(CONNECTION_HANDLE connection, ON_LINK_ATTACHED on_link_attached, void* callback_context)
        -:  730:{
        -:  731:    SESSION_INSTANCE* result;
        -:  732:
        6:  733:    if (connection == NULL)
        -:  734:    {
        -:  735:        /* Codes_S_R_S_SESSION_01_031: [If connection is NULL, session_create shall fail and return NULL.] */
    #####:  736:        result = NULL;
        -:  737:    }
        -:  738:    else
        -:  739:    {
        -:  740:        /* Codes_S_R_S_SESSION_01_030: [session_create shall create a new session instance and return a non-NULL handle to it.] */
        6:  741:        result = (SESSION_INSTANCE*)malloc(sizeof(SESSION_INSTANCE));
        -:  742:        /* Codes_S_R_S_SESSION_01_042: [If allocating memory for the session fails, session_create shall fail and return NULL.] */
        6:  743:        if (result != NULL)
        -:  744:        {
        6:  745:            result->connection = connection;
        6:  746:            result->link_endpoints = NULL;
        6:  747:            result->link_endpoint_count = 0;
        6:  748:            result->handle_max = 4294967295u;
        -:  749:
        -:  750:            /* Codes_S_R_S_SESSION_01_057: [The delivery ids shall be assigned starting at 0.] */
        -:  751:            /* Codes_S_R_S_SESSION_01_017: [The nextoutgoing-id MAY be initialized to an arbitrary value ] */
        6:  752:            result->next_outgoing_id = 0;
        -:  753:
        6:  754:            result->desired_incoming_window = 1;
        6:  755:            result->incoming_window = 1;
        6:  756:            result->outgoing_window = 1;
        6:  757:            result->handle_max = 4294967295u;
        6:  758:            result->remote_incoming_window = 0;
        6:  759:            result->remote_outgoing_window = 0;
        6:  760:            result->previous_session_state = SESSION_STATE_UNMAPPED;
        6:  761:            result->is_underlying_connection_open = UNDERLYING_CONNECTION_NOT_OPEN;
        6:  762:            result->session_state = SESSION_STATE_UNMAPPED;
        6:  763:            result->on_link_attached = on_link_attached;
        6:  764:            result->on_link_attached_callback_context = callback_context;
        -:  765:
        -:  766:            /* Codes_S_R_S_SESSION_01_032: [session_create shall create a new session endpoint by calling connection_create_endpoint.] */
        6:  767:            result->endpoint = connection_create_endpoint(connection);
        6:  768:            if (result->endpoint == NULL)
        -:  769:            {
        -:  770:                /* Codes_S_R_S_SESSION_01_033: [If connection_create_endpoint fails, session_create shall fail and return NULL.] */
    #####:  771:                free(result);
    #####:  772:                result = NULL;
        -:  773:            }
        -:  774:            else
        -:  775:            {
        6:  776:                session_set_state(result, SESSION_STATE_UNMAPPED);
        -:  777:            }
        -:  778:        }
        -:  779:    }
        -:  780:
        6:  781:    return result;
        -:  782:}
        -:  783:
    #####:  784:SESSION_HANDLE session_create_from_endpoint(CONNECTION_HANDLE connection, ENDPOINT_HANDLE endpoint, ON_LINK_ATTACHED on_link_attached, void* callback_context)
        -:  785:{
        -:  786:    SESSION_INSTANCE* result;
        -:  787:
    #####:  788:    if (endpoint == NULL)
        -:  789:    {
    #####:  790:        result = NULL;
        -:  791:    }
        -:  792:    else
        -:  793:    {
    #####:  794:        result = (SESSION_INSTANCE*)malloc(sizeof(SESSION_INSTANCE));
    #####:  795:        if (result != NULL)
        -:  796:        {
    #####:  797:            result->connection = connection;
    #####:  798:            result->link_endpoints = NULL;
    #####:  799:            result->link_endpoint_count = 0;
    #####:  800:            result->handle_max = 4294967295u;
        -:  801:
    #####:  802:            result->next_outgoing_id = 0;
        -:  803:
    #####:  804:            result->desired_incoming_window = 1;
    #####:  805:            result->incoming_window = 1;
    #####:  806:            result->outgoing_window = 1;
    #####:  807:            result->handle_max = 4294967295u;
    #####:  808:            result->remote_incoming_window = 0;
    #####:  809:            result->remote_outgoing_window = 0;
    #####:  810:            result->previous_session_state = SESSION_STATE_UNMAPPED;
    #####:  811:            result->is_underlying_connection_open = UNDERLYING_CONNECTION_NOT_OPEN;
    #####:  812:            result->session_state = SESSION_STATE_UNMAPPED;
    #####:  813:            result->on_link_attached = on_link_attached;
    #####:  814:            result->on_link_attached_callback_context = callback_context;
        -:  815:
    #####:  816:            result->endpoint = endpoint;
    #####:  817:            session_set_state(result, SESSION_STATE_UNMAPPED);
        -:  818:        }
        -:  819:    }
        -:  820:
    #####:  821:    return result;
        -:  822:}
        -:  823:
        6:  824:void session_destroy(SESSION_HANDLE session)
        -:  825:{
        -:  826:    /* Codes_S_R_S_SESSION_01_036: [If session is NULL, session_destroy shall do nothing.] */
        6:  827:    if (session != NULL)
        -:  828:    {
        6:  829:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -:  830:
        6:  831:        session_end(session, NULL, NULL);
        -:  832:
        -:  833:        /* Codes_S_R_S_SESSION_01_034: [session_destroy shall free all resources allocated by session_create.] */
        -:  834:        /* Codes_S_R_S_SESSION_01_035: [The endpoint created in session_create shall be freed by calling connection_destroy_endpoint.] */
        6:  835:        connection_destroy_endpoint(session_instance->endpoint);
        6:  836:        if (session_instance->link_endpoints != NULL)
        -:  837:        {
    #####:  838:            free(session_instance->link_endpoints);
        -:  839:        }
        -:  840:
        6:  841:        free(session);
        -:  842:    }
        6:  843:}
        -:  844:
        9:  845:int session_begin(SESSION_HANDLE session)
        -:  846:{
        -:  847:    int result;
        -:  848:
        9:  849:    if (session == NULL)
        -:  850:    {
    #####:  851:        result = MU_FAILURE;
        -:  852:    }
        -:  853:    else
        -:  854:    {
        9:  855:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -:  856:
        9:  857:        if (connection_start_endpoint(session_instance->endpoint, on_frame_received, on_connection_state_changed, session_instance) != 0)
        -:  858:        {
    #####:  859:            result = MU_FAILURE;
        -:  860:        }
        -:  861:        else
        -:  862:        {
        9:  863:            if (!session_instance->is_underlying_connection_open)
        -:  864:            {
        9:  865:                if (connection_open(session_instance->connection) != 0)
        -:  866:                {
        9:  867:                    session_instance->is_underlying_connection_open = UNDERLYING_CONNECTION_NOT_OPEN;
        9:  868:                    result = MU_FAILURE;
        -:  869:                }
        -:  870:                else
        -:  871:                {
    #####:  872:                    session_instance->is_underlying_connection_open = UNDERLYING_CONNECTION_OPEN;
    #####:  873:                    result = 0;
        -:  874:                }
        -:  875:            }
        -:  876:            else
        -:  877:            {
    #####:  878:                result = 0;
        -:  879:            }
        -:  880:        }
        -:  881:    }
        -:  882:
        9:  883:    return result;
        -:  884:}
        -:  885:
        6:  886:int session_end(SESSION_HANDLE session, const char* condition_value, const char* description)
        -:  887:{
        -:  888:    int result;
        -:  889:
        6:  890:    if (session == NULL)
        -:  891:    {
    #####:  892:        result = MU_FAILURE;
        -:  893:    }
        -:  894:    else
        -:  895:    {
        6:  896:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -:  897:        size_t i;
        -:  898:
        6:  899:        if ((session_instance->session_state != SESSION_STATE_UNMAPPED) &&
        6:  900:            (session_instance->session_state != SESSION_STATE_DISCARDING))
    #####:  901:        {
    #####:  902:            ERROR_HANDLE error_handle = NULL;
    #####:  903:            result = 0;
        -:  904:
    #####:  905:            if (condition_value != NULL)
        -:  906:            {
    #####:  907:                error_handle = error_create(condition_value);
    #####:  908:                if (error_handle == NULL)
        -:  909:                {
    #####:  910:                    result = MU_FAILURE;
        -:  911:                }
        -:  912:                else
        -:  913:                {
    #####:  914:                    if (error_set_description(error_handle, description) != 0)
        -:  915:                    {
    #####:  916:                        result = MU_FAILURE;
        -:  917:                    }
        -:  918:                }
        -:  919:            }
        -:  920:
    #####:  921:            if (result == 0)
        -:  922:            {
    #####:  923:                if (send_end_frame(session_instance, error_handle) != 0)
        -:  924:                {
    #####:  925:                    result = MU_FAILURE;
        -:  926:                }
        -:  927:                else
        -:  928:                {
    #####:  929:                    session_set_state(session_instance, SESSION_STATE_DISCARDING);
    #####:  930:                    result = 0;
        -:  931:                }
        -:  932:            }
        -:  933:
    #####:  934:            if (error_handle != NULL)
        -:  935:            {
    #####:  936:                error_destroy(error_handle);
        -:  937:            }
        -:  938:        }
        -:  939:        else
        -:  940:        {
        6:  941:            result = 0;
        -:  942:        }
        -:  943:
        -:  944:        // all link endpoints are destroyed when the session end happens
       6*:  945:        for (i = 0; i < session_instance->link_endpoint_count; i++)
        -:  946:        {
    #####:  947:            free_link_endpoint(session_instance->link_endpoints[i]);
        -:  948:        }
        -:  949:
        6:  950:        session_instance->link_endpoint_count = 0;
        -:  951:    }
        -:  952:
        6:  953:    return result;
        -:  954:}
        -:  955:
        6:  956:int session_set_incoming_window(SESSION_HANDLE session, uint32_t incoming_window)
        -:  957:{
        -:  958:    int result;
        -:  959:
        6:  960:    if (session == NULL)
        -:  961:    {
    #####:  962:        result = MU_FAILURE;
        -:  963:    }
        -:  964:    else
        -:  965:    {
        6:  966:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -:  967:
        6:  968:        session_instance->desired_incoming_window = incoming_window;
        6:  969:        session_instance->incoming_window = incoming_window;
        -:  970:
        6:  971:        result = 0;
        -:  972:    }
        -:  973:
        6:  974:    return result;
        -:  975:}
        -:  976:
    #####:  977:int session_get_incoming_window(SESSION_HANDLE session, uint32_t* incoming_window)
        -:  978:{
        -:  979:    int result;
        -:  980:
    #####:  981:    if ((session == NULL) ||
        -:  982:        (incoming_window == NULL))
        -:  983:    {
    #####:  984:        result = MU_FAILURE;
        -:  985:    }
        -:  986:    else
        -:  987:    {
    #####:  988:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -:  989:
    #####:  990:        *incoming_window = session_instance->incoming_window;
        -:  991:
    #####:  992:        result = 0;
        -:  993:    }
        -:  994:
    #####:  995:    return result;
        -:  996:}
        -:  997:
        5:  998:int session_set_outgoing_window(SESSION_HANDLE session, uint32_t outgoing_window)
        -:  999:{
        -: 1000:    int result;
        -: 1001:
        5: 1002:    if (session == NULL)
        -: 1003:    {
    #####: 1004:        result = MU_FAILURE;
        -: 1005:    }
        -: 1006:    else
        -: 1007:    {
        5: 1008:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -: 1009:
        5: 1010:        session_instance->outgoing_window = outgoing_window;
        -: 1011:
        5: 1012:        result = 0;
        -: 1013:    }
        -: 1014:
        5: 1015:    return result;
        -: 1016:}
        -: 1017:
    #####: 1018:int session_get_outgoing_window(SESSION_HANDLE session, uint32_t* outgoing_window)
        -: 1019:{
        -: 1020:    int result;
        -: 1021:
    #####: 1022:    if ((session == NULL) ||
        -: 1023:        (outgoing_window == NULL))
        -: 1024:    {
    #####: 1025:        result = MU_FAILURE;
        -: 1026:    }
        -: 1027:    else
        -: 1028:    {
    #####: 1029:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -: 1030:
    #####: 1031:        *outgoing_window = session_instance->outgoing_window;
        -: 1032:
    #####: 1033:        result = 0;
        -: 1034:    }
        -: 1035:
    #####: 1036:    return result;
        -: 1037:}
        -: 1038:
    #####: 1039:int session_set_handle_max(SESSION_HANDLE session, handle handle_max)
        -: 1040:{
        -: 1041:    int result;
        -: 1042:
    #####: 1043:    if (session == NULL)
        -: 1044:    {
    #####: 1045:        result = MU_FAILURE;
        -: 1046:    }
        -: 1047:    else
        -: 1048:    {
    #####: 1049:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -: 1050:
    #####: 1051:        session_instance->handle_max = handle_max;
        -: 1052:
    #####: 1053:        result = 0;
        -: 1054:    }
        -: 1055:
    #####: 1056:    return result;
        -: 1057:}
        -: 1058:
    #####: 1059:int session_get_handle_max(SESSION_HANDLE session, handle* handle_max)
        -: 1060:{
        -: 1061:    int result;
        -: 1062:
    #####: 1063:    if ((session == NULL) ||
        -: 1064:        (handle_max == NULL))
        -: 1065:    {
    #####: 1066:        result = MU_FAILURE;
        -: 1067:    }
        -: 1068:    else
        -: 1069:    {
    #####: 1070:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -: 1071:
    #####: 1072:        *handle_max = session_instance->handle_max;
        -: 1073:
    #####: 1074:        result = 0;
        -: 1075:    }
        -: 1076:
    #####: 1077:    return result;
        -: 1078:}
        -: 1079:
       12: 1080:LINK_ENDPOINT_HANDLE session_create_link_endpoint(SESSION_HANDLE session, const char* name)
        -: 1081:{
        -: 1082:    LINK_ENDPOINT_INSTANCE* result;
        -: 1083:
        -: 1084:    /* Codes_S_R_S_SESSION_01_044: [If session, name or frame_received_callback is NULL, session_create_link_endpoint shall fail and return NULL.] */
       12: 1085:    if ((session == NULL) ||
        -: 1086:        (name == NULL))
        -: 1087:    {
    #####: 1088:        result = NULL;
        -: 1089:    }
        -: 1090:    else
        -: 1091:    {
        -: 1092:        /* Codes_S_R_S_SESSION_01_043: [session_create_link_endpoint shall create a link endpoint associated with a given session and return a non-NULL handle to it.] */
       12: 1093:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)session;
        -: 1094:
       12: 1095:        result = (LINK_ENDPOINT_INSTANCE*)malloc(sizeof(LINK_ENDPOINT_INSTANCE));
        -: 1096:        /* Codes_S_R_S_SESSION_01_045: [If allocating memory for the link endpoint fails, session_create_link_endpoint shall fail and return NULL.] */
       12: 1097:        if (result != NULL)
        -: 1098:        {
        -: 1099:            /* Codes_S_R_S_SESSION_01_046: [An unused handle shall be assigned to the link endpoint.] */
       12: 1100:            handle selected_handle = 0;
        -: 1101:            size_t i;
        -: 1102:            size_t name_length;
        -: 1103:
       21: 1104:            for (i = 0; i < session_instance->link_endpoint_count; i++)
        -: 1105:            {
        9: 1106:                if (session_instance->link_endpoints[i]->output_handle > selected_handle)
        -: 1107:                {
    #####: 1108:                    break;
        -: 1109:                }
        -: 1110:
        9: 1111:                selected_handle++;
        -: 1112:            }
        -: 1113:
       12: 1114:            result->on_session_state_changed = NULL;
       12: 1115:            result->on_session_flow_on = NULL;
       12: 1116:            result->frame_received_callback = NULL;
       12: 1117:            result->callback_context = NULL;
       12: 1118:            result->output_handle = selected_handle;
       12: 1119:            result->input_handle = 0xFFFFFFFF;
       12: 1120:            result->link_endpoint_state = LINK_ENDPOINT_STATE_NOT_ATTACHED;
       12: 1121:            name_length = strlen(name);
       12: 1122:            result->name = (char*)malloc(name_length + 1);
       12: 1123:            if (result->name == NULL)
        -: 1124:            {
        -: 1125:                /* Codes_S_R_S_SESSION_01_045: [If allocating memory for the link endpoint fails, session_create_link_endpoint shall fail and return NULL.] */
    #####: 1126:                free(result);
    #####: 1127:                result = NULL;
        -: 1128:            }
        -: 1129:            else
        -: 1130:            {
        -: 1131:                LINK_ENDPOINT_INSTANCE** new_link_endpoints;
       12: 1132:                (void)memcpy(result->name, name, name_length + 1);
       12: 1133:                result->session = session;
        -: 1134:
       12: 1135:                new_link_endpoints = (LINK_ENDPOINT_INSTANCE**)realloc(session_instance->link_endpoints, sizeof(LINK_ENDPOINT_INSTANCE*) * (session_instance->link_endpoint_count + 1));
       12: 1136:                if (new_link_endpoints == NULL)
        -: 1137:                {
        -: 1138:                    /* Codes_S_R_S_SESSION_01_045: [If allocating memory for the link endpoint fails, session_create_link_endpoint shall fail and return NULL.] */
    #####: 1139:                    free(result->name);
    #####: 1140:                    free(result);
    #####: 1141:                    result = NULL;
        -: 1142:                }
        -: 1143:                else
        -: 1144:                {
       12: 1145:                    session_instance->link_endpoints = new_link_endpoints;
        -: 1146:
       12: 1147:                    if (session_instance->link_endpoint_count - selected_handle > 0)
        -: 1148:                    {
    #####: 1149:                        (void)memmove(&session_instance->link_endpoints[selected_handle + 1], &session_instance->link_endpoints[selected_handle], (session_instance->link_endpoint_count - selected_handle) * sizeof(LINK_ENDPOINT_INSTANCE*));
        -: 1150:                    }
        -: 1151:
       12: 1152:                    session_instance->link_endpoints[selected_handle] = result;
       12: 1153:                    session_instance->link_endpoint_count++;
        -: 1154:                }
        -: 1155:            }
        -: 1156:        }
        -: 1157:    }
        -: 1158:
       12: 1159:    return result;
        -: 1160:}
        -: 1161:
       12: 1162:void session_destroy_link_endpoint(LINK_ENDPOINT_HANDLE link_endpoint)
        -: 1163:{
       12: 1164:    if (link_endpoint != NULL)
        -: 1165:    {
       12: 1166:        LINK_ENDPOINT_INSTANCE* endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
        -: 1167:
       12: 1168:        if (endpoint_instance->link_endpoint_state == LINK_ENDPOINT_STATE_ATTACHED)
        -: 1169:        {
    #####: 1170:            endpoint_instance->link_endpoint_state = LINK_ENDPOINT_STATE_DETACHING;
        -: 1171:        }
        -: 1172:        else
        -: 1173:        {
       12: 1174:            remove_link_endpoint(link_endpoint);
       12: 1175:            free_link_endpoint(link_endpoint);
        -: 1176:        }
        -: 1177:    }
       12: 1178:}
        -: 1179:
    #####: 1180:int session_start_link_endpoint(LINK_ENDPOINT_HANDLE link_endpoint, ON_ENDPOINT_FRAME_RECEIVED frame_received_callback, ON_SESSION_STATE_CHANGED on_session_state_changed, ON_SESSION_FLOW_ON on_session_flow_on, void* context)
        -: 1181:{
        -: 1182:    int result;
        -: 1183:
    #####: 1184:    if ((link_endpoint == NULL) ||
        -: 1185:        (frame_received_callback == NULL))
        -: 1186:    {
    #####: 1187:        result = MU_FAILURE;
        -: 1188:    }
        -: 1189:    else
        -: 1190:    {
    #####: 1191:        link_endpoint->frame_received_callback = frame_received_callback;
    #####: 1192:        link_endpoint->on_session_state_changed = on_session_state_changed;
    #####: 1193:        link_endpoint->on_session_flow_on = on_session_flow_on;
    #####: 1194:        link_endpoint->callback_context = context;
    #####: 1195:        link_endpoint->link_endpoint_state = LINK_ENDPOINT_STATE_NOT_ATTACHED;
        -: 1196:
    #####: 1197:        if (link_endpoint->on_session_state_changed != NULL)
        -: 1198:        {
    #####: 1199:            link_endpoint->on_session_state_changed(link_endpoint->callback_context, link_endpoint->session->session_state, link_endpoint->session->previous_session_state);
        -: 1200:        }
        -: 1201:
    #####: 1202:        result = 0;
        -: 1203:    }
        -: 1204:
    #####: 1205:    return result;
        -: 1206:}
        -: 1207:
    #####: 1208:static int encode_frame(LINK_ENDPOINT_HANDLE link_endpoint, AMQP_VALUE performative, PAYLOAD* payloads, size_t payload_count)
        -: 1209:{
        -: 1210:    int result;
        -: 1211:
    #####: 1212:    if ((link_endpoint == NULL) ||
        -: 1213:        (performative == NULL))
        -: 1214:    {
    #####: 1215:        result = MU_FAILURE;
        -: 1216:    }
        -: 1217:    else
        -: 1218:    {
    #####: 1219:        LINK_ENDPOINT_INSTANCE* link_endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
    #####: 1220:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)link_endpoint_instance->session;
        -: 1221:
    #####: 1222:        if (connection_encode_frame(session_instance->endpoint, performative, payloads, payload_count, NULL, NULL) != 0)
        -: 1223:        {
    #####: 1224:            result = MU_FAILURE;
        -: 1225:        }
        -: 1226:        else
        -: 1227:        {
    #####: 1228:            result = 0;
        -: 1229:        }
        -: 1230:    }
        -: 1231:
    #####: 1232:    return result;
        -: 1233:}
        -: 1234:
    #####: 1235:int session_send_flow(LINK_ENDPOINT_HANDLE link_endpoint, FLOW_HANDLE flow)
        -: 1236:{
        -: 1237:    int result;
        -: 1238:
    #####: 1239:    if ((link_endpoint == NULL) ||
        -: 1240:        (flow == NULL))
        -: 1241:    {
    #####: 1242:        result = MU_FAILURE;
        -: 1243:    }
        -: 1244:    else
        -: 1245:    {
    #####: 1246:        LINK_ENDPOINT_INSTANCE* link_endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
    #####: 1247:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)link_endpoint_instance->session;
        -: 1248:
    #####: 1249:        result = 0;
        -: 1250:
    #####: 1251:        if (session_instance->session_state == SESSION_STATE_BEGIN_RCVD)
        -: 1252:        {
    #####: 1253:            if (flow_set_next_incoming_id(flow, session_instance->next_incoming_id) != 0)
        -: 1254:            {
    #####: 1255:                result = MU_FAILURE;
        -: 1256:            }
        -: 1257:        }
        -: 1258:
    #####: 1259:        if (result == 0)
        -: 1260:        {
    #####: 1261:            if ((flow_set_next_incoming_id(flow, session_instance->next_incoming_id) != 0) ||
    #####: 1262:                (flow_set_incoming_window(flow, session_instance->incoming_window) != 0) ||
    #####: 1263:                (flow_set_next_outgoing_id(flow, session_instance->next_outgoing_id) != 0) ||
    #####: 1264:                (flow_set_outgoing_window(flow, session_instance->outgoing_window) != 0) ||
    #####: 1265:                (flow_set_handle(flow, link_endpoint_instance->output_handle) != 0))
        -: 1266:            {
    #####: 1267:                result = MU_FAILURE;
        -: 1268:            }
        -: 1269:            else
        -: 1270:            {
    #####: 1271:                AMQP_VALUE flow_performative_value = amqpvalue_create_flow(flow);
    #####: 1272:                if (flow_performative_value == NULL)
        -: 1273:                {
    #####: 1274:                    result = MU_FAILURE;
        -: 1275:                }
        -: 1276:                else
        -: 1277:                {
    #####: 1278:                    if (encode_frame(link_endpoint, flow_performative_value, NULL, 0) != 0)
        -: 1279:                    {
    #####: 1280:                        result = MU_FAILURE;
        -: 1281:                    }
        -: 1282:                    else
        -: 1283:                    {
    #####: 1284:                        result = 0;
        -: 1285:                    }
        -: 1286:
    #####: 1287:                    amqpvalue_destroy(flow_performative_value);
        -: 1288:                }
        -: 1289:            }
        -: 1290:        }
        -: 1291:    }
        -: 1292:
    #####: 1293:    return result;
        -: 1294:}
        -: 1295:
    #####: 1296:int session_send_attach(LINK_ENDPOINT_HANDLE link_endpoint, ATTACH_HANDLE attach)
        -: 1297:{
        -: 1298:    int result;
        -: 1299:
    #####: 1300:    if ((link_endpoint == NULL) ||
        -: 1301:        (attach == NULL))
        -: 1302:    {
    #####: 1303:        result = MU_FAILURE;
        -: 1304:    }
        -: 1305:    else
        -: 1306:    {
    #####: 1307:        LINK_ENDPOINT_INSTANCE* link_endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
        -: 1308:
    #####: 1309:        if (attach_set_handle(attach, link_endpoint_instance->output_handle) != 0)
        -: 1310:        {
    #####: 1311:            result = MU_FAILURE;
        -: 1312:        }
        -: 1313:        else
        -: 1314:        {
    #####: 1315:            AMQP_VALUE attach_performative_value = amqpvalue_create_attach(attach);
    #####: 1316:            if (attach_performative_value == NULL)
        -: 1317:            {
    #####: 1318:                result = MU_FAILURE;
        -: 1319:            }
        -: 1320:            else
        -: 1321:            {
    #####: 1322:                if (encode_frame(link_endpoint, attach_performative_value, NULL, 0) != 0)
        -: 1323:                {
    #####: 1324:                    result = MU_FAILURE;
        -: 1325:                }
        -: 1326:                else
        -: 1327:                {
    #####: 1328:                    result = 0;
        -: 1329:                }
        -: 1330:
    #####: 1331:                amqpvalue_destroy(attach_performative_value);
        -: 1332:            }
        -: 1333:        }
        -: 1334:    }
        -: 1335:
    #####: 1336:    return result;
        -: 1337:}
        -: 1338:
    #####: 1339:int session_send_disposition(LINK_ENDPOINT_HANDLE link_endpoint, DISPOSITION_HANDLE disposition)
        -: 1340:{
        -: 1341:    int result;
        -: 1342:
    #####: 1343:    if ((link_endpoint == NULL) ||
        -: 1344:        (disposition == NULL))
        -: 1345:    {
    #####: 1346:        result = MU_FAILURE;
        -: 1347:    }
        -: 1348:    else
        -: 1349:    {
    #####: 1350:        AMQP_VALUE disposition_performative_value = amqpvalue_create_disposition(disposition);
    #####: 1351:        if (disposition_performative_value == NULL)
        -: 1352:        {
    #####: 1353:            result = MU_FAILURE;
        -: 1354:        }
        -: 1355:        else
        -: 1356:        {
    #####: 1357:            if (encode_frame(link_endpoint, disposition_performative_value, NULL, 0) != 0)
        -: 1358:            {
    #####: 1359:                result = MU_FAILURE;
        -: 1360:            }
        -: 1361:            else
        -: 1362:            {
    #####: 1363:                result = 0;
        -: 1364:            }
        -: 1365:
    #####: 1366:            amqpvalue_destroy(disposition_performative_value);
        -: 1367:        }
        -: 1368:    }
        -: 1369:
    #####: 1370:    return result;
        -: 1371:}
        -: 1372:
    #####: 1373:int session_send_detach(LINK_ENDPOINT_HANDLE link_endpoint, DETACH_HANDLE detach)
        -: 1374:{
        -: 1375:    int result;
        -: 1376:
    #####: 1377:    if ((link_endpoint == NULL) ||
        -: 1378:        (detach == NULL))
        -: 1379:    {
    #####: 1380:        result = MU_FAILURE;
        -: 1381:    }
        -: 1382:    else
        -: 1383:    {
    #####: 1384:        LINK_ENDPOINT_INSTANCE* link_endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
        -: 1385:
    #####: 1386:        if (detach_set_handle(detach, link_endpoint_instance->output_handle) != 0)
        -: 1387:        {
    #####: 1388:            result = MU_FAILURE;
        -: 1389:        }
        -: 1390:        else
        -: 1391:        {
    #####: 1392:            AMQP_VALUE detach_performative_value = amqpvalue_create_detach(detach);
    #####: 1393:            if (detach_performative_value == NULL)
        -: 1394:            {
    #####: 1395:                result = MU_FAILURE;
        -: 1396:            }
        -: 1397:            else
        -: 1398:            {
    #####: 1399:                if (encode_frame(link_endpoint, detach_performative_value, NULL, 0) != 0)
        -: 1400:                {
    #####: 1401:                    result = MU_FAILURE;
        -: 1402:                }
        -: 1403:                else
        -: 1404:                {
    #####: 1405:                    result = 0;
        -: 1406:                }
        -: 1407:
    #####: 1408:                amqpvalue_destroy(detach_performative_value);
        -: 1409:            }
        -: 1410:        }
        -: 1411:    }
        -: 1412:
    #####: 1413:    return result;
        -: 1414:}
        -: 1415:
        -: 1416:/* Codes_S_R_S_SESSION_01_051: [session_send_transfer shall send a transfer frame with the performative indicated in the transfer argument.] */
    #####: 1417:SESSION_SEND_TRANSFER_RESULT session_send_transfer(LINK_ENDPOINT_HANDLE link_endpoint, TRANSFER_HANDLE transfer, PAYLOAD* payloads, size_t payload_count, delivery_number* delivery_id, ON_SEND_COMPLETE on_send_complete, void* callback_context)
        -: 1418:{
        -: 1419:    SESSION_SEND_TRANSFER_RESULT result;
        -: 1420:
        -: 1421:    /* Codes_S_R_S_SESSION_01_054: [If link_endpoint or transfer is NULL, session_send_transfer shall fail and return a non-zero value.] */
    #####: 1422:    if ((link_endpoint == NULL) ||
        -: 1423:        (transfer == NULL))
        -: 1424:    {
    #####: 1425:        result = SESSION_SEND_TRANSFER_ERROR;
        -: 1426:    }
        -: 1427:    else
        -: 1428:    {
    #####: 1429:        LINK_ENDPOINT_INSTANCE* link_endpoint_instance = (LINK_ENDPOINT_INSTANCE*)link_endpoint;
    #####: 1430:        SESSION_INSTANCE* session_instance = (SESSION_INSTANCE*)link_endpoint_instance->session;
        -: 1431:
        -: 1432:        /* Codes_S_R_S_SESSION_01_059: [When session_send_transfer is called while the session is not in the MAPPED state, session_send_transfer shall fail and return a non-zero value.] */
    #####: 1433:        if (session_instance->session_state != SESSION_STATE_MAPPED)
        -: 1434:        {
    #####: 1435:            result = SESSION_SEND_TRANSFER_ERROR;
        -: 1436:        }
        -: 1437:        else
        -: 1438:        {
    #####: 1439:            size_t payload_size = 0;
        -: 1440:            size_t i;
        -: 1441:
    #####: 1442:            for (i = 0; i < payload_count; i++)
        -: 1443:            {
    #####: 1444:                if ((payloads[i].length > UINT32_MAX) ||
    #####: 1445:                    (payload_size + payloads[i].length < payload_size))
        -: 1446:                {
        -: 1447:                    break;
        -: 1448:                }
        -: 1449:
    #####: 1450:                payload_size += payloads[i].length;
        -: 1451:            }
        -: 1452:
    #####: 1453:            if ((i < payload_count) ||
        -: 1454:                (payload_size > UINT32_MAX))
        -: 1455:            {
    #####: 1456:                result = SESSION_SEND_TRANSFER_ERROR;
        -: 1457:            }
        -: 1458:            else
        -: 1459:            {
    #####: 1460:                if (session_instance->remote_incoming_window == 0)
        -: 1461:                {
    #####: 1462:                    result = SESSION_SEND_TRANSFER_BUSY;
        -: 1463:                }
        -: 1464:                else
        -: 1465:                {
        -: 1466:                    /* Codes_S_R_S_SESSION_01_012: [The session endpoint assigns each outgoing transfer frame an implicit transfer-id from a session scoped sequence.] */
        -: 1467:                    /* Codes_S_R_S_SESSION_01_027: [sending a transfer Upon sending a transfer, the sending endpoint will increment its next-outgoing-id] */
    #####: 1468:                    *delivery_id = session_instance->next_outgoing_id;
    #####: 1469:                    if ((transfer_set_handle(transfer, link_endpoint_instance->output_handle) != 0) ||
    #####: 1470:                        (transfer_set_delivery_id(transfer, *delivery_id) != 0) ||
    #####: 1471:                        (transfer_set_more(transfer, false) != 0))
        -: 1472:                    {
        -: 1473:                        /* Codes_S_R_S_SESSION_01_058: [When any other error occurs, session_send_transfer shall fail and return a non-zero value.] */
    #####: 1474:                        result = SESSION_SEND_TRANSFER_ERROR;
        -: 1475:                    }
        -: 1476:                    else
        -: 1477:                    {
        -: 1478:                        AMQP_VALUE transfer_value;
        -: 1479:
    #####: 1480:                        transfer_value = amqpvalue_create_transfer(transfer);
    #####: 1481:                        if (transfer_value == NULL)
        -: 1482:                        {
        -: 1483:                            /* Codes_S_R_S_SESSION_01_058: [When any other error occurs, session_send_transfer shall fail and return a non-zero value.] */
    #####: 1484:                            result = SESSION_SEND_TRANSFER_ERROR;
        -: 1485:                        }
        -: 1486:                        else
        -: 1487:                        {
        -: 1488:                            uint32_t available_frame_size;
        -: 1489:                            size_t encoded_size;
        -: 1490:
    #####: 1491:                            if ((connection_get_remote_max_frame_size(session_instance->connection, &available_frame_size) != 0) ||
    #####: 1492:                                (amqpvalue_get_encoded_size(transfer_value, &encoded_size) != 0))
        -: 1493:                            {
    #####: 1494:                                result = SESSION_SEND_TRANSFER_ERROR;
        -: 1495:                            }
        -: 1496:                            else
        -: 1497:                            {
    #####: 1498:                                payload_size = 0;
        -: 1499:
    #####: 1500:                                for (i = 0; i < payload_count; i++)
        -: 1501:                                {
    #####: 1502:                                    payload_size += payloads[i].length;
        -: 1503:                                }
        -: 1504:
    #####: 1505:                                available_frame_size -= (uint32_t)encoded_size;
    #####: 1506:                                available_frame_size -= 8;
        -: 1507:
    #####: 1508:                                if (available_frame_size >= payload_size)
        -: 1509:                                {
        -: 1510:                                    /* Codes_S_R_S_SESSION_01_055: [The encoding of the frame shall be done by calling connection_encode_frame and passing as arguments: the connection handle associated with the session, the transfer performative and the payload chunks passed to session_send_transfer.] */
    #####: 1511:                                    if (connection_encode_frame(session_instance->endpoint, transfer_value, payloads, payload_count, on_send_complete, callback_context) != 0)
        -: 1512:                                    {
        -: 1513:                                        /* Codes_S_R_S_SESSION_01_056: [If connection_encode_frame fails then session_send_transfer shall fail and return a non-zero value.] */
    #####: 1514:                                        result = SESSION_SEND_TRANSFER_ERROR;
        -: 1515:                                    }
        -: 1516:                                    else
        -: 1517:                                    {
        -: 1518:                                        /* Codes_S_R_S_SESSION_01_018: [is incremented after each successive transfer according to RFC-1982 [RFC1982] serial number arithmetic.] */
    #####: 1519:                                        session_instance->next_outgoing_id++;
    #####: 1520:                                        session_instance->remote_incoming_window--;
    #####: 1521:                                        session_instance->outgoing_window--;
        -: 1522:
        -: 1523:                                        /* Codes_S_R_S_SESSION_01_053: [On success, session_send_transfer shall return 0.] */
    #####: 1524:                                        result = SESSION_SEND_TRANSFER_OK;
        -: 1525:                                    }
        -: 1526:                                }
        -: 1527:                                else
        -: 1528:                                {
    #####: 1529:                                    size_t current_payload_index = 0;
    #####: 1530:                                    uint32_t current_payload_pos = 0;
        -: 1531:
        -: 1532:                                    /* break it down into different deliveries */
    #####: 1533:                                    while (payload_size > 0)
        -: 1534:                                    {
    #####: 1535:                                        uint32_t transfer_frame_payload_count = 0;
    #####: 1536:                                        uint32_t current_transfer_frame_payload_size = (uint32_t)payload_size;
        -: 1537:                                        uint32_t byte_counter;
    #####: 1538:                                        size_t temp_current_payload_index = current_payload_index;
    #####: 1539:                                        uint32_t temp_current_payload_pos = current_payload_pos;
        -: 1540:                                        AMQP_VALUE multi_transfer_amqp_value;
        -: 1541:                                        PAYLOAD* transfer_frame_payloads;
        -: 1542:                                        bool more;
        -: 1543:
    #####: 1544:                                        if (current_transfer_frame_payload_size > available_frame_size)
        -: 1545:                                        {
    #####: 1546:                                            current_transfer_frame_payload_size = available_frame_size;
        -: 1547:                                        }
        -: 1548:
    #####: 1549:                                        if (available_frame_size >= payload_size)
        -: 1550:                                        {
    #####: 1551:                                            more = false;
        -: 1552:                                        }
        -: 1553:                                        else
        -: 1554:                                        {
    #####: 1555:                                            more = true;
        -: 1556:                                        }
        -: 1557:
    #####: 1558:                                        if (transfer_set_more(transfer, more) != 0)
        -: 1559:                                        {
    #####: 1560:                                            break;
        -: 1561:                                        }
        -: 1562:
    #####: 1563:                                        multi_transfer_amqp_value = amqpvalue_create_transfer(transfer);
    #####: 1564:                                        if (multi_transfer_amqp_value == NULL)
        -: 1565:                                        {
    #####: 1566:                                            break;
        -: 1567:                                        }
        -: 1568:
    #####: 1569:                                        byte_counter = current_transfer_frame_payload_size;
    #####: 1570:                                        while (byte_counter > 0)
        -: 1571:                                        {
    #####: 1572:                                            if (payloads[temp_current_payload_index].length - temp_current_payload_pos >= byte_counter)
        -: 1573:                                            {
        -: 1574:                                                /* more data than we need */
    #####: 1575:                                                temp_current_payload_pos += byte_counter;
    #####: 1576:                                                byte_counter = 0;
        -: 1577:                                            }
        -: 1578:                                            else
        -: 1579:                                            {
    #####: 1580:                                                byte_counter -= (uint32_t)payloads[temp_current_payload_index].length - temp_current_payload_pos;
    #####: 1581:                                                temp_current_payload_index++;
    #####: 1582:                                                temp_current_payload_pos = 0;
        -: 1583:                                            }
        -: 1584:                                        }
        -: 1585:
    #####: 1586:                                        transfer_frame_payload_count = (uint32_t)(temp_current_payload_index - current_payload_index + 1);
    #####: 1587:                                        transfer_frame_payloads = (PAYLOAD*)malloc(transfer_frame_payload_count * sizeof(PAYLOAD));
    #####: 1588:                                        if (transfer_frame_payloads == NULL)
        -: 1589:                                        {
    #####: 1590:                                            amqpvalue_destroy(multi_transfer_amqp_value);
    #####: 1591:                                            break;
        -: 1592:                                        }
        -: 1593:
        -: 1594:                                        /* copy data */
    #####: 1595:                                        byte_counter = current_transfer_frame_payload_size;
    #####: 1596:                                        transfer_frame_payload_count = 0;
        -: 1597:
    #####: 1598:                                        while (byte_counter > 0)
        -: 1599:                                        {
    #####: 1600:                                            if (payloads[current_payload_index].length - current_payload_pos > byte_counter)
        -: 1601:                                            {
        -: 1602:                                                /* more data than we need */
    #####: 1603:                                                transfer_frame_payloads[transfer_frame_payload_count].bytes = payloads[current_payload_index].bytes + current_payload_pos;
    #####: 1604:                                                transfer_frame_payloads[transfer_frame_payload_count].length = byte_counter;
    #####: 1605:                                                current_payload_pos += byte_counter;
    #####: 1606:                                                byte_counter = 0;
        -: 1607:                                            }
        -: 1608:                                            else
        -: 1609:                                            {
        -: 1610:                                                /* copy entire payload and move to the next */
    #####: 1611:                                                transfer_frame_payloads[transfer_frame_payload_count].bytes = payloads[current_payload_index].bytes + current_payload_pos;
    #####: 1612:                                                transfer_frame_payloads[transfer_frame_payload_count].length = payloads[current_payload_index].length - current_payload_pos;
    #####: 1613:                                                byte_counter -= (uint32_t)payloads[current_payload_index].length - current_payload_pos;
    #####: 1614:                                                current_payload_index++;
    #####: 1615:                                                current_payload_pos = 0;
        -: 1616:                                            }
        -: 1617:
    #####: 1618:                                            transfer_frame_payload_count++;
        -: 1619:                                        }
        -: 1620:
    #####: 1621:                                        if (connection_encode_frame(session_instance->endpoint, multi_transfer_amqp_value, transfer_frame_payloads, transfer_frame_payload_count, on_send_complete, callback_context) != 0)
        -: 1622:                                        {
    #####: 1623:                                            free(transfer_frame_payloads);
    #####: 1624:                                            amqpvalue_destroy(multi_transfer_amqp_value);
    #####: 1625:                                            break;
        -: 1626:                                        }
        -: 1627:
    #####: 1628:                                        free(transfer_frame_payloads);
    #####: 1629:                                        amqpvalue_destroy(multi_transfer_amqp_value);
    #####: 1630:                                        payload_size -= current_transfer_frame_payload_size;
        -: 1631:                                    }
        -: 1632:
    #####: 1633:                                    if (payload_size > 0)
        -: 1634:                                    {
    #####: 1635:                                        result = SESSION_SEND_TRANSFER_ERROR;
        -: 1636:                                    }
        -: 1637:                                    else
        -: 1638:                                    {
        -: 1639:                                        /* Codes_S_R_S_SESSION_01_018: [is incremented after each successive transfer according to RFC-1982 [RFC1982] serial number arithmetic.] */
    #####: 1640:                                        session_instance->next_outgoing_id++;
    #####: 1641:                                        session_instance->remote_incoming_window--;
    #####: 1642:                                        session_instance->outgoing_window--;
        -: 1643:
    #####: 1644:                                        result = SESSION_SEND_TRANSFER_OK;
        -: 1645:                                    }
        -: 1646:                                }
        -: 1647:                            }
        -: 1648:
    #####: 1649:                            amqpvalue_destroy(transfer_value);
        -: 1650:                        }
        -: 1651:                    }
        -: 1652:                }
        -: 1653:            }
        -: 1654:        }
        -: 1655:    }
        -: 1656:
    #####: 1657:    return result;
        -: 1658:}
