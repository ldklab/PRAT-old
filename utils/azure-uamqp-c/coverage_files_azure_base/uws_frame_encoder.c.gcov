        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/deps/azure-c-shared-utility/src/uws_frame_encoder.c
        -:    0:Programs:80
        -:    1: // Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <stdint.h>
        -:    6:#include <stdbool.h>
        -:    7:#include "azure_c_shared_utility/gballoc.h"
        -:    8:#include "azure_c_shared_utility/gb_rand.h"
        -:    9:#include "azure_c_shared_utility/uws_frame_encoder.h"
        -:   10:#include "azure_c_shared_utility/xlogging.h"
        -:   11:#include "azure_c_shared_utility/buffer_.h"
        -:   12:#include "azure_c_shared_utility/uniqueid.h"
        -:   13:
    #####:   14:BUFFER_HANDLE uws_frame_encoder_encode(WS_FRAME_TYPE opcode, const unsigned char* payload, size_t length, bool is_masked, bool is_final, unsigned char reserved)
        -:   15:{
        -:   16:    BUFFER_HANDLE result;
        -:   17:
    #####:   18:    if (reserved > 7)
        -:   19:    {
        -:   20:        /* Codes_SRS_UWS_FRAME_ENCODER_01_052: [ If reserved has any bits set except the lowest 3 then uws_frame_encoder_encode shall fail and return NULL. ]*/
    #####:   21:        LogError("Bad reserved value: 0x%02x", reserved);
    #####:   22:        result = NULL;
        -:   23:    }
    #####:   24:    else if (opcode > 0x0F)
        -:   25:    {
        -:   26:        /* Codes_SRS_UWS_FRAME_ENCODER_01_006: [ If an unknown opcode is received, the receiving endpoint MUST _Fail the WebSocket Connection_. ]*/
    #####:   27:        LogError("Invalid opcode: 0x%02x", opcode);
    #####:   28:        result = NULL;
        -:   29:    }
    #####:   30:    else if ((length > 0) &&
        -:   31:        (payload == NULL))
        -:   32:    {
        -:   33:        /* Codes_SRS_UWS_FRAME_ENCODER_01_054: [ If length is greater than 0 and payload is NULL, then uws_frame_encoder_encode shall fail and return NULL. ]*/
    #####:   34:        LogError("Invalid arguments: NULL payload and length=%u", (unsigned int)length);
    #####:   35:        result = NULL;
        -:   36:    }
        -:   37:    else
        -:   38:    {
    #####:   39:        size_t needed_bytes = 2;
        -:   40:        size_t header_bytes;
        -:   41:
        -:   42:        /* Codes_SRS_UWS_FRAME_ENCODER_01_044: [ On success uws_frame_encoder_encode shall return a non-NULL handle to the result buffer. ]*/
        -:   43:        /* Codes_SRS_UWS_FRAME_ENCODER_01_048: [ The newly created buffer shall be created by calling BUFFER_new. ]*/
    #####:   44:        result = BUFFER_new();
    #####:   45:        if (result == NULL)
        -:   46:        {
        -:   47:            /* Codes_SRS_UWS_FRAME_ENCODER_01_049: [ If BUFFER_new fails then uws_frame_encoder_encode shall fail and return NULL. ]*/
    #####:   48:            LogError("Cannot create new buffer");
        -:   49:        }
        -:   50:        else
        -:   51:        {
        -:   52:            /* Codes_SRS_UWS_FRAME_ENCODER_01_001: [ uws_frame_encoder_encode shall encode the information given in opcode, payload, length, is_masked, is_final and reserved according to the RFC6455 into a new buffer.]*/
    #####:   53:            if (length > 65535)
        -:   54:            {
    #####:   55:                needed_bytes += 8;
        -:   56:            }
    #####:   57:            else if (length > 125)
        -:   58:            {
    #####:   59:                needed_bytes += 2;
        -:   60:            }
        -:   61:
    #####:   62:            if (is_masked)
        -:   63:            {
    #####:   64:                needed_bytes += 4;
        -:   65:            }
        -:   66:
    #####:   67:            header_bytes = needed_bytes;
    #####:   68:            needed_bytes += length;
        -:   69:
        -:   70:            /* Codes_SRS_UWS_FRAME_ENCODER_01_046: [ The result buffer shall be resized accordingly using BUFFER_enlarge. ]*/
    #####:   71:            if (BUFFER_enlarge(result, needed_bytes) != 0)
        -:   72:            {
        -:   73:                /* Codes_SRS_UWS_FRAME_ENCODER_01_047: [ If BUFFER_enlarge fails then uws_frame_encoder_encode shall fail and return NULL. ]*/
    #####:   74:                LogError("Cannot allocate memory for encoded frame");
    #####:   75:                BUFFER_delete(result);
    #####:   76:                result = NULL;
        -:   77:            }
        -:   78:            else
        -:   79:            {
        -:   80:                /* Codes_SRS_UWS_FRAME_ENCODER_01_050: [ The allocated memory shall be accessed by calling BUFFER_u_char. ]*/
    #####:   81:                unsigned char* buffer = BUFFER_u_char(result);
    #####:   82:                if (buffer == NULL)
        -:   83:                {
        -:   84:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_051: [ If BUFFER_u_char fails then uws_frame_encoder_encode shall fail and return a NULL. ]*/
    #####:   85:                    LogError("Cannot get encoded buffer pointer");
    #####:   86:                    BUFFER_delete(result);
    #####:   87:                    result = NULL;
        -:   88:                }
        -:   89:                else
        -:   90:                {
        -:   91:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_007: [ *  %x0 denotes a continuation frame ]*/
        -:   92:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_008: [ *  %x1 denotes a text frame ]*/
        -:   93:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_009: [ *  %x2 denotes a binary frame ]*/
        -:   94:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_010: [ *  %x3-7 are reserved for further non-control frames ]*/
        -:   95:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_011: [ *  %x8 denotes a connection close ]*/
        -:   96:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_012: [ *  %x9 denotes a ping ]*/
        -:   97:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_013: [ *  %xA denotes a pong ]*/
        -:   98:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_014: [ *  %xB-F are reserved for further control frames ]*/
    #####:   99:                    buffer[0] = (unsigned char)opcode;
        -:  100:
        -:  101:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_002: [ Indicates that this is the final fragment in a message. ]*/
        -:  102:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_003: [ The first fragment MAY also be the final fragment. ]*/
    #####:  103:                    if (is_final)
        -:  104:                    {
    #####:  105:                        buffer[0] |= 0x80;
        -:  106:                    }
        -:  107:
        -:  108:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_004: [ MUST be 0 unless an extension is negotiated that defines meanings for non-zero values. ]*/
    #####:  109:                    buffer[0] |= reserved << 4;
        -:  110:
        -:  111:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_022: [ Note that in all cases, the minimal number of bytes MUST be used to encode the length, for example, the length of a 124-byte-long string can't be encoded as the sequence 126, 0, 124. ]*/
        -:  112:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_018: [ The length of the "Payload data", in bytes: ]*/
        -:  113:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_023: [ The payload length is the length of the "Extension data" + the length of the "Application data". ]*/
        -:  114:                    /* Codes_SRS_UWS_FRAME_ENCODER_01_042: [ The payload length, indicated in the framing as frame-payload-length, does NOT include the length of the masking key. ]*/
    #####:  115:                    if (length > 65535)
        -:  116:                    {
        -:  117:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_020: [ If 127, the following 8 bytes interpreted as a 64-bit unsigned integer (the most significant bit MUST be 0) are the payload length. ]*/
    #####:  118:                        buffer[1] = 127;
        -:  119:
        -:  120:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_021: [ Multibyte length quantities are expressed in network byte order. ]*/
    #####:  121:                        buffer[2] = (unsigned char)((uint64_t)length >> 56) & 0xFF;
    #####:  122:                        buffer[3] = (unsigned char)((uint64_t)length >> 48) & 0xFF;
    #####:  123:                        buffer[4] = (unsigned char)((uint64_t)length >> 40) & 0xFF;
    #####:  124:                        buffer[5] = (unsigned char)((uint64_t)length >> 32) & 0xFF;
    #####:  125:                        buffer[6] = (unsigned char)((uint64_t)length >> 24) & 0xFF;
    #####:  126:                        buffer[7] = (unsigned char)((uint64_t)length >> 16) & 0xFF;
    #####:  127:                        buffer[8] = (unsigned char)((uint64_t)length >> 8) & 0xFF;
    #####:  128:                        buffer[9] = (unsigned char)(length & 0xFF);
        -:  129:                    }
    #####:  130:                    else if (length > 125)
        -:  131:                    {
        -:  132:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_019: [ If 126, the following 2 bytes interpreted as a 16-bit unsigned integer are the payload length. ]*/
    #####:  133:                        buffer[1] = 126;
        -:  134:
        -:  135:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_021: [ Multibyte length quantities are expressed in network byte order. ]*/
    #####:  136:                        buffer[2] = (unsigned char)(length >> 8);
    #####:  137:                        buffer[3] = (unsigned char)(length & 0xFF);
        -:  138:                    }
        -:  139:                    else
        -:  140:                    {
        -:  141:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_043: [ if 0-125, that is the payload length. ]*/
    #####:  142:                        buffer[1] = (unsigned char)length;
        -:  143:                    }
        -:  144:
    #####:  145:                    if (is_masked)
        -:  146:                    {
        -:  147:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_015: [ Defines whether the "Payload data" is masked. ]*/
        -:  148:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_033: [ A masked frame MUST have the field frame-masked set to 1, as defined in Section 5.2. ]*/
    #####:  149:                        buffer[1] |= 0x80;
        -:  150:
        -:  151:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_053: [ In order to obtain a 32 bit value for masking, gb_rand shall be used 4 times (for each byte). ]*/
        -:  152:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_016: [ If set to 1, a masking key is present in masking-key, and this is used to unmask the "Payload data" as per Section 5.3. ]*/
        -:  153:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_026: [ This field is present if the mask bit is set to 1 and is absent if the mask bit is set to 0. ]*/
        -:  154:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_034: [ The masking key is contained completely within the frame, as defined in Section 5.2 as frame-masking-key. ]*/
        -:  155:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_036: [ The masking key is a 32-bit value chosen at random by the client. ]*/
        -:  156:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_037: [ When preparing a masked frame, the client MUST pick a fresh masking key from the set of allowed 32-bit values. ]*/
        -:  157:                        /* Codes_SRS_UWS_FRAME_ENCODER_01_038: [ The masking key needs to be unpredictable; thus, the masking key MUST be derived from a strong source of entropy, and the masking key for a given frame MUST NOT make it simple for a server/proxy to predict the masking key for a subsequent frame. ]*/
    #####:  158:                        buffer[header_bytes - 4] = (unsigned char)gb_rand();
    #####:  159:                        buffer[header_bytes - 3] = (unsigned char)gb_rand();
    #####:  160:                        buffer[header_bytes - 2] = (unsigned char)gb_rand();
    #####:  161:                        buffer[header_bytes - 1] = (unsigned char)gb_rand();
        -:  162:                    }
        -:  163:
    #####:  164:                    if (length > 0)
        -:  165:                    {
    #####:  166:                        if (is_masked)
        -:  167:                        {
        -:  168:                            size_t i;
        -:  169:
        -:  170:                            /* Codes_SRS_UWS_FRAME_ENCODER_01_035: [ It is used to mask the "Payload data" defined in the same section as frame-payload-data, which includes "Extension data" and "Application data". ]*/
        -:  171:                            /* Codes_SRS_UWS_FRAME_ENCODER_01_039: [ To convert masked data into unmasked data, or vice versa, the following algorithm is applied. ]*/
        -:  172:                            /* Codes_SRS_UWS_FRAME_ENCODER_01_040: [ The same algorithm applies regardless of the direction of the translation, e.g., the same steps are applied to mask the data as to unmask the data. ]*/
    #####:  173:                            for (i = 0; i < length; i++)
        -:  174:                            {
        -:  175:                                /* Codes_SRS_UWS_FRAME_ENCODER_01_041: [ Octet i of the transformed data ("transformed-octet-i") is the XOR of octet i of the original data ("original-octet-i") with octet at index i modulo 4 of the masking key ("masking-key-octet-j"): ]*/
    #####:  176:                                buffer[header_bytes + i] = ((unsigned char*)payload)[i] ^ buffer[header_bytes - 4 + (i % 4)];
        -:  177:                            }
        -:  178:                        }
        -:  179:                        else
        -:  180:                        {
    #####:  181:                            (void)memcpy(buffer + header_bytes, payload, length);
        -:  182:                        }
        -:  183:                    }
        -:  184:                }
        -:  185:            }
        -:  186:        }
        -:  187:    }
        -:  188:
    #####:  189:    return result;
        -:  190:}
