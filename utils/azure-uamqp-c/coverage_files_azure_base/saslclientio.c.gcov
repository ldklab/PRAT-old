        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/src/saslclientio.c
        -:    0:Programs:101
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <stddef.h>
        -:    6:#include <stdio.h>
        -:    7:#include <string.h>
        -:    8:#include <stdbool.h>
        -:    9:
        -:   10:#include "azure_c_shared_utility/gballoc.h"
        -:   11:#include "azure_macro_utils/macro_utils.h"
        -:   12:#include "azure_uamqp_c/saslclientio.h"
        -:   13:#include "azure_c_shared_utility/xio.h"
        -:   14:#include "azure_c_shared_utility/xlogging.h"
        -:   15:#include "azure_uamqp_c/frame_codec.h"
        -:   16:#include "azure_uamqp_c/sasl_frame_codec.h"
        -:   17:#include "azure_uamqp_c/amqp_definitions.h"
        -:   18:#include "azure_uamqp_c/amqpvalue_to_string.h"
        -:   19:
        -:   20:typedef enum IO_STATE_TAG
        -:   21:{
        -:   22:    IO_STATE_NOT_OPEN,
        -:   23:    IO_STATE_OPENING_UNDERLYING_IO,
        -:   24:    IO_STATE_SASL_HANDSHAKE,
        -:   25:    IO_STATE_OPEN,
        -:   26:    IO_STATE_CLOSING,
        -:   27:    IO_STATE_ERROR
        -:   28:} IO_STATE;
        -:   29:
        -:   30:#define SASL_HEADER_EXCHANGE_STATE_VALUES \
        -:   31:    SASL_HEADER_EXCHANGE_IDLE, \
        -:   32:    SASL_HEADER_EXCHANGE_HEADER_SENT, \
        -:   33:    SASL_HEADER_EXCHANGE_HEADER_RCVD, \
        -:   34:    SASL_HEADER_EXCHANGE_HEADER_EXCH
        -:   35:
        -:   36:// Suppress unused function warning for SASL_HEADER_EXCHANGE_STATEstrings
        -:   37:#ifdef NO_LOGGING
        -:   38:#define ENUM_TO_STRING_UNUSED
        -:   39:#include "azure_macro_utils/macro_utils.h"
        -:   40:#endif
        -:   41:
    #####:   42:MU_DEFINE_LOCAL_ENUM(SASL_HEADER_EXCHANGE_STATE, SASL_HEADER_EXCHANGE_STATE_VALUES)
        -:   43:
        -:   44:#define SASL_CLIENT_NEGOTIATION_STATE_VALUES \
        -:   45:    SASL_CLIENT_NEGOTIATION_NOT_STARTED, \
        -:   46:    SASL_CLIENT_NEGOTIATION_MECH_RCVD, \
        -:   47:    SASL_CLIENT_NEGOTIATION_INIT_SENT, \
        -:   48:    SASL_CLIENT_NEGOTIATION_CHALLENGE_RCVD, \
        -:   49:    SASL_CLIENT_NEGOTIATION_RESPONSE_SENT, \
        -:   50:    SASL_CLIENT_NEGOTIATION_OUTCOME_RCVD, \
        -:   51:    SASL_CLIENT_NEGOTIATION_ERROR
        -:   52:
    #####:   53:MU_DEFINE_LOCAL_ENUM(SASL_CLIENT_NEGOTIATION_STATE, SASL_CLIENT_NEGOTIATION_STATE_VALUES)
        -:   54:
        -:   55:typedef struct SASL_CLIENT_IO_INSTANCE_TAG
        -:   56:{
        -:   57:    XIO_HANDLE underlying_io;
        -:   58:    ON_BYTES_RECEIVED on_bytes_received;
        -:   59:    ON_IO_OPEN_COMPLETE on_io_open_complete;
        -:   60:    ON_IO_CLOSE_COMPLETE on_io_close_complete;
        -:   61:    ON_IO_ERROR on_io_error;
        -:   62:    void* on_bytes_received_context;
        -:   63:    void* on_io_open_complete_context;
        -:   64:    void* on_io_close_complete_context;
        -:   65:    void* on_io_error_context;
        -:   66:    SASL_HEADER_EXCHANGE_STATE sasl_header_exchange_state;
        -:   67:    SASL_CLIENT_NEGOTIATION_STATE sasl_client_negotiation_state;
        -:   68:    size_t header_bytes_received;
        -:   69:    SASL_FRAME_CODEC_HANDLE sasl_frame_codec;
        -:   70:    FRAME_CODEC_HANDLE frame_codec;
        -:   71:    IO_STATE io_state;
        -:   72:    SASL_MECHANISM_HANDLE sasl_mechanism;
        -:   73:    unsigned int is_trace_on : 1;
        -:   74:    unsigned int is_trace_on_set : 1;
        -:   75:} SASL_CLIENT_IO_INSTANCE;
        -:   76:
        -:   77:/* Codes_SRS_SASLCLIENTIO_01_002: [The protocol header consists of the upper case ASCII letters "AMQP" followed by a protocol id of three, followed by three unsigned bytes representing the major, minor, and revision of the specification version (currently 1 (SASL-MAJOR), 0 (SASLMINOR), 0 (SASL-REVISION)).] */
        -:   78:/* Codes_SRS_SASLCLIENTIO_01_124: [SASL-MAJOR 1 major protocol version.] */
        -:   79:/* Codes_SRS_SASLCLIENTIO_01_125: [SASL-MINOR 0 minor protocol version.] */
        -:   80:/* Codes_SRS_SASLCLIENTIO_01_126: [SASL-REVISION 0 protocol revision.] */
        -:   81:static const unsigned char sasl_header[] = { 'A', 'M', 'Q', 'P', 3, 1, 0, 0 };
        -:   82:
    #####:   83:static void indicate_error(SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance)
        -:   84:{
    #####:   85:    if (sasl_client_io_instance->on_io_error != NULL)
        -:   86:    {
    #####:   87:        sasl_client_io_instance->on_io_error(sasl_client_io_instance->on_io_error_context);
        -:   88:    }
    #####:   89:}
        -:   90:
        2:   91:static void indicate_open_complete(SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance, IO_OPEN_RESULT open_result)
        -:   92:{
        2:   93:    if (sasl_client_io_instance->on_io_open_complete != NULL)
        -:   94:    {
        2:   95:        sasl_client_io_instance->on_io_open_complete(sasl_client_io_instance->on_io_open_complete_context, open_result);
        -:   96:    }
        2:   97:}
        -:   98:
    #####:   99:static void indicate_close_complete(SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance)
        -:  100:{
    #####:  101:    if (sasl_client_io_instance->on_io_close_complete != NULL)
        -:  102:    {
    #####:  103:        sasl_client_io_instance->on_io_close_complete(sasl_client_io_instance->on_io_close_complete_context);
        -:  104:    }
    #####:  105:}
        -:  106:
    #####:  107:static void on_underlying_io_close_complete(void* context)
        -:  108:{
    #####:  109:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  110:
    #####:  111:    switch (sasl_client_io_instance->io_state)
        -:  112:    {
    #####:  113:    default:
    #####:  114:        break;
        -:  115:
    #####:  116:    case IO_STATE_OPENING_UNDERLYING_IO:
        -:  117:    case IO_STATE_SASL_HANDSHAKE:
    #####:  118:        sasl_client_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  119:        indicate_open_complete(sasl_client_io_instance, IO_OPEN_ERROR);
    #####:  120:        break;
        -:  121:
    #####:  122:    case IO_STATE_CLOSING:
    #####:  123:        sasl_client_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  124:        indicate_close_complete(sasl_client_io_instance);
    #####:  125:        break;
        -:  126:    }
    #####:  127:}
        -:  128:
        6:  129:static void handle_error(SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance)
        -:  130:{
        6:  131:    switch (sasl_client_io_instance->io_state)
        -:  132:    {
    #####:  133:    default:
        -:  134:    case IO_STATE_NOT_OPEN:
    #####:  135:        break;
        -:  136:
        6:  137:    case IO_STATE_OPENING_UNDERLYING_IO:
        -:  138:    case IO_STATE_SASL_HANDSHAKE:
        6:  139:        if (xio_close(sasl_client_io_instance->underlying_io, on_underlying_io_close_complete, sasl_client_io_instance) != 0)
        -:  140:        {
        2:  141:            sasl_client_io_instance->io_state = IO_STATE_NOT_OPEN;
        2:  142:            indicate_open_complete(sasl_client_io_instance, IO_OPEN_ERROR);
        -:  143:        }
        6:  144:        break;
        -:  145:
    #####:  146:    case IO_STATE_OPEN:
    #####:  147:        sasl_client_io_instance->io_state = IO_STATE_ERROR;
    #####:  148:        indicate_error(sasl_client_io_instance);
    #####:  149:        break;
        -:  150:    }
        6:  151:}
        -:  152:
        -:  153:// This callback usage needs to be either verified and commented or integrated into
        -:  154:// the state machine.
    #####:  155:static void unchecked_on_send_complete(void* context, IO_SEND_RESULT send_result)
        -:  156:{
        -:  157:    (void)context;
        -:  158:    (void)send_result;
    #####:  159:}
        -:  160:
    #####:  161:static int send_sasl_header(SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance)
        -:  162:{
        -:  163:    int result;
        -:  164:
        -:  165:    /* Codes_SRS_SASLCLIENTIO_01_078: [SASL client IO shall start the header exchange by sending the SASL header.] */
        -:  166:    /* Codes_SRS_SASLCLIENTIO_01_095: [Sending the header shall be done by using `xio_send`.]*/
    #####:  167:    if (xio_send(sasl_client_io_instance->underlying_io, sasl_header, sizeof(sasl_header), unchecked_on_send_complete, NULL) != 0)
        -:  168:    {
    #####:  169:        LogError("Sending SASL header failed");
    #####:  170:        result = MU_FAILURE;
        -:  171:    }
        -:  172:    else
        -:  173:    {
    #####:  174:        if (sasl_client_io_instance->is_trace_on != 0)
        -:  175:        {
    #####:  176:            LOG(AZ_LOG_TRACE, LOG_LINE, "-> Header (AMQP 3.1.0.0)");
        -:  177:        }
        -:  178:
    #####:  179:        result = 0;
        -:  180:    }
        -:  181:
    #####:  182:    return result;
        -:  183:}
        -:  184:
        6:  185:static void on_underlying_io_open_complete(void* context, IO_OPEN_RESULT open_result)
        -:  186:{
        6:  187:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  188:
        6:  189:    switch (sasl_client_io_instance->io_state)
        -:  190:    {
    #####:  191:    default:
    #####:  192:        LogError("Open complete received in unexpected state");
    #####:  193:        break;
        -:  194:
    #####:  195:    case IO_STATE_SASL_HANDSHAKE:
        -:  196:        /* Codes_SRS_SASLCLIENTIO_01_110: [raise ERROR] */
        -:  197:    case IO_STATE_OPEN:
        -:  198:        /* Codes_SRS_SASLCLIENTIO_01_106: [raise error] */
    #####:  199:        handle_error(sasl_client_io_instance);
    #####:  200:        break;
        -:  201:
        6:  202:    case IO_STATE_OPENING_UNDERLYING_IO:
        6:  203:        if (open_result == IO_OPEN_OK)
        -:  204:        {
    #####:  205:            sasl_client_io_instance->io_state = IO_STATE_SASL_HANDSHAKE;
    #####:  206:            if (sasl_client_io_instance->sasl_header_exchange_state != SASL_HEADER_EXCHANGE_IDLE)
        -:  207:            {
        -:  208:                /* Codes_SRS_SASLCLIENTIO_01_116: [If the underlying IO indicates another open while the after the header exchange has been started an error shall be indicated by calling `on_io_error`.]*/
    #####:  209:                handle_error(sasl_client_io_instance);
        -:  210:            }
        -:  211:            else
        -:  212:            {
        -:  213:                /* Codes_SRS_SASLCLIENTIO_01_105: [start header exchange] */
        -:  214:                /* Codes_SRS_SASLCLIENTIO_01_001: [To establish a SASL layer, each peer MUST start by sending a protocol header.] */
    #####:  215:                if (send_sasl_header(sasl_client_io_instance) != 0)
        -:  216:                {
        -:  217:                    /* Codes_SRS_SASLCLIENTIO_01_073: [If the handshake fails (i.e. the outcome is an error) the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
        -:  218:                    /* Codes_SRS_SASLCLIENTIO_01_077: [If sending the SASL header fails, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  219:                    handle_error(sasl_client_io_instance);
        -:  220:                }
        -:  221:                else
        -:  222:                {
    #####:  223:                    sasl_client_io_instance->sasl_header_exchange_state = SASL_HEADER_EXCHANGE_HEADER_SENT;
        -:  224:                }
        -:  225:            }
        -:  226:        }
        -:  227:        else
        -:  228:        {
        6:  229:            handle_error(sasl_client_io_instance);
        -:  230:        }
        -:  231:
        6:  232:        break;
        -:  233:    }
        6:  234:}
        -:  235:
    #####:  236:static void on_underlying_io_error(void* context)
        -:  237:{
    #####:  238:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  239:
    #####:  240:    switch (sasl_client_io_instance->io_state)
        -:  241:    {
    #####:  242:    default:
    #####:  243:        LogError("Error callback received in unexpected state");
    #####:  244:        break;
        -:  245:
    #####:  246:    case IO_STATE_OPENING_UNDERLYING_IO:
        -:  247:    case IO_STATE_SASL_HANDSHAKE:
        -:  248:        /* Codes_SRS_SASLCLIENTIO_01_101: [`on_open_complete` with `IO_OPEN_ERROR`]*/
    #####:  249:        if (xio_close(sasl_client_io_instance->underlying_io, on_underlying_io_close_complete, sasl_client_io_instance) != 0)
        -:  250:        {
    #####:  251:            sasl_client_io_instance->io_state = IO_STATE_NOT_OPEN;
    #####:  252:            indicate_open_complete(sasl_client_io_instance, IO_OPEN_ERROR);
        -:  253:        }
        -:  254:
    #####:  255:        break;
        -:  256:
    #####:  257:    case IO_STATE_OPEN:
    #####:  258:        sasl_client_io_instance->io_state = IO_STATE_ERROR;
    #####:  259:        indicate_error(sasl_client_io_instance);
    #####:  260:        break;
        -:  261:    }
    #####:  262:}
        -:  263:
        -:  264:#ifndef NO_LOGGING
    #####:  265:static const char* get_frame_type_as_string(AMQP_VALUE descriptor)
        -:  266:{
        -:  267:    const char* result;
        -:  268:
    #####:  269:    if (is_sasl_mechanisms_type_by_descriptor(descriptor))
        -:  270:    {
    #####:  271:        result = "[SASL MECHANISMS]";
        -:  272:    }
    #####:  273:    else if (is_sasl_init_type_by_descriptor(descriptor))
        -:  274:    {
    #####:  275:        result = "[SASL INIT]";
        -:  276:    }
    #####:  277:    else if (is_sasl_challenge_type_by_descriptor(descriptor))
        -:  278:    {
    #####:  279:        result = "[SASL CHALLENGE]";
        -:  280:    }
    #####:  281:    else if (is_sasl_response_type_by_descriptor(descriptor))
        -:  282:    {
    #####:  283:        result = "[SASL RESPONSE]";
        -:  284:    }
    #####:  285:    else if (is_sasl_outcome_type_by_descriptor(descriptor))
        -:  286:    {
    #####:  287:        result = "[SASL OUTCOME]";
        -:  288:    }
        -:  289:    else
        -:  290:    {
    #####:  291:        result = "[Unknown]";
        -:  292:    }
        -:  293:
    #####:  294:    return result;
        -:  295:}
        -:  296:#endif // NO_LOGGING
        -:  297:
    #####:  298:static void log_incoming_frame(AMQP_VALUE performative)
        -:  299:{
        -:  300:#ifdef NO_LOGGING
        -:  301:    UNUSED(performative);
        -:  302:#else
    #####:  303:    if (xlogging_get_log_function() != NULL)
        -:  304:    {
    #####:  305:        AMQP_VALUE descriptor = amqpvalue_get_inplace_descriptor(performative);
    #####:  306:        if (descriptor != NULL)
        -:  307:        {
        -:  308:            char* performative_as_string;
    #####:  309:            LOG(AZ_LOG_TRACE, 0, "<- ");
    #####:  310:            LOG(AZ_LOG_TRACE, 0, "%s", (char*)get_frame_type_as_string(descriptor));
    #####:  311:            performative_as_string = NULL;
    #####:  312:            LOG(AZ_LOG_TRACE, LOG_LINE, "%s", (performative_as_string = amqpvalue_to_string(performative)));
    #####:  313:            if (performative_as_string != NULL)
        -:  314:            {
    #####:  315:                free(performative_as_string);
        -:  316:            }
        -:  317:        }
        -:  318:    }
        -:  319:#endif
    #####:  320:}
        -:  321:
    #####:  322:static void log_outgoing_frame(AMQP_VALUE performative)
        -:  323:{
        -:  324:#ifdef NO_LOGGING
        -:  325:    UNUSED(performative);
        -:  326:#else
    #####:  327:    if (xlogging_get_log_function() != NULL)
        -:  328:    {
    #####:  329:        AMQP_VALUE descriptor = amqpvalue_get_inplace_descriptor(performative);
    #####:  330:        if (descriptor != NULL)
        -:  331:        {
        -:  332:            char* performative_as_string;
    #####:  333:            LOG(AZ_LOG_TRACE, 0, "-> ");
    #####:  334:            LOG(AZ_LOG_TRACE, 0, "%s", (char*)get_frame_type_as_string(descriptor));
    #####:  335:            performative_as_string = NULL;
    #####:  336:            LOG(AZ_LOG_TRACE, LOG_LINE, "%s", (performative_as_string = amqpvalue_to_string(performative)));
    #####:  337:            if (performative_as_string != NULL)
        -:  338:            {
    #####:  339:                free(performative_as_string);
        -:  340:            }
        -:  341:        }
        -:  342:    }
        -:  343:#endif
    #####:  344:}
        -:  345:
    #####:  346:static int saslclientio_receive_byte(SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance, unsigned char b)
        -:  347:{
        -:  348:    int result;
        -:  349:
    #####:  350:    switch (sasl_client_io_instance->sasl_header_exchange_state)
        -:  351:    {
    #####:  352:    default:
    #####:  353:        LogError("Byte being received in unexpected state: %s", MU_ENUM_TO_STRING(SASL_HEADER_EXCHANGE_STATE, sasl_client_io_instance->sasl_header_exchange_state));
    #####:  354:        result = MU_FAILURE;
    #####:  355:        break;
        -:  356:
    #####:  357:    case SASL_HEADER_EXCHANGE_HEADER_EXCH:
    #####:  358:        switch (sasl_client_io_instance->sasl_client_negotiation_state)
        -:  359:        {
    #####:  360:        case SASL_CLIENT_NEGOTIATION_ERROR:
    #####:  361:            LogError("Byte being received in unexpected state: %s", MU_ENUM_TO_STRING(SASL_CLIENT_NEGOTIATION_STATE, SASL_CLIENT_NEGOTIATION_ERROR));
    #####:  362:            result = MU_FAILURE;
    #####:  363:            break;
        -:  364:
    #####:  365:        default:
        -:  366:            /* Codes_SRS_SASLCLIENTIO_01_068: [During the SASL frame exchange that constitutes the handshake the received bytes from the underlying IO shall be fed to the frame codec instance created in `saslclientio_create` by calling `frame_codec_receive_bytes`.]*/
    #####:  367:            if (frame_codec_receive_bytes(sasl_client_io_instance->frame_codec, &b, 1) != 0)
        -:  368:            {
        -:  369:                /* Codes_SRS_SASLCLIENTIO_01_088: [If `frame_codec_receive_bytes` fails, the `on_io_error` callback shall be triggered.]*/
    #####:  370:                result = MU_FAILURE;
        -:  371:            }
        -:  372:            else
        -:  373:            {
    #####:  374:                result = 0;
        -:  375:            }
        -:  376:
    #####:  377:            break;
        -:  378:
    #####:  379:        case SASL_CLIENT_NEGOTIATION_OUTCOME_RCVD:
    #####:  380:            sasl_client_io_instance->on_bytes_received(sasl_client_io_instance->on_bytes_received_context, &b, 1);
    #####:  381:            result = 0;
    #####:  382:            break;
        -:  383:        }
        -:  384:
    #####:  385:        break;
        -:  386:
        -:  387:    /* Codes_SRS_SASLCLIENTIO_01_003: [Other than using a protocol id of three, the exchange of SASL layer headers follows the same rules specified in the version negotiation section of the transport specification (See Part 2: section 2.2).] */
    #####:  388:    case SASL_HEADER_EXCHANGE_IDLE:
        -:  389:    case SASL_HEADER_EXCHANGE_HEADER_SENT:
    #####:  390:        if (b != sasl_header[sasl_client_io_instance->header_bytes_received])
        -:  391:        {
    #####:  392:            LogError("Mismatched SASL header");
    #####:  393:            result = MU_FAILURE;
        -:  394:        }
        -:  395:        else
        -:  396:        {
    #####:  397:            sasl_client_io_instance->header_bytes_received++;
    #####:  398:            if (sasl_client_io_instance->header_bytes_received == sizeof(sasl_header))
        -:  399:            {
    #####:  400:                if (sasl_client_io_instance->is_trace_on != 0)
        -:  401:                {
    #####:  402:                    LOG(AZ_LOG_TRACE, LOG_LINE, "<- Header (AMQP 3.1.0.0)");
        -:  403:                }
        -:  404:
    #####:  405:                switch (sasl_client_io_instance->sasl_header_exchange_state)
        -:  406:                {
    #####:  407:                default:
    #####:  408:                    LogError("Invalid SASL header exchange state: %s", MU_ENUM_TO_STRING(SASL_HEADER_EXCHANGE_STATE, sasl_client_io_instance->sasl_header_exchange_state));
    #####:  409:                    result = MU_FAILURE;
    #####:  410:                    break;
        -:  411:
    #####:  412:                case SASL_HEADER_EXCHANGE_HEADER_SENT:
        -:  413:                    /* from this point on we need to decode SASL frames */
    #####:  414:                    sasl_client_io_instance->sasl_header_exchange_state = SASL_HEADER_EXCHANGE_HEADER_EXCH;
    #####:  415:                    result = 0;
    #####:  416:                    break;
        -:  417:
    #####:  418:                case SASL_HEADER_EXCHANGE_IDLE:
    #####:  419:                    sasl_client_io_instance->sasl_header_exchange_state = SASL_HEADER_EXCHANGE_HEADER_RCVD;
    #####:  420:                    if (send_sasl_header(sasl_client_io_instance) != 0)
        -:  421:                    {
        -:  422:                        /* Codes_SRS_SASLCLIENTIO_01_077: [If sending the SASL header fails, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  423:                        LogError("Could not send SASL header");
    #####:  424:                        result = MU_FAILURE;
        -:  425:                    }
        -:  426:                    else
        -:  427:                    {
    #####:  428:                        result = 0;
        -:  429:                    }
        -:  430:
    #####:  431:                    break;
        -:  432:                }
        -:  433:            }
        -:  434:            else
        -:  435:            {
    #####:  436:                result = 0;
        -:  437:            }
        -:  438:        }
        -:  439:
    #####:  440:        break;
        -:  441:    }
        -:  442:
    #####:  443:    return result;
        -:  444:}
        -:  445:
    #####:  446:static void on_underlying_io_bytes_received(void* context, const unsigned char* buffer, size_t size)
        -:  447:{
    #####:  448:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  449:
        -:  450:    /* Codes_SRS_SASLCLIENTIO_01_028: [If `buffer` is NULL or `size` is zero, nothing should be indicated as received, the state shall be switched to ERROR and the `on_io_error` callback shall be triggered.]*/
    #####:  451:    if ((buffer == NULL) ||
        -:  452:        (size == 0))
        -:  453:    {
    #####:  454:        LogError("Bad buffer received from the underlying IO, buffer = %p, size = %u",
        -:  455:            buffer, (unsigned int)size);
    #####:  456:        handle_error(sasl_client_io_instance);
        -:  457:    }
        -:  458:    else
        -:  459:    {
    #####:  460:        switch (sasl_client_io_instance->io_state)
        -:  461:        {
    #####:  462:        default:
    #####:  463:            break;
        -:  464:
    #####:  465:        case IO_STATE_OPEN:
        -:  466:            /* Codes_SRS_SASLCLIENTIO_01_027: [When the `on_underlying_io_bytes_received` callback passed to the underlying IO is called and the SASL client IO state is `IO_STATE_OPEN`, the bytes shall be indicated to the user of SASL client IO by calling the `on_bytes_received` callback that was passed in `saslclientio_open`.]*/
        -:  467:            /* Codes_SRS_SASLCLIENTIO_01_029: [The `context` argument for `on_io_error` shall be set to the `on_io_error_context` passed in `saslclientio_open`.]*/
    #####:  468:            sasl_client_io_instance->on_bytes_received(sasl_client_io_instance->on_bytes_received_context, buffer, size);
    #####:  469:            break;
        -:  470:
    #####:  471:        case IO_STATE_SASL_HANDSHAKE:
        -:  472:        {
        -:  473:            size_t i;
        -:  474:
        -:  475:            /* Codes_SRS_SASLCLIENTIO_01_030: [If bytes are received when the SASL client IO state is `IO_STATE_OPENING`, the bytes shall be consumed by the SASL client IO to satisfy the SASL handshake.]*/
    #####:  476:            for (i = 0; i < size; i++)
        -:  477:            {
    #####:  478:                if (saslclientio_receive_byte(sasl_client_io_instance, buffer[i]) != 0)
        -:  479:                {
    #####:  480:                    break;
        -:  481:                }
        -:  482:            }
        -:  483:
    #####:  484:            if (i < size)
        -:  485:            {
        -:  486:                /* Codes_SRS_SASLCLIENTIO_01_073: [If the handshake fails (i.e. the outcome is an error) the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  487:                handle_error(sasl_client_io_instance);
        -:  488:            }
        -:  489:
    #####:  490:            break;
        -:  491:        }
        -:  492:
    #####:  493:        case IO_STATE_ERROR:
        -:  494:            /* Codes_SRS_SASLCLIENTIO_01_031: [If bytes are received when the SASL client IO state is `IO_STATE_ERROR`, SASL client IO shall do nothing.]*/
    #####:  495:            break;
        -:  496:        }
        -:  497:    }
    #####:  498:}
        -:  499:
    #####:  500:static void on_bytes_encoded(void* context, const unsigned char* bytes, size_t length, bool encode_complete)
        -:  501:{
    #####:  502:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  503:
        -:  504:    (void)encode_complete;
        -:  505:
        -:  506:    /* Codes_SRS_SASLCLIENTIO_01_120: [When SASL client IO is notified by `sasl_frame_codec` of bytes that have been encoded via the `on_bytes_encoded` callback and SASL client IO is in the state OPENING, SASL client IO shall send these bytes by using `xio_send`.]*/
    #####:  507:    if (xio_send(sasl_client_io_instance->underlying_io, bytes, length, unchecked_on_send_complete, NULL) != 0)
        -:  508:    {
        -:  509:        /* Codes_SRS_SASLCLIENTIO_01_121: [If `xio_send` fails, the `on_io_error` callback shall be triggered.]*/
    #####:  510:        LogError("xio_send failed");
    #####:  511:        handle_error(sasl_client_io_instance);
        -:  512:    }
    #####:  513:}
        -:  514:
    #####:  515:static int send_sasl_init(SASL_CLIENT_IO_INSTANCE* sasl_client_io, const char* sasl_mechanism_name)
        -:  516:{
        -:  517:    int result;
        -:  518:
        -:  519:    SASL_INIT_HANDLE sasl_init;
        -:  520:    SASL_MECHANISM_BYTES init_bytes;
        -:  521:
    #####:  522:    init_bytes.length = 0;
    #####:  523:    init_bytes.bytes = NULL;
        -:  524:
        -:  525:    /* Codes_SRS_SASLCLIENTIO_01_045: [The name of the SASL mechanism used for the SASL exchange.] */
    #####:  526:    sasl_init = sasl_init_create(sasl_mechanism_name);
    #####:  527:    if (sasl_init == NULL)
        -:  528:    {
        -:  529:        /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  530:        LogError("Could not create sasl_init");
    #####:  531:        result = MU_FAILURE;
        -:  532:    }
        -:  533:    else
        -:  534:    {
        -:  535:        /* Codes_SRS_SASLCLIENTIO_01_048: [The contents of this data are defined by the SASL security mechanism.] */
    #####:  536:        if (saslmechanism_get_init_bytes(sasl_client_io->sasl_mechanism, &init_bytes) != 0)
        -:  537:        {
        -:  538:            /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  539:            LogError("Could not get SASL init bytes");
    #####:  540:            result = MU_FAILURE;
        -:  541:        }
        -:  542:        else
        -:  543:        {
        -:  544:            amqp_binary creds;
    #####:  545:            creds.bytes = init_bytes.bytes;
    #####:  546:            creds.length = init_bytes.length;
    #####:  547:            if ((init_bytes.length > 0) &&
        -:  548:                /* Codes_SRS_SASLCLIENTIO_01_047: [A block of opaque data passed to the security mechanism.] */
    #####:  549:                (sasl_init_set_initial_response(sasl_init, creds) != 0))
        -:  550:            {
        -:  551:                /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  552:                LogError("Could not set initial response");
    #####:  553:                result = MU_FAILURE;
        -:  554:            }
        -:  555:            else
        -:  556:            {
    #####:  557:                AMQP_VALUE sasl_init_value = amqpvalue_create_sasl_init(sasl_init);
    #####:  558:                if (sasl_init_value == NULL)
        -:  559:                {
        -:  560:                    /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  561:                    LogError("Could not create SASL init");
    #####:  562:                    result = MU_FAILURE;
        -:  563:                }
        -:  564:                else
        -:  565:                {
        -:  566:                    /* Codes_SRS_SASLCLIENTIO_01_070: [When a frame needs to be sent as part of the SASL handshake frame exchange, the send shall be done by calling `sasl_frame_codec_encode_frame`.]*/
    #####:  567:                    if (sasl_frame_codec_encode_frame(sasl_client_io->sasl_frame_codec, sasl_init_value, on_bytes_encoded, sasl_client_io) != 0)
        -:  568:                    {
        -:  569:                        /* Codes_SRS_SASLCLIENTIO_01_071: [If `sasl_frame_codec_encode_frame` fails, then the `on_io_error` callback shall be triggered.]*/
    #####:  570:                        LogError("Could not encode SASL init value");
    #####:  571:                        result = MU_FAILURE;
        -:  572:                    }
        -:  573:                    else
        -:  574:                    {
    #####:  575:                        if (sasl_client_io->is_trace_on != 0)
        -:  576:                        {
    #####:  577:                            log_outgoing_frame(sasl_init_value);
        -:  578:                        }
        -:  579:
    #####:  580:                        result = 0;
        -:  581:                    }
        -:  582:
    #####:  583:                    amqpvalue_destroy(sasl_init_value);
        -:  584:                }
        -:  585:            }
        -:  586:        }
        -:  587:
    #####:  588:        sasl_init_destroy(sasl_init);
        -:  589:    }
        -:  590:
    #####:  591:    return result;
        -:  592:}
        -:  593:
    #####:  594:static int send_sasl_response(SASL_CLIENT_IO_INSTANCE* sasl_client_io, SASL_MECHANISM_BYTES sasl_response)
        -:  595:{
        -:  596:    int result;
        -:  597:
        -:  598:    SASL_RESPONSE_HANDLE sasl_response_handle;
        -:  599:    amqp_binary response_binary_value;
        -:  600:
    #####:  601:    response_binary_value.bytes = sasl_response.bytes;
    #####:  602:    response_binary_value.length = sasl_response.length;
        -:  603:
        -:  604:    /* Codes_SRS_SASLCLIENTIO_01_055: [Send the SASL response data as defined by the SASL specification.] */
        -:  605:    /* Codes_SRS_SASLCLIENTIO_01_056: [A block of opaque data passed to the security mechanism.] */
    #####:  606:    if ((sasl_response_handle = sasl_response_create(response_binary_value)) == NULL)
        -:  607:    {
    #####:  608:        LogError("Could not create SASL response");
    #####:  609:        result = MU_FAILURE;
        -:  610:    }
        -:  611:    else
        -:  612:    {
    #####:  613:        AMQP_VALUE sasl_response_value = amqpvalue_create_sasl_response(sasl_response_handle);
    #####:  614:        if (sasl_response_value == NULL)
        -:  615:        {
    #####:  616:            LogError("Could not create SASL response AMQP value");
    #####:  617:            result = MU_FAILURE;
        -:  618:        }
        -:  619:        else
        -:  620:        {
        -:  621:            /* Codes_SRS_SASLCLIENTIO_01_070: [When a frame needs to be sent as part of the SASL handshake frame exchange, the send shall be done by calling `sasl_frame_codec_encode_frame`.]*/
    #####:  622:            if (sasl_frame_codec_encode_frame(sasl_client_io->sasl_frame_codec, sasl_response_value, on_bytes_encoded, sasl_client_io) != 0)
        -:  623:            {
    #####:  624:                LogError("Could not encode SASL response in the frame");
    #####:  625:                result = MU_FAILURE;
        -:  626:            }
        -:  627:            else
        -:  628:            {
    #####:  629:                if (sasl_client_io->is_trace_on != 0)
        -:  630:                {
    #####:  631:                    log_outgoing_frame(sasl_response_value);
        -:  632:                }
        -:  633:
    #####:  634:                result = 0;
        -:  635:            }
        -:  636:
    #####:  637:            amqpvalue_destroy(sasl_response_value);
        -:  638:        }
        -:  639:
    #####:  640:        sasl_response_destroy(sasl_response_handle);
        -:  641:    }
        -:  642:
    #####:  643:    return result;
        -:  644:}
        -:  645:
    #####:  646:static void on_sasl_frame_received_callback(void* context, AMQP_VALUE sasl_frame)
        -:  647:{
    #####:  648:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  649:
        -:  650:    /* Codes_SRS_SASLCLIENTIO_01_067: [The SASL frame exchange shall be started as soon as the SASL header handshake is done.] */
    #####:  651:    switch (sasl_client_io_instance->io_state)
        -:  652:    {
    #####:  653:    default:
    #####:  654:        LogError("SASL frame received while in state %d", (int)sasl_client_io_instance->io_state);
    #####:  655:        break;
        -:  656:
    #####:  657:    case IO_STATE_OPEN:
        -:  658:    case IO_STATE_OPENING_UNDERLYING_IO:
        -:  659:    case IO_STATE_CLOSING:
        -:  660:        /* Codes_SRS_SASLCLIENTIO_01_117: [If `on_sasl_frame_received_callback` is called when the state of the IO is OPEN then the `on_io_error` callback shall be triggered.]*/
    #####:  661:        handle_error(sasl_client_io_instance);
    #####:  662:        break;
        -:  663:
    #####:  664:    case IO_STATE_SASL_HANDSHAKE:
    #####:  665:        if (sasl_client_io_instance->sasl_header_exchange_state != SASL_HEADER_EXCHANGE_HEADER_EXCH)
        -:  666:        {
        -:  667:            /* Codes_SRS_SASLCLIENTIO_01_118: [If `on_sasl_frame_received_callback` is called in the OPENING state but the header exchange has not yet been completed, then the `on_io_error` callback shall be triggered.]*/
    #####:  668:            handle_error(sasl_client_io_instance);
        -:  669:        }
        -:  670:        else
        -:  671:        {
    #####:  672:            AMQP_VALUE descriptor = amqpvalue_get_inplace_descriptor(sasl_frame);
    #####:  673:            if (descriptor == NULL)
        -:  674:            {
        -:  675:                /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  676:                LogError("Could not obtain SASL frame descriptor");
    #####:  677:                handle_error(sasl_client_io_instance);
        -:  678:            }
        -:  679:            else
        -:  680:            {
    #####:  681:                if (sasl_client_io_instance->is_trace_on != 0)
        -:  682:                {
    #####:  683:                    log_incoming_frame(sasl_frame);
        -:  684:                }
        -:  685:
        -:  686:                /* Codes_SRS_SASLCLIENTIO_01_032: [The peer acting as the SASL server MUST announce supported authentication mechanisms using the sasl-mechanisms frame.] */
        -:  687:                /* Codes_SRS_SASLCLIENTIO_01_040: [The peer playing the role of the SASL client and the peer playing the role of the SASL server MUST correspond to the TCP client and server respectively.] */
        -:  688:                /* Codes_SRS_SASLCLIENTIO_01_034: [<-- SASL-MECHANISMS] */
    #####:  689:                if (is_sasl_mechanisms_type_by_descriptor(descriptor))
        -:  690:                {
    #####:  691:                    switch (sasl_client_io_instance->sasl_client_negotiation_state)
        -:  692:                    {
    #####:  693:                    default:
    #####:  694:                        LogError("SASL mechanisms frame received in %s state", MU_ENUM_TO_STRING(SASL_CLIENT_NEGOTIATION_STATE, sasl_client_io_instance->sasl_client_negotiation_state));
    #####:  695:                        handle_error(sasl_client_io_instance);
    #####:  696:                        break;
        -:  697:
    #####:  698:                    case SASL_CLIENT_NEGOTIATION_NOT_STARTED:
        -:  699:                    {
        -:  700:                        SASL_MECHANISMS_HANDLE sasl_mechanisms_handle;
        -:  701:
    #####:  702:                        if (amqpvalue_get_sasl_mechanisms(sasl_frame, &sasl_mechanisms_handle) != 0)
        -:  703:                        {
        -:  704:                            /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  705:                            LogError("Could not get SASL mechanisms");
    #####:  706:                            handle_error(sasl_client_io_instance);
        -:  707:                        }
        -:  708:                        else
        -:  709:                        {
        -:  710:                            AMQP_VALUE sasl_server_mechanisms;
        -:  711:                            uint32_t mechanisms_count;
        -:  712:
    #####:  713:                            if ((sasl_mechanisms_get_sasl_server_mechanisms(sasl_mechanisms_handle, &sasl_server_mechanisms) != 0) ||
    #####:  714:                                (amqpvalue_get_array_item_count(sasl_server_mechanisms, &mechanisms_count) != 0) ||
    #####:  715:                                (mechanisms_count == 0))
        -:  716:                            {
        -:  717:                                /* Codes_SRS_SASLCLIENTIO_01_042: [It is invalid for this list to be null or empty.] */
    #####:  718:                                LogError("Invalid SASL mechanisms list");
    #####:  719:                                handle_error(sasl_client_io_instance);
        -:  720:                            }
        -:  721:                            else
        -:  722:                            {
    #####:  723:                                const char* sasl_mechanism_name = saslmechanism_get_mechanism_name(sasl_client_io_instance->sasl_mechanism);
    #####:  724:                                if (sasl_mechanism_name == NULL)
        -:  725:                                {
        -:  726:                                    /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  727:                                    LogError("Cannot get the mechanism name");
    #####:  728:                                    handle_error(sasl_client_io_instance);
        -:  729:                                }
        -:  730:                                else
        -:  731:                                {
        -:  732:                                    uint32_t i;
        -:  733:
    #####:  734:                                    for (i = 0; i < mechanisms_count; i++)
        -:  735:                                    {
        -:  736:                                        AMQP_VALUE sasl_server_mechanism;
    #####:  737:                                        sasl_server_mechanism = amqpvalue_get_array_item(sasl_server_mechanisms, i);
    #####:  738:                                        if (sasl_server_mechanism == NULL)
        -:  739:                                        {
    #####:  740:                                            LogError("Cannot get SASL mechanisms array item for index %u", (unsigned int)i);
    #####:  741:                                            i = mechanisms_count;
        -:  742:                                        }
        -:  743:                                        else
        -:  744:                                        {
        -:  745:                                            const char* sasl_server_mechanism_name;
    #####:  746:                                            if (amqpvalue_get_symbol(sasl_server_mechanism, &sasl_server_mechanism_name) != 0)
        -:  747:                                            {
    #####:  748:                                                LogError("Error getting server SASL mechanism from array item");
    #####:  749:                                                i = mechanisms_count;
        -:  750:                                            }
        -:  751:                                            else
        -:  752:                                            {
    #####:  753:                                                if (strcmp(sasl_mechanism_name, sasl_server_mechanism_name) == 0)
        -:  754:                                                {
    #####:  755:                                                    amqpvalue_destroy(sasl_server_mechanism);
    #####:  756:                                                    break;
        -:  757:                                                }
        -:  758:                                            }
        -:  759:
    #####:  760:                                            amqpvalue_destroy(sasl_server_mechanism);
        -:  761:                                        }
        -:  762:                                    }
        -:  763:
    #####:  764:                                    if (i == mechanisms_count)
        -:  765:                                    {
        -:  766:                                        /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  767:                                        LogError("Could not find desired SASL mechanism in the list presented by server");
    #####:  768:                                        handle_error(sasl_client_io_instance);
        -:  769:                                    }
        -:  770:                                    else
        -:  771:                                    {
    #####:  772:                                        sasl_client_io_instance->sasl_client_negotiation_state = SASL_CLIENT_NEGOTIATION_MECH_RCVD;
        -:  773:
        -:  774:                                        /* Codes_SRS_SASLCLIENTIO_01_035: [SASL-INIT -->] */
        -:  775:                                        /* Codes_SRS_SASLCLIENTIO_01_033: [The partner MUST then choose one of the supported mechanisms and initiate a sasl exchange.] */
        -:  776:                                        /* Codes_SRS_SASLCLIENTIO_01_054: [Selects the sasl mechanism and provides the initial response if needed.] */
    #####:  777:                                        if (send_sasl_init(sasl_client_io_instance, sasl_mechanism_name) != 0)
        -:  778:                                        {
        -:  779:                                            /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  780:                                            LogError("Could not send SASL init");
    #####:  781:                                            handle_error(sasl_client_io_instance);
        -:  782:                                        }
        -:  783:                                        else
        -:  784:                                        {
    #####:  785:                                            sasl_client_io_instance->sasl_client_negotiation_state = SASL_CLIENT_NEGOTIATION_INIT_SENT;
        -:  786:                                        }
        -:  787:                                    }
        -:  788:                                }
        -:  789:                            }
        -:  790:
    #####:  791:                            sasl_mechanisms_destroy(sasl_mechanisms_handle);
        -:  792:                        }
        -:  793:
    #####:  794:                        break;
        -:  795:                    }
        -:  796:                    }
        -:  797:                }
        -:  798:                /* Codes_SRS_SASLCLIENTIO_01_052: [Send the SASL challenge data as defined by the SASL specification.] */
        -:  799:                /* Codes_SRS_SASLCLIENTIO_01_036: [<-- SASL-CHALLENGE *] */
        -:  800:                /* Codes_SRS_SASLCLIENTIO_01_039: [the SASL challenge/response step can occur zero or more times depending on the details of the SASL mechanism chosen.] */
    #####:  801:                else if (is_sasl_challenge_type_by_descriptor(descriptor))
        -:  802:                {
        -:  803:                    /* Codes_SRS_SASLCLIENTIO_01_032: [The peer acting as the SASL server MUST announce supported authentication mechanisms using the sasl-mechanisms frame.] */
    #####:  804:                    if ((sasl_client_io_instance->sasl_client_negotiation_state != SASL_CLIENT_NEGOTIATION_INIT_SENT) &&
    #####:  805:                        (sasl_client_io_instance->sasl_client_negotiation_state != SASL_CLIENT_NEGOTIATION_RESPONSE_SENT))
        -:  806:                    {
    #####:  807:                        LogError("SASL challenge received in a bad state: %s", MU_ENUM_TO_STRING(SASL_CLIENT_NEGOTIATION_STATE, sasl_client_io_instance->sasl_client_negotiation_state));
    #####:  808:                        handle_error(sasl_client_io_instance);
        -:  809:                    }
        -:  810:                    else
        -:  811:                    {
        -:  812:                        SASL_CHALLENGE_HANDLE sasl_challenge_handle;
        -:  813:
    #####:  814:                        if (amqpvalue_get_sasl_challenge(sasl_frame, &sasl_challenge_handle) != 0)
        -:  815:                        {
        -:  816:                            /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  817:                            LogError("Cannot get SASL challenge values");
    #####:  818:                            handle_error(sasl_client_io_instance);
        -:  819:                        }
        -:  820:                        else
        -:  821:                        {
        -:  822:                            amqp_binary challenge_binary_value;
        -:  823:
    #####:  824:                            challenge_binary_value.bytes = NULL;
    #####:  825:                            challenge_binary_value.length = 0;
        -:  826:
        -:  827:                            /* Codes_SRS_SASLCLIENTIO_01_053: [Challenge information, a block of opaque binary data passed to the security mechanism.] */
    #####:  828:                            if (sasl_challenge_get_challenge(sasl_challenge_handle, &challenge_binary_value) != 0)
        -:  829:                            {
        -:  830:                                /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  831:                                LogError("Cannot get SASL challenge binary value");
    #####:  832:                                handle_error(sasl_client_io_instance);
        -:  833:                            }
        -:  834:                            else
        -:  835:                            {
        -:  836:                                SASL_MECHANISM_BYTES challenge;
        -:  837:                                SASL_MECHANISM_BYTES response_bytes;
        -:  838:
    #####:  839:                                challenge.bytes = challenge_binary_value.bytes;
    #####:  840:                                challenge.length = challenge_binary_value.length;
    #####:  841:                                response_bytes.bytes = NULL;
    #####:  842:                                response_bytes.length = 0;
        -:  843:
        -:  844:                                /* Codes_SRS_SASLCLIENTIO_01_057: [The contents of this data are defined by the SASL security mechanism.] */
        -:  845:                                /* Codes_SRS_SASLCLIENTIO_01_037: [SASL-RESPONSE -->] */
    #####:  846:                                if (saslmechanism_challenge(sasl_client_io_instance->sasl_mechanism, &challenge, &response_bytes) != 0)
        -:  847:                                {
        -:  848:                                    /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  849:                                    LogError("SASL Challenge failed");
    #####:  850:                                    handle_error(sasl_client_io_instance);
        -:  851:                                }
    #####:  852:                                else if (send_sasl_response(sasl_client_io_instance, response_bytes) != 0)
        -:  853:                                {
        -:  854:                                    /* Codes_SRS_SASLCLIENTIO_01_119: [If any error is encountered when parsing the received frame, the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
    #####:  855:                                    LogError("Cannot send SASL reponse");
    #####:  856:                                    handle_error(sasl_client_io_instance);
        -:  857:                                }
        -:  858:                            }
        -:  859:
    #####:  860:                            sasl_challenge_destroy(sasl_challenge_handle);
        -:  861:                        }
        -:  862:                    }
        -:  863:                }
        -:  864:                /* Codes_SRS_SASLCLIENTIO_01_058: [This frame indicates the outcome of the SASL dialog.] */
        -:  865:                /* Codes_SRS_SASLCLIENTIO_01_038: [<-- SASL-OUTCOME] */
    #####:  866:                else if (is_sasl_outcome_type_by_descriptor(descriptor))
        -:  867:                {
        -:  868:                    /* Codes_SRS_SASLCLIENTIO_01_032: [The peer acting as the SASL server MUST announce supported authentication mechanisms using the sasl-mechanisms frame.] */
    #####:  869:                    if ((sasl_client_io_instance->sasl_client_negotiation_state != SASL_CLIENT_NEGOTIATION_INIT_SENT) &&
    #####:  870:                        (sasl_client_io_instance->sasl_client_negotiation_state != SASL_CLIENT_NEGOTIATION_RESPONSE_SENT))
        -:  871:                    {
    #####:  872:                        LogError("SASL outcome received in a bad state: %s", MU_ENUM_TO_STRING(SASL_CLIENT_NEGOTIATION_STATE, sasl_client_io_instance->sasl_client_negotiation_state));
    #####:  873:                        handle_error(sasl_client_io_instance);
        -:  874:                    }
        -:  875:                    else
        -:  876:                    {
        -:  877:                        SASL_OUTCOME_HANDLE sasl_outcome;
        -:  878:
    #####:  879:                        sasl_client_io_instance->sasl_client_negotiation_state = SASL_CLIENT_NEGOTIATION_OUTCOME_RCVD;
        -:  880:
    #####:  881:                        if (amqpvalue_get_sasl_outcome(sasl_frame, &sasl_outcome) != 0)
        -:  882:                        {
    #####:  883:                            LogError("Cannot get SASL outcome");
    #####:  884:                            handle_error(sasl_client_io_instance);
        -:  885:                        }
        -:  886:                        else
        -:  887:                        {
        -:  888:                            sasl_code sasl_code;
        -:  889:
        -:  890:                            /* Codes_SRS_SASLCLIENTIO_01_060: [A reply-code indicating the outcome of the SASL dialog.] */
    #####:  891:                            if (sasl_outcome_get_code(sasl_outcome, &sasl_code) != 0)
        -:  892:                            {
    #####:  893:                                LogError("Cannot get SASL outcome code");
    #####:  894:                                handle_error(sasl_client_io_instance);
        -:  895:                            }
        -:  896:                            else
        -:  897:                            {
    #####:  898:                                switch (sasl_code)
        -:  899:                                {
    #####:  900:                                default:
        -:  901:                                case sasl_code_auth:
        -:  902:                                    /* Codes_SRS_SASLCLIENTIO_01_063: [1 Connection authentication failed due to an unspecified problem with the supplied credentials.] */
        -:  903:                                case sasl_code_sys:
        -:  904:                                    /* Codes_SRS_SASLCLIENTIO_01_064: [2 Connection authentication failed due to a system error.] */
        -:  905:                                case sasl_code_sys_perm:
        -:  906:                                    /* Codes_SRS_SASLCLIENTIO_01_065: [3 Connection authentication failed due to a system error that is unlikely to be corrected without intervention.] */
        -:  907:                                case sasl_code_sys_temp:
        -:  908:                                    /* Codes_SRS_SASLCLIENTIO_01_066: [4 Connection authentication failed due to a transient system error.] */
    #####:  909:                                    LogError("SASL handshake failed with code %02X", (unsigned char)sasl_code);
    #####:  910:                                    handle_error(sasl_client_io_instance);
    #####:  911:                                    break;
        -:  912:
    #####:  913:                                case sasl_code_ok:
        -:  914:                                    /* Codes_SRS_SASLCLIENTIO_01_059: [Upon successful completion of the SASL dialog the security layer has been established] */
        -:  915:                                    /* Codes_SRS_SASLCLIENTIO_01_062: [0 Connection authentication succeeded.]  */
    #####:  916:                                    sasl_client_io_instance->io_state = IO_STATE_OPEN;
        -:  917:
        -:  918:                                    /* Codes_SRS_SASLCLIENTIO_01_072: [When the SASL handshake is complete, if the handshake is successful, the SASL client IO state shall be switched to `IO_STATE_OPEN` and the `on_io_open_complete` callback shall be called with `IO_OPEN_OK`.]*/
    #####:  919:                                    indicate_open_complete(sasl_client_io_instance, IO_OPEN_OK);
    #####:  920:                                    break;
        -:  921:                                }
        -:  922:                            }
        -:  923:
    #####:  924:                            sasl_outcome_destroy(sasl_outcome);
        -:  925:                        }
        -:  926:                    }
        -:  927:                }
        -:  928:                else
        -:  929:                {
    #####:  930:                    LogError("Bad SASL frame");
        -:  931:                }
        -:  932:            }
        -:  933:        }
    #####:  934:        break;
        -:  935:    }
    #####:  936:}
        -:  937:
    #####:  938:static void on_frame_codec_error(void* context)
        -:  939:{
    #####:  940:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  941:
        -:  942:    /* Codes_SRS_SASLCLIENTIO_01_122: [When `on_frame_codec_error` is called while in the OPENING state the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`.]*/
        -:  943:    /* Codes_SRS_SASLCLIENTIO_01_143: [ When `on_frame_codec_error` is called while in the OPEN state the `on_io_error` callback shall be triggered. ]*/
        -:  944:    /* Codes_SRS_SASLCLIENTIO_01_123: [When `on_frame_codec_error` is called in the ERROR state nothing shall be done.]*/
    #####:  945:    LogError("Error encoding frame (on_frame_codec_error)");
    #####:  946:    handle_error(sasl_client_io_instance);
    #####:  947:}
        -:  948:
    #####:  949:static void on_sasl_frame_codec_error(void* context)
        -:  950:{
    #####:  951:    SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)context;
        -:  952:
        -:  953:    /* Codes_SRS_SASLCLIENTIO_01_141: [ When `on_sasl_frame_codec_error` is called while in the OPENING state the `on_io_open_complete` callback shall be triggered with `IO_OPEN_ERROR`. ]*/
        -:  954:    /* Codes_SRS_SASLCLIENTIO_01_144: [ When `on_sasl_frame_codec_error` is called while OPEN state the `on_io_error` callback shall be triggered. ]*/
        -:  955:    /* Codes_SRS_SASLCLIENTIO_01_142: [ When `on_sasl_frame_codec_error` is called in the ERROR state nothing shall be done. ]*/
    #####:  956:    LogError("Error encoding SASL frame (on_sasl_frame_codec_error)");
    #####:  957:    handle_error(sasl_client_io_instance);
    #####:  958:}
        -:  959:
        5:  960:CONCRETE_IO_HANDLE saslclientio_create(void* io_create_parameters)
        -:  961:{
        5:  962:    SASLCLIENTIO_CONFIG* sasl_client_io_config = (SASLCLIENTIO_CONFIG*)io_create_parameters;
        -:  963:    SASL_CLIENT_IO_INSTANCE* result;
        -:  964:
        -:  965:    /* Codes_SRS_SASLCLIENTIO_01_005: [If `io_create_parameters` is NULL, `saslclientio_create` shall fail and return NULL.] */
        5:  966:    if (sasl_client_io_config == NULL)
        -:  967:    {
    #####:  968:        LogError("NULL io_create_parameters");
    #####:  969:        result = NULL;
        -:  970:    }
        -:  971:    /* Codes_SRS_SASLCLIENTIO_01_092: [If any of the `sasl_mechanism` or `underlying_io` members of the configuration structure are NULL, `saslclientio_create` shall fail and return NULL.] */
        5:  972:    else if ((sasl_client_io_config->underlying_io == NULL) ||
        5:  973:        (sasl_client_io_config->sasl_mechanism == NULL))
        -:  974:    {
    #####:  975:        LogError("Bad parameters: underlying_io = %p, sasl_mechanism = %p",
        -:  976:            sasl_client_io_config->underlying_io, sasl_client_io_config->sasl_mechanism);
    #####:  977:        result = NULL;
        -:  978:    }
        -:  979:    else
        -:  980:    {
        5:  981:        result = (SASL_CLIENT_IO_INSTANCE*)malloc(sizeof(SASL_CLIENT_IO_INSTANCE));
        5:  982:        if (result == NULL)
        -:  983:        {
        -:  984:            /* Codes_SRS_SASLCLIENTIO_01_006: [If memory cannot be allocated for the new instance, `saslclientio_create` shall fail and return NULL.] */
    #####:  985:            LogError("Cannot allocate sasl client IO instance");
        -:  986:        }
        -:  987:        else
        -:  988:        {
        5:  989:            result->underlying_io = sasl_client_io_config->underlying_io;
        -:  990:            /* Codes_SRS_SASLCLIENTIO_01_089: [`saslclientio_create` shall create a frame codec to be used for encoding/decoding frames by calling `frame_codec_create` and passing `on_frame_codec_error` and a context as arguments.] */
        5:  991:            result->frame_codec = frame_codec_create(on_frame_codec_error, result);
        5:  992:            if (result->frame_codec == NULL)
        -:  993:            {
        -:  994:                /* Codes_SRS_SASLCLIENTIO_01_090: [If `frame_codec_create` fails, then `saslclientio_create` shall fail and return NULL.] */
    #####:  995:                LogError("frame_codec_create failed");
    #####:  996:                free(result);
    #####:  997:                result = NULL;
        -:  998:            }
        -:  999:            else
        -: 1000:            {
        -: 1001:                /* Codes_SRS_SASLCLIENTIO_01_084: [`saslclientio_create` shall create a SASL frame codec to be used for SASL frame encoding/decoding by calling `sasl_frame_codec_create` and passing the just created frame codec as argument.] */
        5: 1002:                result->sasl_frame_codec = sasl_frame_codec_create(result->frame_codec, on_sasl_frame_received_callback, on_sasl_frame_codec_error, result);
        5: 1003:                if (result->sasl_frame_codec == NULL)
        -: 1004:                {
        -: 1005:                    /* Codes_SRS_SASLCLIENTIO_01_085: [If `sasl_frame_codec_create` fails, then `saslclientio_create` shall fail and return NULL.] */
    #####: 1006:                    LogError("sasl_frame_codec_create failed");
    #####: 1007:                    frame_codec_destroy(result->frame_codec);
    #####: 1008:                    free(result);
    #####: 1009:                    result = NULL;
        -: 1010:                }
        -: 1011:                else
        -: 1012:                {
        -: 1013:                    /* Codes_SRS_SASLCLIENTIO_01_004: [`saslclientio_create` shall return on success a non-NULL handle to a new SASL client IO instance.] */
        5: 1014:                    result->on_bytes_received = NULL;
        5: 1015:                    result->on_io_open_complete = NULL;
        5: 1016:                    result->on_io_error = NULL;
        5: 1017:                    result->on_io_close_complete = NULL;
        5: 1018:                    result->on_bytes_received_context = NULL;
        5: 1019:                    result->on_io_open_complete_context = NULL;
        5: 1020:                    result->on_io_close_complete_context = NULL;
        5: 1021:                    result->on_io_error_context = NULL;
        5: 1022:                    result->sasl_mechanism = sasl_client_io_config->sasl_mechanism;
        -: 1023:
        5: 1024:                    result->io_state = IO_STATE_NOT_OPEN;
        -: 1025:                }
        -: 1026:            }
        -: 1027:        }
        -: 1028:    }
        -: 1029:
        5: 1030:    return result;
        -: 1031:}
        -: 1032:
        4: 1033:void saslclientio_destroy(CONCRETE_IO_HANDLE sasl_client_io)
        -: 1034:{
        4: 1035:    if (sasl_client_io == NULL)
        -: 1036:    {
        -: 1037:        /* Codes_SRS_SASLCLIENTIO_01_008: [If the argument `sasl_client_io` is NULL, `saslclientio_destroy` shall do nothing.] */
    #####: 1038:        LogError("NULL sasl_client_io");
        -: 1039:    }
        -: 1040:    else
        -: 1041:    {
        4: 1042:        SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1043:
        -: 1044:        /* Codes_SRS_SASLCLIENTIO_01_007: [`saslclientio_destroy` shall free all resources associated with the SASL client IO handle.] */
        -: 1045:        /* Codes_SRS_SASLCLIENTIO_01_086: [`saslclientio_destroy` shall destroy the SASL frame codec created in `saslclientio_create` by calling `sasl_frame_codec_destroy`.] */
        4: 1046:        sasl_frame_codec_destroy(sasl_client_io_instance->sasl_frame_codec);
        -: 1047:
        -: 1048:        /* Codes_SRS_SASLCLIENTIO_01_091: [`saslclientio_destroy` shall destroy the frame codec created in `saslclientio_create` by calling `frame_codec_destroy`.] */
        4: 1049:        frame_codec_destroy(sasl_client_io_instance->frame_codec);
        4: 1050:        free(sasl_client_io);
        -: 1051:    }
        4: 1052:}
        -: 1053:
        8: 1054:int saslclientio_open_async(CONCRETE_IO_HANDLE sasl_client_io, ON_IO_OPEN_COMPLETE on_io_open_complete, void* on_io_open_complete_context, ON_BYTES_RECEIVED on_bytes_received, void* on_bytes_received_context, ON_IO_ERROR on_io_error, void* on_io_error_context)
        -: 1055:{
        8: 1056:    int result = 0;
        -: 1057:
        8: 1058:    if ((sasl_client_io == NULL) ||
        8: 1059:        (on_io_open_complete == NULL) ||
        8: 1060:        (on_bytes_received == NULL) ||
        -: 1061:        (on_io_error == NULL))
        -: 1062:    {
        -: 1063:        /* Codes_SRS_SASLCLIENTIO_01_011: [If any of the `sasl_client_io`, `on_io_open_complete`, `on_bytes_received` or `on_io_error` arguments is NULL, `saslclientio_open` shall fail and return a non-zero value.] */
    #####: 1064:        LogError("Bad arguments: sasl_client_io = %p, on_io_open_complete = %p, on_bytes_received = %p, on_io_error = %p",
        -: 1065:            sasl_client_io, on_io_open_complete, on_bytes_received, on_io_error);
    #####: 1066:        result = MU_FAILURE;
        -: 1067:    }
        -: 1068:    else
        -: 1069:    {
        8: 1070:        SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1071:
        8: 1072:        if (sasl_client_io_instance->io_state != IO_STATE_NOT_OPEN)
        -: 1073:        {
        2: 1074:            LogError("Open called while already OPEN");
        2: 1075:            result = MU_FAILURE;
        -: 1076:        }
        -: 1077:        else
        -: 1078:        {
        6: 1079:            sasl_client_io_instance->on_bytes_received = on_bytes_received;
        6: 1080:            sasl_client_io_instance->on_io_open_complete = on_io_open_complete;
        6: 1081:            sasl_client_io_instance->on_io_error = on_io_error;
        6: 1082:            sasl_client_io_instance->on_bytes_received_context = on_bytes_received_context;
        6: 1083:            sasl_client_io_instance->on_io_open_complete_context = on_io_open_complete_context;
        6: 1084:            sasl_client_io_instance->on_io_error_context = on_io_error_context;
        6: 1085:            sasl_client_io_instance->sasl_header_exchange_state = SASL_HEADER_EXCHANGE_IDLE;
        6: 1086:            sasl_client_io_instance->sasl_client_negotiation_state = SASL_CLIENT_NEGOTIATION_NOT_STARTED;
        6: 1087:            sasl_client_io_instance->header_bytes_received = 0;
        6: 1088:            sasl_client_io_instance->io_state = IO_STATE_OPENING_UNDERLYING_IO;
        6: 1089:            sasl_client_io_instance->is_trace_on = 0;
        6: 1090:            sasl_client_io_instance->is_trace_on_set = 0;
        -: 1091:
        -: 1092:            /* Codes_SRS_SASLCLIENTIO_01_009: [`saslclientio_open` shall call `xio_open` on the `underlying_io` passed to `saslclientio_create`.] */
        -: 1093:            /* Codes_SRS_SASLCLIENTIO_01_013: [`saslclientio_open_async` shall pass to `xio_open` the `on_underlying_io_open_complete` as `on_io_open_complete` argument, `on_underlying_io_bytes_received` as `on_bytes_received` argument and `on_underlying_io_error` as `on_io_error` argument.] */
        6: 1094:            if (xio_open(sasl_client_io_instance->underlying_io, on_underlying_io_open_complete, sasl_client_io_instance, on_underlying_io_bytes_received, sasl_client_io_instance, on_underlying_io_error, sasl_client_io_instance) != 0)
        -: 1095:            {
        -: 1096:                /* Codes_SRS_SASLCLIENTIO_01_012: [If the open of the `underlying_io` fails, `saslclientio_open_async` shall fail and return non-zero value.] */
        6: 1097:                LogError("xio_open failed");
        6: 1098:                result = MU_FAILURE;
        -: 1099:            }
        -: 1100:            else
        -: 1101:            {
        -: 1102:                /* Codes_SRS_SASLCLIENTIO_01_010: [On success, `saslclientio_open_async` shall return 0.]*/
    #####: 1103:                result = 0;
        -: 1104:            }
        -: 1105:        }
        -: 1106:    }
        -: 1107:
        8: 1108:    return result;
        -: 1109:}
        -: 1110:
    #####: 1111:int saslclientio_close_async(CONCRETE_IO_HANDLE sasl_client_io, ON_IO_CLOSE_COMPLETE on_io_close_complete, void* on_io_close_complete_context)
        -: 1112:{
    #####: 1113:    int result = 0;
        -: 1114:
        -: 1115:    /* Codes_SRS_SASLCLIENTIO_01_017: [If `sasl_client_io` is NULL, `saslclientio_close_async` shall fail and return a non-zero value.] */
    #####: 1116:    if (sasl_client_io == NULL)
        -: 1117:    {
    #####: 1118:        LogError("NULL saslclientio_close");
    #####: 1119:        result = MU_FAILURE;
        -: 1120:    }
        -: 1121:    else
        -: 1122:    {
    #####: 1123:        SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1124:
        -: 1125:        /* Codes_SRS_SASLCLIENTIO_01_098: [`saslclientio_close_async` shall only perform the close if the state is OPEN, OPENING or ERROR.] */
    #####: 1126:        if ((sasl_client_io_instance->io_state == IO_STATE_NOT_OPEN) ||
    #####: 1127:            (sasl_client_io_instance->io_state == IO_STATE_CLOSING))
        -: 1128:        {
        -: 1129:            /* Codes_SRS_SASLCLIENTIO_01_097: [If `saslclientio_close_async` is called when the IO is in the `IO_STATE_NOT_OPEN` state, `saslclientio_close_async` shall fail and return a non zero value.] */
    #####: 1130:            LogError("saslclientio_close called while not open");
    #####: 1131:            result = MU_FAILURE;
        -: 1132:        }
        -: 1133:        else
        -: 1134:        {
    #####: 1135:            sasl_client_io_instance->io_state = IO_STATE_CLOSING;
        -: 1136:
    #####: 1137:            sasl_client_io_instance->on_io_close_complete = on_io_close_complete;
    #####: 1138:            sasl_client_io_instance->on_io_close_complete_context = on_io_close_complete_context;
        -: 1139:
        -: 1140:            /* Codes_SRS_SASLCLIENTIO_01_015: [`saslclientio_close_async` shall close the underlying io handle passed in `saslclientio_create` by calling `xio_close`.] */
    #####: 1141:            if (xio_close(sasl_client_io_instance->underlying_io, on_underlying_io_close_complete, sasl_client_io_instance) != 0)
        -: 1142:            {
        -: 1143:                /* Codes_SRS_SASLCLIENTIO_01_018: [If `xio_close` fails, then `saslclientio_close_async` shall return a non-zero value.] */
    #####: 1144:                LogError("xio_close failed");
    #####: 1145:                result = MU_FAILURE;
        -: 1146:            }
        -: 1147:            else
        -: 1148:            {
        -: 1149:                /* Codes_SRS_SASLCLIENTIO_01_016: [On success, `saslclientio_close_async` shall return 0.] */
    #####: 1150:                result = 0;
        -: 1151:            }
        -: 1152:        }
        -: 1153:    }
        -: 1154:
    #####: 1155:    return result;
        -: 1156:}
        -: 1157:
    #####: 1158:int saslclientio_send_async(CONCRETE_IO_HANDLE sasl_client_io, const void* buffer, size_t size, ON_SEND_COMPLETE on_send_complete, void* callback_context)
        -: 1159:{
        -: 1160:    int result;
        -: 1161:
        -: 1162:    /* Codes_SRS_SASLCLIENTIO_01_022: [If the `sasl_client_io` or `buffer` argument is NULL, `saslclientio_send_async` shall fail and return a non-zero value.]*/
        -: 1163:    /* Codes_SRS_SASLCLIENTIO_01_127: [ `on_send_complete` shall be allowed to be NULL. ]*/
    #####: 1164:    if ((sasl_client_io == NULL) ||
    #####: 1165:        (buffer == NULL) ||
        -: 1166:        /* Codes_SRS_SASLCLIENTIO_01_023: [If `size` is 0, `saslclientio_send_async` shall fail and return a non-zero value.]*/
        -: 1167:        (size == 0))
        -: 1168:    {
        -: 1169:        /* Invalid arguments */
    #####: 1170:        LogError("Bad arguments: sasl_client_io = %p, buffer = %p, size = %u",
        -: 1171:            sasl_client_io, buffer, (unsigned int)size);
    #####: 1172:        result = MU_FAILURE;
        -: 1173:    }
        -: 1174:    else
        -: 1175:    {
    #####: 1176:        SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1177:
        -: 1178:        /* Codes_SRS_SASLCLIENTIO_01_019: [If `saslclientio_send_async` is called while the SASL client IO state is not `IO_STATE_OPEN`, `saslclientio_send_async` shall fail and return a non-zero value.]*/
    #####: 1179:        if (sasl_client_io_instance->io_state != IO_STATE_OPEN)
        -: 1180:        {
    #####: 1181:            LogError("send called while not open");
    #####: 1182:            result = MU_FAILURE;
        -: 1183:        }
        -: 1184:        else
        -: 1185:        {
        -: 1186:            /* Codes_SRS_SASLCLIENTIO_01_020: [If the SASL client IO state is `IO_STATE_OPEN`, `saslclientio_send_async` shall call `xio_send` on the `underlying_io` passed to `saslclientio_create`, while passing as arguments the `buffer`,`size`, `on_send_complete` and `callback_context`.]*/
    #####: 1187:            if (xio_send(sasl_client_io_instance->underlying_io, buffer, size, on_send_complete, callback_context) != 0)
        -: 1188:            {
        -: 1189:                /* Codes_SRS_SASLCLIENTIO_01_024: [If the call to `xio_send` fails, then `saslclientio_send_async` shall fail and return a non-zero value.]*/
    #####: 1190:                LogError("xio_send failed");
    #####: 1191:                result = MU_FAILURE;
        -: 1192:            }
        -: 1193:            else
        -: 1194:            {
        -: 1195:                /* Codes_SRS_SASLCLIENTIO_01_021: [On success, `saslclientio_send_async` shall return 0.]*/
    #####: 1196:                result = 0;
        -: 1197:            }
        -: 1198:        }
        -: 1199:    }
        -: 1200:
    #####: 1201:    return result;
        -: 1202:}
        -: 1203:
    #####: 1204:void saslclientio_dowork(CONCRETE_IO_HANDLE sasl_client_io)
        -: 1205:{
        -: 1206:    /* Codes_SRS_SASLCLIENTIO_01_026: [If the `sasl_client_io` argument is NULL, `saslclientio_dowork` shall do nothing.]*/
    #####: 1207:    if (sasl_client_io == NULL)
        -: 1208:    {
    #####: 1209:        LogError("NULL sasl_client_io");
        -: 1210:    }
        -: 1211:    else
        -: 1212:    {
    #####: 1213:        SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1214:
        -: 1215:        /* Codes_SRS_SASLCLIENTIO_01_099: [If the state of the IO is `IO_NOT_OPEN`, `saslclientio_dowork` shall make no calls to the underlying IO.]*/
    #####: 1216:        if (sasl_client_io_instance->io_state != IO_STATE_NOT_OPEN)
        -: 1217:        {
        -: 1218:            /* Codes_SRS_SASLCLIENTIO_01_025: [`saslclientio_dowork` shall call the `xio_dowork` on the `underlying_io` passed in `saslclientio_create`.]*/
    #####: 1219:            xio_dowork(sasl_client_io_instance->underlying_io);
        -: 1220:        }
        -: 1221:    }
    #####: 1222:}
        -: 1223:
    #####: 1224:int saslclientio_setoption(CONCRETE_IO_HANDLE sasl_client_io, const char* option_name, const void* value)
        -: 1225:{
        -: 1226:    int result;
        -: 1227:
    #####: 1228:    if ((sasl_client_io == NULL) ||
        -: 1229:        (option_name == NULL))
        -: 1230:    {
        -: 1231:        /* Codes_SRS_SASLCLIENTIO_01_130: [ If `sasl_client_io` or `option_name` is NULL, `saslclientio_setoption`  shall fail and return a non-zero value. ]*/
    #####: 1232:        LogError("Bad arguments: sasl_client_io = %p, option_name = %p",
        -: 1233:            sasl_client_io, option_name);
    #####: 1234:        result = MU_FAILURE;
        -: 1235:    }
        -: 1236:    else
        -: 1237:    {
    #####: 1238:        SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1239:
    #####: 1240:        if (sasl_client_io_instance->underlying_io == NULL)
        -: 1241:        {
    #####: 1242:            LogError("NULL underlying_io");
    #####: 1243:            result = MU_FAILURE;
        -: 1244:        }
        -: 1245:        /* Codes_SRS_SASLCLIENTIO_01_131: [ SASL client IO shall handle the following options: ]*/
        -: 1246:        /* Codes_SRS_SASLCLIENTIO_01_132: [ - logtrace - bool. ]*/
    #####: 1247:        else if (strcmp("logtrace", option_name) == 0)
        -: 1248:        {
    #####: 1249:            sasl_client_io_instance->is_trace_on = *((bool*)value) == true ? 1 : 0;
    #####: 1250:            sasl_client_io_instance->is_trace_on_set = 1;
        -: 1251:
        -: 1252:            /* Codes_SRS_SASLCLIENTIO_01_128: [ On success, `saslclientio_setoption` shall return 0. ]*/
    #####: 1253:            result = 0;
        -: 1254:        }
        -: 1255:        else
        -: 1256:        {
        -: 1257:            /* Codes_SRS_SASLCLIENTIO_03_001: [`saslclientio_setoption` shall forward all unhandled options to underlying io by calling `xio_setoption`.]*/
    #####: 1258:            if (xio_setoption(sasl_client_io_instance->underlying_io, option_name, value) != 0)
        -: 1259:            {
    #####: 1260:                LogError("Error executing xio_setoption");
    #####: 1261:                result = MU_FAILURE;
        -: 1262:            }
        -: 1263:            else
        -: 1264:            {
        -: 1265:                /* Codes_SRS_SASLCLIENTIO_01_128: [ On success, `saslclientio_setoption` shall return 0. ]*/
    #####: 1266:                result = 0;
        -: 1267:            }
        -: 1268:        }
        -: 1269:    }
        -: 1270:
    #####: 1271:    return result;
        -: 1272:}
        -: 1273:
        -: 1274:/*this function will clone an option given by name and value*/
    #####: 1275:static void* saslclientio_clone_option(const char* name, const void* value)
        -: 1276:{
        -: 1277:    (void)name;
        -: 1278:    (void)value;
    #####: 1279:    return NULL;
        -: 1280:}
        -: 1281:
        -: 1282:/*this function destroys an option previously created*/
    #####: 1283:static void saslclientio_destroy_option(const char* name, const void* value)
        -: 1284:{
        -: 1285:    (void)name;
        -: 1286:    (void)value;
    #####: 1287:}
        -: 1288:
    #####: 1289:static OPTIONHANDLER_HANDLE saslclientio_retrieveoptions(CONCRETE_IO_HANDLE sasl_client_io)
        -: 1290:{
        -: 1291:    OPTIONHANDLER_HANDLE result;
        -: 1292:
    #####: 1293:    if (sasl_client_io == NULL)
        -: 1294:    {
        -: 1295:        /* Codes_SRS_SASLCLIENTIO_01_139: [ When `saslclientio_retrieveoptions` is called with NULL `sasl_client_io` it shall fail and return NULL. ]*/
    #####: 1296:        result = NULL;
        -: 1297:    }
        -: 1298:    else
        -: 1299:    {
        -: 1300:        /* Codes_SRS_SASLCLIENTIO_01_133: [ `saslclientio_retrieveoptions` shall create an option handler by calling `OptionHandler_Create`. ]*/
    #####: 1301:        result = OptionHandler_Create(saslclientio_clone_option, saslclientio_destroy_option, saslclientio_setoption);
    #####: 1302:        if (result == NULL)
        -: 1303:        {
        -: 1304:            /* Codes_SRS_SASLCLIENTIO_01_138: [ If `OptionHandler_AddOption` or `OptionHandler_Create` fails then `saslclientio_retrieveoptions` shall fail and return NULL. ]*/
    #####: 1305:            LogError("unable to OptionHandler_Create");
        -: 1306:            /*return as is*/
        -: 1307:        }
        -: 1308:        else
        -: 1309:        {
    #####: 1310:            SASL_CLIENT_IO_INSTANCE* sasl_client_io_instance = (SASL_CLIENT_IO_INSTANCE*)sasl_client_io;
        -: 1311:
        -: 1312:            /*insert here work to add the options to "result" handle*/
    #####: 1313:            if (sasl_client_io_instance->is_trace_on_set)
        -: 1314:            {
    #####: 1315:                bool logtrace = sasl_client_io_instance->is_trace_on ? true : false;
        -: 1316:                /* Codes_SRS_SASLCLIENTIO_01_137: [ The options shall be added by calling `OptionHandler_AddOption`. ]*/
    #####: 1317:                if (OptionHandler_AddOption(result, "logtrace", &logtrace) != 0)
        -: 1318:                {
        -: 1319:                    /* Codes_SRS_SASLCLIENTIO_01_138: [ If `OptionHandler_AddOption` or `OptionHandler_Create` fails then `saslclientio_retrieveoptions` shall fail and return NULL. ]*/
    #####: 1320:                    LogError("unable to add logtrace option");
    #####: 1321:                    OptionHandler_Destroy(result);
    #####: 1322:                    result = NULL;
        -: 1323:                }
        -: 1324:            }
        -: 1325:        }
        -: 1326:    }
        -: 1327:
    #####: 1328:    return result;
        -: 1329:}
        -: 1330:
        -: 1331:static const IO_INTERFACE_DESCRIPTION sasl_client_io_interface_description =
        -: 1332:{
        -: 1333:    saslclientio_retrieveoptions,
        -: 1334:    saslclientio_create,
        -: 1335:    saslclientio_destroy,
        -: 1336:    saslclientio_open_async,
        -: 1337:    saslclientio_close_async,
        -: 1338:    saslclientio_send_async,
        -: 1339:    saslclientio_dowork,
        -: 1340:    saslclientio_setoption
        -: 1341:};
        -: 1342:
        -: 1343:/* Codes_SRS_SASLCLIENTIO_01_087: [`saslclientio_get_interface_description` shall return a pointer to an `IO_INTERFACE_DESCRIPTION` structure that contains pointers to the functions: `saslclientio_create`, `saslclientio_destroy`, `saslclientio_open_async`, `saslclientio_close_async`, `saslclientio_send_async`, `saslclientio_setoption`, `saslclientio_retrieveoptions` and `saslclientio_dowork`.]*/
        5: 1344:const IO_INTERFACE_DESCRIPTION* saslclientio_get_interface_description(void)
        -: 1345:{
        5: 1346:    return &sasl_client_io_interface_description;
        -: 1347:}
