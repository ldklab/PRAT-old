        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/deps/azure-c-shared-utility/src/buffer.c
        -:    0:Programs:80
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include <stdbool.h>
        -:    7:#include "azure_c_shared_utility/gballoc.h"
        -:    8:#include "azure_c_shared_utility/buffer_.h"
        -:    9:#include "azure_c_shared_utility/optimize_size.h"
        -:   10:#include "azure_c_shared_utility/xlogging.h"
        -:   11:
        -:   12:typedef struct BUFFER_TAG
        -:   13:{
        -:   14:    unsigned char* buffer;
        -:   15:    size_t size;
        -:   16:} BUFFER;
        -:   17:
        -:   18:/* Codes_SRS_BUFFER_07_001: [BUFFER_new shall allocate a BUFFER_HANDLE that will contain a NULL unsigned char*.] */
        2:   19:BUFFER_HANDLE BUFFER_new(void)
        -:   20:{
        2:   21:    BUFFER* temp = (BUFFER*)malloc(sizeof(BUFFER));
        -:   22:    /* Codes_SRS_BUFFER_07_002: [BUFFER_new shall return NULL on any error that occurs.] */
        2:   23:    if (temp != NULL)
        -:   24:    {
        2:   25:        temp->buffer = NULL;
        2:   26:        temp->size = 0;
        -:   27:    }
        2:   28:    return (BUFFER_HANDLE)temp;
        -:   29:}
        -:   30:
        1:   31:static int BUFFER_safemalloc(BUFFER* handleptr, size_t size)
        -:   32:{
        -:   33:    int result;
        1:   34:    size_t sizetomalloc = size;
        1:   35:    if (size == 0)
        -:   36:    {
    #####:   37:        sizetomalloc = 1;
        -:   38:    }
        1:   39:    handleptr->buffer = (unsigned char*)malloc(sizetomalloc);
        1:   40:    if (handleptr->buffer == NULL)
        -:   41:    {
        -:   42:        /*Codes_SRS_BUFFER_02_003: [If allocating memory fails, then BUFFER_create shall return NULL.]*/
    #####:   43:        LogError("Failure allocating data");
    #####:   44:        result = MU_FAILURE;
        -:   45:    }
        -:   46:    else
        -:   47:    {
        -:   48:        // we still consider the real buffer size is 0
        1:   49:        handleptr->size = size;
        1:   50:        result = 0;
        -:   51:    }
        1:   52:    return result;
        -:   53:}
        -:   54:
        1:   55:BUFFER_HANDLE BUFFER_create(const unsigned char* source, size_t size)
        -:   56:{
        -:   57:    BUFFER* result;
        -:   58:    /*Codes_SRS_BUFFER_02_001: [If source is NULL then BUFFER_create shall return NULL.]*/
        1:   59:    if (source == NULL)
        -:   60:    {
    #####:   61:        LogError("invalid parameter source: %p", source);
    #####:   62:        result = NULL;
        -:   63:    }
        -:   64:    else
        -:   65:    {
        -:   66:        /*Codes_SRS_BUFFER_02_002: [Otherwise, BUFFER_create shall allocate memory to hold size bytes and shall copy from source size bytes into the newly allocated memory.] */
        1:   67:        result = (BUFFER*)malloc(sizeof(BUFFER));
        1:   68:        if (result == NULL)
        -:   69:        {
        -:   70:            /*Codes_SRS_BUFFER_02_003: [If allocating memory fails, then BUFFER_create shall return NULL.] */
        -:   71:            /*fallthrough*/
    #####:   72:            LogError("Failure allocating BUFFER structure");
        -:   73:        }
        -:   74:        else
        -:   75:        {
        -:   76:            /* Codes_SRS_BUFFER_02_005: [If size parameter is 0 then 1 byte of memory shall be allocated yet size of the buffer shall be set to 0.]*/
        1:   77:            if (BUFFER_safemalloc(result, size) != 0)
        -:   78:            {
    #####:   79:                LogError("unable to BUFFER_safemalloc ");
    #####:   80:                free(result);
    #####:   81:                result = NULL;
        -:   82:            }
        -:   83:            else
        -:   84:            {
        -:   85:                /*Codes_SRS_BUFFER_02_004: [Otherwise, BUFFER_create shall return a non-NULL handle.] */
        1:   86:                (void)memcpy(result->buffer, source, size);
        -:   87:            }
        -:   88:        }
        -:   89:    }
        1:   90:    return (BUFFER_HANDLE)result;
        -:   91:}
        -:   92:
        -:   93:// Codes_SRS_BUFFER_07_029: [ BUFFER_create_with_size shall create a BUFFER_HANDLE with a pre allocated underlying buffer size.]
    #####:   94:BUFFER_HANDLE BUFFER_create_with_size(size_t buff_size)
        -:   95:{
        -:   96:    BUFFER* result;
    #####:   97:    result = (BUFFER*)malloc(sizeof(BUFFER));
    #####:   98:    if (result != NULL)
        -:   99:    {
    #####:  100:        if (buff_size == 0)
        -:  101:        {
        -:  102:            // Codes_SRS_BUFFER_07_030: [ If buff_size is 0 BUFFER_create_with_size shall create a valid non-NULL handle of zero size. ]
    #####:  103:            result->size = 0;
    #####:  104:            result->buffer = NULL;
        -:  105:        }
        -:  106:        else
        -:  107:        {
        -:  108:            // Codes_SRS_BUFFER_07_031: [ BUFFER_create_with_size shall allocate a buffer of buff_size. ]
    #####:  109:            result->size = buff_size;
    #####:  110:            if ((result->buffer = (unsigned char*)malloc(result->size)) == NULL)
        -:  111:            {
        -:  112:                // Codes_SRS_BUFFER_07_032: [ If allocating memory fails, then BUFFER_create_with_size shall return NULL. ]
    #####:  113:                LogError("unable to allocate buffer");
    #####:  114:                free(result);
    #####:  115:                result = NULL;
        -:  116:            }
        -:  117:        }
        -:  118:    }
        -:  119:    else
        -:  120:    {
        -:  121:        // Codes_SRS_BUFFER_07_032: [ If allocating memory fails, then BUFFER_create_with_size shall return NULL. ]
    #####:  122:        LogError("unable to allocate BUFFER");
        -:  123:    }
        -:  124:    // Codes_SRS_BUFFER_07_033: [ Otherwise, BUFFER_create_with_size shall return a non-NULL handle. ]
    #####:  125:    return (BUFFER_HANDLE)result;
        -:  126:}
        -:  127:
        -:  128:/* Codes_SRS_BUFFER_07_003: [BUFFER_delete shall delete the data associated with the BUFFER_HANDLE along with the Buffer.] */
        3:  129:void BUFFER_delete(BUFFER_HANDLE handle)
        -:  130:{
        -:  131:    /* Codes_SRS_BUFFER_07_004: [BUFFER_delete shall not delete any BUFFER_HANDLE that is NULL.] */
        3:  132:    if (handle != NULL)
        -:  133:    {
        3:  134:        BUFFER* b = (BUFFER*)handle;
        3:  135:        if (b->buffer != NULL)
        -:  136:        {
        -:  137:            /* Codes_SRS_BUFFER_07_003: [BUFFER_delete shall delete the data associated with the BUFFER_HANDLE along with the Buffer.] */
        3:  138:            free(b->buffer);
        -:  139:        }
        3:  140:        free(b);
        -:  141:    }
        3:  142:}
        -:  143:
        -:  144:/*return 0 if the buffer was copied*/
        -:  145:/*else return different than zero*/
        -:  146:/* Codes_SRS_BUFFER_07_008: [BUFFER_build allocates size_t bytes, copies the unsigned char* into the buffer and returns zero on success.] */
    #####:  147:int BUFFER_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
        -:  148:{
        -:  149:    int result;
    #####:  150:    if (handle == NULL)
        -:  151:    {
        -:  152:        /* Codes_SRS_BUFFER_07_009: [BUFFER_build shall return nonzero if handle is NULL ] */
    #####:  153:        result = MU_FAILURE;
        -:  154:    }
        -:  155:    /* Codes_SRS_BUFFER_01_002: [The size argument can be zero, in which case the underlying buffer held by the buffer instance shall be freed.] */
    #####:  156:    else if (size == 0)
        -:  157:    {
        -:  158:        /* Codes_SRS_BUFFER_01_003: [If size is zero, source can be NULL.] */
    #####:  159:        BUFFER* b = (BUFFER*)handle;
    #####:  160:        free(b->buffer);
    #####:  161:        b->buffer = NULL;
    #####:  162:        b->size = 0;
        -:  163:
    #####:  164:        result = 0;
        -:  165:    }
        -:  166:    else
        -:  167:    {
    #####:  168:        if (source == NULL)
        -:  169:        {
        -:  170:            /* Codes_SRS_BUFFER_01_001: [If size is positive and source is NULL, BUFFER_build shall return nonzero] */
    #####:  171:            result = MU_FAILURE;
        -:  172:        }
        -:  173:        else
        -:  174:        {
    #####:  175:            BUFFER* b = (BUFFER*)handle;
        -:  176:            /* Codes_SRS_BUFFER_07_011: [BUFFER_build shall overwrite previous contents if the buffer has been previously allocated.] */
    #####:  177:            unsigned char* newBuffer = (unsigned char*)realloc(b->buffer, size);
    #####:  178:            if (newBuffer == NULL)
        -:  179:            {
        -:  180:                /* Codes_SRS_BUFFER_07_010: [BUFFER_build shall return nonzero if any error is encountered.] */
    #####:  181:                LogError("Failure reallocating buffer");
    #####:  182:                result = MU_FAILURE;
        -:  183:            }
        -:  184:            else
        -:  185:            {
    #####:  186:                b->buffer = newBuffer;
    #####:  187:                b->size = size;
        -:  188:                /* Codes_SRS_BUFFER_01_002: [The size argument can be zero, in which case nothing shall be copied from source.] */
    #####:  189:                (void)memcpy(b->buffer, source, size);
        -:  190:
    #####:  191:                result = 0;
        -:  192:            }
        -:  193:        }
        -:  194:    }
        -:  195:
    #####:  196:    return result;
        -:  197:}
        -:  198:
    #####:  199:int BUFFER_append_build(BUFFER_HANDLE handle, const unsigned char* source, size_t size)
        -:  200:{
        -:  201:    int result;
    #####:  202:    if (handle == NULL || source == NULL || size == 0)
        -:  203:    {
        -:  204:        /* Codes_SRS_BUFFER_07_029: [ BUFFER_append_build shall return nonzero if handle or source are NULL or if size is 0. ] */
    #####:  205:        LogError("BUFFER_append_build failed invalid parameter handle: %p, source: %p, size: %lu", handle, source, (unsigned long)size);
    #####:  206:        result = MU_FAILURE;
        -:  207:    }
        -:  208:    else
        -:  209:    {
    #####:  210:        if (handle->buffer == NULL)
        -:  211:        {
        -:  212:            /* Codes_SRS_BUFFER_07_030: [ if handle->buffer is NULL BUFFER_append_build shall allocate the a buffer of size bytes... ] */
    #####:  213:            if (BUFFER_safemalloc(handle, size) != 0)
        -:  214:            {
        -:  215:                /* Codes_SRS_BUFFER_07_035: [ If any error is encountered BUFFER_append_build shall return a non-null value. ] */
    #####:  216:                LogError("Failure with BUFFER_safemalloc");
    #####:  217:                result = MU_FAILURE;
        -:  218:            }
        -:  219:            else
        -:  220:            {
        -:  221:                /* Codes_SRS_BUFFER_07_031: [ ... and copy the contents of source to handle->buffer. ] */
    #####:  222:                (void)memcpy(handle->buffer, source, size);
        -:  223:                /* Codes_SRS_BUFFER_07_034: [ On success BUFFER_append_build shall return 0 ] */
    #####:  224:                result = 0;
        -:  225:            }
        -:  226:        }
        -:  227:        else
        -:  228:        {
        -:  229:            /* Codes_SRS_BUFFER_07_032: [ if handle->buffer is not NULL BUFFER_append_build shall realloc the buffer to be the handle->size + size ] */
    #####:  230:            unsigned char* temp = (unsigned char*)realloc(handle->buffer, handle->size + size);
    #####:  231:            if (temp == NULL)
        -:  232:            {
        -:  233:                /* Codes_SRS_BUFFER_07_035: [ If any error is encountered BUFFER_append_build shall return a non-null value. ] */
    #####:  234:                LogError("Failure reallocating temporary buffer");
    #####:  235:                result = MU_FAILURE;
        -:  236:            }
        -:  237:            else
        -:  238:            {
        -:  239:                /* Codes_SRS_BUFFER_07_033: [ ... and copy the contents of source to the end of the buffer. ] */
    #####:  240:                handle->buffer = temp;
        -:  241:                // Append the BUFFER
    #####:  242:                (void)memcpy(&handle->buffer[handle->size], source, size);
    #####:  243:                handle->size += size;
        -:  244:                /* Codes_SRS_BUFFER_07_034: [ On success BUFFER_append_build shall return 0 ] */
    #####:  245:                result = 0;
        -:  246:            }
        -:  247:        }
        -:  248:    }
    #####:  249:    return result;
        -:  250:}
        -:  251:
        -:  252:/*return 0 if the buffer was pre-build(that is, had its space allocated)*/
        -:  253:/*else return different than zero*/
        -:  254:/* Codes_SRS_BUFFER_07_005: [BUFFER_pre_build allocates size_t bytes of BUFFER_HANDLE and returns zero on success.] */
        1:  255:int BUFFER_pre_build(BUFFER_HANDLE handle, size_t size)
        -:  256:{
        -:  257:    int result;
        1:  258:    if (handle == NULL)
        -:  259:    {
        -:  260:        /* Codes_SRS_BUFFER_07_006: [If handle is NULL or size is 0 then BUFFER_pre_build shall return a nonzero value.] */
    #####:  261:        result = MU_FAILURE;
        -:  262:    }
        1:  263:    else if (size == 0)
        -:  264:    {
        -:  265:        /* Codes_SRS_BUFFER_07_006: [If handle is NULL or size is 0 then BUFFER_pre_build shall return a nonzero value.] */
    #####:  266:        result = MU_FAILURE;
        -:  267:    }
        -:  268:    else
        -:  269:    {
        1:  270:        BUFFER* b = (BUFFER*)handle;
        1:  271:        if (b->buffer != NULL)
        -:  272:        {
        -:  273:            /* Codes_SRS_BUFFER_07_007: [BUFFER_pre_build shall return nonzero if the buffer has been previously allocated and is not NULL.] */
    #####:  274:            LogError("Failure buffer data is NULL");
    #####:  275:            result = MU_FAILURE;
        -:  276:        }
        -:  277:        else
        -:  278:        {
        1:  279:            if ((b->buffer = (unsigned char*)malloc(size)) == NULL)
        -:  280:            {
        -:  281:                /* Codes_SRS_BUFFER_07_013: [BUFFER_pre_build shall return nonzero if any error is encountered.] */
    #####:  282:                LogError("Failure allocating buffer");
    #####:  283:                result = MU_FAILURE;
        -:  284:            }
        -:  285:            else
        -:  286:            {
        1:  287:                b->size = size;
        1:  288:                result = 0;
        -:  289:            }
        -:  290:        }
        -:  291:    }
        1:  292:    return result;
        -:  293:}
        -:  294:
        -:  295:/* Codes_SRS_BUFFER_07_019: [BUFFER_content shall return the data contained within the BUFFER_HANDLE.] */
        2:  296:int BUFFER_content(BUFFER_HANDLE handle, const unsigned char** content)
        -:  297:{
        -:  298:    int result;
        2:  299:    if ((handle == NULL) || (content == NULL))
        -:  300:    {
        -:  301:        /* Codes_SRS_BUFFER_07_020: [If the handle and/or content*is NULL BUFFER_content shall return nonzero.] */
    #####:  302:        result = MU_FAILURE;
        -:  303:    }
        -:  304:    else
        -:  305:    {
        2:  306:        BUFFER* b = (BUFFER*)handle;
        2:  307:        *content = b->buffer;
        2:  308:        result = 0;
        -:  309:    }
        2:  310:    return result;
        -:  311:}
        -:  312:
        -:  313:/*return 0 if everything went ok and whatever was built in the buffer was unbuilt*/
        -:  314:/* Codes_SRS_BUFFER_07_012: [BUFFER_unbuild shall clear the underlying unsigned char* data associated with the BUFFER_HANDLE this will return zero on success.] */
    #####:  315:extern int BUFFER_unbuild(BUFFER_HANDLE handle)
        -:  316:{
        -:  317:    int result;
    #####:  318:    if (handle == NULL)
        -:  319:    {
        -:  320:        /* Codes_SRS_BUFFER_07_014: [BUFFER_unbuild shall return a nonzero value if BUFFER_HANDLE is NULL.] */
    #####:  321:        result = MU_FAILURE;
        -:  322:    }
        -:  323:    else
        -:  324:    {
    #####:  325:        BUFFER* b = (BUFFER*)handle;
    #####:  326:        if (b->buffer != NULL)
        -:  327:        {
    #####:  328:            LogError("Failure buffer data is NULL");
    #####:  329:            free(b->buffer);
    #####:  330:            b->buffer = NULL;
    #####:  331:            b->size = 0;
    #####:  332:            result = 0;
        -:  333:        }
        -:  334:        else
        -:  335:        {
        -:  336:            /* Codes_SRS_BUFFER_07_015: [BUFFER_unbuild shall return a nonzero value if the unsigned char* referenced by BUFFER_HANDLE is NULL.] */
    #####:  337:            result = MU_FAILURE;
        -:  338:        }
        -:  339:    }
    #####:  340:    return result;
        -:  341:}
        -:  342:
        -:  343:/* Codes_SRS_BUFFER_07_016: [BUFFER_enlarge shall increase the size of the unsigned char* referenced by BUFFER_HANDLE.] */
        1:  344:int BUFFER_enlarge(BUFFER_HANDLE handle, size_t enlargeSize)
        -:  345:{
        -:  346:    int result;
        1:  347:    if (handle == NULL)
        -:  348:    {
        -:  349:        /* Codes_SRS_BUFFER_07_017: [BUFFER_enlarge shall return a nonzero result if any parameters are NULL or zero.] */
    #####:  350:        LogError("Failure: handle is invalid.");
    #####:  351:        result = MU_FAILURE;
        -:  352:    }
        1:  353:    else if (enlargeSize == 0)
        -:  354:    {
        -:  355:        /* Codes_SRS_BUFFER_07_017: [BUFFER_enlarge shall return a nonzero result if any parameters are NULL or zero.] */
    #####:  356:        LogError("Failure: enlargeSize size is 0.");
    #####:  357:        result = MU_FAILURE;
        -:  358:    }
        -:  359:    else
        -:  360:    {
        1:  361:        BUFFER* b = (BUFFER*)handle;
        1:  362:        unsigned char* temp = (unsigned char*)realloc(b->buffer, b->size + enlargeSize);
        1:  363:        if (temp == NULL)
        -:  364:        {
        -:  365:            /* Codes_SRS_BUFFER_07_018: [BUFFER_enlarge shall return a nonzero result if any error is encountered.] */
    #####:  366:            LogError("Failure: allocating temp buffer.");
    #####:  367:            result = MU_FAILURE;
        -:  368:        }
        -:  369:        else
        -:  370:        {
        1:  371:            b->buffer = temp;
        1:  372:            b->size += enlargeSize;
        1:  373:            result = 0;
        -:  374:        }
        -:  375:    }
        1:  376:    return result;
        -:  377:}
        -:  378:
    #####:  379:int BUFFER_shrink(BUFFER_HANDLE handle, size_t decreaseSize, bool fromEnd)
        -:  380:{
        -:  381:    int result;
    #####:  382:    if (handle == NULL)
        -:  383:    {
        -:  384:        /* Codes_SRS_BUFFER_07_036: [ if handle is NULL, BUFFER_shrink shall return a non-null value ]*/
    #####:  385:        LogError("Failure: handle is invalid.");
    #####:  386:        result = MU_FAILURE;
        -:  387:    }
    #####:  388:    else if (decreaseSize == 0)
        -:  389:    {
        -:  390:        /* Codes_SRS_BUFFER_07_037: [ If decreaseSize is equal zero, BUFFER_shrink shall return a non-null value ] */
    #####:  391:        LogError("Failure: decrease size is 0.");
    #####:  392:        result = MU_FAILURE;
        -:  393:    }
    #####:  394:    else if (decreaseSize > handle->size)
        -:  395:    {
        -:  396:        /* Codes_SRS_BUFFER_07_038: [ If decreaseSize is less than the size of the buffer, BUFFER_shrink shall return a non-null value ] */
    #####:  397:        LogError("Failure: decrease size is less than buffer size.");
    #####:  398:        result = MU_FAILURE;
        -:  399:    }
        -:  400:    else
        -:  401:    {
        -:  402:        /* Codes_SRS_BUFFER_07_039: [ BUFFER_shrink shall allocate a temporary buffer of existing buffer size minus decreaseSize. ] */
    #####:  403:        size_t alloc_size = handle->size - decreaseSize;
    #####:  404:        if (alloc_size == 0)
        -:  405:        {
        -:  406:            /* Codes_SRS_BUFFER_07_043: [ If the decreaseSize is equal the buffer size , BUFFER_shrink shall deallocate the buffer and set the size to zero. ] */
    #####:  407:            free(handle->buffer);
    #####:  408:            handle->buffer = NULL;
    #####:  409:            handle->size = 0;
    #####:  410:            result = 0;
        -:  411:        }
        -:  412:        else
        -:  413:        {
    #####:  414:            unsigned char* tmp = malloc(alloc_size);
    #####:  415:            if (tmp == NULL)
        -:  416:            {
        -:  417:                /* Codes_SRS_BUFFER_07_042: [ If a failure is encountered, BUFFER_shrink shall return a non-null value ] */
    #####:  418:                LogError("Failure: allocating temp buffer.");
    #####:  419:                result = MU_FAILURE;
        -:  420:            }
        -:  421:            else
        -:  422:            {
    #####:  423:                if (fromEnd)
        -:  424:                {
        -:  425:                    /* Codes_SRS_BUFFER_07_040: [ if the fromEnd variable is true, BUFFER_shrink shall remove the end of the buffer of size decreaseSize. ] */
    #####:  426:                    memcpy(tmp, handle->buffer, alloc_size);
    #####:  427:                    free(handle->buffer);
    #####:  428:                    handle->buffer = tmp;
    #####:  429:                    handle->size = alloc_size;
    #####:  430:                    result = 0;
        -:  431:                }
        -:  432:                else
        -:  433:                {
        -:  434:                    /* Codes_SRS_BUFFER_07_041: [ if the fromEnd variable is false, BUFFER_shrink shall remove the beginning of the buffer of size decreaseSize. ] */
    #####:  435:                    memcpy(tmp, handle->buffer + decreaseSize, alloc_size);
    #####:  436:                    free(handle->buffer);
    #####:  437:                    handle->buffer = tmp;
    #####:  438:                    handle->size = alloc_size;
    #####:  439:                    result = 0;
        -:  440:                }
        -:  441:            }
        -:  442:        }
        -:  443:    }
    #####:  444:    return result;
        -:  445:}
        -:  446:
        -:  447:/* Codes_SRS_BUFFER_07_021: [BUFFER_size shall place the size of the associated buffer in the size variable and return zero on success.] */
        2:  448:int BUFFER_size(BUFFER_HANDLE handle, size_t* size)
        -:  449:{
        -:  450:    int result;
        2:  451:    if ((handle == NULL) || (size == NULL))
        -:  452:    {
        -:  453:        /* Codes_SRS_BUFFER_07_022: [BUFFER_size shall return a nonzero value for any error that is encountered.] */
    #####:  454:        result = MU_FAILURE;
        -:  455:    }
        -:  456:    else
        -:  457:    {
        2:  458:        BUFFER* b = (BUFFER*)handle;
        2:  459:        *size = b->size;
        2:  460:        result = 0;
        -:  461:    }
        2:  462:    return result;
        -:  463:}
        -:  464:
        -:  465:/* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.] */
    #####:  466:int BUFFER_append(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
        -:  467:{
        -:  468:    int result;
    #####:  469:    if ( (handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2) )
        -:  470:    {
        -:  471:        /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */
    #####:  472:        result = MU_FAILURE;
        -:  473:    }
        -:  474:    else
        -:  475:    {
    #####:  476:        BUFFER* b1 = (BUFFER*)handle1;
    #####:  477:        BUFFER* b2 = (BUFFER*)handle2;
    #####:  478:        if (b1->buffer == NULL)
        -:  479:        {
        -:  480:            /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */
    #####:  481:            result = MU_FAILURE;
        -:  482:        }
    #####:  483:        else if (b2->buffer == NULL)
        -:  484:        {
        -:  485:            /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */
    #####:  486:            result = MU_FAILURE;
        -:  487:        }
        -:  488:        else
        -:  489:        {
    #####:  490:            if (b2->size ==0)
        -:  491:            {
        -:  492:                // b2->size = 0, whatever b1->size is, do nothing
    #####:  493:                result = 0;
        -:  494:            }
        -:  495:            else
        -:  496:            {
        -:  497:                // b2->size != 0, whatever b1->size is
    #####:  498:                unsigned char* temp = (unsigned char*)realloc(b1->buffer, b1->size + b2->size);
    #####:  499:                if (temp == NULL)
        -:  500:                {
        -:  501:                    /* Codes_SRS_BUFFER_07_023: [BUFFER_append shall return a nonzero upon any error that is encountered.] */
    #####:  502:                    LogError("Failure: allocating temp buffer.");
    #####:  503:                    result = MU_FAILURE;
        -:  504:                }
        -:  505:                else
        -:  506:                {
        -:  507:                    /* Codes_SRS_BUFFER_07_024: [BUFFER_append concatenates b2 onto b1 without modifying b2 and shall return zero on success.]*/
    #####:  508:                    b1->buffer = temp;
        -:  509:                    // Append the BUFFER
    #####:  510:                    (void)memcpy(&b1->buffer[b1->size], b2->buffer, b2->size);
    #####:  511:                    b1->size += b2->size;
    #####:  512:                    result = 0;
        -:  513:                }
        -:  514:            }
        -:  515:        }
        -:  516:    }
    #####:  517:    return result;
        -:  518:}
        -:  519:
    #####:  520:int BUFFER_prepend(BUFFER_HANDLE handle1, BUFFER_HANDLE handle2)
        -:  521:{
        -:  522:    int result;
    #####:  523:    if ((handle1 == NULL) || (handle2 == NULL) || (handle1 == handle2))
        -:  524:    {
        -:  525:        /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
    #####:  526:        result = MU_FAILURE;
        -:  527:    }
        -:  528:    else
        -:  529:    {
    #####:  530:        BUFFER* b1 = (BUFFER*)handle1;
    #####:  531:        BUFFER* b2 = (BUFFER*)handle2;
    #####:  532:        if (b1->buffer == NULL)
        -:  533:        {
        -:  534:            /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
    #####:  535:            result = MU_FAILURE;
        -:  536:        }
    #####:  537:        else if (b2->buffer == NULL)
        -:  538:        {
        -:  539:            /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
    #####:  540:            result = MU_FAILURE;
        -:  541:        }
        -:  542:        else
        -:  543:        {
        -:  544:            //put b2 ahead of b1: [b2][b1], return b1
    #####:  545:            if (b2->size ==0)
        -:  546:            {
        -:  547:                // do nothing
    #####:  548:                result = 0;
        -:  549:            }
        -:  550:            else
        -:  551:            {
        -:  552:                // b2->size != 0
    #####:  553:                unsigned char* temp = (unsigned char*)malloc(b1->size + b2->size);
    #####:  554:                if (temp == NULL)
        -:  555:                {
        -:  556:                    /* Codes_SRS_BUFFER_01_005: [ BUFFER_prepend shall return a non-zero upon value any error that is encountered. ]*/
    #####:  557:                    LogError("Failure: allocating temp buffer.");
    #####:  558:                    result = MU_FAILURE;
        -:  559:                }
        -:  560:                else
        -:  561:                {
        -:  562:                    /* Codes_SRS_BUFFER_01_004: [ BUFFER_prepend concatenates handle1 onto handle2 without modifying handle1 and shall return zero on success. ]*/
        -:  563:                    // Append the BUFFER
    #####:  564:                    (void)memcpy(temp, b2->buffer, b2->size);
        -:  565:                    // start from b1->size to append b1
    #####:  566:                    (void)memcpy(&temp[b2->size], b1->buffer, b1->size);
    #####:  567:                    free(b1->buffer);
    #####:  568:                    b1->buffer = temp;
    #####:  569:                    b1->size += b2->size;
    #####:  570:                    result = 0;
        -:  571:                }
        -:  572:            }
        -:  573:        }
        -:  574:    }
    #####:  575:    return result;
        -:  576:}
        -:  577:
    #####:  578:int BUFFER_fill(BUFFER_HANDLE handle, unsigned char fill_char)
        -:  579:{
        -:  580:    int result;
    #####:  581:    if (handle == NULL)
        -:  582:    {
        -:  583:        /* Codes_SRS_BUFFER_07_002: [ If handle is NULL BUFFER_fill shall return a non-zero value. ] */
    #####:  584:        LogError("Invalid parameter specified, handle == NULL.");
    #####:  585:        result = MU_FAILURE;
        -:  586:    }
        -:  587:    else
        -:  588:    {
        -:  589:        size_t index;
        -:  590:        /* Codes_SRS_BUFFER_07_001: [ BUFFER_fill shall fill the supplied BUFFER_HANDLE with the supplied fill character. ] */
    #####:  591:        BUFFER* buffer_data = (BUFFER*)handle;
    #####:  592:        for (index = 0; index < buffer_data->size; index++)
        -:  593:        {
    #####:  594:            buffer_data->buffer[index] = fill_char;
        -:  595:        }
    #####:  596:        result = 0;
        -:  597:    }
    #####:  598:    return result;
        -:  599:}
        -:  600:
        -:  601:
        -:  602:/* Codes_SRS_BUFFER_07_025: [BUFFER_u_char shall return a pointer to the underlying unsigned char*.] */
        3:  603:unsigned char* BUFFER_u_char(BUFFER_HANDLE handle)
        -:  604:{
        3:  605:    BUFFER* handleData = (BUFFER*)handle;
        -:  606:    unsigned char* result;
        3:  607:    if (handle == NULL || handleData->size == 0)
        -:  608:    {
        -:  609:        /* Codes_SRS_BUFFER_07_026: [BUFFER_u_char shall return NULL for any error that is encountered.] */
        -:  610:        /* Codes_SRS_BUFFER_07_029: [BUFFER_u_char shall return NULL if underlying buffer size is zero.] */
    #####:  611:        result = NULL;
        -:  612:    }
        -:  613:    else
        -:  614:    {
        3:  615:        result = handleData->buffer;
        -:  616:    }
        3:  617:    return result;
        -:  618:}
        -:  619:
        -:  620:/* Codes_SRS_BUFFER_07_027: [BUFFER_length shall return the size of the underlying buffer.] */
        1:  621:size_t BUFFER_length(BUFFER_HANDLE handle)
        -:  622:{
        -:  623:    size_t result;
        1:  624:    if (handle == NULL)
        -:  625:    {
        -:  626:        /* Codes_SRS_BUFFER_07_028: [BUFFER_length shall return zero for any error that is encountered.] */
    #####:  627:        result = 0;
        -:  628:    }
        -:  629:    else
        -:  630:    {
        1:  631:        BUFFER* b = (BUFFER*)handle;
        1:  632:        result = b->size;
        -:  633:    }
        1:  634:    return result;
        -:  635:}
        -:  636:
    #####:  637:BUFFER_HANDLE BUFFER_clone(BUFFER_HANDLE handle)
        -:  638:{
        -:  639:    BUFFER_HANDLE result;
    #####:  640:    if (handle == NULL)
        -:  641:    {
    #####:  642:        result = NULL;
        -:  643:    }
        -:  644:    else
        -:  645:    {
    #####:  646:        BUFFER* suppliedBuff = (BUFFER*)handle;
    #####:  647:        BUFFER* b = (BUFFER*)malloc(sizeof(BUFFER));
    #####:  648:        if (b != NULL)
        -:  649:        {
    #####:  650:            if (BUFFER_safemalloc(b, suppliedBuff->size) != 0)
        -:  651:            {
    #####:  652:                free(b);
    #####:  653:                LogError("Failure: allocating temp buffer.");
    #####:  654:                result = NULL;
        -:  655:            }
        -:  656:            else
        -:  657:            {
    #####:  658:                (void)memcpy(b->buffer, suppliedBuff->buffer, suppliedBuff->size);
    #####:  659:                b->size = suppliedBuff->size;
    #####:  660:                result = (BUFFER_HANDLE)b;
        -:  661:            }
        -:  662:        }
        -:  663:        else
        -:  664:        {
    #####:  665:            result = NULL;
        -:  666:        }
        -:  667:    }
    #####:  668:    return result;
        -:  669:}
