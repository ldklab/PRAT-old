        -:    0:Source:/home/ryan/TARGETS/azure-uamqp-c/deps/azure-c-shared-utility/src/consolelogger.c
        -:    0:Programs:80
        -:    1:// Copyright (c) Microsoft. All rights reserved.
        -:    2:// Licensed under the MIT license. See LICENSE file in the project root for full license information.
        -:    3:
        -:    4:#include <stdarg.h>
        -:    5:#include <stdio.h>
        -:    6:#include <time.h>
        -:    7:#include "azure_c_shared_utility/xlogging.h"
        -:    8:#include "azure_c_shared_utility/consolelogger.h"
        -:    9:
        -:   10:#if (defined(_MSC_VER))
        -:   11:#include "windows.h"
        -:   12:
        -:   13:/*returns a string as if printed by vprintf*/
        -:   14:static char* vprintf_alloc(const char* format, va_list va)
        -:   15:{
        -:   16:    char* result;
        -:   17:    int neededSize = vsnprintf(NULL, 0, format, va);
        -:   18:    if (neededSize < 0)
        -:   19:    {
        -:   20:        result = NULL;
        -:   21:    }
        -:   22:    else
        -:   23:    {
        -:   24:        result = (char*)malloc(neededSize + 1);
        -:   25:        if (result == NULL)
        -:   26:        {
        -:   27:            /*return as is*/
        -:   28:        }
        -:   29:        else
        -:   30:        {
        -:   31:            if (vsnprintf(result, neededSize + 1, format, va) != neededSize)
        -:   32:            {
        -:   33:                free(result);
        -:   34:                result = NULL;
        -:   35:            }
        -:   36:        }
        -:   37:    }
        -:   38:    return result;
        -:   39:}
        -:   40:
        -:   41:/*returns a string as if printed by printf*/
        -:   42:static char* printf_alloc(const char* format, ...)
        -:   43:{
        -:   44:    char* result;
        -:   45:    va_list va;
        -:   46:    va_start(va, format);
        -:   47:    result = vprintf_alloc(format, va);
        -:   48:    va_end(va);
        -:   49:    return result;
        -:   50:}
        -:   51:
        -:   52:/*returns NULL if it fails*/
        -:   53:static char* lastErrorToString(DWORD lastError)
        -:   54:{
        -:   55:    char* result;
        -:   56:    if (lastError == 0)
        -:   57:    {
        -:   58:        result = printf_alloc(""); /*no error should appear*/
        -:   59:        if (result == NULL)
        -:   60:        {
        -:   61:            (void)printf("failure in printf_alloc");
        -:   62:        }
        -:   63:        else
        -:   64:        {
        -:   65:            /*return as is*/
        -:   66:        }
        -:   67:    }
        -:   68:    else
        -:   69:    {
        -:   70:        char temp[MESSAGE_BUFFER_SIZE];
        -:   71:        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, NULL, lastError, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), temp, MESSAGE_BUFFER_SIZE, NULL) == 0)
        -:   72:        {
        -:   73:            result = printf_alloc("GetLastError()=0X%x", lastError);
        -:   74:            if (result == NULL)
        -:   75:            {
        -:   76:                (void)printf("failure in printf_alloc\n");
        -:   77:                /*return as is*/
        -:   78:            }
        -:   79:            else
        -:   80:            {
        -:   81:                /*return as is*/
        -:   82:            }
        -:   83:        }
        -:   84:        else
        -:   85:        {
        -:   86:            /*eliminate the \r or \n from the string*/
        -:   87:            /*one replace of each is enough*/
        -:   88:            char* whereAreThey;
        -:   89:            if ((whereAreThey = strchr(temp, '\r')) != NULL)
        -:   90:            {
        -:   91:                *whereAreThey = '\0';
        -:   92:            }
        -:   93:            if ((whereAreThey = strchr(temp, '\n')) != NULL)
        -:   94:            {
        -:   95:                *whereAreThey = '\0';
        -:   96:            }
        -:   97:
        -:   98:            result = printf_alloc("GetLastError()==0X%x (%s)", lastError, temp);
        -:   99:
        -:  100:            if (result == NULL)
        -:  101:            {
        -:  102:                (void)printf("failure in printf_alloc\n");
        -:  103:                /*return as is*/
        -:  104:            }
        -:  105:            else
        -:  106:            {
        -:  107:                /*return as is*/
        -:  108:            }
        -:  109:        }
        -:  110:    }
        -:  111:    return result;
        -:  112:}
        -:  113:/*this function will use 1x printf (in the happy case) .*/
        -:  114:/*more than 1x printf / function call can mean intermingled LogErrors in a multithreaded env*/
        -:  115:/*the function will also attempt to produce some human readable strings for GetLastError*/
        -:  116:void consolelogger_log_with_GetLastError(const char* file, const char* func, int line, const char* format, ...)
        -:  117:{
        -:  118:    DWORD lastError;
        -:  119:    char* lastErrorAsString;
        -:  120:    int lastErrorAsString_should_be_freed;
        -:  121:    time_t t;
        -:  122:    int systemMessage_should_be_freed;
        -:  123:    char* systemMessage;
        -:  124:    int userMessage_should_be_freed;
        -:  125:    char* userMessage;
        -:  126:
        -:  127:    va_list args;
        -:  128:    va_start(args, format);
        -:  129:
        -:  130:    /*this is what this case will do:
        -:  131:    1. snip the last error
        -:  132:    2. create a string with what that last error means
        -:  133:    3. printf the system message (__FILE__, __LINE__ etc) + the last error + whatever the user wanted
        -:  134:    */
        -:  135:    /*1. snip the last error*/
        -:  136:    lastError = GetLastError();
        -:  137:
        -:  138:    /*2. create a string with what that last error means*/
        -:  139:    lastErrorAsString = lastErrorToString(lastError);
        -:  140:    if (lastErrorAsString == NULL)
        -:  141:    {
        -:  142:        (void)printf("failure in lastErrorToString");
        -:  143:        lastErrorAsString = "";
        -:  144:        lastErrorAsString_should_be_freed = 0;
        -:  145:    }
        -:  146:    else
        -:  147:    {
        -:  148:        lastErrorAsString_should_be_freed = 1;
        -:  149:    }
        -:  150:
        -:  151:    t = time(NULL);
        -:  152:    systemMessage = printf_alloc("Error: Time:%.24s File:%s Func:%s Line:%d %s", ctime(&t), file, func, line, lastErrorAsString);
        -:  153:
        -:  154:    if (systemMessage == NULL)
        -:  155:    {
        -:  156:        systemMessage = "";
        -:  157:        (void)printf("Error: [FAILED] Time:%.24s File : %s Func : %s Line : %d %s", ctime(&t), file, func, line, lastErrorAsString);
        -:  158:        systemMessage_should_be_freed = 0;
        -:  159:    }
        -:  160:    else
        -:  161:    {
        -:  162:        systemMessage_should_be_freed = 1;
        -:  163:    }
        -:  164:
        -:  165:    userMessage = vprintf_alloc(format, args);
        -:  166:    if (userMessage == NULL)
        -:  167:    {
        -:  168:        (void)printf("[FAILED] ");
        -:  169:        (void)vprintf(format, args);
        -:  170:        (void)printf("\n");
        -:  171:        userMessage_should_be_freed = 0;
        -:  172:    }
        -:  173:    else
        -:  174:    {
        -:  175:        /*3. printf the system message(__FILE__, __LINE__ etc) + the last error + whatever the user wanted*/
        -:  176:        (void)printf("%s %s\n", systemMessage, userMessage);
        -:  177:        userMessage_should_be_freed = 1;
        -:  178:    }
        -:  179:
        -:  180:    if (userMessage_should_be_freed == 1)
        -:  181:    {
        -:  182:        free(userMessage);
        -:  183:    }
        -:  184:
        -:  185:    if (systemMessage_should_be_freed == 1)
        -:  186:    {
        -:  187:        free(systemMessage);
        -:  188:    }
        -:  189:
        -:  190:    if (lastErrorAsString_should_be_freed == 1)
        -:  191:    {
        -:  192:        free(lastErrorAsString);
        -:  193:    }
        -:  194:    va_end(args);
        -:  195:}
        -:  196:#endif
        -:  197:
        -:  198:#if defined(__GNUC__)
        -:  199:__attribute__ ((format (printf, 6, 7)))
        -:  200:#endif
       79:  201:void consolelogger_log(LOG_CATEGORY log_category, const char* file, const char* func, int line, unsigned int options, const char* format, ...)
        -:  202:{
        -:  203:    time_t t;
        -:  204:    va_list args;
       79:  205:    va_start(args, format);
        -:  206:
       79:  207:    t = time(NULL);
        -:  208:
       79:  209:    switch (log_category)
        -:  210:    {
        4:  211:    case AZ_LOG_INFO:
        4:  212:        (void)printf("Info: ");
        4:  213:        break;
       75:  214:    case AZ_LOG_ERROR:
       75:  215:        (void)printf("Error: Time:%.24s File:%s Func:%s Line:%d ", ctime(&t), file, func, line);
       75:  216:        break;
    #####:  217:    default:
    #####:  218:        break;
        -:  219:    }
        -:  220:
       79:  221:    (void)vprintf(format, args);
       79:  222:    va_end(args);
        -:  223:
        -:  224:    (void)log_category;
       79:  225:    if (options & LOG_LINE)
        -:  226:    {
       79:  227:        (void)printf("\r\n");
        -:  228:    }
       79:  229:}
        -:  230:
