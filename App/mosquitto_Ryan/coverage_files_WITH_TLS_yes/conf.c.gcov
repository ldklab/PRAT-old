        -:    0:Source:conf.c
        -:    0:Graph:conf.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2:Copyright (c) 2009-2020 Roger Light <roger@atchoo.org>
        -:    3:
        -:    4:All rights reserved. This program and the accompanying materials
        -:    5:are made available under the terms of the Eclipse Public License v1.0
        -:    6:and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7:
        -:    8:The Eclipse Public License is available at
        -:    9:   http://www.eclipse.org/legal/epl-v10.html
        -:   10:and the Eclipse Distribution License is available at
        -:   11:  http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12:
        -:   13:Contributors:
        -:   14:   Roger Light - initial implementation and documentation.
        -:   15:*/
        -:   16:
        -:   17:#include "config.h"
        -:   18:
        -:   19:#include <limits.h>
        -:   20:#include <stdio.h>
        -:   21:#include <stdlib.h>
        -:   22:#include <string.h>
        -:   23:#include <errno.h>
        -:   24:
        -:   25:#ifdef WIN32
        -:   26:#else
        -:   27:#  include <dirent.h>
        -:   28:#  include <strings.h>
        -:   29:#endif
        -:   30:
        -:   31:#ifndef WIN32
        -:   32:#  include <netdb.h>
        -:   33:#  include <sys/socket.h>
        -:   34:#else
        -:   35:#  include <winsock2.h>
        -:   36:#  include <ws2tcpip.h>
        -:   37:#endif
        -:   38:
        -:   39:#if !defined(WIN32) && !defined(__CYGWIN__)
        -:   40:#  include <syslog.h>
        -:   41:#endif
        -:   42:
        -:   43:#include "mosquitto_broker_internal.h"
        -:   44:#include "memory_mosq.h"
        -:   45:#include "misc_mosq.h"
        -:   46:#include "tls_mosq.h"
        -:   47:#include "util_mosq.h"
        -:   48:#include "mqtt_protocol.h"
        -:   49:
        -:   50:struct config_recurse {
        -:   51:	int log_dest;
        -:   52:	int log_dest_set;
        -:   53:	int log_type;
        -:   54:	int log_type_set;
        -:   55:	unsigned long max_inflight_bytes;
        -:   56:	unsigned long max_queued_bytes;
        -:   57:	int max_queued_messages;
        -:   58:};
        -:   59:
        -:   60:#if defined(WIN32) || defined(__CYGWIN__)
        -:   61:#include <windows.h>
        -:   62:extern SERVICE_STATUS_HANDLE service_handle;
        -:   63:#endif
        -:   64:
        -:   65:static struct mosquitto__security_options *cur_security_options = NULL;
        -:   66:
        -:   67:static int conf__parse_bool(char **token, const char *name, bool *value, char *saveptr);
        -:   68:static int conf__parse_int(char **token, const char *name, int *value, char *saveptr);
        -:   69:static int conf__parse_ssize_t(char **token, const char *name, ssize_t *value, char *saveptr);
        -:   70:static int conf__parse_string(char **token, const char *name, char **value, char *saveptr);
        -:   71:static int config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *config_tmp, int level, int *lineno);
        -:   72:static int config__check(struct mosquitto__config *config);
        -:   73:static void config__cleanup_plugins(struct mosquitto__config *config);
        -:   74:
    #####:   75:static void conf__set_cur_security_options(struct mosquitto__config *config, struct mosquitto__listener *cur_listener, struct mosquitto__security_options **security_options)
        -:   76:{
    #####:   77:	if(config->per_listener_settings){
    #####:   78:		(*security_options) = &cur_listener->security_options;
    #####:   79:	}else{
    #####:   80:		(*security_options) = &config->security_options;
        -:   81:	}
    #####:   82:}
        -:   83:
    #####:   84:static int conf__attempt_resolve(const char *host, const char *text, int log, const char *msg)
        -:   85:{
        -:   86:	struct addrinfo gai_hints;
        -:   87:	struct addrinfo *gai_res;
        -:   88:	int rc;
        -:   89:
    #####:   90:	memset(&gai_hints, 0, sizeof(struct addrinfo));
    #####:   91:	gai_hints.ai_family = AF_UNSPEC;
    #####:   92:	gai_hints.ai_socktype = SOCK_STREAM;
    #####:   93:	gai_res = NULL;
    #####:   94:	rc = getaddrinfo(host, NULL, &gai_hints, &gai_res);
    #####:   95:	if(gai_res){
    #####:   96:		freeaddrinfo(gai_res);
    #####:   97:	}
    #####:   98:	if(rc != 0){
        -:   99:#ifndef WIN32
    #####:  100:		if(rc == EAI_SYSTEM){
    #####:  101:			if(errno == ENOENT){
    #####:  102:				log__printf(NULL, log, "%s: Unable to resolve %s %s.", msg, text, host);
    #####:  103:			}else{
    #####:  104:				log__printf(NULL, log, "%s: Error resolving %s: %s.", msg, text, strerror(errno));
        -:  105:			}
    #####:  106:		}else{
    #####:  107:			log__printf(NULL, log, "%s: Error resolving %s: %s.", msg, text, gai_strerror(rc));
        -:  108:		}
        -:  109:#else
        -:  110:		if(rc == WSAHOST_NOT_FOUND){
        -:  111:			log__printf(NULL, log, "%s: Error resolving %s.", msg, text);
        -:  112:		}
        -:  113:#endif
    #####:  114:		return MOSQ_ERR_INVAL;
        -:  115:	}
    #####:  116:	return MOSQ_ERR_SUCCESS;
    #####:  117:}
        -:  118:
        -:  119:
    #####:  120:static void config__init_reload(struct mosquitto_db *db, struct mosquitto__config *config)
        -:  121:{
        -:  122:	int i;
        -:  123:	/* Set defaults */
    #####:  124:	for(i=0; i<config->listener_count; i++){
    #####:  125:		mosquitto__free(config->listeners[i].security_options.acl_file);
    #####:  126:		config->listeners[i].security_options.acl_file = NULL;
        -:  127:
    #####:  128:		mosquitto__free(config->listeners[i].security_options.password_file);
    #####:  129:		config->listeners[i].security_options.password_file = NULL;
        -:  130:
    #####:  131:		mosquitto__free(config->listeners[i].security_options.psk_file);
    #####:  132:		config->listeners[i].security_options.psk_file = NULL;
        -:  133:
    #####:  134:		config->listeners[i].security_options.allow_anonymous = -1;
    #####:  135:		config->listeners[i].security_options.allow_zero_length_clientid = true;
    #####:  136:		config->listeners[i].security_options.auto_id_prefix = NULL;
    #####:  137:		config->listeners[i].security_options.auto_id_prefix_len = 0;
    #####:  138:	}
        -:  139:
    #####:  140:	config->allow_duplicate_messages = false;
        -:  141:
    #####:  142:	mosquitto__free(config->security_options.acl_file);
    #####:  143:	config->security_options.acl_file = NULL;
        -:  144:
    #####:  145:	config->security_options.allow_anonymous = -1;
    #####:  146:	config->security_options.allow_zero_length_clientid = true;
    #####:  147:	config->security_options.auto_id_prefix = NULL;
    #####:  148:	config->security_options.auto_id_prefix_len = 0;
        -:  149:
    #####:  150:	mosquitto__free(config->security_options.password_file);
    #####:  151:	config->security_options.password_file = NULL;
        -:  152:
    #####:  153:	mosquitto__free(config->security_options.psk_file);
    #####:  154:	config->security_options.psk_file = NULL;
        -:  155:
    #####:  156:	config->autosave_interval = 1800;
    #####:  157:	config->autosave_on_changes = false;
    #####:  158:	mosquitto__free(config->clientid_prefixes);
    #####:  159:	config->connection_messages = true;
    #####:  160:	config->clientid_prefixes = NULL;
    #####:  161:	config->per_listener_settings = false;
    #####:  162:	if(config->log_fptr){
    #####:  163:		fclose(config->log_fptr);
    #####:  164:		config->log_fptr = NULL;
    #####:  165:	}
    #####:  166:	mosquitto__free(config->log_file);
    #####:  167:	config->log_file = NULL;
        -:  168:
        -:  169:#if defined(WIN32) || defined(__CYGWIN__)
        -:  170:	if(service_handle){
        -:  171:		/* This is running as a Windows service. Default to no logging. Using
        -:  172:		 * stdout/stderr is forbidden because the first clients to connect will
        -:  173:		 * get log information sent to them for some reason. */
        -:  174:		config->log_dest = MQTT3_LOG_NONE;
        -:  175:	}else{
        -:  176:		config->log_dest = MQTT3_LOG_STDERR;
        -:  177:	}
        -:  178:#else
    #####:  179:	config->log_facility = LOG_DAEMON;
    #####:  180:	config->log_dest = MQTT3_LOG_STDERR;
    #####:  181:	if(db->verbose){
    #####:  182:		config->log_type = UINT_MAX;
    #####:  183:	}else{
    #####:  184:		config->log_type = MOSQ_LOG_ERR | MOSQ_LOG_WARNING | MOSQ_LOG_NOTICE | MOSQ_LOG_INFO;
        -:  185:	}
        -:  186:#endif
    #####:  187:	config->log_timestamp = true;
    #####:  188:	mosquitto__free(config->log_timestamp_format);
    #####:  189:	config->log_timestamp_format = NULL;
    #####:  190:	config->max_keepalive = 65535;
    #####:  191:	config->max_packet_size = 0;
    #####:  192:	config->max_inflight_messages = 20;
    #####:  193:	config->persistence = false;
    #####:  194:	mosquitto__free(config->persistence_location);
    #####:  195:	config->persistence_location = NULL;
    #####:  196:	mosquitto__free(config->persistence_file);
    #####:  197:	config->persistence_file = NULL;
    #####:  198:	config->persistent_client_expiration = 0;
    #####:  199:	config->queue_qos0_messages = false;
    #####:  200:	config->retain_available = true;
    #####:  201:	config->set_tcp_nodelay = false;
    #####:  202:	config->sys_interval = 10;
    #####:  203:	config->upgrade_outgoing_qos = false;
        -:  204:
    #####:  205:	config__cleanup_plugins(config);
    #####:  206:}
        -:  207:
        -:  208:
    #####:  209:static void config__cleanup_plugins(struct mosquitto__config *config)
        -:  210:{
        -:  211:	int i, j;
        -:  212:	struct mosquitto__auth_plugin_config *plug;
        -:  213:
    #####:  214:	if(config->security_options.auth_plugin_configs){
    #####:  215:		for(i=0; i<config->security_options.auth_plugin_config_count; i++){
    #####:  216:			plug = &config->security_options.auth_plugin_configs[i];
    #####:  217:			mosquitto__free(plug->path);
    #####:  218:			plug->path = NULL;
        -:  219:
    #####:  220:			if(plug->options){
    #####:  221:				for(j=0; j<plug->option_count; j++){
    #####:  222:					mosquitto__free(plug->options[j].key);
    #####:  223:					mosquitto__free(plug->options[j].value);
    #####:  224:				}
    #####:  225:				mosquitto__free(plug->options);
    #####:  226:				plug->options = NULL;
    #####:  227:				plug->option_count = 0;
    #####:  228:			}
    #####:  229:		}
    #####:  230:		mosquitto__free(config->security_options.auth_plugin_configs);
    #####:  231:		config->security_options.auth_plugin_configs = NULL;
    #####:  232:	}
    #####:  233:}
        -:  234:
        -:  235:
    #####:  236:void config__init(struct mosquitto_db *db, struct mosquitto__config *config)
        -:  237:{
    #####:  238:	memset(config, 0, sizeof(struct mosquitto__config));
    #####:  239:	config__init_reload(db, config);
        -:  240:
    #####:  241:	config->daemon = false;
    #####:  242:	memset(&config->default_listener, 0, sizeof(struct mosquitto__listener));
    #####:  243:	config->default_listener.max_connections = -1;
    #####:  244:	config->default_listener.protocol = mp_mqtt;
    #####:  245:	config->default_listener.security_options.allow_anonymous = -1;
    #####:  246:	config->default_listener.security_options.allow_zero_length_clientid = true;
    #####:  247:	config->default_listener.maximum_qos = 2;
    #####:  248:	config->default_listener.max_topic_alias = 10;
    #####:  249:}
        -:  250:
    #####:  251:void config__cleanup(struct mosquitto__config *config)
        -:  252:{
        -:  253:	int i;
        -:  254:#ifdef WITH_BRIDGE
        -:  255:	int j;
        -:  256:#endif
        -:  257:
    #####:  258:	mosquitto__free(config->clientid_prefixes);
    #####:  259:	mosquitto__free(config->persistence_location);
    #####:  260:	mosquitto__free(config->persistence_file);
    #####:  261:	mosquitto__free(config->persistence_filepath);
    #####:  262:	mosquitto__free(config->security_options.auto_id_prefix);
    #####:  263:	mosquitto__free(config->security_options.acl_file);
    #####:  264:	mosquitto__free(config->security_options.password_file);
    #####:  265:	mosquitto__free(config->security_options.psk_file);
    #####:  266:	mosquitto__free(config->pid_file);
    #####:  267:	mosquitto__free(config->user);
    #####:  268:	mosquitto__free(config->log_timestamp_format);
    #####:  269:	if(config->listeners){
    #####:  270:		for(i=0; i<config->listener_count; i++){
    #####:  271:			mosquitto__free(config->listeners[i].host);
    #####:  272:			mosquitto__free(config->listeners[i].bind_interface);
    #####:  273:			mosquitto__free(config->listeners[i].mount_point);
    #####:  274:			mosquitto__free(config->listeners[i].socks);
    #####:  275:			mosquitto__free(config->listeners[i].security_options.auto_id_prefix);
    #####:  276:			mosquitto__free(config->listeners[i].security_options.acl_file);
    #####:  277:			mosquitto__free(config->listeners[i].security_options.password_file);
    #####:  278:			mosquitto__free(config->listeners[i].security_options.psk_file);
        -:  279:#ifdef WITH_TLS
    #####:  280:			mosquitto__free(config->listeners[i].cafile);
    #####:  281:			mosquitto__free(config->listeners[i].capath);
    #####:  282:			mosquitto__free(config->listeners[i].certfile);
    #####:  283:			mosquitto__free(config->listeners[i].keyfile);
    #####:  284:			mosquitto__free(config->listeners[i].ciphers);
    #####:  285:			mosquitto__free(config->listeners[i].psk_hint);
    #####:  286:			mosquitto__free(config->listeners[i].crlfile);
    #####:  287:			mosquitto__free(config->listeners[i].dhparamfile);
    #####:  288:			mosquitto__free(config->listeners[i].tls_version);
    #####:  289:			mosquitto__free(config->listeners[i].tls_engine);
    #####:  290:			mosquitto__free(config->listeners[i].tls_engine_kpass_sha1);
        -:  291:#ifdef WITH_WEBSOCKETS
        -:  292:			if(!config->listeners[i].ws_context) /* libwebsockets frees its own SSL_CTX */
        -:  293:#endif
        -:  294:			{
    #####:  295:				SSL_CTX_free(config->listeners[i].ssl_ctx);
        -:  296:			}
        -:  297:#endif
        -:  298:#ifdef WITH_WEBSOCKETS
        -:  299:			mosquitto__free(config->listeners[i].http_dir);
        -:  300:#endif
    #####:  301:		}
    #####:  302:		mosquitto__free(config->listeners);
    #####:  303:	}
        -:  304:#ifdef WITH_BRIDGE
        -:  305:	if(config->bridges){
        -:  306:		for(i=0; i<config->bridge_count; i++){
        -:  307:			mosquitto__free(config->bridges[i].name);
        -:  308:			if(config->bridges[i].addresses){
        -:  309:				for(j=0; j<config->bridges[i].address_count; j++){
        -:  310:					mosquitto__free(config->bridges[i].addresses[j].address);
        -:  311:				}
        -:  312:				mosquitto__free(config->bridges[i].addresses);
        -:  313:			}
        -:  314:			mosquitto__free(config->bridges[i].remote_clientid);
        -:  315:			mosquitto__free(config->bridges[i].remote_username);
        -:  316:			mosquitto__free(config->bridges[i].remote_password);
        -:  317:			mosquitto__free(config->bridges[i].local_clientid);
        -:  318:			mosquitto__free(config->bridges[i].local_username);
        -:  319:			mosquitto__free(config->bridges[i].local_password);
        -:  320:			if(config->bridges[i].topics){
        -:  321:				for(j=0; j<config->bridges[i].topic_count; j++){
        -:  322:					mosquitto__free(config->bridges[i].topics[j].topic);
        -:  323:					mosquitto__free(config->bridges[i].topics[j].local_prefix);
        -:  324:					mosquitto__free(config->bridges[i].topics[j].remote_prefix);
        -:  325:					mosquitto__free(config->bridges[i].topics[j].local_topic);
        -:  326:					mosquitto__free(config->bridges[i].topics[j].remote_topic);
        -:  327:				}
        -:  328:				mosquitto__free(config->bridges[i].topics);
        -:  329:			}
        -:  330:			mosquitto__free(config->bridges[i].notification_topic);
        -:  331:#ifdef WITH_TLS
        -:  332:			mosquitto__free(config->bridges[i].tls_version);
        -:  333:			mosquitto__free(config->bridges[i].tls_cafile);
        -:  334:			mosquitto__free(config->bridges[i].tls_alpn);
        -:  335:#ifdef FINAL_WITH_TLS_PSK
        -:  336:			mosquitto__free(config->bridges[i].tls_psk_identity);
        -:  337:			mosquitto__free(config->bridges[i].tls_psk);
        -:  338:#endif
        -:  339:#endif
        -:  340:		}
        -:  341:		mosquitto__free(config->bridges);
        -:  342:	}
        -:  343:#endif
    #####:  344:	config__cleanup_plugins(config);
        -:  345:
    #####:  346:	if(config->log_fptr){
    #####:  347:		fclose(config->log_fptr);
    #####:  348:		config->log_fptr = NULL;
    #####:  349:	}
    #####:  350:	if(config->log_file){
    #####:  351:		mosquitto__free(config->log_file);
    #####:  352:		config->log_file = NULL;
    #####:  353:	}
    #####:  354:}
        -:  355:
    #####:  356:static void print_usage(void)
        -:  357:{
    #####:  358:	printf("mosquitto version %s\n\n", VERSION);
    #####:  359:	printf("mosquitto is an MQTT v3.1.1 broker.\n\n");
    #####:  360:	printf("Usage: mosquitto [-c config_file] [-d] [-h] [-p port]\n\n");
    #####:  361:	printf(" -c : specify the broker config file.\n");
    #####:  362:	printf(" -d : put the broker into the background after starting.\n");
    #####:  363:	printf(" -h : display this help.\n");
    #####:  364:	printf(" -p : start the broker listening on the specified port.\n");
    #####:  365:	printf("      Not recommended in conjunction with the -c option.\n");
    #####:  366:	printf(" -v : verbose mode - enable all logging types. This overrides\n");
    #####:  367:	printf("      any logging options given in the config file.\n");
    #####:  368:	printf("\nSee http://mosquitto.org/ for more information.\n\n");
    #####:  369:}
        -:  370:
    #####:  371:int config__parse_args(struct mosquitto_db *db, struct mosquitto__config *config, int argc, char *argv[])
        -:  372:{
        -:  373:	int i;
        -:  374:	int port_tmp;
        -:  375:
    #####:  376:	for(i=1; i<argc; i++){
    #####:  377:		if(!strcmp(argv[i], "-c") || !strcmp(argv[i], "--config-file")){
    #####:  378:			if(i<argc-1){
    #####:  379:				db->config_file = argv[i+1];
        -:  380:
    #####:  381:				if(config__read(db, config, false)){
    #####:  382:					return MOSQ_ERR_INVAL;
        -:  383:				}
    #####:  384:			}else{
    #####:  385:				log__printf(NULL, MOSQ_LOG_ERR, "Error: -c argument given, but no config file specified.");
    #####:  386:				return MOSQ_ERR_INVAL;
        -:  387:			}
    #####:  388:			i++;
    #####:  389:		}else if(!strcmp(argv[i], "-d") || !strcmp(argv[i], "--daemon")){
    #####:  390:			config->daemon = true;
    #####:  391:		}else if(!strcmp(argv[i], "-h") || !strcmp(argv[i], "--help")){
    #####:  392:			print_usage();
    #####:  393:			return MOSQ_ERR_INVAL;
    #####:  394:		}else if(!strcmp(argv[i], "-p") || !strcmp(argv[i], "--port")){
    #####:  395:			if(i<argc-1){
    #####:  396:				port_tmp = atoi(argv[i+1]);
    #####:  397:				if(port_tmp<1 || port_tmp>65535){
    #####:  398:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid port specified (%d).", port_tmp);
    #####:  399:					return MOSQ_ERR_INVAL;
        -:  400:				}else{
    #####:  401:					if(config->default_listener.port){
    #####:  402:						log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Default listener port specified multiple times. Only the latest will be used.");
    #####:  403:					}
    #####:  404:					config->default_listener.port = port_tmp;
        -:  405:				}
    #####:  406:			}else{
    #####:  407:				log__printf(NULL, MOSQ_LOG_ERR, "Error: -p argument given, but no port specified.");
    #####:  408:				return MOSQ_ERR_INVAL;
        -:  409:			}
    #####:  410:			i++;
    #####:  411:		}else if(!strcmp(argv[i], "-v") || !strcmp(argv[i], "--verbose")){
    #####:  412:			db->verbose = true;
    #####:  413:		}else{
    #####:  414:			fprintf(stderr, "Error: Unknown option '%s'.\n",argv[i]);
    #####:  415:			print_usage();
    #####:  416:			return MOSQ_ERR_INVAL;
        -:  417:		}
    #####:  418:	}
        -:  419:
    #####:  420:	if(config->listener_count == 0
    #####:  421:			|| config->default_listener.bind_interface
        -:  422:#ifdef WITH_TLS
    #####:  423:			|| config->default_listener.cafile
    #####:  424:			|| config->default_listener.capath
    #####:  425:			|| config->default_listener.certfile
    #####:  426:			|| config->default_listener.keyfile
    #####:  427:			|| config->default_listener.tls_engine
    #####:  428:			|| config->default_listener.tls_keyform != mosq_k_pem
    #####:  429:			|| config->default_listener.tls_engine_kpass_sha1
    #####:  430:			|| config->default_listener.ciphers
    #####:  431:			|| config->default_listener.dhparamfile
    #####:  432:			|| config->default_listener.psk_hint
    #####:  433:			|| config->default_listener.require_certificate
    #####:  434:			|| config->default_listener.crlfile
    #####:  435:			|| config->default_listener.use_identity_as_username
    #####:  436:			|| config->default_listener.use_subject_as_username
        -:  437:#endif
    #####:  438:			|| config->default_listener.use_username_as_clientid
    #####:  439:			|| config->default_listener.host
    #####:  440:			|| config->default_listener.port
    #####:  441:			|| config->default_listener.max_connections != -1
    #####:  442:			|| config->default_listener.maximum_qos != 2
    #####:  443:			|| config->default_listener.mount_point
    #####:  444:			|| config->default_listener.protocol != mp_mqtt
    #####:  445:			|| config->default_listener.socket_domain
    #####:  446:			|| config->default_listener.security_options.password_file
    #####:  447:			|| config->default_listener.security_options.psk_file
    #####:  448:			|| config->default_listener.security_options.auth_plugin_config_count
    #####:  449:			|| config->default_listener.security_options.allow_anonymous != -1
    #####:  450:			|| config->default_listener.security_options.allow_zero_length_clientid != true
        -:  451:			){
        -:  452:
    #####:  453:		config->listener_count++;
    #####:  454:		config->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);
    #####:  455:		if(!config->listeners){
    #####:  456:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  457:			return MOSQ_ERR_NOMEM;
        -:  458:		}
    #####:  459:		memset(&config->listeners[config->listener_count-1], 0, sizeof(struct mosquitto__listener));
    #####:  460:		if(config->default_listener.port){
    #####:  461:			config->listeners[config->listener_count-1].port = config->default_listener.port;
    #####:  462:		}else{
    #####:  463:			config->listeners[config->listener_count-1].port = 1883;
        -:  464:		}
    #####:  465:		if(config->default_listener.host){
    #####:  466:			config->listeners[config->listener_count-1].host = config->default_listener.host;
    #####:  467:		}else{
    #####:  468:			config->listeners[config->listener_count-1].host = NULL;
        -:  469:		}
    #####:  470:		if(config->default_listener.mount_point){
    #####:  471:			config->listeners[config->listener_count-1].mount_point = config->default_listener.mount_point;
    #####:  472:		}else{
    #####:  473:			config->listeners[config->listener_count-1].mount_point = NULL;
        -:  474:		}
    #####:  475:		config->listeners[config->listener_count-1].bind_interface = config->default_listener.bind_interface;
    #####:  476:		config->listeners[config->listener_count-1].max_connections = config->default_listener.max_connections;
    #####:  477:		config->listeners[config->listener_count-1].protocol = config->default_listener.protocol;
    #####:  478:		config->listeners[config->listener_count-1].socket_domain = config->default_listener.socket_domain;
    #####:  479:		config->listeners[config->listener_count-1].client_count = 0;
    #####:  480:		config->listeners[config->listener_count-1].socks = NULL;
    #####:  481:		config->listeners[config->listener_count-1].sock_count = 0;
    #####:  482:		config->listeners[config->listener_count-1].client_count = 0;
    #####:  483:		config->listeners[config->listener_count-1].use_username_as_clientid = config->default_listener.use_username_as_clientid;
    #####:  484:		config->listeners[config->listener_count-1].maximum_qos = config->default_listener.maximum_qos;
    #####:  485:		config->listeners[config->listener_count-1].max_topic_alias = config->default_listener.max_topic_alias;
        -:  486:#ifdef WITH_TLS
    #####:  487:		config->listeners[config->listener_count-1].tls_version = config->default_listener.tls_version;
    #####:  488:		config->listeners[config->listener_count-1].tls_engine = config->default_listener.tls_engine;
    #####:  489:		config->listeners[config->listener_count-1].tls_keyform = config->default_listener.tls_keyform;
    #####:  490:		config->listeners[config->listener_count-1].tls_engine_kpass_sha1 = config->default_listener.tls_engine_kpass_sha1;
    #####:  491:		config->listeners[config->listener_count-1].cafile = config->default_listener.cafile;
    #####:  492:		config->listeners[config->listener_count-1].capath = config->default_listener.capath;
    #####:  493:		config->listeners[config->listener_count-1].certfile = config->default_listener.certfile;
    #####:  494:		config->listeners[config->listener_count-1].keyfile = config->default_listener.keyfile;
    #####:  495:		config->listeners[config->listener_count-1].ciphers = config->default_listener.ciphers;
    #####:  496:		config->listeners[config->listener_count-1].dhparamfile = config->default_listener.dhparamfile;
    #####:  497:		config->listeners[config->listener_count-1].psk_hint = config->default_listener.psk_hint;
    #####:  498:		config->listeners[config->listener_count-1].require_certificate = config->default_listener.require_certificate;
    #####:  499:		config->listeners[config->listener_count-1].ssl_ctx = NULL;
    #####:  500:		config->listeners[config->listener_count-1].crlfile = config->default_listener.crlfile;
    #####:  501:		config->listeners[config->listener_count-1].use_identity_as_username = config->default_listener.use_identity_as_username;
    #####:  502:		config->listeners[config->listener_count-1].use_subject_as_username = config->default_listener.use_subject_as_username;
        -:  503:#endif
    #####:  504:		config->listeners[config->listener_count-1].security_options.acl_file = config->default_listener.security_options.acl_file;
    #####:  505:		config->listeners[config->listener_count-1].security_options.password_file = config->default_listener.security_options.password_file;
    #####:  506:		config->listeners[config->listener_count-1].security_options.psk_file = config->default_listener.security_options.psk_file;
    #####:  507:		config->listeners[config->listener_count-1].security_options.auth_plugin_configs = config->default_listener.security_options.auth_plugin_configs;
    #####:  508:		config->listeners[config->listener_count-1].security_options.auth_plugin_config_count = config->default_listener.security_options.auth_plugin_config_count;
    #####:  509:		config->listeners[config->listener_count-1].security_options.allow_anonymous = config->default_listener.security_options.allow_anonymous;
    #####:  510:		config->listeners[config->listener_count-1].security_options.allow_zero_length_clientid = config->default_listener.security_options.allow_zero_length_clientid;
    #####:  511:	}
        -:  512:
        -:  513:	/* Default to drop to mosquitto user if we are privileged and no user specified. */
    #####:  514:	if(!config->user){
    #####:  515:		config->user = mosquitto__strdup("mosquitto");
    #####:  516:		if(config->user == NULL){
    #####:  517:			return MOSQ_ERR_NOMEM;
        -:  518:		}
    #####:  519:	}
    #####:  520:	if(db->verbose){
    #####:  521:		config->log_type = UINT_MAX;
    #####:  522:	}
    #####:  523:	return config__check(config);
    #####:  524:}
        -:  525:
    #####:  526:void config__copy(struct mosquitto__config *src, struct mosquitto__config *dest)
        -:  527:{
    #####:  528:	mosquitto__free(dest->security_options.acl_file);
    #####:  529:	dest->security_options.acl_file = src->security_options.acl_file;
        -:  530:
    #####:  531:	dest->security_options.allow_anonymous = src->security_options.allow_anonymous;
    #####:  532:	dest->security_options.allow_zero_length_clientid = src->security_options.allow_zero_length_clientid;
        -:  533:
    #####:  534:	mosquitto__free(dest->security_options.auto_id_prefix);
    #####:  535:	dest->security_options.auto_id_prefix = src->security_options.auto_id_prefix;
    #####:  536:	dest->security_options.auto_id_prefix_len = src->security_options.auto_id_prefix_len;
        -:  537:
    #####:  538:	mosquitto__free(dest->security_options.password_file);
    #####:  539:	dest->security_options.password_file = src->security_options.password_file;
        -:  540:
    #####:  541:	mosquitto__free(dest->security_options.psk_file);
    #####:  542:	dest->security_options.psk_file = src->security_options.psk_file;
        -:  543:
        -:  544:
    #####:  545:	dest->allow_duplicate_messages = src->allow_duplicate_messages;
        -:  546:
        -:  547:
    #####:  548:	dest->autosave_interval = src->autosave_interval;
    #####:  549:	dest->autosave_on_changes = src->autosave_on_changes;
        -:  550:
    #####:  551:	mosquitto__free(dest->clientid_prefixes);
    #####:  552:	dest->clientid_prefixes = src->clientid_prefixes;
        -:  553:
    #####:  554:	dest->connection_messages = src->connection_messages;
    #####:  555:	dest->log_dest = src->log_dest;
    #####:  556:	dest->log_facility = src->log_facility;
    #####:  557:	dest->log_type = src->log_type;
    #####:  558:	dest->log_timestamp = src->log_timestamp;
        -:  559:
    #####:  560:	mosquitto__free(dest->log_timestamp_format);
    #####:  561:	dest->log_timestamp_format = src->log_timestamp_format;
        -:  562:
    #####:  563:	mosquitto__free(dest->log_file);
    #####:  564:	dest->log_file = src->log_file;
        -:  565:
    #####:  566:	dest->message_size_limit = src->message_size_limit;
        -:  567:
    #####:  568:	dest->persistence = src->persistence;
        -:  569:
    #####:  570:	mosquitto__free(dest->persistence_location);
    #####:  571:	dest->persistence_location = src->persistence_location;
        -:  572:
    #####:  573:	mosquitto__free(dest->persistence_file);
    #####:  574:	dest->persistence_file = src->persistence_file;
        -:  575:
    #####:  576:	mosquitto__free(dest->persistence_filepath);
    #####:  577:	dest->persistence_filepath = src->persistence_filepath;
        -:  578:
    #####:  579:	dest->persistent_client_expiration = src->persistent_client_expiration;
        -:  580:
        -:  581:
    #####:  582:	dest->queue_qos0_messages = src->queue_qos0_messages;
    #####:  583:	dest->sys_interval = src->sys_interval;
    #####:  584:	dest->upgrade_outgoing_qos = src->upgrade_outgoing_qos;
        -:  585:
        -:  586:#ifdef WITH_WEBSOCKETS
        -:  587:	dest->websockets_log_level = src->websockets_log_level;
        -:  588:#endif
    #####:  589:}
        -:  590:
        -:  591:
    #####:  592:int config__read(struct mosquitto_db *db, struct mosquitto__config *config, bool reload)
        -:  593:{
    #####:  594:	int rc = MOSQ_ERR_SUCCESS;
        -:  595:	struct config_recurse cr;
    #####:  596:	int lineno = 0;
        -:  597:#ifdef WITH_PERSISTENCE
        -:  598:	int len;
        -:  599:#endif
        -:  600:	struct mosquitto__config config_reload;
        -:  601:	struct mosquitto__auth_plugin *plugin;
        -:  602:	int i, j;
        -:  603:
    #####:  604:	if(reload){
    #####:  605:		memset(&config_reload, 0, sizeof(struct mosquitto__config));
    #####:  606:	}
        -:  607:
    #####:  608:	cr.log_dest = MQTT3_LOG_NONE;
    #####:  609:	cr.log_dest_set = 0;
    #####:  610:	cr.log_type = MOSQ_LOG_NONE;
    #####:  611:	cr.log_type_set = 0;
    #####:  612:	cr.max_inflight_bytes = 0;
    #####:  613:	cr.max_queued_bytes = 0;
    #####:  614:	cr.max_queued_messages = 100;
        -:  615:
    #####:  616:	if(!db->config_file) return 0;
        -:  617:
    #####:  618:	if(reload){
        -:  619:		/* Re-initialise appropriate config vars to default for reload. */
    #####:  620:		config__init_reload(db, &config_reload);
    #####:  621:		config_reload.listeners = config->listeners;
    #####:  622:		config_reload.listener_count = config->listener_count;
    #####:  623:		cur_security_options = NULL;
    #####:  624:		rc = config__read_file(&config_reload, reload, db->config_file, &cr, 0, &lineno);
    #####:  625:	}else{
    #####:  626:		rc = config__read_file(config, reload, db->config_file, &cr, 0, &lineno);
        -:  627:	}
    #####:  628:	if(rc){
    #####:  629:		if(lineno > 0){
    #####:  630:			log__printf(NULL, MOSQ_LOG_ERR, "Error found at %s:%d.", db->config_file, lineno);
    #####:  631:		}
    #####:  632:		return rc;
        -:  633:	}
        -:  634:
    #####:  635:	if(reload){
    #####:  636:		config__copy(&config_reload, config);
    #####:  637:	}
        -:  638:
        -:  639:	/* If auth/access options are set and allow_anonymous not explicitly set, disallow anon. */
    #####:  640:	if(config->per_listener_settings){
    #####:  641:		for(i=0; i<config->listener_count; i++){
    #####:  642:			if(config->listeners[i].security_options.allow_anonymous == -1){
        -:  643:				/* Default option if no security options set */
    #####:  644:				config->listeners[i].security_options.allow_anonymous = true;
        -:  645:
    #####:  646:				if(config->listeners[i].security_options.password_file
    #####:  647:					|| config->listeners[i].security_options.psk_file){
        -:  648:
        -:  649:					/* allow_anonymous not set explicitly, some other security options
        -:  650:					* have been set - so disable allow_anonymous
        -:  651:					*/
    #####:  652:					config->listeners[i].security_options.allow_anonymous = false;
    #####:  653:				}
        -:  654:
        -:  655:				/* Check plugins loaded to see if they have username/password checks enabled */
    #####:  656:				for(j=0; j<config->listeners[i].security_options.auth_plugin_config_count; j++){ 
    #####:  657:					plugin = &config->listeners[i].security_options.auth_plugin_configs[j].plugin;
        -:  658:
    #####:  659:					if(plugin->version == 3 || plugin->version == 2){
        -:  660:						/* Version 2 and 3 always have username/password checks */
    #####:  661:						config->listeners[i].security_options.allow_anonymous = false;
    #####:  662:						break;
        -:  663:					}else{
        -:  664:						/* Version 4 has optional unpwd checks. */
    #####:  665:						if(plugin->unpwd_check_v4 != NULL){
    #####:  666:							config->listeners[i].security_options.allow_anonymous = false;
    #####:  667:							break;
        -:  668:						}
        -:  669:					}
    #####:  670:				}
    #####:  671:			}
    #####:  672:		}
    #####:  673:	}else{
    #####:  674:		if(config->security_options.allow_anonymous == -1){
        -:  675:			/* Default option if no security options set */
    #####:  676:			config->security_options.allow_anonymous = true;
        -:  677:
    #####:  678:			if(config->security_options.password_file
    #####:  679:				 || config->security_options.psk_file){
        -:  680:
        -:  681:				/* allow_anonymous not set explicitly, some other security options
        -:  682:				* have been set - so disable allow_anonymous
        -:  683:				*/
    #####:  684:				config->security_options.allow_anonymous = false;
    #####:  685:			}
        -:  686:
        -:  687:			/* Check plugins loaded to see if they have username/password checks enabled */
    #####:  688:			for(j=0; j<config->security_options.auth_plugin_config_count; j++){ 
    #####:  689:				plugin = &config->security_options.auth_plugin_configs[j].plugin;
        -:  690:
    #####:  691:				if(plugin->version == 3 || plugin->version == 2){
        -:  692:					/* Version 2 and 3 always have username/password checks */
    #####:  693:					config->security_options.allow_anonymous = false;
    #####:  694:					break;
        -:  695:				}else{
        -:  696:					/* Version 4 has optional unpwd checks. */
    #####:  697:					if(plugin->unpwd_check_v4 != NULL){
    #####:  698:						config->security_options.allow_anonymous = false;
    #####:  699:						break;
        -:  700:					}
        -:  701:				}
    #####:  702:			}
    #####:  703:		}
        -:  704:	}
        -:  705:#ifdef WITH_PERSISTENCE
        -:  706:	if(config->persistence){
        -:  707:		if(!config->persistence_file){
        -:  708:			config->persistence_file = mosquitto__strdup("mosquitto.db");
        -:  709:			if(!config->persistence_file) return MOSQ_ERR_NOMEM;
        -:  710:		}
        -:  711:		mosquitto__free(config->persistence_filepath);
        -:  712:		if(config->persistence_location && strlen(config->persistence_location)){
        -:  713:			len = strlen(config->persistence_location) + strlen(config->persistence_file) + 1;
        -:  714:			config->persistence_filepath = mosquitto__malloc(len);
        -:  715:			if(!config->persistence_filepath) return MOSQ_ERR_NOMEM;
        -:  716:			snprintf(config->persistence_filepath, len, "%s%s", config->persistence_location, config->persistence_file);
        -:  717:		}else{
        -:  718:			config->persistence_filepath = mosquitto__strdup(config->persistence_file);
        -:  719:			if(!config->persistence_filepath) return MOSQ_ERR_NOMEM;
        -:  720:		}
        -:  721:	}
        -:  722:#endif
        -:  723:	/* Default to drop to mosquitto user if no other user specified. This must
        -:  724:	 * remain here even though it is covered in config__parse_args() because this
        -:  725:	 * function may be called on its own. */
    #####:  726:	if(!config->user){
    #####:  727:		config->user = mosquitto__strdup("mosquitto");
    #####:  728:	}
        -:  729:
    #####:  730:	db__limits_set(cr.max_inflight_bytes, cr.max_queued_messages, cr.max_queued_bytes);
        -:  731:
        -:  732:#ifdef WITH_BRIDGE
        -:  733:	for(i=0; i<config->bridge_count; i++){
        -:  734:		if(!config->bridges[i].name || !config->bridges[i].addresses || !config->bridges[i].topic_count){
        -:  735:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -:  736:			return MOSQ_ERR_INVAL;
        -:  737:		}
        -:  738:#ifdef FINAL_WITH_TLS_PSK
        -:  739:		if(config->bridges[i].tls_psk && !config->bridges[i].tls_psk_identity){
        -:  740:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration: missing bridge_identity.");
        -:  741:			return MOSQ_ERR_INVAL;
        -:  742:		}
        -:  743:		if(config->bridges[i].tls_psk_identity && !config->bridges[i].tls_psk){
        -:  744:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration: missing bridge_psk.");
        -:  745:			return MOSQ_ERR_INVAL;
        -:  746:		}
        -:  747:#endif
        -:  748:	}
        -:  749:#endif
        -:  750:
    #####:  751:	if(cr.log_dest_set){
    #####:  752:		config->log_dest = cr.log_dest;
    #####:  753:	}
    #####:  754:	if(db->verbose){
    #####:  755:		config->log_type = UINT_MAX;
    #####:  756:	}else if(cr.log_type_set){
    #####:  757:		config->log_type = cr.log_type;
    #####:  758:	}
    #####:  759:	return MOSQ_ERR_SUCCESS;
    #####:  760:}
        -:  761:
    #####:  762:int config__read_file_core(struct mosquitto__config *config, bool reload, struct config_recurse *cr, int level, int *lineno, FILE *fptr, char **buf, int *buflen)
        -:  763:{
        -:  764:	int rc;
        -:  765:	char *token;
        -:  766:	int tmp_int;
    #####:  767:	char *saveptr = NULL;
        -:  768:#ifdef WITH_BRIDGE
        -:  769:	char *tmp_char;
        -:  770:	struct mosquitto__bridge *cur_bridge = NULL;
        -:  771:	struct mosquitto__bridge_topic *cur_topic;
        -:  772:	int len;
        -:  773:#endif
    #####:  774:	struct mosquitto__auth_plugin_config *cur_auth_plugin_config = NULL;
        -:  775:
        -:  776:	time_t expiration_mult;
        -:  777:	char *key;
    #####:  778:	struct mosquitto__listener *cur_listener = &config->default_listener;
        -:  779:	int i;
    #####:  780:	int lineno_ext = 0;
        -:  781:
    #####:  782:	*lineno = 0;
        -:  783:
    #####:  784:	while(fgets_extending(buf, buflen, fptr)){
    #####:  785:		(*lineno)++;
    #####:  786:		if((*buf)[0] != '#' && (*buf)[0] != 10 && (*buf)[0] != 13){
    #####:  787:			while((*buf)[strlen((*buf))-1] == 10 || (*buf)[strlen((*buf))-1] == 13){
    #####:  788:				(*buf)[strlen((*buf))-1] = 0;
        -:  789:			}
    #####:  790:			token = strtok_r((*buf), " ", &saveptr);
    #####:  791:			if(token){
    #####:  792:				if(!strcmp(token, "acl_file")){
    #####:  793:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####:  794:					if(reload){
    #####:  795:						mosquitto__free(cur_security_options->acl_file);
    #####:  796:						cur_security_options->acl_file = NULL;
    #####:  797:					}
    #####:  798:					if(conf__parse_string(&token, "acl_file", &cur_security_options->acl_file, saveptr)) return MOSQ_ERR_INVAL;
    #####:  799:				}else if(!strcmp(token, "address") || !strcmp(token, "addresses")){
        -:  800:#ifdef WITH_BRIDGE
        -:  801:					if(reload) continue; // FIXME
        -:  802:					if(!cur_bridge || cur_bridge->addresses){
        -:  803:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -:  804:						return MOSQ_ERR_INVAL;
        -:  805:					}
        -:  806:					while((token = strtok_r(NULL, " ", &saveptr))){
        -:  807:						if (token[0] == '#'){
        -:  808:							break;
        -:  809:						}
        -:  810:						cur_bridge->address_count++;
        -:  811:						cur_bridge->addresses = mosquitto__realloc(cur_bridge->addresses, sizeof(struct bridge_address)*cur_bridge->address_count);
        -:  812:						if(!cur_bridge->addresses){
        -:  813:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -:  814:							return MOSQ_ERR_NOMEM;
        -:  815:						}
        -:  816:						cur_bridge->addresses[cur_bridge->address_count-1].address = token;
        -:  817:					}
        -:  818:					for(i=0; i<cur_bridge->address_count; i++){
        -:  819:						/* cur_bridge->addresses[i].address is now
        -:  820:						 * "address[:port]". If address is an IPv6 address,
        -:  821:						 * then port is required. We must check for the :
        -:  822:						 * backwards. */
        -:  823:						tmp_char = strrchr(cur_bridge->addresses[i].address, ':');
        -:  824:						if(tmp_char){
        -:  825:							/* Remove ':', so cur_bridge->addresses[i].address
        -:  826:							 * now just looks like the address. */
        -:  827:							tmp_char[0] = '\0';
        -:  828:
        -:  829:							/* The remainder of the string */
        -:  830:							tmp_int = atoi(&tmp_char[1]);
        -:  831:							if(tmp_int < 1 || tmp_int > 65535){
        -:  832:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid port value (%d).", tmp_int);
        -:  833:								return MOSQ_ERR_INVAL;
        -:  834:							}
        -:  835:							cur_bridge->addresses[i].port = tmp_int;
        -:  836:						}else{
        -:  837:							cur_bridge->addresses[i].port = 1883;
        -:  838:						}
        -:  839:						/* This looks a bit weird, but isn't. Before this
        -:  840:						 * call, cur_bridge->addresses[i].address points
        -:  841:						 * to the tokenised part of the line, it will be
        -:  842:						 * reused in a future parse of a config line so we
        -:  843:						 * must duplicate it. */
        -:  844:						cur_bridge->addresses[i].address = mosquitto__strdup(cur_bridge->addresses[i].address);
        -:  845:						conf__attempt_resolve(cur_bridge->addresses[i].address, "bridge address", MOSQ_LOG_WARNING, "Warning");
        -:  846:					}
        -:  847:					if(cur_bridge->address_count == 0){
        -:  848:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty address value in configuration.");
        -:  849:						return MOSQ_ERR_INVAL;
        -:  850:					}
        -:  851:#else
    #####:  852:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -:  853:#endif
    #####:  854:				}else if(!strcmp(token, "allow_anonymous")){
    #####:  855:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####:  856:					if(conf__parse_bool(&token, "allow_anonymous", (bool *)&cur_security_options->allow_anonymous, saveptr)) return MOSQ_ERR_INVAL;
    #####:  857:				}else if(!strcmp(token, "allow_duplicate_messages")){
    #####:  858:					if(conf__parse_bool(&token, "allow_duplicate_messages", &config->allow_duplicate_messages, saveptr)) return MOSQ_ERR_INVAL;
    #####:  859:				}else if(!strcmp(token, "allow_zero_length_clientid")){
    #####:  860:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####:  861:					if(conf__parse_bool(&token, "allow_zero_length_clientid", &cur_security_options->allow_zero_length_clientid, saveptr)) return MOSQ_ERR_INVAL;
    #####:  862:				}else if(!strncmp(token, "auth_opt_", 9)){
    #####:  863:					if(reload) continue; // Auth plugin not currently valid for reloading.
    #####:  864:					if(!cur_auth_plugin_config){
    #####:  865:						log__printf(NULL, MOSQ_LOG_ERR, "Error: An auth_opt_ option exists in the config file without an auth_plugin.");
    #####:  866:						return MOSQ_ERR_INVAL;
        -:  867:					}
    #####:  868:					if(strlen(token) < 12){
        -:  869:						/* auth_opt_ == 9, + one digit key == 10, + one space == 11, + one value == 12 */
    #####:  870:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid auth_opt_ config option.");
    #####:  871:						return MOSQ_ERR_INVAL;
        -:  872:					}
    #####:  873:					key = mosquitto__strdup(&token[9]);
    #####:  874:					if(!key){
    #####:  875:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  876:						return MOSQ_ERR_NOMEM;
    #####:  877:					}else if(STREMPTY(key)){
    #####:  878:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid auth_opt_ config option.");
    #####:  879:						mosquitto__free(key);
    #####:  880:						return MOSQ_ERR_INVAL;
        -:  881:					}
    #####:  882:					token += 9+strlen(key)+1;
    #####:  883:					while(token[0] == ' ' || token[0] == '\t'){
    #####:  884:						token++;
        -:  885:					}
    #####:  886:					if(token[0]){
    #####:  887:						cur_auth_plugin_config->option_count++;
    #####:  888:						cur_auth_plugin_config->options = mosquitto__realloc(cur_auth_plugin_config->options, cur_auth_plugin_config->option_count*sizeof(struct mosquitto_auth_opt));
    #####:  889:						if(!cur_auth_plugin_config->options){
    #####:  890:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  891:							mosquitto__free(key);
    #####:  892:							return MOSQ_ERR_NOMEM;
        -:  893:						}
    #####:  894:						cur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].key = key;
    #####:  895:						cur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].value = mosquitto__strdup(token);
    #####:  896:						if(!cur_auth_plugin_config->options[cur_auth_plugin_config->option_count-1].value){
    #####:  897:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  898:							return MOSQ_ERR_NOMEM;
        -:  899:						}
    #####:  900:					}else{
    #####:  901:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty %s value in configuration.", key);
    #####:  902:						mosquitto__free(key);
    #####:  903:						return MOSQ_ERR_INVAL;
        -:  904:					}
    #####:  905:				}else if(!strcmp(token, "auth_plugin")){
    #####:  906:					if(reload) continue; // Auth plugin not currently valid for reloading.
    #####:  907:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####:  908:					cur_security_options->auth_plugin_configs = mosquitto__realloc(cur_security_options->auth_plugin_configs, (cur_security_options->auth_plugin_config_count+1)*sizeof(struct mosquitto__auth_plugin_config));
    #####:  909:					if(!cur_security_options->auth_plugin_configs){
    #####:  910:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  911:						return MOSQ_ERR_NOMEM;
        -:  912:					}
    #####:  913:					cur_auth_plugin_config = &cur_security_options->auth_plugin_configs[cur_security_options->auth_plugin_config_count];
    #####:  914:					memset(cur_auth_plugin_config, 0, sizeof(struct mosquitto__auth_plugin_config));
    #####:  915:					cur_auth_plugin_config->path = NULL;
    #####:  916:					cur_auth_plugin_config->options = NULL;
    #####:  917:					cur_auth_plugin_config->option_count = 0;
    #####:  918:					cur_auth_plugin_config->deny_special_chars = true;
    #####:  919:					cur_security_options->auth_plugin_config_count++;
    #####:  920:					if(conf__parse_string(&token, "auth_plugin", &cur_auth_plugin_config->path, saveptr)) return MOSQ_ERR_INVAL;
    #####:  921:				}else if(!strcmp(token, "auth_plugin_deny_special_chars")){
    #####:  922:					if(reload) continue; // Auth plugin not currently valid for reloading.
    #####:  923:					if(!cur_auth_plugin_config){
    #####:  924:						log__printf(NULL, MOSQ_LOG_ERR, "Error: An auth_plugin_deny_special_chars option exists in the config file without an auth_plugin.");
    #####:  925:						return MOSQ_ERR_INVAL;
        -:  926:					}
    #####:  927:					if(conf__parse_bool(&token, "auth_plugin_deny_special_chars", &cur_auth_plugin_config->deny_special_chars, saveptr)) return MOSQ_ERR_INVAL;
    #####:  928:				}else if(!strcmp(token, "auto_id_prefix")){
    #####:  929:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####:  930:					if(conf__parse_string(&token, "auto_id_prefix", &cur_security_options->auto_id_prefix, saveptr)) return MOSQ_ERR_INVAL;
    #####:  931:					if(cur_security_options->auto_id_prefix){
    #####:  932:						cur_security_options->auto_id_prefix_len = strlen(cur_security_options->auto_id_prefix);
    #####:  933:					}else{
    #####:  934:						cur_security_options->auto_id_prefix_len = 0;
        -:  935:					}
    #####:  936:				}else if(!strcmp(token, "autosave_interval")){
    #####:  937:					if(conf__parse_int(&token, "autosave_interval", &config->autosave_interval, saveptr)) return MOSQ_ERR_INVAL;
    #####:  938:					if(config->autosave_interval < 0) config->autosave_interval = 0;
    #####:  939:				}else if(!strcmp(token, "autosave_on_changes")){
    #####:  940:					if(conf__parse_bool(&token, "autosave_on_changes", &config->autosave_on_changes, saveptr)) return MOSQ_ERR_INVAL;
    #####:  941:				}else if(!strcmp(token, "bind_address")){
    #####:  942:					if(reload) continue; // Listener not valid for reloading.
    #####:  943:					if(conf__parse_string(&token, "default listener bind_address", &config->default_listener.host, saveptr)) return MOSQ_ERR_INVAL;
    #####:  944:					if(conf__attempt_resolve(config->default_listener.host, "bind_address", MOSQ_LOG_ERR, "Error")){
    #####:  945:						return MOSQ_ERR_INVAL;
        -:  946:					}
    #####:  947:				}else if(!strcmp(token, "bind_interface")){
        -:  948:#ifdef SO_BINDTODEVICE
    #####:  949:					if(reload) continue; // Listeners not valid for reloading.
    #####:  950:					if(conf__parse_string(&token, "bind_interface", &cur_listener->bind_interface, saveptr)) return MOSQ_ERR_INVAL;
        -:  951:#else
        -:  952:					log__printf(NULL, MOSQ_LOG_ERR, "Error: bind_interface specified but socket option not available.");
        -:  953:					return MOSQ_ERR_INVAL;
        -:  954:#endif
    #####:  955:				}else if(!strcmp(token, "bridge_attempt_unsubscribe")){
        -:  956:#ifdef WITH_BRIDGE
        -:  957:					if(reload) continue; // FIXME
        -:  958:					if(!cur_bridge){
        -:  959:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -:  960:						return MOSQ_ERR_INVAL;
        -:  961:					}
        -:  962:					if(conf__parse_bool(&token, "bridge_attempt_unsubscribe", &cur_bridge->attempt_unsubscribe, saveptr)) return MOSQ_ERR_INVAL;
        -:  963:#else
    #####:  964:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -:  965:#endif
    #####:  966:				}else if(!strcmp(token, "bridge_cafile")){
        -:  967:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -:  968:					if(reload) continue; // FIXME
        -:  969:					if(!cur_bridge){
        -:  970:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -:  971:						return MOSQ_ERR_INVAL;
        -:  972:					}
        -:  973:#ifdef FINAL_WITH_TLS_PSK
        -:  974:					if(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){
        -:  975:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single bridge.");
        -:  976:						return MOSQ_ERR_INVAL;
        -:  977:					}
        -:  978:#endif
        -:  979:					if(conf__parse_string(&token, "bridge_cafile", &cur_bridge->tls_cafile, saveptr)) return MOSQ_ERR_INVAL;
        -:  980:#else
    #####:  981:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS support not available.");
        -:  982:#endif
    #####:  983:				}else if(!strcmp(token, "bridge_alpn")){
        -:  984:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -:  985:					if(reload) continue; // FIXME
        -:  986:					if(!cur_bridge){
        -:  987:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -:  988:						return MOSQ_ERR_INVAL;
        -:  989:					}
        -:  990:					if(conf__parse_string(&token, "bridge_alpn", &cur_bridge->tls_alpn, saveptr)) return MOSQ_ERR_INVAL;
        -:  991:#else
    #####:  992:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS support not available.");
        -:  993:#endif
    #####:  994:				}else if(!strcmp(token, "bridge_capath")){
        -:  995:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -:  996:					if(reload) continue; // FIXME
        -:  997:					if(!cur_bridge){
        -:  998:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -:  999:						return MOSQ_ERR_INVAL;
        -: 1000:					}
        -: 1001:#ifdef FINAL_WITH_TLS_PSK
        -: 1002:					if(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){
        -: 1003:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single bridge.");
        -: 1004:						return MOSQ_ERR_INVAL;
        -: 1005:					}
        -: 1006:#endif
        -: 1007:					if(conf__parse_string(&token, "bridge_capath", &cur_bridge->tls_capath, saveptr)) return MOSQ_ERR_INVAL;
        -: 1008:#else
    #####: 1009:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS support not available.");
        -: 1010:#endif
    #####: 1011:				}else if(!strcmp(token, "bridge_certfile")){
        -: 1012:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -: 1013:					if(reload) continue; // FIXME
        -: 1014:					if(!cur_bridge){
        -: 1015:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1016:						return MOSQ_ERR_INVAL;
        -: 1017:					}
        -: 1018:#ifdef FINAL_WITH_TLS_PSK
        -: 1019:					if(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){
        -: 1020:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single bridge.");
        -: 1021:						return MOSQ_ERR_INVAL;
        -: 1022:					}
        -: 1023:#endif
        -: 1024:					if(conf__parse_string(&token, "bridge_certfile", &cur_bridge->tls_certfile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1025:#else
    #####: 1026:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS support not available.");
        -: 1027:#endif
    #####: 1028:				}else if(!strcmp(token, "bridge_identity")){
        -: 1029:#if defined(WITH_BRIDGE) && defined(FINAL_WITH_TLS_PSK)
        -: 1030:					if(reload) continue; // FIXME
        -: 1031:					if(!cur_bridge){
        -: 1032:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1033:						return MOSQ_ERR_INVAL;
        -: 1034:					}
        -: 1035:					if(cur_bridge->tls_cafile || cur_bridge->tls_capath || cur_bridge->tls_certfile || cur_bridge->tls_keyfile){
        -: 1036:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and identity encryption in a single bridge.");
        -: 1037:						return MOSQ_ERR_INVAL;
        -: 1038:					}
        -: 1039:					if(conf__parse_string(&token, "bridge_identity", &cur_bridge->tls_psk_identity, saveptr)) return MOSQ_ERR_INVAL;
        -: 1040:#else
    #####: 1041:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS-PSK support not available.");
        -: 1042:#endif
    #####: 1043:				}else if(!strcmp(token, "bridge_insecure")){
        -: 1044:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -: 1045:					if(reload) continue; // FIXME
        -: 1046:					if(!cur_bridge){
        -: 1047:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1048:						return MOSQ_ERR_INVAL;
        -: 1049:					}
        -: 1050:					if(conf__parse_bool(&token, "bridge_insecure", &cur_bridge->tls_insecure, saveptr)) return MOSQ_ERR_INVAL;
        -: 1051:					if(cur_bridge->tls_insecure){
        -: 1052:						log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge %s using insecure mode.", cur_bridge->name);
        -: 1053:					}
        -: 1054:#else
    #####: 1055:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS-PSK support not available.");
        -: 1056:#endif
    #####: 1057:				}else if(!strcmp(token, "bridge_require_ocsp")){
        -: 1058:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -: 1059:					if(reload) continue; // Listeners not valid for reloading.
        -: 1060:					if(!cur_bridge){
        -: 1061:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1062:						return MOSQ_ERR_INVAL;
        -: 1063:					}
        -: 1064:					if(conf__parse_bool(&token, "bridge_require_ocsp", &cur_bridge->tls_ocsp_required, saveptr)) return MOSQ_ERR_INVAL;
        -: 1065:#else
    #####: 1066:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1067:#endif
    #####: 1068:				}else if(!strcmp(token, "bridge_keyfile")){
        -: 1069:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -: 1070:					if(reload) continue; // FIXME
        -: 1071:					if(!cur_bridge){
        -: 1072:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1073:						return MOSQ_ERR_INVAL;
        -: 1074:					}
        -: 1075:#ifdef FINAL_WITH_TLS_PSK
        -: 1076:					if(cur_bridge->tls_psk_identity || cur_bridge->tls_psk){
        -: 1077:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single bridge.");
        -: 1078:						return MOSQ_ERR_INVAL;
        -: 1079:					}
        -: 1080:#endif
        -: 1081:					if(conf__parse_string(&token, "bridge_keyfile", &cur_bridge->tls_keyfile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1082:#else
    #####: 1083:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS support not available.");
        -: 1084:#endif
    #####: 1085:				}else if(!strcmp(token, "bridge_protocol_version")){
        -: 1086:#ifdef WITH_BRIDGE
        -: 1087:					if(reload) continue; // FIXME
        -: 1088:					if(!cur_bridge){
        -: 1089:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1090:						return MOSQ_ERR_INVAL;
        -: 1091:					}
        -: 1092:					token = strtok_r(NULL, "", &saveptr);
        -: 1093:					if(token){
        -: 1094:						if(!strcmp(token, "mqttv31")){
        -: 1095:							cur_bridge->protocol_version = mosq_p_mqtt31;
        -: 1096:						}else if(!strcmp(token, "mqttv311")){
        -: 1097:							cur_bridge->protocol_version = mosq_p_mqtt311;
        -: 1098:						}else{
        -: 1099:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge_protocol_version value (%s).", token);
        -: 1100:							return MOSQ_ERR_INVAL;
        -: 1101:						}
        -: 1102:					}else{
        -: 1103:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty bridge_protocol_version value in configuration.");
        -: 1104:						return MOSQ_ERR_INVAL;
        -: 1105:					}
        -: 1106:#else
    #####: 1107:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1108:#endif
    #####: 1109:				}else if(!strcmp(token, "bridge_psk")){
        -: 1110:#if defined(WITH_BRIDGE) && defined(FINAL_WITH_TLS_PSK)
        -: 1111:					if(reload) continue; // FIXME
        -: 1112:					if(!cur_bridge){
        -: 1113:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1114:						return MOSQ_ERR_INVAL;
        -: 1115:					}
        -: 1116:					if(cur_bridge->tls_cafile || cur_bridge->tls_capath || cur_bridge->tls_certfile || cur_bridge->tls_keyfile){
        -: 1117:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single bridge.");
        -: 1118:						return MOSQ_ERR_INVAL;
        -: 1119:					}
        -: 1120:					if(conf__parse_string(&token, "bridge_psk", &cur_bridge->tls_psk, saveptr)) return MOSQ_ERR_INVAL;
        -: 1121:#else
    #####: 1122:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS-PSK support not available.");
        -: 1123:#endif
    #####: 1124:				}else if(!strcmp(token, "bridge_tls_version")){
        -: 1125:#if defined(WITH_BRIDGE) && defined(WITH_TLS)
        -: 1126:					if(reload) continue; // FIXME
        -: 1127:					if(!cur_bridge){
        -: 1128:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1129:						return MOSQ_ERR_INVAL;
        -: 1130:					}
        -: 1131:					if(conf__parse_string(&token, "bridge_tls_version", &cur_bridge->tls_version, saveptr)) return MOSQ_ERR_INVAL;
        -: 1132:#else
    #####: 1133:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge and/or TLS support not available.");
        -: 1134:#endif
    #####: 1135:				}else if(!strcmp(token, "cafile")){
        -: 1136:#if defined(WITH_TLS)
    #####: 1137:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1138:					if(cur_listener->psk_hint){
    #####: 1139:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single listener.");
    #####: 1140:						return MOSQ_ERR_INVAL;
        -: 1141:					}
    #####: 1142:					if(conf__parse_string(&token, "cafile", &cur_listener->cafile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1143:#else
        -: 1144:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1145:#endif
    #####: 1146:				}else if(!strcmp(token, "capath")){
        -: 1147:#ifdef WITH_TLS
    #####: 1148:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1149:					if(conf__parse_string(&token, "capath", &cur_listener->capath, saveptr)) return MOSQ_ERR_INVAL;
        -: 1150:#else
        -: 1151:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1152:#endif
    #####: 1153:				}else if(!strcmp(token, "certfile")){
        -: 1154:#ifdef WITH_TLS
    #####: 1155:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1156:					if(cur_listener->psk_hint){
    #####: 1157:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot use both certificate and psk encryption in a single listener.");
    #####: 1158:						return MOSQ_ERR_INVAL;
        -: 1159:					}
    #####: 1160:					if(conf__parse_string(&token, "certfile", &cur_listener->certfile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1161:#else
        -: 1162:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1163:#endif
    #####: 1164:				}else if(!strcmp(token, "check_retain_source")){
    #####: 1165:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####: 1166:					if(conf__parse_bool(&token, "check_retain_source", &config->check_retain_source, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1167:				}else if(!strcmp(token, "ciphers")){
        -: 1168:#ifdef WITH_TLS
    #####: 1169:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1170:					if(conf__parse_string(&token, "ciphers", &cur_listener->ciphers, saveptr)) return MOSQ_ERR_INVAL;
        -: 1171:#else
        -: 1172:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1173:#endif
    #####: 1174:				}else if(!strcmp(token, "clientid") || !strcmp(token, "remote_clientid")){
        -: 1175:#ifdef WITH_BRIDGE
        -: 1176:					if(reload) continue; // FIXME
        -: 1177:					if(!cur_bridge){
        -: 1178:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1179:						return MOSQ_ERR_INVAL;
        -: 1180:					}
        -: 1181:					if(conf__parse_string(&token, "bridge remote clientid", &cur_bridge->remote_clientid, saveptr)) return MOSQ_ERR_INVAL;
        -: 1182:#else
    #####: 1183:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1184:#endif
    #####: 1185:				}else if(!strcmp(token, "cleansession")){
        -: 1186:#ifdef WITH_BRIDGE
        -: 1187:					if(reload) continue; // FIXME
        -: 1188:					if(!cur_bridge){
        -: 1189:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1190:						return MOSQ_ERR_INVAL;
        -: 1191:					}
        -: 1192:					if(conf__parse_bool(&token, "cleansession", &cur_bridge->clean_start, saveptr)) return MOSQ_ERR_INVAL;
        -: 1193:#else
    #####: 1194:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1195:#endif
    #####: 1196:				}else if(!strcmp(token, "clientid_prefixes")){
    #####: 1197:					if(reload){
    #####: 1198:						mosquitto__free(config->clientid_prefixes);
    #####: 1199:						config->clientid_prefixes = NULL;
    #####: 1200:					}
    #####: 1201:					if(conf__parse_string(&token, "clientid_prefixes", &config->clientid_prefixes, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1202:				}else if(!strcmp(token, "connection")){
        -: 1203:#ifdef WITH_BRIDGE
        -: 1204:					if(reload) continue; // FIXME
        -: 1205:					token = strtok_r(NULL, " ", &saveptr);
        -: 1206:					if(token){
        -: 1207:						/* Check for existing bridge name. */
        -: 1208:						for(i=0; i<config->bridge_count; i++){
        -: 1209:							if(!strcmp(config->bridges[i].name, token)){
        -: 1210:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Duplicate bridge name \"%s\".", token);
        -: 1211:								return MOSQ_ERR_INVAL;
        -: 1212:							}
        -: 1213:						}
        -: 1214:
        -: 1215:						config->bridge_count++;
        -: 1216:						config->bridges = mosquitto__realloc(config->bridges, config->bridge_count*sizeof(struct mosquitto__bridge));
        -: 1217:						if(!config->bridges){
        -: 1218:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 1219:							return MOSQ_ERR_NOMEM;
        -: 1220:						}
        -: 1221:						cur_bridge = &(config->bridges[config->bridge_count-1]);
        -: 1222:						memset(cur_bridge, 0, sizeof(struct mosquitto__bridge));
        -: 1223:						cur_bridge->name = mosquitto__strdup(token);
        -: 1224:						if(!cur_bridge->name){
        -: 1225:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 1226:							return MOSQ_ERR_NOMEM;
        -: 1227:						}
        -: 1228:						cur_bridge->keepalive = 60;
        -: 1229:						cur_bridge->notifications = true;
        -: 1230:						cur_bridge->notifications_local_only = false;
        -: 1231:						cur_bridge->start_type = bst_automatic;
        -: 1232:						cur_bridge->idle_timeout = 60;
        -: 1233:						cur_bridge->restart_timeout = 0;
        -: 1234:						cur_bridge->backoff_base = 5;
        -: 1235:						cur_bridge->backoff_cap = 30;
        -: 1236:						cur_bridge->threshold = 10;
        -: 1237:						cur_bridge->try_private = true;
        -: 1238:						cur_bridge->attempt_unsubscribe = true;
        -: 1239:						cur_bridge->protocol_version = mosq_p_mqtt311;
        -: 1240:						cur_bridge->primary_retry_sock = INVALID_SOCKET;
        -: 1241:					}else{
        -: 1242:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty connection value in configuration.");
        -: 1243:						return MOSQ_ERR_INVAL;
        -: 1244:					}
        -: 1245:#else
    #####: 1246:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1247:#endif
    #####: 1248:				}else if(!strcmp(token, "connection_messages")){
    #####: 1249:					if(conf__parse_bool(&token, token, &config->connection_messages, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1250:				}else if(!strcmp(token, "crlfile")){
        -: 1251:#ifdef WITH_TLS
    #####: 1252:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1253:					if(conf__parse_string(&token, "crlfile", &cur_listener->crlfile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1254:#else
        -: 1255:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1256:#endif
    #####: 1257:				}else if(!strcmp(token, "dhparamfile")){
        -: 1258:#ifdef WITH_TLS
    #####: 1259:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1260:					if(conf__parse_string(&token, "dhparamfile", &cur_listener->dhparamfile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1261:#else
        -: 1262:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1263:#endif
    #####: 1264:				}else if(!strcmp(token, "http_dir")){
        -: 1265:#ifdef WITH_WEBSOCKETS
        -: 1266:					if(reload) continue; // Listeners not valid for reloading.
        -: 1267:					if(conf__parse_string(&token, "http_dir", &cur_listener->http_dir, saveptr)) return MOSQ_ERR_INVAL;
        -: 1268:#else
    #####: 1269:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Websockets support not available.");
        -: 1270:#endif
    #####: 1271:				}else if(!strcmp(token, "idle_timeout")){
        -: 1272:#ifdef WITH_BRIDGE
        -: 1273:					if(reload) continue; // FIXME
        -: 1274:					if(!cur_bridge){
        -: 1275:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1276:						return MOSQ_ERR_INVAL;
        -: 1277:					}
        -: 1278:					if(conf__parse_int(&token, "idle_timeout", &cur_bridge->idle_timeout, saveptr)) return MOSQ_ERR_INVAL;
        -: 1279:					if(cur_bridge->idle_timeout < 1){
        -: 1280:						log__printf(NULL, MOSQ_LOG_NOTICE, "idle_timeout interval too low, using 1 second.");
        -: 1281:						cur_bridge->idle_timeout = 1;
        -: 1282:					}
        -: 1283:#else
    #####: 1284:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1285:#endif
    #####: 1286:				}else if(!strcmp(token, "include_dir")){
    #####: 1287:					if(level == 0){
        -: 1288:						/* Only process include_dir from the main config file. */
    #####: 1289:						token = strtok_r(NULL, "", &saveptr);
    #####: 1290:						if(!token){
    #####: 1291:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty include_dir value in configuration.");
    #####: 1292:							return 1;
        -: 1293:						}
        -: 1294:
        -: 1295:						char **files;
        -: 1296:						int file_count;
    #####: 1297:						rc = config__get_dir_files(token, &files, &file_count);
    #####: 1298:						if(rc) return rc;
        -: 1299:
    #####: 1300:						for(i=0; i<file_count; i++){
    #####: 1301:							log__printf(NULL, MOSQ_LOG_INFO, "Loading config file %s", files[i]);
        -: 1302:
    #####: 1303:							rc = config__read_file(config, reload, files[i], cr, level+1, &lineno_ext);
    #####: 1304:							if(rc){
    #####: 1305:								if(lineno_ext > 0){
    #####: 1306:									log__printf(NULL, MOSQ_LOG_ERR, "Error found at %s:%d.", files[i], lineno_ext);
    #####: 1307:								}
        -: 1308:								/* Free happens below */
    #####: 1309:								break;
        -: 1310:							}
    #####: 1311:						}
    #####: 1312:						for(i=0; i<file_count; i++){
    #####: 1313:							mosquitto__free(files[i]);
    #####: 1314:						}
    #####: 1315:						mosquitto__free(files);
    #####: 1316:						if(rc) return rc; /* This returns if config__read_file() fails above */
    #####: 1317:					}
    #####: 1318:				}else if(!strcmp(token, "keepalive_interval")){
        -: 1319:#ifdef WITH_BRIDGE
        -: 1320:					if(reload) continue; // FIXME
        -: 1321:					if(!cur_bridge){
        -: 1322:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1323:						return MOSQ_ERR_INVAL;
        -: 1324:					}
        -: 1325:					if(conf__parse_int(&token, "keepalive_interval", &cur_bridge->keepalive, saveptr)) return MOSQ_ERR_INVAL;
        -: 1326:					if(cur_bridge->keepalive < 5){
        -: 1327:						log__printf(NULL, MOSQ_LOG_NOTICE, "keepalive interval too low, using 5 seconds.");
        -: 1328:						cur_bridge->keepalive = 5;
        -: 1329:					}
        -: 1330:#else
    #####: 1331:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1332:#endif
    #####: 1333:				}else if(!strcmp(token, "keyfile")){
        -: 1334:#ifdef WITH_TLS
    #####: 1335:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1336:					if(conf__parse_string(&token, "keyfile", &cur_listener->keyfile, saveptr)) return MOSQ_ERR_INVAL;
        -: 1337:#else
        -: 1338:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1339:#endif
    #####: 1340:				}else if(!strcmp(token, "listener")){
    #####: 1341:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1342:					if(token){
    #####: 1343:						tmp_int = atoi(token);
    #####: 1344:						if(tmp_int < 1 || tmp_int > 65535){
    #####: 1345:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid port value (%d).", tmp_int);
    #####: 1346:							return MOSQ_ERR_INVAL;
        -: 1347:						}
        -: 1348:
    #####: 1349:						if(reload){
        -: 1350:							/* We reload listeners settings based on port number.
        -: 1351:							 * If the port number doesn't already exist, exit with a complaint. */
    #####: 1352:							cur_listener = NULL;
    #####: 1353:							for(i=0; i<config->listener_count; i++){
    #####: 1354:								if(config->listeners[i].port == tmp_int){
    #####: 1355:									cur_listener = &config->listeners[i];
    #####: 1356:								}
    #####: 1357:							}
    #####: 1358:							if(!cur_listener){
    #####: 1359:								log__printf(NULL, MOSQ_LOG_ERR, "Error: It is not currently possible to add/remove listeners when reloading the config file.");
    #####: 1360:								return MOSQ_ERR_INVAL;
        -: 1361:							}
    #####: 1362:						}else{
    #####: 1363:							config->listener_count++;
    #####: 1364:							config->listeners = mosquitto__realloc(config->listeners, sizeof(struct mosquitto__listener)*config->listener_count);
    #####: 1365:							if(!config->listeners){
    #####: 1366:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####: 1367:								return MOSQ_ERR_NOMEM;
        -: 1368:							}
    #####: 1369:							cur_listener = &config->listeners[config->listener_count-1];
    #####: 1370:							memset(cur_listener, 0, sizeof(struct mosquitto__listener));
        -: 1371:						}
        -: 1372:
    #####: 1373:						cur_listener->security_options.allow_anonymous = -1;
    #####: 1374:						cur_listener->security_options.allow_zero_length_clientid = true;
    #####: 1375:						cur_listener->protocol = mp_mqtt;
    #####: 1376:						cur_listener->port = tmp_int;
    #####: 1377:						cur_listener->maximum_qos = 2;
    #####: 1378:						cur_listener->max_topic_alias = 10;
    #####: 1379:						token = strtok_r(NULL, " ", &saveptr);
    #####: 1380:						if (token != NULL && token[0] == '#'){
    #####: 1381:							token = NULL;
    #####: 1382:						}
    #####: 1383:						mosquitto__free(cur_listener->host);
    #####: 1384:						if(token){
    #####: 1385:							cur_listener->host = mosquitto__strdup(token);
    #####: 1386:						}else{
    #####: 1387:							cur_listener->host = NULL;
        -: 1388:						}
    #####: 1389:					}else{
    #####: 1390:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty listener value in configuration.");
    #####: 1391:						return MOSQ_ERR_INVAL;
        -: 1392:					}
    #####: 1393:				}else if(!strcmp(token, "local_clientid")){
        -: 1394:#ifdef WITH_BRIDGE
        -: 1395:					if(reload) continue; // FIXME
        -: 1396:					if(!cur_bridge){
        -: 1397:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1398:						return MOSQ_ERR_INVAL;
        -: 1399:					}
        -: 1400:					if(conf__parse_string(&token, "bridge local clientd", &cur_bridge->local_clientid, saveptr)) return MOSQ_ERR_INVAL;
        -: 1401:#else
    #####: 1402:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1403:#endif
    #####: 1404:				}else if(!strcmp(token, "local_password")){
        -: 1405:#ifdef WITH_BRIDGE
        -: 1406:					if(reload) continue; // FIXME
        -: 1407:					if(!cur_bridge){
        -: 1408:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1409:						return MOSQ_ERR_INVAL;
        -: 1410:					}
        -: 1411:					if(conf__parse_string(&token, "bridge local_password", &cur_bridge->local_password, saveptr)) return MOSQ_ERR_INVAL;
        -: 1412:#else
    #####: 1413:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1414:#endif
    #####: 1415:				}else if(!strcmp(token, "local_username")){
        -: 1416:#ifdef WITH_BRIDGE
        -: 1417:					if(reload) continue; // FIXME
        -: 1418:					if(!cur_bridge){
        -: 1419:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1420:						return MOSQ_ERR_INVAL;
        -: 1421:					}
        -: 1422:					if(conf__parse_string(&token, "bridge local_username", &cur_bridge->local_username, saveptr)) return MOSQ_ERR_INVAL;
        -: 1423:#else
    #####: 1424:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1425:#endif
    #####: 1426:				}else if(!strcmp(token, "log_dest")){
    #####: 1427:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1428:					if(token){
    #####: 1429:						cr->log_dest_set = 1;
    #####: 1430:						if(!strcmp(token, "none")){
    #####: 1431:							cr->log_dest = MQTT3_LOG_NONE;
    #####: 1432:						}else if(!strcmp(token, "syslog")){
    #####: 1433:							cr->log_dest |= MQTT3_LOG_SYSLOG;
    #####: 1434:						}else if(!strcmp(token, "stdout")){
    #####: 1435:							cr->log_dest |= MQTT3_LOG_STDOUT;
    #####: 1436:						}else if(!strcmp(token, "stderr")){
    #####: 1437:							cr->log_dest |= MQTT3_LOG_STDERR;
    #####: 1438:						}else if(!strcmp(token, "topic")){
    #####: 1439:							cr->log_dest |= MQTT3_LOG_TOPIC;
    #####: 1440:						}else if(!strcmp(token, "file")){
    #####: 1441:							cr->log_dest |= MQTT3_LOG_FILE;
    #####: 1442:							if(config->log_fptr || config->log_file){
    #####: 1443:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Duplicate \"log_dest file\" value.");
    #####: 1444:								return MOSQ_ERR_INVAL;
        -: 1445:							}
        -: 1446:							/* Get remaining string. */
    #####: 1447:							token = &token[strlen(token)+1];
    #####: 1448:							while(token[0] == ' ' || token[0] == '\t'){
    #####: 1449:								token++;
        -: 1450:							}
    #####: 1451:							if(token[0]){
    #####: 1452:								config->log_file = mosquitto__strdup(token);
    #####: 1453:								if(!config->log_file){
    #####: 1454:									log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####: 1455:									return MOSQ_ERR_NOMEM;
        -: 1456:								}
    #####: 1457:							}else{
    #####: 1458:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty \"log_dest file\" value in configuration.");
    #####: 1459:								return MOSQ_ERR_INVAL;
        -: 1460:							}
    #####: 1461:						}else{
    #####: 1462:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid log_dest value (%s).", token);
    #####: 1463:							return MOSQ_ERR_INVAL;
        -: 1464:						}
        -: 1465:#if defined(WIN32) || defined(__CYGWIN__)
        -: 1466:						if(service_handle){
        -: 1467:							if(cr->log_dest == MQTT3_LOG_STDOUT || cr->log_dest == MQTT3_LOG_STDERR){
        -: 1468:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Cannot log to stdout/stderr when running as a Windows service.");
        -: 1469:								return MOSQ_ERR_INVAL;
        -: 1470:							}
        -: 1471:						}
        -: 1472:#endif
    #####: 1473:					}else{
    #####: 1474:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty log_dest value in configuration.");
    #####: 1475:						return MOSQ_ERR_INVAL;
        -: 1476:					}
    #####: 1477:				}else if(!strcmp(token, "log_facility")){
        -: 1478:#if defined(WIN32) || defined(__CYGWIN__)
        -: 1479:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: log_facility not supported on Windows.");
        -: 1480:#else
    #####: 1481:					if(conf__parse_int(&token, "log_facility", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1482:					switch(tmp_int){
        -: 1483:						case 0:
    #####: 1484:							config->log_facility = LOG_LOCAL0;
    #####: 1485:							break;
        -: 1486:						case 1:
    #####: 1487:							config->log_facility = LOG_LOCAL1;
    #####: 1488:							break;
        -: 1489:						case 2:
    #####: 1490:							config->log_facility = LOG_LOCAL2;
    #####: 1491:							break;
        -: 1492:						case 3:
    #####: 1493:							config->log_facility = LOG_LOCAL3;
    #####: 1494:							break;
        -: 1495:						case 4:
    #####: 1496:							config->log_facility = LOG_LOCAL4;
    #####: 1497:							break;
        -: 1498:						case 5:
    #####: 1499:							config->log_facility = LOG_LOCAL5;
    #####: 1500:							break;
        -: 1501:						case 6:
    #####: 1502:							config->log_facility = LOG_LOCAL6;
    #####: 1503:							break;
        -: 1504:						case 7:
    #####: 1505:							config->log_facility = LOG_LOCAL7;
    #####: 1506:							break;
        -: 1507:						default:
    #####: 1508:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid log_facility value (%d).", tmp_int);
    #####: 1509:							return MOSQ_ERR_INVAL;
        -: 1510:					}
        -: 1511:#endif
    #####: 1512:				}else if(!strcmp(token, "log_timestamp")){
    #####: 1513:					if(conf__parse_bool(&token, token, &config->log_timestamp, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1514:				}else if(!strcmp(token, "log_timestamp_format")){
    #####: 1515:					if(conf__parse_string(&token, token, &config->log_timestamp_format, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1516:				}else if(!strcmp(token, "log_type")){
    #####: 1517:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1518:					if(token){
    #####: 1519:						cr->log_type_set = 1;
    #####: 1520:						if(!strcmp(token, "none")){
    #####: 1521:							cr->log_type = MOSQ_LOG_NONE;
    #####: 1522:						}else if(!strcmp(token, "information")){
    #####: 1523:							cr->log_type |= MOSQ_LOG_INFO;
    #####: 1524:						}else if(!strcmp(token, "notice")){
    #####: 1525:							cr->log_type |= MOSQ_LOG_NOTICE;
    #####: 1526:						}else if(!strcmp(token, "warning")){
    #####: 1527:							cr->log_type |= MOSQ_LOG_WARNING;
    #####: 1528:						}else if(!strcmp(token, "error")){
    #####: 1529:							cr->log_type |= MOSQ_LOG_ERR;
    #####: 1530:						}else if(!strcmp(token, "debug")){
    #####: 1531:							cr->log_type |= MOSQ_LOG_DEBUG;
    #####: 1532:						}else if(!strcmp(token, "subscribe")){
    #####: 1533:							cr->log_type |= MOSQ_LOG_SUBSCRIBE;
    #####: 1534:						}else if(!strcmp(token, "unsubscribe")){
    #####: 1535:							cr->log_type |= MOSQ_LOG_UNSUBSCRIBE;
    #####: 1536:						}else if(!strcmp(token, "internal")){
    #####: 1537:							cr->log_type |= MOSQ_LOG_INTERNAL;
        -: 1538:#ifdef WITH_WEBSOCKETS
        -: 1539:						}else if(!strcmp(token, "websockets")){
        -: 1540:							cr->log_type |= MOSQ_LOG_WEBSOCKETS;
        -: 1541:#endif
    #####: 1542:						}else if(!strcmp(token, "all")){
    #####: 1543:							cr->log_type = MOSQ_LOG_ALL;
    #####: 1544:						}else{
    #####: 1545:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid log_type value (%s).", token);
    #####: 1546:							return MOSQ_ERR_INVAL;
        -: 1547:						}
    #####: 1548:					}else{
    #####: 1549:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty log_type value in configuration.");
        -: 1550:					}
    #####: 1551:				}else if(!strcmp(token, "max_connections")){
    #####: 1552:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1553:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1554:					if(token){
    #####: 1555:						cur_listener->max_connections = atoi(token);
    #####: 1556:						if(cur_listener->max_connections < 0) cur_listener->max_connections = -1;
    #####: 1557:					}else{
    #####: 1558:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty max_connections value in configuration.");
        -: 1559:					}
    #####: 1560:				}else if(!strcmp(token, "maximum_qos")){
    #####: 1561:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1562:					if(conf__parse_int(&token, "maximum_qos", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1563:					if(tmp_int < 0 || tmp_int > 2){
    #####: 1564:						log__printf(NULL, MOSQ_LOG_ERR, "Error: maximum_qos must be between 0 and 2 inclusive.");
    #####: 1565:						return MOSQ_ERR_INVAL;
        -: 1566:					}
    #####: 1567:					cur_listener->maximum_qos = tmp_int;
    #####: 1568:				}else if(!strcmp(token, "max_inflight_bytes")){
    #####: 1569:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1570:					if(token){
    #####: 1571:						cr->max_inflight_bytes = atol(token);
    #####: 1572:					}else{
    #####: 1573:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty max_inflight_bytes value in configuration.");
        -: 1574:					}
    #####: 1575:				}else if(!strcmp(token, "max_inflight_messages")){
    #####: 1576:					if(conf__parse_int(&token, "max_inflight_messages", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1577:					if(tmp_int < 0 || tmp_int == 65535){
    #####: 1578:						tmp_int = 0;
    #####: 1579:					}else if(tmp_int > 65535){
    #####: 1580:						log__printf(NULL, MOSQ_LOG_ERR, "Error: max_inflight_messages must be <= 65535.");
    #####: 1581:						return MOSQ_ERR_INVAL;
        -: 1582:					}
    #####: 1583:					config->max_inflight_messages = tmp_int;
    #####: 1584:				}else if(!strcmp(token, "max_keepalive")){
    #####: 1585:					if(conf__parse_int(&token, "max_keepalive", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1586:					if(tmp_int < 10 || tmp_int > 65535){
    #####: 1587:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid max_keepalive value (%d).", tmp_int);
    #####: 1588:						return MOSQ_ERR_INVAL;
        -: 1589:					}
    #####: 1590:					config->max_keepalive = tmp_int;
    #####: 1591:				}else if(!strcmp(token, "max_packet_size")){
    #####: 1592:					if(conf__parse_int(&token, "max_packet_size", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1593:					if(tmp_int < 20){
    #####: 1594:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid max_packet_size value (%d).", tmp_int);
    #####: 1595:						return MOSQ_ERR_INVAL;
        -: 1596:					}
    #####: 1597:					config->max_packet_size = tmp_int;
    #####: 1598:				}else if(!strcmp(token, "max_queued_bytes")){
    #####: 1599:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1600:					if(token){
    #####: 1601:						cr->max_queued_bytes = atol(token); /* 63 bits is ok right? */
    #####: 1602:					}else{
    #####: 1603:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty max_queued_bytes value in configuration.");
        -: 1604:					}
    #####: 1605:				}else if(!strcmp(token, "max_queued_messages")){
    #####: 1606:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1607:					if(token){
    #####: 1608:						cr->max_queued_messages = atoi(token);
    #####: 1609:						if(cr->max_queued_messages < 0) cr->max_queued_messages = 0;
    #####: 1610:					}else{
    #####: 1611:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty max_queued_messages value in configuration.");
        -: 1612:					}
    #####: 1613:				}else if(!strcmp(token, "memory_limit")){
        -: 1614:					ssize_t lim;
    #####: 1615:					if(conf__parse_ssize_t(&token, "memory_limit", &lim, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1616:					if(lim < 0){
    #####: 1617:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid memory_limit value (%ld).", lim);
    #####: 1618:						return MOSQ_ERR_INVAL;
        -: 1619:					}
    #####: 1620:					memory__set_limit(lim);
    #####: 1621:				}else if(!strcmp(token, "message_size_limit")){
    #####: 1622:					if(conf__parse_int(&token, "message_size_limit", (int *)&config->message_size_limit, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1623:					if(config->message_size_limit > MQTT_MAX_PAYLOAD){
    #####: 1624:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid message_size_limit value (%u).", config->message_size_limit);
    #####: 1625:						return MOSQ_ERR_INVAL;
        -: 1626:					}
    #####: 1627:				}else if(!strcmp(token, "mount_point")){
    #####: 1628:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1629:					if(config->listener_count == 0){
    #####: 1630:						log__printf(NULL, MOSQ_LOG_ERR, "Error: You must use create a listener before using the mount_point option in the configuration file.");
    #####: 1631:						return MOSQ_ERR_INVAL;
        -: 1632:					}
    #####: 1633:					if(conf__parse_string(&token, "mount_point", &cur_listener->mount_point, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1634:					if(mosquitto_pub_topic_check(cur_listener->mount_point) != MOSQ_ERR_SUCCESS){
    #####: 1635:						log__printf(NULL, MOSQ_LOG_ERR,
        -: 1636:								"Error: Invalid mount_point '%s'. Does it contain a wildcard character?",
    #####: 1637:								cur_listener->mount_point);
    #####: 1638:						return MOSQ_ERR_INVAL;
        -: 1639:					}
    #####: 1640:				}else if(!strcmp(token, "notifications")){
        -: 1641:#ifdef WITH_BRIDGE
        -: 1642:					if(reload) continue; // FIXME
        -: 1643:					if(!cur_bridge){
        -: 1644:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1645:						return MOSQ_ERR_INVAL;
        -: 1646:					}
        -: 1647:					if(conf__parse_bool(&token, "notifications", &cur_bridge->notifications, saveptr)) return MOSQ_ERR_INVAL;
        -: 1648:#else
    #####: 1649:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1650:#endif
    #####: 1651:				}else if(!strcmp(token, "notifications_local_only")){
        -: 1652:#ifdef WITH_BRIDGE
        -: 1653:					if(reload) continue; // FIXME
        -: 1654:					if(!cur_bridge){
        -: 1655:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration");
        -: 1656:						return MOSQ_ERR_INVAL;
        -: 1657:					}
        -: 1658:					if(conf__parse_bool(&token, "notifications_local_only", &cur_bridge->notifications_local_only, saveptr)) return MOSQ_ERR_INVAL;
        -: 1659:#else
    #####: 1660:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1661:#endif
    #####: 1662:				}else if(!strcmp(token, "notification_topic")){
        -: 1663:#ifdef WITH_BRIDGE
        -: 1664:					if(reload) continue; // FIXME
        -: 1665:					if(!cur_bridge){
        -: 1666:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1667:						return MOSQ_ERR_INVAL;
        -: 1668:					}
        -: 1669:					if(conf__parse_string(&token, "notification_topic", &cur_bridge->notification_topic, saveptr)) return MOSQ_ERR_INVAL;
        -: 1670:#else
    #####: 1671:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1672:#endif
    #####: 1673:				}else if(!strcmp(token, "password") || !strcmp(token, "remote_password")){
        -: 1674:#ifdef WITH_BRIDGE
        -: 1675:					if(reload) continue; // FIXME
        -: 1676:					if(!cur_bridge){
        -: 1677:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1678:						return MOSQ_ERR_INVAL;
        -: 1679:					}
        -: 1680:					if(conf__parse_string(&token, "bridge remote_password", &cur_bridge->remote_password, saveptr)) return MOSQ_ERR_INVAL;
        -: 1681:#else
    #####: 1682:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1683:#endif
    #####: 1684:				}else if(!strcmp(token, "password_file")){
    #####: 1685:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
    #####: 1686:					if(reload){
    #####: 1687:						mosquitto__free(cur_security_options->password_file);
    #####: 1688:						cur_security_options->password_file = NULL;
    #####: 1689:					}
    #####: 1690:					if(conf__parse_string(&token, "password_file", &cur_security_options->password_file, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1691:				}else if(!strcmp(token, "per_listener_settings")){
    #####: 1692:					if(conf__parse_bool(&token, "per_listener_settings", &config->per_listener_settings, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1693:					if(cur_security_options && config->per_listener_settings){
    #####: 1694:						log__printf(NULL, MOSQ_LOG_ERR, "Error: per_listener_settings must be set before any other security settings.");
    #####: 1695:						return MOSQ_ERR_INVAL;
        -: 1696:					}
    #####: 1697:				}else if(!strcmp(token, "persistence") || !strcmp(token, "retained_persistence")){
    #####: 1698:					if(conf__parse_bool(&token, token, &config->persistence, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1699:				}else if(!strcmp(token, "persistence_file")){
    #####: 1700:					if(conf__parse_string(&token, "persistence_file", &config->persistence_file, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1701:				}else if(!strcmp(token, "persistence_location")){
    #####: 1702:					if(conf__parse_string(&token, "persistence_location", &config->persistence_location, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1703:				}else if(!strcmp(token, "persistent_client_expiration")){
    #####: 1704:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1705:					if(token){
    #####: 1706:						switch(token[strlen(token)-1]){
        -: 1707:							case 'h':
    #####: 1708:								expiration_mult = 3600;
    #####: 1709:								break;
        -: 1710:							case 'd':
    #####: 1711:								expiration_mult = 86400;
    #####: 1712:								break;
        -: 1713:							case 'w':
    #####: 1714:								expiration_mult = 86400*7;
    #####: 1715:								break;
        -: 1716:							case 'm':
    #####: 1717:								expiration_mult = 86400*30;
    #####: 1718:								break;
        -: 1719:							case 'y':
    #####: 1720:								expiration_mult = 86400*365;
    #####: 1721:								break;
        -: 1722:							default:
    #####: 1723:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid persistent_client_expiration duration in configuration.");
    #####: 1724:								return MOSQ_ERR_INVAL;
        -: 1725:						}
    #####: 1726:						token[strlen(token)-1] = '\0';
    #####: 1727:						config->persistent_client_expiration = atoi(token)*expiration_mult;
    #####: 1728:						if(config->persistent_client_expiration <= 0){
    #####: 1729:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid persistent_client_expiration duration in configuration.");
    #####: 1730:							return MOSQ_ERR_INVAL;
        -: 1731:						}
    #####: 1732:					}else{
    #####: 1733:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty persistent_client_expiration value in configuration.");
        -: 1734:					}
    #####: 1735:				}else if(!strcmp(token, "pid_file")){
    #####: 1736:					if(reload) continue; // pid file not valid for reloading.
    #####: 1737:					if(conf__parse_string(&token, "pid_file", &config->pid_file, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1738:				}else if(!strcmp(token, "port")){
    #####: 1739:					if(reload) continue; // Listener not valid for reloading.
    #####: 1740:					if(config->default_listener.port){
    #####: 1741:						log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Default listener port specified multiple times. Only the latest will be used.");
    #####: 1742:					}
    #####: 1743:					if(conf__parse_int(&token, "port", &tmp_int, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1744:					if(tmp_int < 1 || tmp_int > 65535){
    #####: 1745:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid port value (%d).", tmp_int);
    #####: 1746:						return MOSQ_ERR_INVAL;
        -: 1747:					}
    #####: 1748:					config->default_listener.port = tmp_int;
    #####: 1749:				}else if(!strcmp(token, "protocol")){
    #####: 1750:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1751:					if(token){
    #####: 1752:						if(!strcmp(token, "mqtt")){
    #####: 1753:							cur_listener->protocol = mp_mqtt;
        -: 1754:						/*
        -: 1755:						}else if(!strcmp(token, "mqttsn")){
        -: 1756:							cur_listener->protocol = mp_mqttsn;
        -: 1757:						*/
    #####: 1758:						}else if(!strcmp(token, "websockets")){
        -: 1759:#ifdef WITH_WEBSOCKETS
        -: 1760:							cur_listener->protocol = mp_websockets;
        -: 1761:							config->have_websockets_listener = true;
        -: 1762:#else
    #####: 1763:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Websockets support not available.");
    #####: 1764:							return MOSQ_ERR_INVAL;
        -: 1765:#endif
        -: 1766:						}else{
    #####: 1767:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid protocol value (%s).", token);
    #####: 1768:							return MOSQ_ERR_INVAL;
        -: 1769:						}
    #####: 1770:					}else{
    #####: 1771:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty protocol value in configuration.");
        -: 1772:					}
    #####: 1773:				}else if(!strcmp(token, "psk_file")){
        -: 1774:#ifdef FINAL_WITH_TLS_PSK
        -: 1775:					conf__set_cur_security_options(config, cur_listener, &cur_security_options);
        -: 1776:					if(reload){
        -: 1777:						mosquitto__free(cur_security_options->psk_file);
        -: 1778:						cur_security_options->psk_file = NULL;
        -: 1779:					}
        -: 1780:					if(conf__parse_string(&token, "psk_file", &cur_security_options->psk_file, saveptr)) return MOSQ_ERR_INVAL;
        -: 1781:#else
    #####: 1782:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS/TLS-PSK support not available.");
        -: 1783:#endif
    #####: 1784:				}else if(!strcmp(token, "psk_hint")){
        -: 1785:#ifdef FINAL_WITH_TLS_PSK
        -: 1786:					if(reload) continue; // Listeners not valid for reloading.
        -: 1787:					if(conf__parse_string(&token, "psk_hint", &cur_listener->psk_hint, saveptr)) return MOSQ_ERR_INVAL;
        -: 1788:#else
    #####: 1789:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS/TLS-PSK support not available.");
        -: 1790:#endif
    #####: 1791:				}else if(!strcmp(token, "queue_qos0_messages")){
    #####: 1792:					if(conf__parse_bool(&token, token, &config->queue_qos0_messages, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1793:				}else if(!strcmp(token, "require_certificate")){
        -: 1794:#ifdef WITH_TLS
    #####: 1795:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1796:					if(conf__parse_bool(&token, "require_certificate", &cur_listener->require_certificate, saveptr)) return MOSQ_ERR_INVAL;
        -: 1797:#else
        -: 1798:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1799:#endif
    #####: 1800:				}else if(!strcmp(token, "restart_timeout")){
        -: 1801:#ifdef WITH_BRIDGE
        -: 1802:					if(reload) continue; // FIXME
        -: 1803:					if(!cur_bridge){
        -: 1804:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1805:						return MOSQ_ERR_INVAL;
        -: 1806:					}
        -: 1807:					token = strtok_r(NULL, " ", &saveptr);
        -: 1808:					if(!token){
        -: 1809:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty restart_timeout value in configuration.");
        -: 1810:						return MOSQ_ERR_INVAL;
        -: 1811:					}
        -: 1812:					cur_bridge->restart_timeout = atoi(token);
        -: 1813:					if(cur_bridge->restart_timeout < 1){
        -: 1814:						log__printf(NULL, MOSQ_LOG_NOTICE, "restart_timeout interval too low, using 1 second.");
        -: 1815:						cur_bridge->restart_timeout = 1;
        -: 1816:					}
        -: 1817:					token = strtok_r(NULL, " ", &saveptr);
        -: 1818:					if(token){
        -: 1819:						cur_bridge->backoff_base = cur_bridge->restart_timeout;
        -: 1820:						cur_bridge->backoff_cap = atoi(token);
        -: 1821:						if(cur_bridge->backoff_cap < cur_bridge->backoff_base){
        -: 1822:							log__printf(NULL, MOSQ_LOG_ERR, "Error: backoff cap is lower than the base in restart_timeout.");
        -: 1823:							return MOSQ_ERR_INVAL;
        -: 1824:						}
        -: 1825:					}
        -: 1826:#else
    #####: 1827:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1828:#endif
    #####: 1829:				}else if(!strcmp(token, "retain_available")){
    #####: 1830:					if(conf__parse_bool(&token, token, &config->retain_available, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1831:				}else if(!strcmp(token, "retry_interval")){
    #####: 1832:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: The retry_interval option is no longer available.");
    #####: 1833:				}else if(!strcmp(token, "round_robin")){
        -: 1834:#ifdef WITH_BRIDGE
        -: 1835:					if(reload) continue; // FIXME
        -: 1836:					if(!cur_bridge){
        -: 1837:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1838:						return MOSQ_ERR_INVAL;
        -: 1839:					}
        -: 1840:					if(conf__parse_bool(&token, "round_robin", &cur_bridge->round_robin, saveptr)) return MOSQ_ERR_INVAL;
        -: 1841:#else
    #####: 1842:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1843:#endif
    #####: 1844:				}else if(!strcmp(token, "set_tcp_nodelay")){
    #####: 1845:					if(conf__parse_bool(&token, "set_tcp_nodelay", &config->set_tcp_nodelay, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1846:				}else if(!strcmp(token, "start_type")){
        -: 1847:#ifdef WITH_BRIDGE
        -: 1848:					if(reload) continue; // FIXME
        -: 1849:					if(!cur_bridge){
        -: 1850:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1851:						return MOSQ_ERR_INVAL;
        -: 1852:					}
        -: 1853:					token = strtok_r(NULL, " ", &saveptr);
        -: 1854:					if(token){
        -: 1855:						if(!strcmp(token, "automatic")){
        -: 1856:							cur_bridge->start_type = bst_automatic;
        -: 1857:						}else if(!strcmp(token, "lazy")){
        -: 1858:							cur_bridge->start_type = bst_lazy;
        -: 1859:						}else if(!strcmp(token, "manual")){
        -: 1860:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Manual start_type not supported.");
        -: 1861:							return MOSQ_ERR_INVAL;
        -: 1862:						}else if(!strcmp(token, "once")){
        -: 1863:							cur_bridge->start_type = bst_once;
        -: 1864:						}else{
        -: 1865:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid start_type value in configuration (%s).", token);
        -: 1866:							return MOSQ_ERR_INVAL;
        -: 1867:						}
        -: 1868:					}else{
        -: 1869:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty start_type value in configuration.");
        -: 1870:						return MOSQ_ERR_INVAL;
        -: 1871:					}
        -: 1872:#else
    #####: 1873:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1874:#endif
    #####: 1875:				}else if(!strcmp(token, "socket_domain")){
    #####: 1876:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1877:					token = strtok_r(NULL, " ", &saveptr);
    #####: 1878:					if(token){
    #####: 1879:						if(!strcmp(token, "ipv4")){
    #####: 1880:							cur_listener->socket_domain = AF_INET;
    #####: 1881:						}else if(!strcmp(token, "ipv6")){
    #####: 1882:							cur_listener->socket_domain = AF_INET6;
    #####: 1883:						}else{
    #####: 1884:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid socket_domain value \"%s\" in configuration.", token);
    #####: 1885:							return MOSQ_ERR_INVAL;
        -: 1886:						}
    #####: 1887:					}else{
    #####: 1888:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty socket_domain value in configuration.");
    #####: 1889:						return MOSQ_ERR_INVAL;
        -: 1890:					}
    #####: 1891:				}else if(!strcmp(token, "store_clean_interval")){
    #####: 1892:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: store_clean_interval is no longer needed.");
    #####: 1893:				}else if(!strcmp(token, "sys_interval")){
    #####: 1894:					if(conf__parse_int(&token, "sys_interval", &config->sys_interval, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1895:					if(config->sys_interval < 0 || config->sys_interval > 65535){
    #####: 1896:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid sys_interval value (%d).", config->sys_interval);
    #####: 1897:						return MOSQ_ERR_INVAL;
        -: 1898:					}
    #####: 1899:				}else if(!strcmp(token, "threshold")){
        -: 1900:#ifdef WITH_BRIDGE
        -: 1901:					if(reload) continue; // FIXME
        -: 1902:					if(!cur_bridge){
        -: 1903:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1904:						return MOSQ_ERR_INVAL;
        -: 1905:					}
        -: 1906:					if(conf__parse_int(&token, "threshold", &cur_bridge->threshold, saveptr)) return MOSQ_ERR_INVAL;
        -: 1907:					if(cur_bridge->threshold < 1){
        -: 1908:						log__printf(NULL, MOSQ_LOG_NOTICE, "threshold too low, using 1 message.");
        -: 1909:						cur_bridge->threshold = 1;
        -: 1910:					}
        -: 1911:#else
    #####: 1912:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 1913:#endif
    #####: 1914:				}else if(!strcmp(token, "tls_engine")){
        -: 1915:#ifdef WITH_TLS
    #####: 1916:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1917:					if(conf__parse_string(&token, "tls_engine", &cur_listener->tls_engine, saveptr)) return MOSQ_ERR_INVAL;
        -: 1918:#else
        -: 1919:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1920:#endif
    #####: 1921:				}else if(!strcmp(token, "tls_engine_kpass_sha1")){
        -: 1922:#ifdef WITH_TLS
    #####: 1923:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1924:					char *kpass_sha = NULL, *kpass_sha_bin = NULL;
    #####: 1925:					if(conf__parse_string(&token, "tls_engine_kpass_sha1", &kpass_sha, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1926:					if(mosquitto__hex2bin_sha1(kpass_sha, (unsigned char**)&kpass_sha_bin) != MOSQ_ERR_SUCCESS){
    #####: 1927:						mosquitto__free(kpass_sha);
    #####: 1928:						return MOSQ_ERR_INVAL;
        -: 1929:					}
    #####: 1930:					cur_listener->tls_engine_kpass_sha1 = kpass_sha_bin;
    #####: 1931:					mosquitto__free(kpass_sha);
        -: 1932:#else
        -: 1933:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1934:#endif
    #####: 1935:				}else if(!strcmp(token, "tls_keyform")){
        -: 1936:#ifdef WITH_TLS
    #####: 1937:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1938:					char *keyform = NULL;
    #####: 1939:					if(conf__parse_string(&token, "tls_keyform", &keyform, saveptr)) return MOSQ_ERR_INVAL;
    #####: 1940:					cur_listener->tls_keyform = mosq_k_pem;
    #####: 1941:					if(!strcmp(keyform, "engine")) cur_listener->tls_keyform = mosq_k_engine;
    #####: 1942:					mosquitto__free(keyform);
        -: 1943:#else
        -: 1944:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1945:#endif
    #####: 1946:				}else if(!strcmp(token, "tls_version")){
        -: 1947:#if defined(WITH_TLS)
    #####: 1948:					if(reload) continue; // Listeners not valid for reloading.
    #####: 1949:					if(conf__parse_string(&token, "tls_version", &cur_listener->tls_version, saveptr)) return MOSQ_ERR_INVAL;
        -: 1950:#else
        -: 1951:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 1952:#endif
    #####: 1953:				}else if(!strcmp(token, "topic")){
        -: 1954:#ifdef WITH_BRIDGE
        -: 1955:					if(reload) continue; // FIXME
        -: 1956:					if(!cur_bridge){
        -: 1957:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 1958:						return MOSQ_ERR_INVAL;
        -: 1959:					}
        -: 1960:					token = strtok_r(NULL, " ", &saveptr);
        -: 1961:					if(token){
        -: 1962:						cur_bridge->topic_count++;
        -: 1963:						cur_bridge->topics = mosquitto__realloc(cur_bridge->topics,
        -: 1964:								sizeof(struct mosquitto__bridge_topic)*cur_bridge->topic_count);
        -: 1965:						if(!cur_bridge->topics){
        -: 1966:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 1967:							return MOSQ_ERR_NOMEM;
        -: 1968:						}
        -: 1969:						cur_topic = &cur_bridge->topics[cur_bridge->topic_count-1];
        -: 1970:						if(!strcmp(token, "\"\"")){
        -: 1971:							cur_topic->topic = NULL;
        -: 1972:						}else{
        -: 1973:							cur_topic->topic = mosquitto__strdup(token);
        -: 1974:							if(!cur_topic->topic){
        -: 1975:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 1976:								return MOSQ_ERR_NOMEM;
        -: 1977:							}
        -: 1978:						}
        -: 1979:						cur_topic->direction = bd_out;
        -: 1980:						cur_topic->qos = 0;
        -: 1981:						cur_topic->local_prefix = NULL;
        -: 1982:						cur_topic->remote_prefix = NULL;
        -: 1983:					}else{
        -: 1984:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty topic value in configuration.");
        -: 1985:						return MOSQ_ERR_INVAL;
        -: 1986:					}
        -: 1987:					token = strtok_r(NULL, " ", &saveptr);
        -: 1988:					if(token){
        -: 1989:						if(!strcasecmp(token, "out")){
        -: 1990:							cur_topic->direction = bd_out;
        -: 1991:						}else if(!strcasecmp(token, "in")){
        -: 1992:							cur_topic->direction = bd_in;
        -: 1993:						}else if(!strcasecmp(token, "both")){
        -: 1994:							cur_topic->direction = bd_both;
        -: 1995:						}else{
        -: 1996:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge topic direction '%s'.", token);
        -: 1997:							return MOSQ_ERR_INVAL;
        -: 1998:						}
        -: 1999:						token = strtok_r(NULL, " ", &saveptr);
        -: 2000:						if(token){
        -: 2001:							if (token[0] == '#'){
        -: 2002:								strtok_r(NULL, "", &saveptr);
        -: 2003:							}
        -: 2004:							cur_topic->qos = atoi(token);
        -: 2005:							if(cur_topic->qos < 0 || cur_topic->qos > 2){
        -: 2006:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge QoS level '%s'.", token);
        -: 2007:								return MOSQ_ERR_INVAL;
        -: 2008:							}
        -: 2009:
        -: 2010:							token = strtok_r(NULL, " ", &saveptr);
        -: 2011:							if(token){
        -: 2012:								cur_bridge->topic_remapping = true;
        -: 2013:								if(!strcmp(token, "\"\"") || token[0] == '#'){
        -: 2014:									cur_topic->local_prefix = NULL;
        -: 2015:									if (token[0] == '#'){
        -: 2016:										strtok_r(NULL, "", &saveptr);
        -: 2017:									}
        -: 2018:								}else{
        -: 2019:									if(mosquitto_pub_topic_check(token) != MOSQ_ERR_SUCCESS){
        -: 2020:										log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge topic local prefix '%s'.", token);
        -: 2021:										return MOSQ_ERR_INVAL;
        -: 2022:									}
        -: 2023:									cur_topic->local_prefix = mosquitto__strdup(token);
        -: 2024:									if(!cur_topic->local_prefix){
        -: 2025:										log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2026:										return MOSQ_ERR_NOMEM;
        -: 2027:									}
        -: 2028:								}
        -: 2029:
        -: 2030:								token = strtok_r(NULL, " ", &saveptr);
        -: 2031:								if(token){
        -: 2032:									if(!strcmp(token, "\"\"") || token[0] == '#'){
        -: 2033:										cur_topic->remote_prefix = NULL;
        -: 2034:									}else{
        -: 2035:										if(mosquitto_pub_topic_check(token) != MOSQ_ERR_SUCCESS){
        -: 2036:											log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge topic remote prefix '%s'.", token);
        -: 2037:											return MOSQ_ERR_INVAL;
        -: 2038:										}
        -: 2039:										cur_topic->remote_prefix = mosquitto__strdup(token);
        -: 2040:										if(!cur_topic->remote_prefix){
        -: 2041:											log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2042:											return MOSQ_ERR_NOMEM;
        -: 2043:										}
        -: 2044:									}
        -: 2045:								}
        -: 2046:							}
        -: 2047:						}
        -: 2048:					}
        -: 2049:					if(cur_topic->topic == NULL &&
        -: 2050:							(cur_topic->local_prefix == NULL || cur_topic->remote_prefix == NULL)){
        -: 2051:
        -: 2052:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge remapping.");
        -: 2053:						return MOSQ_ERR_INVAL;
        -: 2054:					}
        -: 2055:					if(cur_topic->local_prefix){
        -: 2056:						if(cur_topic->topic){
        -: 2057:							len = strlen(cur_topic->topic) + strlen(cur_topic->local_prefix)+1;
        -: 2058:							cur_topic->local_topic = mosquitto__malloc(len+1);
        -: 2059:							if(!cur_topic->local_topic){
        -: 2060:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2061:								return MOSQ_ERR_NOMEM;
        -: 2062:							}
        -: 2063:							snprintf(cur_topic->local_topic, len+1, "%s%s", cur_topic->local_prefix, cur_topic->topic);
        -: 2064:							cur_topic->local_topic[len] = '\0';
        -: 2065:						}else{
        -: 2066:							cur_topic->local_topic = mosquitto__strdup(cur_topic->local_prefix);
        -: 2067:							if(!cur_topic->local_topic){
        -: 2068:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2069:								return MOSQ_ERR_NOMEM;
        -: 2070:							}
        -: 2071:						}
        -: 2072:					}else{
        -: 2073:						cur_topic->local_topic = mosquitto__strdup(cur_topic->topic);
        -: 2074:						if(!cur_topic->local_topic){
        -: 2075:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2076:							return MOSQ_ERR_NOMEM;
        -: 2077:						}
        -: 2078:					}
        -: 2079:
        -: 2080:					if(cur_topic->remote_prefix){
        -: 2081:						if(cur_topic->topic){
        -: 2082:							len = strlen(cur_topic->topic) + strlen(cur_topic->remote_prefix)+1;
        -: 2083:							cur_topic->remote_topic = mosquitto__malloc(len+1);
        -: 2084:							if(!cur_topic->remote_topic){
        -: 2085:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2086:								return MOSQ_ERR_NOMEM;
        -: 2087:							}
        -: 2088:							snprintf(cur_topic->remote_topic, len, "%s%s", cur_topic->remote_prefix, cur_topic->topic);
        -: 2089:							cur_topic->remote_topic[len] = '\0';
        -: 2090:						}else{
        -: 2091:							cur_topic->remote_topic = mosquitto__strdup(cur_topic->remote_prefix);
        -: 2092:							if(!cur_topic->remote_topic){
        -: 2093:								log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2094:								return MOSQ_ERR_NOMEM;
        -: 2095:							}
        -: 2096:						}
        -: 2097:					}else{
        -: 2098:						cur_topic->remote_topic = mosquitto__strdup(cur_topic->topic);
        -: 2099:						if(!cur_topic->remote_topic){
        -: 2100:							log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2101:							return MOSQ_ERR_NOMEM;
        -: 2102:						}
        -: 2103:					}
        -: 2104:#else
    #####: 2105:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 2106:#endif
    #####: 2107:				}else if(!strcmp(token, "max_topic_alias")){
    #####: 2108:					if(reload) continue; // Listeners not valid for reloading.
    #####: 2109:					token = strtok_r(NULL, " ", &saveptr);
    #####: 2110:					if(token){
    #####: 2111:						cur_listener->max_topic_alias = atoi(token);
    #####: 2112:					}else{
    #####: 2113:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty max_topic_alias value in configuration.");
        -: 2114:					}
    #####: 2115:				}else if(!strcmp(token, "try_private")){
        -: 2116:#ifdef WITH_BRIDGE
        -: 2117:					if(reload) continue; // FIXME
        -: 2118:					if(!cur_bridge){
        -: 2119:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 2120:						return MOSQ_ERR_INVAL;
        -: 2121:					}
        -: 2122:					if(conf__parse_bool(&token, "try_private", &cur_bridge->try_private, saveptr)) return MOSQ_ERR_INVAL;
        -: 2123:#else
    #####: 2124:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 2125:#endif
    #####: 2126:				}else if(!strcmp(token, "upgrade_outgoing_qos")){
    #####: 2127:					if(conf__parse_bool(&token, token, &config->upgrade_outgoing_qos, saveptr)) return MOSQ_ERR_INVAL;
    #####: 2128:				}else if(!strcmp(token, "use_identity_as_username")){
        -: 2129:#ifdef WITH_TLS
    #####: 2130:					if(reload) continue; // Listeners not valid for reloading.
    #####: 2131:					if(conf__parse_bool(&token, "use_identity_as_username", &cur_listener->use_identity_as_username, saveptr)) return MOSQ_ERR_INVAL;
        -: 2132:#else
        -: 2133:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 2134:#endif
    #####: 2135:				}else if(!strcmp(token, "use_subject_as_username")){
        -: 2136:#ifdef WITH_TLS
    #####: 2137:					if(reload) continue; // Listeners not valid for reloading.
    #####: 2138:					if(conf__parse_bool(&token, "use_subject_as_username", &cur_listener->use_subject_as_username, saveptr)) return MOSQ_ERR_INVAL;
        -: 2139:#else
        -: 2140:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: TLS support not available.");
        -: 2141:#endif
    #####: 2142:				}else if(!strcmp(token, "user")){
    #####: 2143:					if(reload) continue; // Drop privileges user not valid for reloading.
    #####: 2144:					mosquitto__free(config->user);
    #####: 2145:					if(conf__parse_string(&token, "user", &config->user, saveptr)) return MOSQ_ERR_INVAL;
    #####: 2146:				}else if(!strcmp(token, "use_username_as_clientid")){
    #####: 2147:					if(reload) continue; // Listeners not valid for reloading.
    #####: 2148:					if(conf__parse_bool(&token, "use_username_as_clientid", &cur_listener->use_username_as_clientid, saveptr)) return MOSQ_ERR_INVAL;
    #####: 2149:				}else if(!strcmp(token, "username") || !strcmp(token, "remote_username")){
        -: 2150:#ifdef WITH_BRIDGE
        -: 2151:					if(reload) continue; // FIXME
        -: 2152:					if(!cur_bridge){
        -: 2153:						log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid bridge configuration.");
        -: 2154:						return MOSQ_ERR_INVAL;
        -: 2155:					}
        -: 2156:					if(conf__parse_string(&token, "bridge remote_username", &cur_bridge->remote_username, saveptr)) return MOSQ_ERR_INVAL;
        -: 2157:#else
    #####: 2158:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Bridge support not available.");
        -: 2159:#endif
    #####: 2160:				}else if(!strcmp(token, "websockets_log_level")){
        -: 2161:#ifdef WITH_WEBSOCKETS
        -: 2162:					if(conf__parse_int(&token, "websockets_log_level", &config->websockets_log_level, saveptr)) return MOSQ_ERR_INVAL;
        -: 2163:#else
    #####: 2164:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Websockets support not available.");
        -: 2165:#endif
    #####: 2166:				}else if(!strcmp(token, "websockets_headers_size")){
        -: 2167:#ifdef WITH_WEBSOCKETS
        -: 2168:#  if defined(LWS_LIBRARY_VERSION_NUMBER) && LWS_LIBRARY_VERSION_NUMBER>=1007000
        -: 2169:					if(conf__parse_int(&token, "websockets_headers_size", &config->websockets_headers_size, saveptr)) return MOSQ_ERR_INVAL;
        -: 2170:#  else
        -: 2171:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Websockets headers size require libwebsocket 1.7+");
        -: 2172:#  endif
        -: 2173:#else
    #####: 2174:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Websockets support not available.");
        -: 2175:#endif
    #####: 2176:				}else if(!strcmp(token, "trace_level")
    #####: 2177:						|| !strcmp(token, "ffdc_output")
    #####: 2178:						|| !strcmp(token, "max_log_entries")
    #####: 2179:						|| !strcmp(token, "trace_output")){
    #####: 2180:					log__printf(NULL, MOSQ_LOG_WARNING, "Warning: Unsupported rsmb configuration option \"%s\".", token);
    #####: 2181:				}else{
    #####: 2182:					log__printf(NULL, MOSQ_LOG_ERR, "Error: Unknown configuration variable \"%s\".", token);
    #####: 2183:					return MOSQ_ERR_INVAL;
        -: 2184:				}
    #####: 2185:			}
    #####: 2186:		}
        -: 2187:	}
    #####: 2188:	return MOSQ_ERR_SUCCESS;
    #####: 2189:}
        -: 2190:
    #####: 2191:int config__read_file(struct mosquitto__config *config, bool reload, const char *file, struct config_recurse *cr, int level, int *lineno)
        -: 2192:{
        -: 2193:	int rc;
    #####: 2194:	FILE *fptr = NULL;
        -: 2195:	char *buf;
        -: 2196:	int buflen;
        -: 2197:
    #####: 2198:	fptr = mosquitto__fopen(file, "rt", false);
    #####: 2199:	if(!fptr){
    #####: 2200:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Unable to open config file %s.", file);
    #####: 2201:		return 1;
        -: 2202:	}
        -: 2203:
    #####: 2204:	buflen = 1000;
    #####: 2205:	buf = mosquitto__malloc(buflen);
    #####: 2206:	if(!buf){
    #####: 2207:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####: 2208:		fclose(fptr);
    #####: 2209:		return MOSQ_ERR_NOMEM;
        -: 2210:	}
        -: 2211:
    #####: 2212:	rc = config__read_file_core(config, reload, cr, level, lineno, fptr, &buf, &buflen);
    #####: 2213:	mosquitto__free(buf);
    #####: 2214:	fclose(fptr);
        -: 2215:
    #####: 2216:	return rc;
    #####: 2217:}
        -: 2218:
        -: 2219:
    #####: 2220:static int config__check(struct mosquitto__config *config)
        -: 2221:{
        -: 2222:	/* Checks that are easy to make after the config has been loaded. */
        -: 2223:
        -: 2224:	int i;
        -: 2225:
        -: 2226:#ifdef WITH_BRIDGE
        -: 2227:	int j;
        -: 2228:	struct mosquitto__bridge *bridge1, *bridge2;
        -: 2229:	char hostname[256];
        -: 2230:	int len;
        -: 2231:
        -: 2232:	/* Check for bridge duplicate local_clientid, need to generate missing IDs
        -: 2233:	 * first. */
        -: 2234:	for(i=0; i<config->bridge_count; i++){
        -: 2235:		bridge1 = &config->bridges[i];
        -: 2236:
        -: 2237:		if(!bridge1->remote_clientid){
        -: 2238:			if(!gethostname(hostname, 256)){
        -: 2239:				len = strlen(hostname) + strlen(bridge1->name) + 2;
        -: 2240:				bridge1->remote_clientid = mosquitto__malloc(len);
        -: 2241:				if(!bridge1->remote_clientid){
        -: 2242:					return MOSQ_ERR_NOMEM;
        -: 2243:				}
        -: 2244:				snprintf(bridge1->remote_clientid, len, "%s.%s", hostname, bridge1->name);
        -: 2245:			}else{
        -: 2246:				return 1;
        -: 2247:			}
        -: 2248:		}
        -: 2249:
        -: 2250:		if(!bridge1->local_clientid){
        -: 2251:			len = strlen(bridge1->remote_clientid) + strlen("local.") + 2;
        -: 2252:			bridge1->local_clientid = mosquitto__malloc(len);
        -: 2253:			if(!bridge1->local_clientid){
        -: 2254:				log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
        -: 2255:				return MOSQ_ERR_NOMEM;
        -: 2256:			}
        -: 2257:			snprintf(bridge1->local_clientid, len, "local.%s", bridge1->remote_clientid);
        -: 2258:		}
        -: 2259:	}
        -: 2260:
        -: 2261:	for(i=0; i<config->bridge_count; i++){
        -: 2262:		bridge1 = &config->bridges[i];
        -: 2263:		for(j=i+1; j<config->bridge_count; j++){
        -: 2264:			bridge2 = &config->bridges[j];
        -: 2265:			if(!strcmp(bridge1->local_clientid, bridge2->local_clientid)){
        -: 2266:				log__printf(NULL, MOSQ_LOG_ERR, "Error: Bridge local_clientid "
        -: 2267:						"'%s' is not unique. Try changing or setting the "
        -: 2268:						"local_clientid value for one of the bridges.",
        -: 2269:						bridge1->local_clientid);
        -: 2270:				return MOSQ_ERR_INVAL;
        -: 2271:			}
        -: 2272:		}
        -: 2273:	}
        -: 2274:#endif
        -: 2275:
        -: 2276:	/* Default to auto_id_prefix = 'auto-' if none set. */
    #####: 2277:	if(config->per_listener_settings){
    #####: 2278:		for(i=0; i<config->listener_count; i++){
    #####: 2279:			if(!config->listeners[i].security_options.auto_id_prefix){
    #####: 2280:				config->listeners[i].security_options.auto_id_prefix = mosquitto__strdup("auto-");
    #####: 2281:				if(!config->listeners[i].security_options.auto_id_prefix){
    #####: 2282:					return MOSQ_ERR_NOMEM;
        -: 2283:				}
    #####: 2284:				config->listeners[i].security_options.auto_id_prefix_len = strlen("auto-");
    #####: 2285:			}
    #####: 2286:		}
    #####: 2287:	}else{
    #####: 2288:		if(!config->security_options.auto_id_prefix){
    #####: 2289:			config->security_options.auto_id_prefix = mosquitto__strdup("auto-");
    #####: 2290:			if(!config->security_options.auto_id_prefix){
    #####: 2291:				return MOSQ_ERR_NOMEM;
        -: 2292:			}
    #####: 2293:			config->security_options.auto_id_prefix_len = strlen("auto-");
    #####: 2294:		}
        -: 2295:	}
        -: 2296:
    #####: 2297:	return MOSQ_ERR_SUCCESS;
    #####: 2298:}
        -: 2299:
        -: 2300:
    #####: 2301:static int conf__parse_bool(char **token, const char *name, bool *value, char *saveptr)
        -: 2302:{
    #####: 2303:	*token = strtok_r(NULL, " ", &saveptr);
    #####: 2304:	if(*token){
    #####: 2305:		if(!strcmp(*token, "false") || !strcmp(*token, "0")){
    #####: 2306:			*value = false;
    #####: 2307:		}else if(!strcmp(*token, "true") || !strcmp(*token, "1")){
    #####: 2308:			*value = true;
    #####: 2309:		}else{
    #####: 2310:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Invalid %s value (%s).", name, *token);
    #####: 2311:			return MOSQ_ERR_INVAL;
        -: 2312:		}
    #####: 2313:	}else{
    #####: 2314:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty %s value in configuration.", name);
    #####: 2315:		return MOSQ_ERR_INVAL;
        -: 2316:	}
        -: 2317:
    #####: 2318:	return MOSQ_ERR_SUCCESS;
    #####: 2319:}
        -: 2320:
    #####: 2321:static int conf__parse_int(char **token, const char *name, int *value, char *saveptr)
        -: 2322:{
    #####: 2323:	*token = strtok_r(NULL, " ", &saveptr);
    #####: 2324:	if(*token){
    #####: 2325:		*value = atoi(*token);
    #####: 2326:	}else{
    #####: 2327:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty %s value in configuration.", name);
    #####: 2328:		return MOSQ_ERR_INVAL;
        -: 2329:	}
        -: 2330:
    #####: 2331:	return MOSQ_ERR_SUCCESS;
    #####: 2332:}
        -: 2333:
    #####: 2334:static int conf__parse_ssize_t(char **token, const char *name, ssize_t *value, char *saveptr)
        -: 2335:{
    #####: 2336:	*token = strtok_r(NULL, " ", &saveptr);
    #####: 2337:	if(*token){
    #####: 2338:		*value = atol(*token);
    #####: 2339:	}else{
    #####: 2340:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty %s value in configuration.", name);
    #####: 2341:		return MOSQ_ERR_INVAL;
        -: 2342:	}
        -: 2343:
    #####: 2344:	return MOSQ_ERR_SUCCESS;
    #####: 2345:}
        -: 2346:
    #####: 2347:static int conf__parse_string(char **token, const char *name, char **value, char *saveptr)
        -: 2348:{
    #####: 2349:	*token = strtok_r(NULL, "", &saveptr);
    #####: 2350:	if(*token){
    #####: 2351:		if(*value){
    #####: 2352:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Duplicate %s value in configuration.", name);
    #####: 2353:			return MOSQ_ERR_INVAL;
        -: 2354:		}
        -: 2355:		/* Deal with multiple spaces at the beginning of the string. */
    #####: 2356:		*token = misc__trimblanks(*token);
    #####: 2357:		if(strlen(*token) == 0){
    #####: 2358:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty %s value in configuration.", name);
    #####: 2359:			return MOSQ_ERR_INVAL;
        -: 2360:		}
        -: 2361:
    #####: 2362:		if(mosquitto_validate_utf8(*token, strlen(*token))){
    #####: 2363:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Malformed UTF-8 in configuration.");
    #####: 2364:			return MOSQ_ERR_INVAL;
        -: 2365:		}
    #####: 2366:		*value = mosquitto__strdup(*token);
    #####: 2367:		if(!*value){
    #####: 2368:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####: 2369:			return MOSQ_ERR_NOMEM;
        -: 2370:		}
    #####: 2371:	}else{
    #####: 2372:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Empty %s value in configuration.", name);
    #####: 2373:		return MOSQ_ERR_INVAL;
        -: 2374:	}
    #####: 2375:	return MOSQ_ERR_SUCCESS;
    #####: 2376:}
