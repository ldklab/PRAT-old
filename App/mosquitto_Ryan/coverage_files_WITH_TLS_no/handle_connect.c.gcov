        -:    0:Source:handle_connect.c
        -:    0:Graph:handle_connect.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2:Copyright (c) 2009-2020 Roger Light <roger@atchoo.org>
        -:    3:
        -:    4:All rights reserved. This program and the accompanying materials
        -:    5:are made available under the terms of the Eclipse Public License v1.0
        -:    6:and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7:
        -:    8:The Eclipse Public License is available at
        -:    9:   http://www.eclipse.org/legal/epl-v10.html
        -:   10:and the Eclipse Distribution License is available at
        -:   11:  http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12:
        -:   13:Contributors:
        -:   14:   Roger Light - initial implementation and documentation.
        -:   15:*/
        -:   16:
        -:   17:#include "config.h"
        -:   18:
        -:   19:#include <stdio.h>
        -:   20:#include <string.h>
        -:   21:#include <utlist.h>
        -:   22:
        -:   23:#include "mosquitto_broker_internal.h"
        -:   24:#include "mqtt_protocol.h"
        -:   25:#include "memory_mosq.h"
        -:   26:#include "packet_mosq.h"
        -:   27:#include "property_mosq.h"
        -:   28:#include "send_mosq.h"
        -:   29:#include "sys_tree.h"
        -:   30:#include "time_mosq.h"
        -:   31:#include "tls_mosq.h"
        -:   32:#include "util_mosq.h"
        -:   33:#include "will_mosq.h"
        -:   34:
        -:   35:#ifdef WITH_WEBSOCKETS
        -:   36:#  include <libwebsockets.h>
        -:   37:#endif
        -:   38:
        -:   39:
    #####:   40:static char nibble_to_hex(uint8_t value)
        -:   41:{
    #####:   42:	if(value < 0x0A){
    #####:   43:		return '0'+value;
        -:   44:	}else{
    #####:   45:		return 'A'+value-0x0A;
        -:   46:	}
    #####:   47:}
        -:   48:
    #####:   49:static char *client_id_gen(int *idlen, const char *auto_id_prefix, int auto_id_prefix_len)
        -:   50:{
        -:   51:	char *client_id;
        -:   52:	uint8_t rnd[16];
        -:   53:	int i;
        -:   54:	int pos;
        -:   55:
    #####:   56:	if(util__random_bytes(rnd, 16)) return NULL;
        -:   57:
    #####:   58:	*idlen = 36 + auto_id_prefix_len;
        -:   59:
    #####:   60:	client_id = (char *)mosquitto__calloc((*idlen) + 1, sizeof(char));
    #####:   61:	if(!client_id){
    #####:   62:		return NULL;
        -:   63:	}
    #####:   64:	if(auto_id_prefix){
    #####:   65:		memcpy(client_id, auto_id_prefix, auto_id_prefix_len);
    #####:   66:	}
        -:   67:
    #####:   68:	pos = 0;
    #####:   69:	for(i=0; i<16; i++){
    #####:   70:		client_id[auto_id_prefix_len + pos + 0] = nibble_to_hex(rnd[i] & 0x0F);
    #####:   71:		client_id[auto_id_prefix_len + pos + 1] = nibble_to_hex((rnd[i] >> 4) & 0x0F);
    #####:   72:		pos += 2;
    #####:   73:		if(pos == 8 || pos == 13 || pos == 18 || pos == 23){
    #####:   74:			client_id[auto_id_prefix_len + pos] = '-';
    #####:   75:			pos++;
    #####:   76:		}
    #####:   77:	}
        -:   78:
    #####:   79:	return client_id;
    #####:   80:}
        -:   81:
        -:   82:/* Remove any queued messages that are no longer allowed through ACL,
        -:   83: * assuming a possible change of username. */
    #####:   84:void connection_check_acl(struct mosquitto_db *db, struct mosquitto *context, struct mosquitto_client_msg **head)
        -:   85:{
        -:   86:	struct mosquitto_client_msg *msg_tail, *tmp;
        -:   87:
    #####:   88:	DL_FOREACH_SAFE((*head), msg_tail, tmp){
    #####:   89:		if(msg_tail->direction == mosq_md_out){
    #####:   90:			if(mosquitto_acl_check(db, context, msg_tail->store->topic,
    #####:   91:								   msg_tail->store->payloadlen, UHPA_ACCESS(msg_tail->store->payload, msg_tail->store->payloadlen),
    #####:   92:								   msg_tail->store->qos, msg_tail->store->retain, MOSQ_ACL_READ) != MOSQ_ERR_SUCCESS){
        -:   93:
    #####:   94:				DL_DELETE((*head), msg_tail);
    #####:   95:				db__msg_store_ref_dec(db, &msg_tail->store);
    #####:   96:				mosquitto_property_free_all(&msg_tail->properties);
    #####:   97:				mosquitto__free(msg_tail);
    #####:   98:			}
    #####:   99:		}
    #####:  100:	}
    #####:  101:}
        -:  102:
        -:  103:
    #####:  104:int connect__on_authorised(struct mosquitto_db *db, struct mosquitto *context, void *auth_data_out, uint16_t auth_data_out_len)
        -:  105:{
        -:  106:	struct mosquitto *found_context;
        -:  107:	struct mosquitto__subleaf *leaf;
    #####:  108:	mosquitto_property *connack_props = NULL;
    #####:  109:	uint8_t connect_ack = 0;
        -:  110:	int i;
        -:  111:	int rc;
        -:  112:
        -:  113:	/* Find if this client already has an entry. This must be done *after* any security checks. */
    #####:  114:	HASH_FIND(hh_id, db->contexts_by_id, context->id, strlen(context->id), found_context);
    #####:  115:	if(found_context){
        -:  116:		/* Found a matching client */
    #####:  117:		if(found_context->sock == INVALID_SOCKET){
        -:  118:			/* Client is reconnecting after a disconnect */
        -:  119:			/* FIXME - does anything need to be done here? */
    #####:  120:		}else{
        -:  121:			/* Client is already connected, disconnect old version. This is
        -:  122:			 * done in context__cleanup() below. */
    #####:  123:			if(db->config->connection_messages == true){
    #####:  124:				log__printf(NULL, MOSQ_LOG_ERR, "Client %s already connected, closing old connection.", context->id);
    #####:  125:			}
        -:  126:		}
        -:  127:
    #####:  128:		if(context->clean_start == false && found_context->session_expiry_interval > 0){
    #####:  129:			if(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){
    #####:  130:				connect_ack |= 0x01;
    #####:  131:			}
        -:  132:
    #####:  133:			if(found_context->msgs_in.inflight || found_context->msgs_in.queued
    #####:  134:					|| found_context->msgs_out.inflight || found_context->msgs_out.queued){
        -:  135:
    #####:  136:				memcpy(&context->msgs_in, &found_context->msgs_in, sizeof(struct mosquitto_msg_data));
    #####:  137:				memcpy(&context->msgs_out, &found_context->msgs_out, sizeof(struct mosquitto_msg_data));
        -:  138:
    #####:  139:				memset(&found_context->msgs_in, 0, sizeof(struct mosquitto_msg_data));
    #####:  140:				memset(&found_context->msgs_out, 0, sizeof(struct mosquitto_msg_data));
        -:  141:
    #####:  142:				db__message_reconnect_reset(db, context);
    #####:  143:			}
    #####:  144:			context->subs = found_context->subs;
    #####:  145:			found_context->subs = NULL;
    #####:  146:			context->sub_count = found_context->sub_count;
    #####:  147:			found_context->sub_count = 0;
    #####:  148:			context->last_mid = found_context->last_mid;
        -:  149:
    #####:  150:			for(i=0; i<context->sub_count; i++){
    #####:  151:				if(context->subs[i]){
    #####:  152:					leaf = context->subs[i]->subs;
    #####:  153:					while(leaf){
    #####:  154:						if(leaf->context == found_context){
    #####:  155:							leaf->context = context;
    #####:  156:						}
    #####:  157:						leaf = leaf->next;
        -:  158:					}
    #####:  159:				}
    #####:  160:			}
    #####:  161:		}
        -:  162:
    #####:  163:		if(context->clean_start == true){
    #####:  164:			sub__clean_session(db, found_context);
    #####:  165:		}
    #####:  166:		session_expiry__remove(found_context);
    #####:  167:		will_delay__remove(found_context);
    #####:  168:		will__clear(found_context);
        -:  169:
    #####:  170:		found_context->clean_start = true;
    #####:  171:		found_context->session_expiry_interval = 0;
    #####:  172:		mosquitto__set_state(found_context, mosq_cs_duplicate);
    #####:  173:		do_disconnect(db, found_context, MOSQ_ERR_SUCCESS);
    #####:  174:	}
        -:  175:
    #####:  176:	rc = acl__find_acls(db, context);
    #####:  177:	if(rc){
    #####:  178:		free(auth_data_out);
    #####:  179:		return rc;
        -:  180:	}
        -:  181:
    #####:  182:	if(db->config->connection_messages == true){
    #####:  183:		if(context->is_bridge){
    #####:  184:			if(context->username){
    #####:  185:				log__printf(NULL, MOSQ_LOG_NOTICE, "New bridge connected from %s as %s (p%d, c%d, k%d, u'%s').",
    #####:  186:						context->address, context->id, context->protocol, context->clean_start, context->keepalive, context->username);
    #####:  187:			}else{
    #####:  188:				log__printf(NULL, MOSQ_LOG_NOTICE, "New bridge connected from %s as %s (p%d, c%d, k%d).",
    #####:  189:						context->address, context->id, context->protocol, context->clean_start, context->keepalive);
        -:  190:			}
    #####:  191:		}else{
    #####:  192:			if(context->username){
    #####:  193:				log__printf(NULL, MOSQ_LOG_NOTICE, "New client connected from %s as %s (p%d, c%d, k%d, u'%s').",
    #####:  194:						context->address, context->id, context->protocol, context->clean_start, context->keepalive, context->username);
    #####:  195:			}else{
    #####:  196:				log__printf(NULL, MOSQ_LOG_NOTICE, "New client connected from %s as %s (p%d, c%d, k%d).",
    #####:  197:						context->address, context->id, context->protocol, context->clean_start, context->keepalive);
        -:  198:			}
        -:  199:		}
        -:  200:
    #####:  201:		if(context->will) {
    #####:  202:			log__printf(NULL, MOSQ_LOG_DEBUG, "Will message specified (%ld bytes) (r%d, q%d).",
    #####:  203:					(long)context->will->msg.payloadlen,
    #####:  204:					context->will->msg.retain,
    #####:  205:					context->will->msg.qos);
        -:  206:
    #####:  207:			log__printf(NULL, MOSQ_LOG_DEBUG, "\t%s", context->will->msg.topic);
    #####:  208:		} else {
    #####:  209:			log__printf(NULL, MOSQ_LOG_DEBUG, "No will message specified.");
        -:  210:		}
    #####:  211:	}
        -:  212:
    #####:  213:	context->ping_t = 0;
    #####:  214:	context->is_dropping = false;
        -:  215:
    #####:  216:	connection_check_acl(db, context, &context->msgs_in.inflight);
    #####:  217:	connection_check_acl(db, context, &context->msgs_in.queued);
    #####:  218:	connection_check_acl(db, context, &context->msgs_out.inflight);
    #####:  219:	connection_check_acl(db, context, &context->msgs_out.queued);
        -:  220:
    #####:  221:	HASH_ADD_KEYPTR(hh_id, db->contexts_by_id, context->id, strlen(context->id), context);
        -:  222:
        -:  223:#ifdef WITH_PERSISTENCE
        -:  224:	if(!context->clean_start){
        -:  225:		db->persistence_changes++;
        -:  226:	}
        -:  227:#endif
    #####:  228:	context->maximum_qos = context->listener->maximum_qos;
        -:  229:
    #####:  230:	if(context->protocol == mosq_p_mqtt5){
    #####:  231:		if(context->maximum_qos != 2){
    #####:  232:			if(mosquitto_property_add_byte(&connack_props, MQTT_PROP_MAXIMUM_QOS, context->maximum_qos)){
    #####:  233:				rc = MOSQ_ERR_NOMEM;
    #####:  234:				goto error;
        -:  235:			}
    #####:  236:		}
    #####:  237:		if(context->listener->max_topic_alias > 0){
    #####:  238:			if(mosquitto_property_add_int16(&connack_props, MQTT_PROP_TOPIC_ALIAS_MAXIMUM, context->listener->max_topic_alias)){
    #####:  239:				rc = MOSQ_ERR_NOMEM;
    #####:  240:				goto error;
        -:  241:			}
    #####:  242:		}
    #####:  243:		if(context->keepalive > db->config->max_keepalive){
    #####:  244:			context->keepalive = db->config->max_keepalive;
    #####:  245:			if(mosquitto_property_add_int16(&connack_props, MQTT_PROP_SERVER_KEEP_ALIVE, context->keepalive)){
    #####:  246:				rc = MOSQ_ERR_NOMEM;
    #####:  247:				goto error;
        -:  248:			}
    #####:  249:		}
    #####:  250:		if(context->assigned_id){
    #####:  251:			if(mosquitto_property_add_string(&connack_props, MQTT_PROP_ASSIGNED_CLIENT_IDENTIFIER, context->id)){
    #####:  252:				rc = MOSQ_ERR_NOMEM;
    #####:  253:				goto error;
        -:  254:			}
    #####:  255:		}
    #####:  256:		if(context->auth_method){
    #####:  257:			if(mosquitto_property_add_string(&connack_props, MQTT_PROP_AUTHENTICATION_METHOD, context->auth_method)){
    #####:  258:				rc = MOSQ_ERR_NOMEM;
    #####:  259:				goto error;
        -:  260:			}
        -:  261:
    #####:  262:			if(auth_data_out && auth_data_out_len > 0){
    #####:  263:				if(mosquitto_property_add_binary(&connack_props, MQTT_PROP_AUTHENTICATION_DATA, auth_data_out, auth_data_out_len)){
    #####:  264:					rc = MOSQ_ERR_NOMEM;
    #####:  265:					goto error;
        -:  266:				}
    #####:  267:			}
    #####:  268:		}
    #####:  269:	}
    #####:  270:	free(auth_data_out);
        -:  271:
    #####:  272:	mosquitto__set_state(context, mosq_cs_active);
    #####:  273:	rc = send__connack(db, context, connect_ack, CONNACK_ACCEPTED, connack_props);
    #####:  274:	mosquitto_property_free_all(&connack_props);
    #####:  275:	return rc;
        -:  276:error:
    #####:  277:	free(auth_data_out);
    #####:  278:	mosquitto_property_free_all(&connack_props);
    #####:  279:	return rc;
    #####:  280:}
        -:  281:
        -:  282:
    #####:  283:static int will__read(struct mosquitto *context, struct mosquitto_message_all **will, uint8_t will_qos, int will_retain)
        -:  284:{
    #####:  285:	int rc = MOSQ_ERR_SUCCESS;
        -:  286:	int slen;
    #####:  287:	struct mosquitto_message_all *will_struct = NULL;
    #####:  288:	char *will_topic_mount = NULL;
        -:  289:	uint16_t payloadlen;
    #####:  290:	mosquitto_property *properties = NULL;
        -:  291:
    #####:  292:	will_struct = mosquitto__calloc(1, sizeof(struct mosquitto_message_all));
    #####:  293:	if(!will_struct){
    #####:  294:		rc = MOSQ_ERR_NOMEM;
    #####:  295:		goto error_cleanup;
        -:  296:	}
    #####:  297:	if(context->protocol == PROTOCOL_VERSION_v5){
    #####:  298:		rc = property__read_all(CMD_WILL, &context->in_packet, &properties);
    #####:  299:		if(rc) goto error_cleanup;
        -:  300:
    #####:  301:		rc = property__process_will(context, will_struct, &properties);
    #####:  302:		mosquitto_property_free_all(&properties);
    #####:  303:		if(rc) goto error_cleanup;
    #####:  304:	}
    #####:  305:	rc = packet__read_string(&context->in_packet, &will_struct->msg.topic, &slen);
    #####:  306:	if(rc) goto error_cleanup;
    #####:  307:	if(!slen){
    #####:  308:		rc = MOSQ_ERR_PROTOCOL;
    #####:  309:		goto error_cleanup;
        -:  310:	}
        -:  311:
    #####:  312:	if(context->listener->mount_point){
    #####:  313:		slen = strlen(context->listener->mount_point) + strlen(will_struct->msg.topic) + 1;
    #####:  314:		will_topic_mount = mosquitto__malloc(slen+1);
    #####:  315:		if(!will_topic_mount){
    #####:  316:			rc = MOSQ_ERR_NOMEM;
    #####:  317:			goto error_cleanup;
        -:  318:		}
        -:  319:
    #####:  320:		snprintf(will_topic_mount, slen, "%s%s", context->listener->mount_point, will_struct->msg.topic);
    #####:  321:		will_topic_mount[slen] = '\0';
        -:  322:
    #####:  323:		mosquitto__free(will_struct->msg.topic);
    #####:  324:		will_struct->msg.topic = will_topic_mount;
    #####:  325:	}
        -:  326:
    #####:  327:	rc = mosquitto_pub_topic_check(will_struct->msg.topic);
    #####:  328:	if(rc) goto error_cleanup;
        -:  329:
    #####:  330:	rc = packet__read_uint16(&context->in_packet, &payloadlen);
    #####:  331:	if(rc) goto error_cleanup;
        -:  332:
    #####:  333:	will_struct->msg.payloadlen = payloadlen;
    #####:  334:	if(will_struct->msg.payloadlen > 0){
    #####:  335:		will_struct->msg.payload = mosquitto__malloc(will_struct->msg.payloadlen);
    #####:  336:		if(!will_struct->msg.payload){
    #####:  337:			rc = MOSQ_ERR_NOMEM;
    #####:  338:			goto error_cleanup;
        -:  339:		}
        -:  340:
    #####:  341:		rc = packet__read_bytes(&context->in_packet, will_struct->msg.payload, will_struct->msg.payloadlen);
    #####:  342:		if(rc) goto error_cleanup;
    #####:  343:	}
        -:  344:
    #####:  345:	will_struct->msg.qos = will_qos;
    #####:  346:	will_struct->msg.retain = will_retain;
        -:  347:
    #####:  348:	*will = will_struct;
    #####:  349:	return MOSQ_ERR_SUCCESS;
        -:  350:
        -:  351:error_cleanup:
    #####:  352:	if(will_struct){
    #####:  353:		mosquitto__free(will_struct->msg.topic);
    #####:  354:		mosquitto__free(will_struct->msg.payload);
    #####:  355:		mosquitto_property_free_all(&will_struct->properties);
    #####:  356:		mosquitto__free(will_struct);
    #####:  357:	}
    #####:  358:	return rc;
    #####:  359:}
        -:  360:
        -:  361:/**
        -:  362: * This doesn't do anything right now.
        -:  363: * Just a pre- function to call the next.
        -:  364: * @param db
        -:  365: * @param context
        -:  366: */
        -:  367:/*int handle__connect2(struct mosquitto_db *db, struct mosquitto *context) {
        -:  368:    // This will be some "key" that is agreed upon at handshake time to determine client/broker version type.
        -:  369:    int id = 1337;
        -:  370:    handle__connect2(db, context, id);
        -:  371:}*/
        -:  372:
    #####:  373:int handle__connect(struct mosquitto_db *db, struct mosquitto *context, int version)
        -:  374:{
        -:  375:	char protocol_name[7];
        -:  376:	uint8_t protocol_version;
        -:  377:	uint8_t connect_flags;
    #####:  378:	char *client_id = NULL;
    #####:  379:	struct mosquitto_message_all *will_struct = NULL;
        -:  380:	uint8_t will, will_retain, will_qos, clean_start;
        -:  381:	uint8_t username_flag, password_flag;
    #####:  382:	char *username = NULL, *password = NULL;
        -:  383:	int rc;
        -:  384:	int slen;
        -:  385:	uint16_t slen16;
    #####:  386:	mosquitto_property *properties = NULL;
    #####:  387:	void *auth_data = NULL;
    #####:  388:	uint16_t auth_data_len = 0;
    #####:  389:	void *auth_data_out = NULL;
    #####:  390:	uint16_t auth_data_out_len = 0;
        -:  391:
        -:  392:    // TEST - RPW.
    #####:  393:    int nonce = context->nonce;
    #####:  394:	log__printf(NULL, MOSQ_LOG_NOTICE, "Nonce value: %d", nonce);
        -:  395:	/*if (nonce != 1337) {
        -:  396:		log__printf(NULL, MOSQ_LOG_NOTICE, "Client::Broker mismatch. Disconnecting.");
        -:  397:		goto handle_connect_error;
        -:  398:	}*/
    #####:  399:    assert(nonce == 1337);
        -:  400:    // END TEST - RPW.
        -:  401:
        -:  402:#ifdef WITH_TLS
        -:  403:	int i;
        -:  404:	X509 *client_cert = NULL;
        -:  405:	X509_NAME *name;
        -:  406:	X509_NAME_ENTRY *name_entry;
        -:  407:	ASN1_STRING *name_asn1 = NULL;
        -:  408:#endif
        -:  409:
        -:  410:	G_CONNECTION_COUNT_INC();
        -:  411:
    #####:  412:	if(!context->listener){
    #####:  413:		return MOSQ_ERR_INVAL;
        -:  414:	}
        -:  415:
        -:  416:	/* Manually-created check for the added dummy transformation. */
        -:  417:	/*if(version != 1337) {
        -:  418:	    log__printf(NULL, MOSQ_LOG_NOTICE, "Client::Broker mismatch. Disconnecting.");
        -:  419:	    goto handle_connect_error;
        -:  420:	}*/
        -:  421:
        -:  422:	/* Don't accept multiple CONNECT commands. */
    #####:  423:	if(context->state != mosq_cs_new){
    #####:  424:		log__printf(NULL, MOSQ_LOG_NOTICE, "Bad client %s sending multiple CONNECT messages.", context->id);
    #####:  425:		rc = MOSQ_ERR_PROTOCOL;
    #####:  426:		goto handle_connect_error;
        -:  427:	}
        -:  428:
        -:  429:	/* Read protocol name as length then bytes rather than with read_string
        -:  430:	 * because the length is fixed and we can check that. Removes the need
        -:  431:	 * for another malloc as well. */
    #####:  432:	if(packet__read_uint16(&context->in_packet, &slen16)){
    #####:  433:		rc = 1;
    #####:  434:		goto handle_connect_error;
        -:  435:	}
    #####:  436:	slen = slen16;
    #####:  437:	if(slen != 4 /* MQTT */ && slen != 6 /* MQIsdp */){
    #####:  438:		rc = MOSQ_ERR_PROTOCOL;
    #####:  439:		goto handle_connect_error;
        -:  440:	}
    #####:  441:	if(packet__read_bytes(&context->in_packet, protocol_name, slen)){
    #####:  442:		rc = MOSQ_ERR_PROTOCOL;
    #####:  443:		goto handle_connect_error;
        -:  444:	}
    #####:  445:	protocol_name[slen] = '\0';
        -:  446:
        -:  447:	// Tests - RPW.
        -:  448:	#ifdef WITH_RPW_DBG
        -:  449:	log__printf(NULL, MOSQ_LOG_NOTICE, "Protocol name: %s", protocol_name);
        -:  450:	#endif
        -:  451:	// End tests.
        -:  452:
    #####:  453:	if(packet__read_byte(&context->in_packet, &protocol_version)){
    #####:  454:		rc = 1;
    #####:  455:		goto handle_connect_error;
        -:  456:	}
    #####:  457:	if(!strcmp(protocol_name, PROTOCOL_NAME_v31)){
    #####:  458:		if((protocol_version&0x7F) != PROTOCOL_VERSION_v31){
    #####:  459:			if(db->config->connection_messages == true){
    #####:  460:				log__printf(NULL, MOSQ_LOG_INFO, "Invalid protocol version %d in CONNECT from %s.",
    #####:  461:						protocol_version, context->address);
    #####:  462:			}
    #####:  463:			send__connack(db, context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);
    #####:  464:			rc = MOSQ_ERR_PROTOCOL;
    #####:  465:			goto handle_connect_error;
        -:  466:		}
    #####:  467:		context->protocol = mosq_p_mqtt31;
    #####:  468:		if((protocol_version&0x80) == 0x80){
    #####:  469:			context->is_bridge = true;
    #####:  470:		}
    #####:  471:	}else if(!strcmp(protocol_name, PROTOCOL_NAME)){
    #####:  472:		if((protocol_version&0x7F) == PROTOCOL_VERSION_v311){
    #####:  473:			context->protocol = mosq_p_mqtt311;
        -:  474:
    #####:  475:			if((protocol_version&0x80) == 0x80){
    #####:  476:				context->is_bridge = true;
    #####:  477:			}
    #####:  478:		}else if((protocol_version&0x7F) == PROTOCOL_VERSION_v5){
    #####:  479:			context->protocol = mosq_p_mqtt5;
    #####:  480:		}else{
    #####:  481:			if(db->config->connection_messages == true){
    #####:  482:				log__printf(NULL, MOSQ_LOG_INFO, "Invalid protocol version %d in CONNECT from %s.",
    #####:  483:						protocol_version, context->address);
    #####:  484:			}
    #####:  485:			send__connack(db, context, 0, CONNACK_REFUSED_PROTOCOL_VERSION, NULL);
    #####:  486:			rc = MOSQ_ERR_PROTOCOL;
    #####:  487:			goto handle_connect_error;
        -:  488:		}
    #####:  489:		if((context->in_packet.command&0x0F) != 0x00){
        -:  490:			/* Reserved flags not set to 0, must disconnect. */
    #####:  491:			rc = MOSQ_ERR_PROTOCOL;
    #####:  492:			goto handle_connect_error;
        -:  493:		}
    #####:  494:	}else{
    #####:  495:		if(db->config->connection_messages == true){
    #####:  496:			log__printf(NULL, MOSQ_LOG_INFO, "Invalid protocol \"%s\" in CONNECT from %s.",
    #####:  497:					protocol_name, context->address);
    #####:  498:		}
    #####:  499:		rc = MOSQ_ERR_PROTOCOL;
    #####:  500:		goto handle_connect_error;
        -:  501:	}
        -:  502:
    #####:  503:	if(packet__read_byte(&context->in_packet, &connect_flags)){
    #####:  504:		rc = 1;
    #####:  505:		goto handle_connect_error;
        -:  506:	}
    #####:  507:	if(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){
    #####:  508:		if((connect_flags & 0x01) != 0x00){
    #####:  509:			rc = MOSQ_ERR_PROTOCOL;
    #####:  510:			goto handle_connect_error;
        -:  511:		}
    #####:  512:	}
        -:  513:
    #####:  514:	clean_start = (connect_flags & 0x02) >> 1;
        -:  515:	/* session_expiry_interval will be overriden if the properties are read later */
    #####:  516:	if(clean_start == false && protocol_version != PROTOCOL_VERSION_v5){
        -:  517:		/* v3* has clean_start == false mean the session never expires */
    #####:  518:		context->session_expiry_interval = UINT32_MAX;
    #####:  519:	}else{
    #####:  520:		context->session_expiry_interval = 0;
        -:  521:	}
    #####:  522:	will = connect_flags & 0x04;
    #####:  523:	will_qos = (connect_flags & 0x18) >> 3;
    #####:  524:	if(will_qos == 3){
    #####:  525:		log__printf(NULL, MOSQ_LOG_INFO, "Invalid Will QoS in CONNECT from %s.",
    #####:  526:				context->address);
    #####:  527:		rc = MOSQ_ERR_PROTOCOL;
    #####:  528:		goto handle_connect_error;
        -:  529:	}
    #####:  530:	will_retain = ((connect_flags & 0x20) == 0x20); // Temporary hack because MSVC<1800 doesn't have stdbool.h.
    #####:  531:	password_flag = connect_flags & 0x40;
    #####:  532:	username_flag = connect_flags & 0x80;
        -:  533:
    #####:  534:	if(will && will_retain && db->config->retain_available == false){
    #####:  535:		if(protocol_version == mosq_p_mqtt5){
    #####:  536:			send__connack(db, context, 0, MQTT_RC_RETAIN_NOT_SUPPORTED, NULL);
    #####:  537:		}
    #####:  538:		rc = 1;
    #####:  539:		goto handle_connect_error;
        -:  540:	}
        -:  541:
    #####:  542:	if(packet__read_uint16(&context->in_packet, &(context->keepalive))){
    #####:  543:		rc = 1;
    #####:  544:		goto handle_connect_error;
        -:  545:	}
        -:  546:
    #####:  547:	if(protocol_version == PROTOCOL_VERSION_v5){
    #####:  548:		rc = property__read_all(CMD_CONNECT, &context->in_packet, &properties);
    #####:  549:		if(rc) goto handle_connect_error;
    #####:  550:	}
    #####:  551:	property__process_connect(context, &properties);
        -:  552:
    #####:  553:	if(mosquitto_property_read_string(properties, MQTT_PROP_AUTHENTICATION_METHOD, &context->auth_method, false)){
    #####:  554:		mosquitto_property_read_binary(properties, MQTT_PROP_AUTHENTICATION_DATA, &auth_data, &auth_data_len, false);
    #####:  555:	}
        -:  556:
    #####:  557:	mosquitto_property_free_all(&properties); /* FIXME - TEMPORARY UNTIL PROPERTIES PROCESSED */
        -:  558:
    #####:  559:	if(packet__read_string(&context->in_packet, &client_id, &slen)){
    #####:  560:		rc = 1;
    #####:  561:		goto handle_connect_error;
        -:  562:	}
        -:  563:
    #####:  564:	if(slen == 0){
    #####:  565:		if(context->protocol == mosq_p_mqtt31){
    #####:  566:			send__connack(db, context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);
    #####:  567:			rc = MOSQ_ERR_PROTOCOL;
    #####:  568:			goto handle_connect_error;
        -:  569:		}else{ /* mqtt311/mqtt5 */
    #####:  570:			mosquitto__free(client_id);
    #####:  571:			client_id = NULL;
        -:  572:
        -:  573:			bool allow_zero_length_clientid;
    #####:  574:			if(db->config->per_listener_settings){
    #####:  575:				allow_zero_length_clientid = context->listener->security_options.allow_zero_length_clientid;
    #####:  576:			}else{
    #####:  577:				allow_zero_length_clientid = db->config->security_options.allow_zero_length_clientid;
        -:  578:			}
    #####:  579:			if((context->protocol == mosq_p_mqtt311 && clean_start == 0) || allow_zero_length_clientid == false){
    #####:  580:				if(context->protocol == mosq_p_mqtt311){
    #####:  581:					send__connack(db, context, 0, CONNACK_REFUSED_IDENTIFIER_REJECTED, NULL);
    #####:  582:				}else{
    #####:  583:					send__connack(db, context, 0, MQTT_RC_UNSPECIFIED, NULL);
        -:  584:				}
    #####:  585:				rc = MOSQ_ERR_PROTOCOL;
    #####:  586:				goto handle_connect_error;
        -:  587:			}else{
    #####:  588:				if(db->config->per_listener_settings){
    #####:  589:					client_id = client_id_gen(&slen, context->listener->security_options.auto_id_prefix, context->listener->security_options.auto_id_prefix_len);
    #####:  590:				}else{
    #####:  591:					client_id = client_id_gen(&slen, db->config->security_options.auto_id_prefix, db->config->security_options.auto_id_prefix_len);
        -:  592:				}
    #####:  593:				if(!client_id){
    #####:  594:					rc = MOSQ_ERR_NOMEM;
    #####:  595:					goto handle_connect_error;
        -:  596:				}
    #####:  597:				context->assigned_id = true;
        -:  598:			}
        -:  599:		}
    #####:  600:	}
        -:  601:
        -:  602:	/* clientid_prefixes check */
    #####:  603:	if(db->config->clientid_prefixes){
    #####:  604:		if(strncmp(db->config->clientid_prefixes, client_id, strlen(db->config->clientid_prefixes))){
    #####:  605:			if(context->protocol == mosq_p_mqtt5){
    #####:  606:				send__connack(db, context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);
    #####:  607:			}else{
    #####:  608:				send__connack(db, context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);
        -:  609:			}
    #####:  610:			rc = 1;
    #####:  611:			goto handle_connect_error;
        -:  612:		}
    #####:  613:	}
        -:  614:
    #####:  615:	if(will){
    #####:  616:		rc = will__read(context, &will_struct, will_qos, will_retain);
    #####:  617:		if(rc) goto handle_connect_error;
    #####:  618:	}else{
    #####:  619:		if(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt5){
    #####:  620:			if(will_qos != 0 || will_retain != 0){
    #####:  621:				rc = MOSQ_ERR_PROTOCOL;
    #####:  622:				goto handle_connect_error;
        -:  623:			}
    #####:  624:		}
        -:  625:	}
        -:  626:
    #####:  627:	if(username_flag){
    #####:  628:		rc = packet__read_string(&context->in_packet, &username, &slen);
    #####:  629:		if(rc == MOSQ_ERR_NOMEM){
    #####:  630:			rc = MOSQ_ERR_NOMEM;
    #####:  631:			goto handle_connect_error;
    #####:  632:		}else if(rc != MOSQ_ERR_SUCCESS){
    #####:  633:			if(context->protocol == mosq_p_mqtt31){
        -:  634:				/* Username flag given, but no username. Ignore. */
    #####:  635:				username_flag = 0;
    #####:  636:			}else{
    #####:  637:				rc = MOSQ_ERR_PROTOCOL;
    #####:  638:				goto handle_connect_error;
        -:  639:			}
    #####:  640:		}
    #####:  641:	}else{
    #####:  642:		if(context->protocol == mosq_p_mqtt311 || context->protocol == mosq_p_mqtt31){
    #####:  643:			if(password_flag){
        -:  644:				/* username_flag == 0 && password_flag == 1 is forbidden */
    #####:  645:				log__printf(NULL, MOSQ_LOG_ERR, "Protocol error from %s: password without username, closing connection.", client_id);
    #####:  646:				rc = MOSQ_ERR_PROTOCOL;
    #####:  647:				goto handle_connect_error;
        -:  648:			}
    #####:  649:		}
        -:  650:	}
    #####:  651:	if(password_flag){
    #####:  652:		rc = packet__read_binary(&context->in_packet, (uint8_t **)&password, &slen);
    #####:  653:		if(rc == MOSQ_ERR_NOMEM){
    #####:  654:			rc = MOSQ_ERR_NOMEM;
    #####:  655:			goto handle_connect_error;
    #####:  656:		}else if(rc == MOSQ_ERR_PROTOCOL){
    #####:  657:			if(context->protocol == mosq_p_mqtt31){
        -:  658:				/* Password flag given, but no password. Ignore. */
    #####:  659:			}else{
    #####:  660:				rc = MOSQ_ERR_PROTOCOL;
    #####:  661:				goto handle_connect_error;
        -:  662:			}
    #####:  663:		}
    #####:  664:	}
        -:  665:
    #####:  666:	if(context->in_packet.pos != context->in_packet.remaining_length){
        -:  667:		/* Surplus data at end of packet, this must be an error. */
    #####:  668:		rc = MOSQ_ERR_PROTOCOL;
    #####:  669:		goto handle_connect_error;
        -:  670:	}
        -:  671:
        -:  672:#ifdef WITH_TLS
        -:  673:	if(context->listener->ssl_ctx && (context->listener->use_identity_as_username || context->listener->use_subject_as_username)){
        -:  674:		/* Don't need the username or password if provided */
        -:  675:		mosquitto__free(username);
        -:  676:		username = NULL;
        -:  677:		mosquitto__free(password);
        -:  678:		password = NULL;
        -:  679:
        -:  680:		if(!context->ssl){
        -:  681:			if(context->protocol == mosq_p_mqtt5){
        -:  682:				send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  683:			}else{
        -:  684:				send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  685:			}
        -:  686:			rc = 1;
        -:  687:			goto handle_connect_error;
        -:  688:		}
        -:  689:#ifdef FINAL_WITH_TLS_PSK
        -:  690:		if(context->listener->psk_hint){
        -:  691:			/* Client should have provided an identity to get this far. */
        -:  692:			if(!context->username){
        -:  693:				if(context->protocol == mosq_p_mqtt5){
        -:  694:					send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  695:				}else{
        -:  696:					send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  697:				}
        -:  698:				rc = 1;
        -:  699:				goto handle_connect_error;
        -:  700:			}
        -:  701:		}else{
        -:  702:#endif /* FINAL_WITH_TLS_PSK */
        -:  703:			client_cert = SSL_get_peer_certificate(context->ssl);
        -:  704:			if(!client_cert){
        -:  705:				if(context->protocol == mosq_p_mqtt5){
        -:  706:					send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  707:				}else{
        -:  708:					send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  709:				}
        -:  710:				rc = 1;
        -:  711:				goto handle_connect_error;
        -:  712:			}
        -:  713:			name = X509_get_subject_name(client_cert);
        -:  714:			if(!name){
        -:  715:				if(context->protocol == mosq_p_mqtt5){
        -:  716:					send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  717:				}else{
        -:  718:					send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  719:				}
        -:  720:				rc = 1;
        -:  721:				goto handle_connect_error;
        -:  722:			}
        -:  723:			if (context->listener->use_identity_as_username) { //use_identity_as_username
        -:  724:				i = X509_NAME_get_index_by_NID(name, NID_commonName, -1);
        -:  725:				if(i == -1){
        -:  726:					if(context->protocol == mosq_p_mqtt5){
        -:  727:						send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  728:					}else{
        -:  729:						send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  730:					}
        -:  731:					rc = 1;
        -:  732:					goto handle_connect_error;
        -:  733:				}
        -:  734:				name_entry = X509_NAME_get_entry(name, i);
        -:  735:				if(name_entry){
        -:  736:					name_asn1 = X509_NAME_ENTRY_get_data(name_entry);
        -:  737:					if (name_asn1 == NULL) {
        -:  738:						if(context->protocol == mosq_p_mqtt5){
        -:  739:							send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  740:						}else{
        -:  741:							send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  742:						}
        -:  743:						rc = 1;
        -:  744:						goto handle_connect_error;
        -:  745:					}
        -:  746:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  747:					context->username = mosquitto__strdup((char *) ASN1_STRING_data(name_asn1));
        -:  748:#else
        -:  749:					context->username = mosquitto__strdup((char *) ASN1_STRING_get0_data(name_asn1));
        -:  750:#endif
        -:  751:					if(!context->username){
        -:  752:						if(context->protocol == mosq_p_mqtt5){
        -:  753:							send__connack(db, context, 0, MQTT_RC_SERVER_UNAVAILABLE, NULL);
        -:  754:						}else{
        -:  755:							send__connack(db, context, 0, CONNACK_REFUSED_SERVER_UNAVAILABLE, NULL);
        -:  756:						}
        -:  757:						rc = MOSQ_ERR_NOMEM;
        -:  758:						goto handle_connect_error;
        -:  759:					}
        -:  760:					/* Make sure there isn't an embedded NUL character in the CN */
        -:  761:					if ((size_t)ASN1_STRING_length(name_asn1) != strlen(context->username)) {
        -:  762:						if(context->protocol == mosq_p_mqtt5){
        -:  763:							send__connack(db, context, 0, MQTT_RC_BAD_USERNAME_OR_PASSWORD, NULL);
        -:  764:						}else{
        -:  765:							send__connack(db, context, 0, CONNACK_REFUSED_BAD_USERNAME_PASSWORD, NULL);
        -:  766:						}
        -:  767:						rc = 1;
        -:  768:						goto handle_connect_error;
        -:  769:					}
        -:  770:				}
        -:  771:			} else { // use_subject_as_username
        -:  772:				BIO *subject_bio = BIO_new(BIO_s_mem());
        -:  773:				X509_NAME_print_ex(subject_bio, X509_get_subject_name(client_cert), 0, XN_FLAG_RFC2253);
        -:  774:				char *data_start = NULL;
        -:  775:				long name_length = BIO_get_mem_data(subject_bio, &data_start);
        -:  776:				char *subject = mosquitto__malloc(sizeof(char)*name_length+1);
        -:  777:				if(!subject){
        -:  778:					BIO_free(subject_bio);
        -:  779:					rc = MOSQ_ERR_NOMEM;
        -:  780:					goto handle_connect_error;
        -:  781:				}
        -:  782:				memcpy(subject, data_start, name_length);
        -:  783:				subject[name_length] = '\0';
        -:  784:				BIO_free(subject_bio);
        -:  785:				context->username = subject;
        -:  786:			}
        -:  787:			if(!context->username){
        -:  788:				rc = 1;
        -:  789:				goto handle_connect_error;
        -:  790:			}
        -:  791:			X509_free(client_cert);
        -:  792:			client_cert = NULL;
        -:  793:#ifdef FINAL_WITH_TLS_PSK
        -:  794:		}
        -:  795:#endif /* FINAL_WITH_TLS_PSK */
        -:  796:	}else{
        -:  797:#endif /* WITH_TLS */
    #####:  798:		if(username_flag || password_flag){
        -:  799:			/* FIXME - these ensure the mosquitto_client_id() and
        -:  800:			 * mosquitto_client_username() functions work, but is hacky */
    #####:  801:			context->id = client_id;
    #####:  802:			context->username = username;
    #####:  803:			rc = mosquitto_unpwd_check(db, context, username, password);
    #####:  804:			context->username = NULL;
    #####:  805:			context->id = NULL;
    #####:  806:			switch(rc){
        -:  807:				case MOSQ_ERR_SUCCESS:
    #####:  808:					break;
        -:  809:				case MOSQ_ERR_AUTH:
    #####:  810:					if(context->protocol == mosq_p_mqtt5){
    #####:  811:						send__connack(db, context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);
    #####:  812:					}else{
    #####:  813:						send__connack(db, context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);
        -:  814:					}
    #####:  815:					context__disconnect(db, context);
    #####:  816:					rc = 1;
    #####:  817:					goto handle_connect_error;
        -:  818:					break;
        -:  819:				default:
    #####:  820:					context__disconnect(db, context);
    #####:  821:					rc = 1;
    #####:  822:					goto handle_connect_error;
        -:  823:					break;
        -:  824:			}
    #####:  825:			context->username = username;
    #####:  826:			context->password = password;
    #####:  827:			username = NULL; /* Avoid free() in error: below. */
    #####:  828:			password = NULL;
    #####:  829:		}else{
    #####:  830:			if((db->config->per_listener_settings && context->listener->security_options.allow_anonymous == false)
    #####:  831:					|| (!db->config->per_listener_settings && db->config->security_options.allow_anonymous == false)){
        -:  832:
    #####:  833:				if(context->protocol == mosq_p_mqtt5){
    #####:  834:					send__connack(db, context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);
    #####:  835:				}else{
    #####:  836:					send__connack(db, context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);
        -:  837:				}
    #####:  838:				rc = 1;
    #####:  839:				goto handle_connect_error;
        -:  840:			}
        -:  841:		}
        -:  842:#ifdef WITH_TLS
        -:  843:	}
        -:  844:#endif
        -:  845:
    #####:  846:	if(context->listener->use_username_as_clientid){
    #####:  847:		if(context->username){
    #####:  848:			mosquitto__free(client_id);
    #####:  849:			client_id = mosquitto__strdup(context->username);
    #####:  850:			if(!client_id){
    #####:  851:				rc = MOSQ_ERR_NOMEM;
    #####:  852:				goto handle_connect_error;
        -:  853:			}
    #####:  854:		}else{
    #####:  855:			if(context->protocol == mosq_p_mqtt5){
    #####:  856:				send__connack(db, context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);
    #####:  857:			}else{
    #####:  858:				send__connack(db, context, 0, CONNACK_REFUSED_NOT_AUTHORIZED, NULL);
        -:  859:			}
    #####:  860:			rc = 1;
    #####:  861:			goto handle_connect_error;
        -:  862:		}
    #####:  863:	}
    #####:  864:	context->clean_start = clean_start;
    #####:  865:	context->id = client_id;
    #####:  866:	context->will = will_struct;
        -:  867:
    #####:  868:	if(context->auth_method){
    #####:  869:		rc = mosquitto_security_auth_start(db, context, false, auth_data, auth_data_len, &auth_data_out, &auth_data_out_len);
    #####:  870:		mosquitto__free(auth_data);
    #####:  871:		if(rc == MOSQ_ERR_SUCCESS){
    #####:  872:			return connect__on_authorised(db, context, auth_data_out, auth_data_out_len);
    #####:  873:		}else if(rc == MOSQ_ERR_AUTH_CONTINUE){
    #####:  874:			mosquitto__set_state(context, mosq_cs_authenticating);
    #####:  875:			rc = send__auth(db, context, MQTT_RC_CONTINUE_AUTHENTICATION, auth_data_out, auth_data_out_len);
    #####:  876:			free(auth_data_out);
    #####:  877:			return rc;
        -:  878:		}else{
    #####:  879:			free(auth_data_out);
    #####:  880:			will__clear(context);
    #####:  881:			if(rc == MOSQ_ERR_AUTH){
    #####:  882:				send__connack(db, context, 0, MQTT_RC_NOT_AUTHORIZED, NULL);
    #####:  883:				mosquitto__free(context->id);
    #####:  884:				context->id = NULL;
    #####:  885:				return MOSQ_ERR_PROTOCOL;
    #####:  886:			}else if(rc == MOSQ_ERR_NOT_SUPPORTED){
        -:  887:				/* Client has requested extended authentication, but we don't support it. */
    #####:  888:				send__connack(db, context, 0, MQTT_RC_BAD_AUTHENTICATION_METHOD, NULL);
    #####:  889:				mosquitto__free(context->id);
    #####:  890:				context->id = NULL;
    #####:  891:				return MOSQ_ERR_PROTOCOL;
        -:  892:			}else{
    #####:  893:				mosquitto__free(context->id);
    #####:  894:				context->id = NULL;
    #####:  895:				return rc;
        -:  896:			}
        -:  897:		}
        -:  898:	}else{
    #####:  899:		return connect__on_authorised(db, context, NULL, 0);
        -:  900:	}
        -:  901:
        -:  902:
        -:  903:handle_connect_error:
    #####:  904:	mosquitto__free(auth_data);
    #####:  905:	mosquitto__free(client_id);
    #####:  906:	mosquitto__free(username);
    #####:  907:	mosquitto__free(password);
        -:  908:
        -:  909:	// This will send DISCONNECT to the client.
        -:  910:	//send__disconnect(context, 0, NULL);
    #####:  911:	if(will_struct){
    #####:  912:		mosquitto_property_free_all(&will_struct->properties);
    #####:  913:		mosquitto__free(will_struct->msg.payload);
    #####:  914:		mosquitto__free(will_struct->msg.topic);
    #####:  915:		mosquitto__free(will_struct);
    #####:  916:	}
        -:  917:#ifdef WITH_TLS
        -:  918:	if(client_cert) X509_free(client_cert);
        -:  919:#endif
        -:  920:	/* We return an error here which means the client is freed later on. */
    #####:  921:	return rc;
    #####:  922:}
