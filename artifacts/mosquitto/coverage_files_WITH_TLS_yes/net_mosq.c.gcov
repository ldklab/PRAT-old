        -:    0:Source:../lib/net_mosq.c
        -:    0:Graph:net_mosq.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2:Copyright (c) 2009-2020 Roger Light <roger@atchoo.org>
        -:    3:
        -:    4:All rights reserved. This program and the accompanying materials
        -:    5:are made available under the terms of the Eclipse Public License v1.0
        -:    6:and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7:
        -:    8:The Eclipse Public License is available at
        -:    9:   http://www.eclipse.org/legal/epl-v10.html
        -:   10:and the Eclipse Distribution License is available at
        -:   11:  http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12:
        -:   13:Contributors:
        -:   14:   Roger Light - initial implementation and documentation.
        -:   15:*/
        -:   16:
        -:   17:#define _GNU_SOURCE
        -:   18:#include "config.h"
        -:   19:
        -:   20:#include <assert.h>
        -:   21:#include <errno.h>
        -:   22:#include <fcntl.h>
        -:   23:#include <stdio.h>
        -:   24:#include <string.h>
        -:   25:#ifndef WIN32
        -:   26:#define _GNU_SOURCE
        -:   27:#include <netdb.h>
        -:   28:#include <sys/socket.h>
        -:   29:#include <unistd.h>
        -:   30:#else
        -:   31:#include <winsock2.h>
        -:   32:#include <ws2tcpip.h>
        -:   33:#endif
        -:   34:
        -:   35:#ifdef __ANDROID__
        -:   36:#include <linux/in.h>
        -:   37:#include <linux/in6.h>
        -:   38:#include <sys/endian.h>
        -:   39:#endif
        -:   40:
        -:   41:#ifdef HAVE_NETINET_IN_H
        -:   42:#  include <netinet/in.h>
        -:   43:#endif
        -:   44:
        -:   45:#ifdef __QNX__
        -:   46:#include <net/netbyte.h>
        -:   47:#endif
        -:   48:
        -:   49:#ifdef WITH_TLS
        -:   50:#include <openssl/conf.h>
        -:   51:#include <openssl/engine.h>
        -:   52:#include <openssl/err.h>
        -:   53:#include <openssl/ui.h>
        -:   54:#include <tls_mosq.h>
        -:   55:#endif
        -:   56:
        -:   57:#ifdef WITH_BROKER
        -:   58:#  include "mosquitto_broker_internal.h"
        -:   59:#  ifdef WITH_WEBSOCKETS
        -:   60:#    include <libwebsockets.h>
        -:   61:#  endif
        -:   62:#else
        -:   63:#  include "read_handle.h"
        -:   64:#endif
        -:   65:
        -:   66:#include "logging_mosq.h"
        -:   67:#include "memory_mosq.h"
        -:   68:#include "mqtt_protocol.h"
        -:   69:#include "net_mosq.h"
        -:   70:#include "time_mosq.h"
        -:   71:#include "util_mosq.h"
        -:   72:
        -:   73:#ifdef WITH_TLS
        -:   74:int tls_ex_index_mosq = -1;
        -:   75:UI_METHOD *_ui_method = NULL;
        -:   76:
        -:   77:/* Functions taken from OpenSSL s_server/s_client */
    #####:   78:static int ui_open(UI *ui)
        -:   79:{
    #####:   80:	return UI_method_get_opener(UI_OpenSSL())(ui);
        -:   81:}
        -:   82:
    #####:   83:static int ui_read(UI *ui, UI_STRING *uis)
        -:   84:{
    #####:   85:	return UI_method_get_reader(UI_OpenSSL())(ui, uis);
        -:   86:}
        -:   87:
    #####:   88:static int ui_write(UI *ui, UI_STRING *uis)
        -:   89:{
    #####:   90:	return UI_method_get_writer(UI_OpenSSL())(ui, uis);
        -:   91:}
        -:   92:
    #####:   93:static int ui_close(UI *ui)
        -:   94:{
    #####:   95:	return UI_method_get_closer(UI_OpenSSL())(ui);
        -:   96:}
        -:   97:
    #####:   98:static void setup_ui_method(void)
        -:   99:{
    #####:  100:	_ui_method = UI_create_method("OpenSSL application user interface");
    #####:  101:	UI_method_set_opener(_ui_method, ui_open);
    #####:  102:	UI_method_set_reader(_ui_method, ui_read);
    #####:  103:	UI_method_set_writer(_ui_method, ui_write);
    #####:  104:	UI_method_set_closer(_ui_method, ui_close);
    #####:  105:}
        -:  106:
    #####:  107:static void cleanup_ui_method(void)
        -:  108:{
    #####:  109:	if(_ui_method){
    #####:  110:		UI_destroy_method(_ui_method);
    #####:  111:		_ui_method = NULL;
    #####:  112:	}
    #####:  113:}
        -:  114:
    #####:  115:UI_METHOD *net__get_ui_method(void)
        -:  116:{
    #####:  117:	return _ui_method;
        -:  118:}
        -:  119:#endif
        -:  120:
    #####:  121:int net__init(void)
        -:  122:{
        -:  123:#ifdef WIN32
        -:  124:	WSADATA wsaData;
        -:  125:	if(WSAStartup(MAKEWORD(2,2), &wsaData) != 0){
        -:  126:		return MOSQ_ERR_UNKNOWN;
        -:  127:	}
        -:  128:#endif
        -:  129:
        -:  130:#ifdef WITH_SRV
        -:  131:	ares_library_init(ARES_LIB_INIT_ALL);
        -:  132:#endif
        -:  133:
        -:  134:#ifdef WITH_TLS
        -:  135:#  if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  136:	SSL_load_error_strings();
        -:  137:	SSL_library_init();
        -:  138:	OpenSSL_add_all_algorithms();
        -:  139:#  else
    #####:  140:	OPENSSL_init_crypto(OPENSSL_INIT_ADD_ALL_CIPHERS \
        -:  141:			| OPENSSL_INIT_ADD_ALL_DIGESTS \
        -:  142:			| OPENSSL_INIT_LOAD_CONFIG, NULL);
        -:  143:#  endif
        -:  144:#if !defined(OPENSSL_NO_ENGINE)
    #####:  145:	ENGINE_load_builtin_engines();
        -:  146:#endif
    #####:  147:	setup_ui_method();
    #####:  148:	if(tls_ex_index_mosq == -1){
    #####:  149:		tls_ex_index_mosq = SSL_get_ex_new_index(0, "client context", NULL, NULL, NULL);
    #####:  150:	}
        -:  151:#endif
    #####:  152:	return MOSQ_ERR_SUCCESS;
        -:  153:}
        -:  154:
    #####:  155:void net__cleanup(void)
        -:  156:{
        -:  157:#ifdef WITH_TLS
        -:  158:#  if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  159:	CRYPTO_cleanup_all_ex_data();
        -:  160:	ERR_free_strings();
        -:  161:	ERR_remove_thread_state(NULL);
        -:  162:	EVP_cleanup();
        -:  163:
        -:  164:#    if !defined(OPENSSL_NO_ENGINE)
        -:  165:	ENGINE_cleanup();
        -:  166:#    endif
        -:  167:#  endif
        -:  168:
    #####:  169:	CONF_modules_unload(1);
    #####:  170:	cleanup_ui_method();
        -:  171:#endif
        -:  172:
        -:  173:#ifdef WITH_SRV
        -:  174:	ares_library_cleanup();
        -:  175:#endif
        -:  176:
        -:  177:#ifdef WIN32
        -:  178:	WSACleanup();
        -:  179:#endif
    #####:  180:}
        -:  181:
        -:  182:
        -:  183:/* Close a socket associated with a context and set it to -1.
        -:  184: * Returns 1 on failure (context is NULL)
        -:  185: * Returns 0 on success.
        -:  186: */
        -:  187:#ifdef WITH_BROKER
    #####:  188:int net__socket_close(struct mosquitto_db *db, struct mosquitto *mosq)
        -:  189:#else
        -:  190:int net__socket_close(struct mosquitto *mosq)
        -:  191:#endif
        -:  192:{
    #####:  193:	int rc = 0;
        -:  194:
    #####:  195:	assert(mosq);
        -:  196:#ifdef WITH_TLS
        -:  197:#ifdef WITH_WEBSOCKETS
        -:  198:	if(!mosq->wsi)
        -:  199:#endif
        -:  200:	{
    #####:  201:		if(mosq->ssl){
    #####:  202:			if(!SSL_in_init(mosq->ssl)){
    #####:  203:				SSL_shutdown(mosq->ssl);
    #####:  204:			}
    #####:  205:			SSL_free(mosq->ssl);
    #####:  206:			mosq->ssl = NULL;
    #####:  207:		}
        -:  208:	}
        -:  209:#endif
        -:  210:
        -:  211:#ifdef WITH_WEBSOCKETS
        -:  212:	if(mosq->wsi)
        -:  213:	{
        -:  214:		if(mosq->state != mosq_cs_disconnecting){
        -:  215:			mosquitto__set_state(mosq, mosq_cs_disconnect_ws);
        -:  216:		}
        -:  217:		libwebsocket_callback_on_writable(mosq->ws_context, mosq->wsi);
        -:  218:	}else
        -:  219:#endif
        -:  220:	{
    #####:  221:		if(mosq->sock != INVALID_SOCKET){
        -:  222:#ifdef WITH_BROKER
    #####:  223:			HASH_DELETE(hh_sock, db->contexts_by_sock, mosq);
        -:  224:#endif
    #####:  225:			rc = COMPAT_CLOSE(mosq->sock);
    #####:  226:			mosq->sock = INVALID_SOCKET;
    #####:  227:		}
        -:  228:	}
        -:  229:
        -:  230:#ifdef WITH_BROKER
    #####:  231:	if(mosq->listener){
    #####:  232:		mosq->listener->client_count--;
    #####:  233:	}
        -:  234:#endif
        -:  235:
    #####:  236:	return rc;
        -:  237:}
        -:  238:
        -:  239:
        -:  240:#ifdef FINAL_WITH_TLS_PSK
        -:  241:static unsigned int psk_client_callback(SSL *ssl, const char *hint,
        -:  242:		char *identity, unsigned int max_identity_len,
        -:  243:		unsigned char *psk, unsigned int max_psk_len)
        -:  244:{
        -:  245:	struct mosquitto *mosq;
        -:  246:	int len;
        -:  247:
        -:  248:	UNUSED(hint);
        -:  249:
        -:  250:	mosq = SSL_get_ex_data(ssl, tls_ex_index_mosq);
        -:  251:	if(!mosq) return 0;
        -:  252:
        -:  253:	snprintf(identity, max_identity_len, "%s", mosq->tls_psk_identity);
        -:  254:
        -:  255:	len = mosquitto__hex2bin(mosq->tls_psk, psk, max_psk_len);
        -:  256:	if (len < 0) return 0;
        -:  257:	return len;
        -:  258:}
        -:  259:#endif
        -:  260:
        -:  261:#if defined(WITH_BROKER) && defined(__GLIBC__) && defined(WITH_ADNS)
        -:  262:/* Async connect, part 1 (dns lookup) */
        -:  263:int net__try_connect_step1(struct mosquitto *mosq, const char *host)
        -:  264:{
        -:  265:	int s;
        -:  266:	void *sevp = NULL;
        -:  267:	struct addrinfo *hints;
        -:  268:
        -:  269:	if(mosq->adns){
        -:  270:		gai_cancel(mosq->adns);
        -:  271:		mosquitto__free((struct addrinfo *)mosq->adns->ar_request);
        -:  272:		mosquitto__free(mosq->adns);
        -:  273:	}
        -:  274:	mosq->adns = mosquitto__calloc(1, sizeof(struct gaicb));
        -:  275:	if(!mosq->adns){
        -:  276:		return MOSQ_ERR_NOMEM;
        -:  277:	}
        -:  278:
        -:  279:	hints = mosquitto__calloc(1, sizeof(struct addrinfo));
        -:  280:	if(!hints){
        -:  281:		mosquitto__free(mosq->adns);
        -:  282:		mosq->adns = NULL;
        -:  283:		return MOSQ_ERR_NOMEM;
        -:  284:	}
        -:  285:
        -:  286:	hints->ai_family = AF_UNSPEC;
        -:  287:	hints->ai_socktype = SOCK_STREAM;
        -:  288:
        -:  289:	mosq->adns->ar_name = host;
        -:  290:	mosq->adns->ar_request = hints;
        -:  291:
        -:  292:	s = getaddrinfo_a(GAI_NOWAIT, &mosq->adns, 1, sevp);
        -:  293:	if(s){
        -:  294:		errno = s;
        -:  295:		if(mosq->adns){
        -:  296:			mosquitto__free((struct addrinfo *)mosq->adns->ar_request);
        -:  297:			mosquitto__free(mosq->adns);
        -:  298:			mosq->adns = NULL;
        -:  299:		}
        -:  300:		return MOSQ_ERR_EAI;
        -:  301:	}
        -:  302:
        -:  303:	return MOSQ_ERR_SUCCESS;
        -:  304:}
        -:  305:
        -:  306:/* Async connect part 2, the connection. */
        -:  307:int net__try_connect_step2(struct mosquitto *mosq, uint16_t port, mosq_sock_t *sock)
        -:  308:{
        -:  309:	struct addrinfo *ainfo, *rp;
        -:  310:	int rc;
        -:  311:
        -:  312:	ainfo = mosq->adns->ar_result;
        -:  313:
        -:  314:	for(rp = ainfo; rp != NULL; rp = rp->ai_next){
        -:  315:		*sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
        -:  316:		if(*sock == INVALID_SOCKET) continue;
        -:  317:
        -:  318:		if(rp->ai_family == AF_INET){
        -:  319:			((struct sockaddr_in *)rp->ai_addr)->sin_port = htons(port);
        -:  320:		}else if(rp->ai_family == AF_INET6){
        -:  321:			((struct sockaddr_in6 *)rp->ai_addr)->sin6_port = htons(port);
        -:  322:		}else{
        -:  323:			COMPAT_CLOSE(*sock);
        -:  324:			*sock = INVALID_SOCKET;
        -:  325:			continue;
        -:  326:		}
        -:  327:
        -:  328:		/* Set non-blocking */
        -:  329:		if(net__socket_nonblock(sock)){
        -:  330:			continue;
        -:  331:		}
        -:  332:
        -:  333:		rc = connect(*sock, rp->ai_addr, rp->ai_addrlen);
        -:  334:#ifdef WIN32
        -:  335:		errno = WSAGetLastError();
        -:  336:#endif
        -:  337:		if(rc == 0 || errno == EINPROGRESS || errno == COMPAT_EWOULDBLOCK){
        -:  338:			if(rc < 0 && (errno == EINPROGRESS || errno == COMPAT_EWOULDBLOCK)){
        -:  339:				rc = MOSQ_ERR_CONN_PENDING;
        -:  340:			}
        -:  341:
        -:  342:			/* Set non-blocking */
        -:  343:			if(net__socket_nonblock(sock)){
        -:  344:				continue;
        -:  345:			}
        -:  346:			break;
        -:  347:		}
        -:  348:
        -:  349:		COMPAT_CLOSE(*sock);
        -:  350:		*sock = INVALID_SOCKET;
        -:  351:	}
        -:  352:	freeaddrinfo(mosq->adns->ar_result);
        -:  353:	mosq->adns->ar_result = NULL;
        -:  354:
        -:  355:	mosquitto__free((struct addrinfo *)mosq->adns->ar_request);
        -:  356:	mosquitto__free(mosq->adns);
        -:  357:	mosq->adns = NULL;
        -:  358:
        -:  359:	if(!rp){
        -:  360:		return MOSQ_ERR_ERRNO;
        -:  361:	}
        -:  362:
        -:  363:	return rc;
        -:  364:}
        -:  365:
        -:  366:#endif
        -:  367:
        -:  368:
    #####:  369:int net__try_connect(const char *host, uint16_t port, mosq_sock_t *sock, const char *bind_address, bool blocking)
        -:  370:{
        -:  371:	struct addrinfo hints;
        -:  372:	struct addrinfo *ainfo, *rp;
        -:  373:	struct addrinfo *ainfo_bind, *rp_bind;
        -:  374:	int s;
    #####:  375:	int rc = MOSQ_ERR_SUCCESS;
        -:  376:#ifdef WIN32
        -:  377:	uint32_t val = 1;
        -:  378:#endif
        -:  379:
    #####:  380:	*sock = INVALID_SOCKET;
    #####:  381:	memset(&hints, 0, sizeof(struct addrinfo));
    #####:  382:	hints.ai_family = AF_UNSPEC;
    #####:  383:	hints.ai_socktype = SOCK_STREAM;
        -:  384:
    #####:  385:	s = getaddrinfo(host, NULL, &hints, &ainfo);
    #####:  386:	if(s){
    #####:  387:		errno = s;
    #####:  388:		return MOSQ_ERR_EAI;
        -:  389:	}
        -:  390:
    #####:  391:	if(bind_address){
    #####:  392:		s = getaddrinfo(bind_address, NULL, &hints, &ainfo_bind);
    #####:  393:		if(s){
    #####:  394:			freeaddrinfo(ainfo);
    #####:  395:			errno = s;
    #####:  396:			return MOSQ_ERR_EAI;
        -:  397:		}
    #####:  398:	}
        -:  399:
    #####:  400:	for(rp = ainfo; rp != NULL; rp = rp->ai_next){
    #####:  401:		*sock = socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
    #####:  402:		if(*sock == INVALID_SOCKET) continue;
        -:  403:
    #####:  404:		if(rp->ai_family == AF_INET){
    #####:  405:			((struct sockaddr_in *)rp->ai_addr)->sin_port = htons(port);
    #####:  406:		}else if(rp->ai_family == AF_INET6){
    #####:  407:			((struct sockaddr_in6 *)rp->ai_addr)->sin6_port = htons(port);
    #####:  408:		}else{
    #####:  409:			COMPAT_CLOSE(*sock);
    #####:  410:			*sock = INVALID_SOCKET;
    #####:  411:			continue;
        -:  412:		}
        -:  413:
    #####:  414:		if(bind_address){
    #####:  415:			for(rp_bind = ainfo_bind; rp_bind != NULL; rp_bind = rp_bind->ai_next){
    #####:  416:				if(bind(*sock, rp_bind->ai_addr, rp_bind->ai_addrlen) == 0){
    #####:  417:					break;
        -:  418:				}
    #####:  419:			}
    #####:  420:			if(!rp_bind){
    #####:  421:				COMPAT_CLOSE(*sock);
    #####:  422:				*sock = INVALID_SOCKET;
    #####:  423:				continue;
        -:  424:			}
    #####:  425:		}
        -:  426:
    #####:  427:		if(!blocking){
        -:  428:			/* Set non-blocking */
    #####:  429:			if(net__socket_nonblock(sock)){
    #####:  430:				continue;
        -:  431:			}
    #####:  432:		}
        -:  433:
    #####:  434:		rc = connect(*sock, rp->ai_addr, rp->ai_addrlen);
        -:  435:#ifdef WIN32
        -:  436:		errno = WSAGetLastError();
        -:  437:#endif
    #####:  438:		if(rc == 0 || errno == EINPROGRESS || errno == COMPAT_EWOULDBLOCK){
    #####:  439:			if(rc < 0 && (errno == EINPROGRESS || errno == COMPAT_EWOULDBLOCK)){
    #####:  440:				rc = MOSQ_ERR_CONN_PENDING;
    #####:  441:			}
        -:  442:
    #####:  443:			if(blocking){
        -:  444:				/* Set non-blocking */
    #####:  445:				if(net__socket_nonblock(sock)){
    #####:  446:					continue;
        -:  447:				}
    #####:  448:			}
    #####:  449:			break;
        -:  450:		}
        -:  451:
    #####:  452:		COMPAT_CLOSE(*sock);
    #####:  453:		*sock = INVALID_SOCKET;
    #####:  454:	}
    #####:  455:	freeaddrinfo(ainfo);
    #####:  456:	if(bind_address){
    #####:  457:		freeaddrinfo(ainfo_bind);
    #####:  458:	}
    #####:  459:	if(!rp){
    #####:  460:		return MOSQ_ERR_ERRNO;
        -:  461:	}
    #####:  462:	return rc;
    #####:  463:}
        -:  464:
        -:  465:
        -:  466:#ifdef WITH_TLS
    #####:  467:void net__print_ssl_error(struct mosquitto *mosq)
        -:  468:{
        -:  469:	char ebuf[256];
        -:  470:	unsigned long e;
    #####:  471:	int num = 0;
        -:  472:
    #####:  473:	e = ERR_get_error();
    #####:  474:	while(e){
    #####:  475:		log__printf(mosq, MOSQ_LOG_ERR, "OpenSSL Error[%d]: %s", num, ERR_error_string(e, ebuf));
    #####:  476:		e = ERR_get_error();
    #####:  477:		num++;
        -:  478:	}
    #####:  479:}
        -:  480:
        -:  481:
    #####:  482:int net__socket_connect_tls(struct mosquitto *mosq)
        -:  483:{
        -:  484:	int ret, err;
        -:  485:
    #####:  486:	ERR_clear_error();
        -:  487:	long res;
    #####:  488:	if (mosq->tls_ocsp_required) {
        -:  489:		// Note: OCSP is available in all currently supported OpenSSL versions.
    #####:  490:		if ((res=SSL_set_tlsext_status_type(mosq->ssl, TLSEXT_STATUSTYPE_ocsp)) != 1) {
    #####:  491:			log__printf(mosq, MOSQ_LOG_ERR, "Could not activate OCSP (error: %ld)", res);
    #####:  492:			return MOSQ_ERR_OCSP;
        -:  493:		}
    #####:  494:		if ((res=SSL_CTX_set_tlsext_status_cb(mosq->ssl_ctx, mosquitto__verify_ocsp_status_cb)) != 1) {
    #####:  495:			log__printf(mosq, MOSQ_LOG_ERR, "Could not activate OCSP (error: %ld)", res);
    #####:  496:			return MOSQ_ERR_OCSP;
        -:  497:		}
    #####:  498:		if ((res=SSL_CTX_set_tlsext_status_arg(mosq->ssl_ctx, mosq)) != 1) {
    #####:  499:			log__printf(mosq, MOSQ_LOG_ERR, "Could not activate OCSP (error: %ld)", res);
    #####:  500:			return MOSQ_ERR_OCSP;
        -:  501:		}
    #####:  502:	}
        -:  503:
    #####:  504:	ret = SSL_connect(mosq->ssl);
    #####:  505:	if(ret != 1) {
    #####:  506:		err = SSL_get_error(mosq->ssl, ret);
    #####:  507:		if (err == SSL_ERROR_SYSCALL) {
    #####:  508:			mosq->want_connect = true;
    #####:  509:			return MOSQ_ERR_SUCCESS;
        -:  510:		}
    #####:  511:		if(err == SSL_ERROR_WANT_READ){
    #####:  512:			mosq->want_connect = true;
        -:  513:			/* We always try to read anyway */
    #####:  514:		}else if(err == SSL_ERROR_WANT_WRITE){
    #####:  515:			mosq->want_write = true;
    #####:  516:			mosq->want_connect = true;
    #####:  517:		}else{
    #####:  518:			net__print_ssl_error(mosq);
        -:  519:
    #####:  520:			COMPAT_CLOSE(mosq->sock);
    #####:  521:			mosq->sock = INVALID_SOCKET;
    #####:  522:			net__print_ssl_error(mosq);
    #####:  523:			return MOSQ_ERR_TLS;
        -:  524:		}
    #####:  525:	}else{
    #####:  526:		mosq->want_connect = false;
        -:  527:	}
    #####:  528:	return MOSQ_ERR_SUCCESS;
    #####:  529:}
        -:  530:#endif
        -:  531:
        -:  532:
        -:  533:#ifdef WITH_TLS
    #####:  534:static int net__init_ssl_ctx(struct mosquitto *mosq)
        -:  535:{
        -:  536:	int ret;
    #####:  537:	ENGINE *engine = NULL;
        -:  538:	uint8_t tls_alpn_wire[256];
        -:  539:	uint8_t tls_alpn_len;
        -:  540:
    #####:  541:	if(mosq->ssl_ctx){
    #####:  542:		if(!mosq->ssl_ctx_defaults){
    #####:  543:			return MOSQ_ERR_SUCCESS;
    #####:  544:		}else if(!mosq->tls_cafile && !mosq->tls_capath && !mosq->tls_psk){
    #####:  545:			log__printf(mosq, MOSQ_LOG_ERR, "Error: MOSQ_OPT_SSL_CTX_WITH_DEFAULTS used without specifying cafile, capath or psk.");
    #####:  546:			return MOSQ_ERR_INVAL;
        -:  547:		}
    #####:  548:	}
        -:  549:
        -:  550:	/* Apply default SSL_CTX settings. This is only used if MOSQ_OPT_SSL_CTX
        -:  551:	 * has not been set, or if both of MOSQ_OPT_SSL_CTX and
        -:  552:	 * MOSQ_OPT_SSL_CTX_WITH_DEFAULTS are set. */
    #####:  553:	if(mosq->tls_cafile || mosq->tls_capath || mosq->tls_psk){
    #####:  554:		if(!mosq->ssl_ctx){
        -:  555:#if OPENSSL_VERSION_NUMBER < 0x10100000L
        -:  556:			mosq->ssl_ctx = SSL_CTX_new(SSLv23_client_method());
        -:  557:#else
    #####:  558:			mosq->ssl_ctx = SSL_CTX_new(TLS_client_method());
        -:  559:#endif
        -:  560:
    #####:  561:			if(!mosq->ssl_ctx){
    #####:  562:				log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to create TLS context.");
    #####:  563:				COMPAT_CLOSE(mosq->sock);
    #####:  564:				mosq->sock = INVALID_SOCKET;
    #####:  565:				net__print_ssl_error(mosq);
    #####:  566:				return MOSQ_ERR_TLS;
        -:  567:			}
    #####:  568:		}
        -:  569:
    #####:  570:		if(!mosq->tls_version){
    #####:  571:			SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1);
        -:  572:#ifdef SSL_OP_NO_TLSv1_3
    #####:  573:		}else if(!strcmp(mosq->tls_version, "tlsv1.3")){
    #####:  574:			SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_2);
    #####:  575:		}else if(!strcmp(mosq->tls_version, "tlsv1.2")){
    #####:  576:			SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1 | SSL_OP_NO_TLSv1_3);
    #####:  577:		}else if(!strcmp(mosq->tls_version, "tlsv1.1")){
    #####:  578:			SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_2 | SSL_OP_NO_TLSv1_3);
        -:  579:#else
        -:  580:		}else if(!strcmp(mosq->tls_version, "tlsv1.2")){
        -:  581:			SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_1);
        -:  582:		}else if(!strcmp(mosq->tls_version, "tlsv1.1")){
        -:  583:			SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_SSLv3 | SSL_OP_NO_TLSv1 | SSL_OP_NO_TLSv1_2);
        -:  584:#endif
    #####:  585:		}else{
    #####:  586:			log__printf(mosq, MOSQ_LOG_ERR, "Error: Protocol %s not supported.", mosq->tls_version);
    #####:  587:			COMPAT_CLOSE(mosq->sock);
    #####:  588:			mosq->sock = INVALID_SOCKET;
    #####:  589:			return MOSQ_ERR_INVAL;
        -:  590:		}
        -:  591:
        -:  592:		/* Disable compression */
    #####:  593:		SSL_CTX_set_options(mosq->ssl_ctx, SSL_OP_NO_COMPRESSION);
        -:  594:
        -:  595:		/* Set ALPN */
    #####:  596:		if(mosq->tls_alpn) {
    #####:  597:			tls_alpn_len = (uint8_t) strnlen(mosq->tls_alpn, 254);
    #####:  598:			tls_alpn_wire[0] = tls_alpn_len;  // first byte is length of string
    #####:  599:			memcpy(tls_alpn_wire + 1, mosq->tls_alpn, tls_alpn_len);
    #####:  600:			SSL_CTX_set_alpn_protos(mosq->ssl_ctx, tls_alpn_wire, tls_alpn_len + 1);
    #####:  601:		}
        -:  602:
        -:  603:#ifdef SSL_MODE_RELEASE_BUFFERS
        -:  604:			/* Use even less memory per SSL connection. */
    #####:  605:			SSL_CTX_set_mode(mosq->ssl_ctx, SSL_MODE_RELEASE_BUFFERS);
        -:  606:#endif
        -:  607:
        -:  608:#if !defined(OPENSSL_NO_ENGINE)
    #####:  609:		if(mosq->tls_engine){
    #####:  610:			engine = ENGINE_by_id(mosq->tls_engine);
    #####:  611:			if(!engine){
    #####:  612:				log__printf(mosq, MOSQ_LOG_ERR, "Error loading %s engine\n", mosq->tls_engine);
    #####:  613:				COMPAT_CLOSE(mosq->sock);
    #####:  614:				mosq->sock = INVALID_SOCKET;
    #####:  615:				return MOSQ_ERR_TLS;
        -:  616:			}
    #####:  617:			if(!ENGINE_init(engine)){
    #####:  618:				log__printf(mosq, MOSQ_LOG_ERR, "Failed engine initialisation\n");
    #####:  619:				ENGINE_free(engine);
    #####:  620:				COMPAT_CLOSE(mosq->sock);
    #####:  621:				mosq->sock = INVALID_SOCKET;
    #####:  622:				return MOSQ_ERR_TLS;
        -:  623:			}
    #####:  624:			ENGINE_set_default(engine, ENGINE_METHOD_ALL);
    #####:  625:			ENGINE_free(engine); /* release the structural reference from ENGINE_by_id() */
    #####:  626:		}
        -:  627:#endif
        -:  628:
    #####:  629:		if(mosq->tls_ciphers){
    #####:  630:			ret = SSL_CTX_set_cipher_list(mosq->ssl_ctx, mosq->tls_ciphers);
    #####:  631:			if(ret == 0){
    #####:  632:				log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to set TLS ciphers. Check cipher list \"%s\".", mosq->tls_ciphers);
        -:  633:#if !defined(OPENSSL_NO_ENGINE)
    #####:  634:				ENGINE_FINISH(engine);
        -:  635:#endif
    #####:  636:				COMPAT_CLOSE(mosq->sock);
    #####:  637:				mosq->sock = INVALID_SOCKET;
    #####:  638:				net__print_ssl_error(mosq);
    #####:  639:				return MOSQ_ERR_TLS;
        -:  640:			}
    #####:  641:		}
    #####:  642:		if(mosq->tls_cafile || mosq->tls_capath){
    #####:  643:			ret = SSL_CTX_load_verify_locations(mosq->ssl_ctx, mosq->tls_cafile, mosq->tls_capath);
    #####:  644:			if(ret == 0){
        -:  645:#ifdef WITH_BROKER
    #####:  646:				if(mosq->tls_cafile && mosq->tls_capath){
    #####:  647:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load CA certificates, check bridge_cafile \"%s\" and bridge_capath \"%s\".", mosq->tls_cafile, mosq->tls_capath);
    #####:  648:				}else if(mosq->tls_cafile){
    #####:  649:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load CA certificates, check bridge_cafile \"%s\".", mosq->tls_cafile);
    #####:  650:				}else{
    #####:  651:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load CA certificates, check bridge_capath \"%s\".", mosq->tls_capath);
        -:  652:				}
        -:  653:#else
        -:  654:				if(mosq->tls_cafile && mosq->tls_capath){
        -:  655:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load CA certificates, check cafile \"%s\" and capath \"%s\".", mosq->tls_cafile, mosq->tls_capath);
        -:  656:				}else if(mosq->tls_cafile){
        -:  657:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load CA certificates, check cafile \"%s\".", mosq->tls_cafile);
        -:  658:				}else{
        -:  659:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load CA certificates, check capath \"%s\".", mosq->tls_capath);
        -:  660:				}
        -:  661:#endif
        -:  662:#if !defined(OPENSSL_NO_ENGINE)
    #####:  663:				ENGINE_FINISH(engine);
        -:  664:#endif
    #####:  665:				COMPAT_CLOSE(mosq->sock);
    #####:  666:				mosq->sock = INVALID_SOCKET;
    #####:  667:				net__print_ssl_error(mosq);
    #####:  668:				return MOSQ_ERR_TLS;
        -:  669:			}
    #####:  670:			if(mosq->tls_cert_reqs == 0){
    #####:  671:				SSL_CTX_set_verify(mosq->ssl_ctx, SSL_VERIFY_NONE, NULL);
    #####:  672:			}else{
    #####:  673:				SSL_CTX_set_verify(mosq->ssl_ctx, SSL_VERIFY_PEER, mosquitto__server_certificate_verify);
        -:  674:			}
        -:  675:
    #####:  676:			if(mosq->tls_pw_callback){
    #####:  677:				SSL_CTX_set_default_passwd_cb(mosq->ssl_ctx, mosq->tls_pw_callback);
    #####:  678:				SSL_CTX_set_default_passwd_cb_userdata(mosq->ssl_ctx, mosq);
    #####:  679:			}
        -:  680:
    #####:  681:			if(mosq->tls_certfile){
    #####:  682:				ret = SSL_CTX_use_certificate_chain_file(mosq->ssl_ctx, mosq->tls_certfile);
    #####:  683:				if(ret != 1){
        -:  684:#ifdef WITH_BROKER
    #####:  685:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load client certificate, check bridge_certfile \"%s\".", mosq->tls_certfile);
        -:  686:#else
        -:  687:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load client certificate \"%s\".", mosq->tls_certfile);
        -:  688:#endif
        -:  689:#if !defined(OPENSSL_NO_ENGINE)
    #####:  690:					ENGINE_FINISH(engine);
        -:  691:#endif
    #####:  692:					COMPAT_CLOSE(mosq->sock);
    #####:  693:					mosq->sock = INVALID_SOCKET;
    #####:  694:					net__print_ssl_error(mosq);
    #####:  695:					return MOSQ_ERR_TLS;
        -:  696:				}
    #####:  697:			}
    #####:  698:			if(mosq->tls_keyfile){
    #####:  699:				if(mosq->tls_keyform == mosq_k_engine){
        -:  700:#if !defined(OPENSSL_NO_ENGINE)
    #####:  701:					UI_METHOD *ui_method = net__get_ui_method();
    #####:  702:					if(mosq->tls_engine_kpass_sha1){
    #####:  703:						if(!ENGINE_ctrl_cmd(engine, ENGINE_SECRET_MODE, ENGINE_SECRET_MODE_SHA, NULL, NULL, 0)){
    #####:  704:							log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to set engine secret mode sha1");
    #####:  705:							ENGINE_FINISH(engine);
    #####:  706:							COMPAT_CLOSE(mosq->sock);
    #####:  707:							mosq->sock = INVALID_SOCKET;
    #####:  708:							net__print_ssl_error(mosq);
    #####:  709:							return MOSQ_ERR_TLS;
        -:  710:						}
    #####:  711:						if(!ENGINE_ctrl_cmd(engine, ENGINE_PIN, 0, mosq->tls_engine_kpass_sha1, NULL, 0)){
    #####:  712:							log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to set engine pin");
    #####:  713:							ENGINE_FINISH(engine);
    #####:  714:							COMPAT_CLOSE(mosq->sock);
    #####:  715:							mosq->sock = INVALID_SOCKET;
    #####:  716:							net__print_ssl_error(mosq);
    #####:  717:							return MOSQ_ERR_TLS;
        -:  718:						}
    #####:  719:						ui_method = NULL;
    #####:  720:					}
    #####:  721:					EVP_PKEY *pkey = ENGINE_load_private_key(engine, mosq->tls_keyfile, ui_method, NULL);
    #####:  722:					if(!pkey){
    #####:  723:						log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load engine private key file \"%s\".", mosq->tls_keyfile);
    #####:  724:						ENGINE_FINISH(engine);
    #####:  725:						COMPAT_CLOSE(mosq->sock);
    #####:  726:						mosq->sock = INVALID_SOCKET;
    #####:  727:						net__print_ssl_error(mosq);
    #####:  728:						return MOSQ_ERR_TLS;
        -:  729:					}
    #####:  730:					if(SSL_CTX_use_PrivateKey(mosq->ssl_ctx, pkey) <= 0){
    #####:  731:						log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to use engine private key file \"%s\".", mosq->tls_keyfile);
    #####:  732:						ENGINE_FINISH(engine);
    #####:  733:						COMPAT_CLOSE(mosq->sock);
    #####:  734:						mosq->sock = INVALID_SOCKET;
    #####:  735:						net__print_ssl_error(mosq);
    #####:  736:						return MOSQ_ERR_TLS;
        -:  737:					}
        -:  738:#endif
    #####:  739:				}else{
    #####:  740:					ret = SSL_CTX_use_PrivateKey_file(mosq->ssl_ctx, mosq->tls_keyfile, SSL_FILETYPE_PEM);
    #####:  741:					if(ret != 1){
        -:  742:#ifdef WITH_BROKER
    #####:  743:						log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load client key file, check bridge_keyfile \"%s\".", mosq->tls_keyfile);
        -:  744:#else
        -:  745:						log__printf(mosq, MOSQ_LOG_ERR, "Error: Unable to load client key file \"%s\".", mosq->tls_keyfile);
        -:  746:#endif
        -:  747:#if !defined(OPENSSL_NO_ENGINE)
    #####:  748:						ENGINE_FINISH(engine);
        -:  749:#endif
    #####:  750:						COMPAT_CLOSE(mosq->sock);
    #####:  751:						mosq->sock = INVALID_SOCKET;
    #####:  752:						net__print_ssl_error(mosq);
    #####:  753:						return MOSQ_ERR_TLS;
        -:  754:					}
        -:  755:				}
    #####:  756:				ret = SSL_CTX_check_private_key(mosq->ssl_ctx);
    #####:  757:				if(ret != 1){
    #####:  758:					log__printf(mosq, MOSQ_LOG_ERR, "Error: Client certificate/key are inconsistent.");
        -:  759:#if !defined(OPENSSL_NO_ENGINE)
    #####:  760:					ENGINE_FINISH(engine);
        -:  761:#endif
    #####:  762:					COMPAT_CLOSE(mosq->sock);
    #####:  763:					mosq->sock = INVALID_SOCKET;
    #####:  764:					net__print_ssl_error(mosq);
    #####:  765:					return MOSQ_ERR_TLS;
        -:  766:				}
    #####:  767:			}
        -:  768:#ifdef FINAL_WITH_TLS_PSK
        -:  769:		}else if(mosq->tls_psk){
        -:  770:			SSL_CTX_set_psk_client_callback(mosq->ssl_ctx, psk_client_callback);
        -:  771:#endif
    #####:  772:		}
    #####:  773:	}
        -:  774:
    #####:  775:	return MOSQ_ERR_SUCCESS;
    #####:  776:}
        -:  777:#endif
        -:  778:
        -:  779:
    #####:  780:int net__socket_connect_step3(struct mosquitto *mosq, const char *host)
        -:  781:{
        -:  782:#ifdef WITH_TLS
        -:  783:	BIO *bio;
        -:  784:
    #####:  785:	int rc = net__init_ssl_ctx(mosq);
    #####:  786:	if(rc) return rc;
        -:  787:
    #####:  788:	if(mosq->ssl_ctx){
    #####:  789:		if(mosq->ssl){
    #####:  790:			SSL_free(mosq->ssl);
    #####:  791:		}
    #####:  792:		mosq->ssl = SSL_new(mosq->ssl_ctx);
    #####:  793:		if(!mosq->ssl){
    #####:  794:			COMPAT_CLOSE(mosq->sock);
    #####:  795:			mosq->sock = INVALID_SOCKET;
    #####:  796:			net__print_ssl_error(mosq);
    #####:  797:			return MOSQ_ERR_TLS;
        -:  798:		}
        -:  799:
    #####:  800:		SSL_set_ex_data(mosq->ssl, tls_ex_index_mosq, mosq);
    #####:  801:		bio = BIO_new_socket(mosq->sock, BIO_NOCLOSE);
    #####:  802:		if(!bio){
    #####:  803:			COMPAT_CLOSE(mosq->sock);
    #####:  804:			mosq->sock = INVALID_SOCKET;
    #####:  805:			net__print_ssl_error(mosq);
    #####:  806:			return MOSQ_ERR_TLS;
        -:  807:		}
    #####:  808:		SSL_set_bio(mosq->ssl, bio, bio);
        -:  809:
        -:  810:		/*
        -:  811:		 * required for the SNI resolving
        -:  812:		 */
    #####:  813:		if(SSL_set_tlsext_host_name(mosq->ssl, host) != 1) {
    #####:  814:			COMPAT_CLOSE(mosq->sock);
    #####:  815:			mosq->sock = INVALID_SOCKET;
    #####:  816:			return MOSQ_ERR_TLS;
        -:  817:		}
        -:  818:
    #####:  819:		if(net__socket_connect_tls(mosq)){
    #####:  820:			return MOSQ_ERR_TLS;
        -:  821:		}
        -:  822:
    #####:  823:	}
        -:  824:#endif
    #####:  825:	return MOSQ_ERR_SUCCESS;
    #####:  826:}
        -:  827:
        -:  828:/* Create a socket and connect it to 'ip' on port 'port'.  */
    #####:  829:int net__socket_connect(struct mosquitto *mosq, const char *host, uint16_t port, const char *bind_address, bool blocking)
        -:  830:{
    #####:  831:	mosq_sock_t sock = INVALID_SOCKET;
        -:  832:	int rc, rc2;
        -:  833:
    #####:  834:	if(!mosq || !host || !port) return MOSQ_ERR_INVAL;
        -:  835:
    #####:  836:	rc = net__try_connect(host, port, &sock, bind_address, blocking);
    #####:  837:	if(rc > 0) return rc;
        -:  838:
    #####:  839:	mosq->sock = sock;
        -:  840:
        -:  841:#if defined(WITH_SOCKS) && !defined(WITH_BROKER)
        -:  842:	if(!mosq->socks5_host)
        -:  843:#endif
        -:  844:	{
    #####:  845:		rc2 = net__socket_connect_step3(mosq, host);
    #####:  846:		if(rc2) return rc2;
        -:  847:	}
        -:  848:
    #####:  849:	return MOSQ_ERR_SUCCESS;
    #####:  850:}
        -:  851:
        -:  852:
    #####:  853:ssize_t net__read(struct mosquitto *mosq, void *buf, size_t count)
        -:  854:{
        -:  855:#ifdef WITH_TLS
        -:  856:	int ret;
        -:  857:	int err;
        -:  858:#endif
    #####:  859:	assert(mosq);
    #####:  860:	errno = 0;
        -:  861:#ifdef WITH_TLS
    #####:  862:	if(mosq->ssl){
    #####:  863:		ret = SSL_read(mosq->ssl, buf, count);
    #####:  864:		if(ret <= 0){
    #####:  865:			err = SSL_get_error(mosq->ssl, ret);
    #####:  866:			if(err == SSL_ERROR_WANT_READ){
    #####:  867:				ret = -1;
    #####:  868:				errno = EAGAIN;
    #####:  869:			}else if(err == SSL_ERROR_WANT_WRITE){
    #####:  870:				ret = -1;
    #####:  871:				mosq->want_write = true;
    #####:  872:				errno = EAGAIN;
    #####:  873:			}else{
    #####:  874:				net__print_ssl_error(mosq);
    #####:  875:				errno = EPROTO;
        -:  876:			}
    #####:  877:			ERR_clear_error();
        -:  878:#ifdef WIN32
        -:  879:			WSASetLastError(errno);
        -:  880:#endif
    #####:  881:		}
    #####:  882:		return (ssize_t )ret;
        -:  883:	}else{
        -:  884:		/* Call normal read/recv */
        -:  885:
        -:  886:#endif
        -:  887:
        -:  888:#ifndef WIN32
    #####:  889:	return read(mosq->sock, buf, count);
        -:  890:#else
        -:  891:	return recv(mosq->sock, buf, count, 0);
        -:  892:#endif
        -:  893:
        -:  894:#ifdef WITH_TLS
        -:  895:	}
        -:  896:#endif
    #####:  897:}
        -:  898:
    #####:  899:ssize_t net__write(struct mosquitto *mosq, void *buf, size_t count)
        -:  900:{
        -:  901:#ifdef WITH_TLS
        -:  902:	int ret;
        -:  903:	int err;
        -:  904:#endif
    #####:  905:	assert(mosq);
        -:  906:
    #####:  907:	errno = 0;
        -:  908:#ifdef WITH_TLS
    #####:  909:	if(mosq->ssl){
    #####:  910:		mosq->want_write = false;
    #####:  911:		ret = SSL_write(mosq->ssl, buf, count);
    #####:  912:		if(ret < 0){
    #####:  913:			err = SSL_get_error(mosq->ssl, ret);
    #####:  914:			if(err == SSL_ERROR_WANT_READ){
    #####:  915:				ret = -1;
    #####:  916:				errno = EAGAIN;
    #####:  917:			}else if(err == SSL_ERROR_WANT_WRITE){
    #####:  918:				ret = -1;
    #####:  919:				mosq->want_write = true;
    #####:  920:				errno = EAGAIN;
    #####:  921:			}else{
    #####:  922:				net__print_ssl_error(mosq);
    #####:  923:				errno = EPROTO;
        -:  924:			}
    #####:  925:			ERR_clear_error();
        -:  926:#ifdef WIN32
        -:  927:			WSASetLastError(errno);
        -:  928:#endif
    #####:  929:		}
    #####:  930:		return (ssize_t )ret;
        -:  931:	}else{
        -:  932:		/* Call normal write/send */
        -:  933:#endif
        -:  934:
        -:  935:#ifndef WIN32
    #####:  936:	return write(mosq->sock, buf, count);
        -:  937:#else
        -:  938:	return send(mosq->sock, buf, count, 0);
        -:  939:#endif
        -:  940:
        -:  941:#ifdef WITH_TLS
        -:  942:	}
        -:  943:#endif
    #####:  944:}
        -:  945:
        -:  946:
    #####:  947:int net__socket_nonblock(mosq_sock_t *sock)
        -:  948:{
        -:  949:#ifndef WIN32
        -:  950:	int opt;
        -:  951:	/* Set non-blocking */
    #####:  952:	opt = fcntl(*sock, F_GETFL, 0);
    #####:  953:	if(opt == -1){
    #####:  954:		COMPAT_CLOSE(*sock);
    #####:  955:		*sock = INVALID_SOCKET;
    #####:  956:		return MOSQ_ERR_ERRNO;
        -:  957:	}
    #####:  958:	if(fcntl(*sock, F_SETFL, opt | O_NONBLOCK) == -1){
        -:  959:		/* If either fcntl fails, don't want to allow this client to connect. */
    #####:  960:		COMPAT_CLOSE(*sock);
    #####:  961:		*sock = INVALID_SOCKET;
    #####:  962:		return MOSQ_ERR_ERRNO;
        -:  963:	}
        -:  964:#else
        -:  965:	unsigned long opt = 1;
        -:  966:	if(ioctlsocket(*sock, FIONBIO, &opt)){
        -:  967:		COMPAT_CLOSE(*sock);
        -:  968:		*sock = INVALID_SOCKET;
        -:  969:		return MOSQ_ERR_ERRNO;
        -:  970:	}
        -:  971:#endif
    #####:  972:	return MOSQ_ERR_SUCCESS;
    #####:  973:}
        -:  974:
        -:  975:
        -:  976:#ifndef WITH_BROKER
        -:  977:int net__socketpair(mosq_sock_t *pairR, mosq_sock_t *pairW)
        -:  978:{
        -:  979:#ifdef WIN32
        -:  980:	int family[2] = {AF_INET, AF_INET6};
        -:  981:	int i;
        -:  982:	struct sockaddr_storage ss;
        -:  983:	struct sockaddr_in *sa = (struct sockaddr_in *)&ss;
        -:  984:	struct sockaddr_in6 *sa6 = (struct sockaddr_in6 *)&ss;
        -:  985:	socklen_t ss_len;
        -:  986:	mosq_sock_t spR, spW;
        -:  987:
        -:  988:	mosq_sock_t listensock;
        -:  989:
        -:  990:	*pairR = INVALID_SOCKET;
        -:  991:	*pairW = INVALID_SOCKET;
        -:  992:
        -:  993:	for(i=0; i<2; i++){
        -:  994:		memset(&ss, 0, sizeof(ss));
        -:  995:		if(family[i] == AF_INET){
        -:  996:			sa->sin_family = family[i];
        -:  997:			sa->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        -:  998:			sa->sin_port = 0;
        -:  999:			ss_len = sizeof(struct sockaddr_in);
        -: 1000:		}else if(family[i] == AF_INET6){
        -: 1001:			sa6->sin6_family = family[i];
        -: 1002:			sa6->sin6_addr = in6addr_loopback;
        -: 1003:			sa6->sin6_port = 0;
        -: 1004:			ss_len = sizeof(struct sockaddr_in6);
        -: 1005:		}else{
        -: 1006:			return MOSQ_ERR_INVAL;
        -: 1007:		}
        -: 1008:
        -: 1009:		listensock = socket(family[i], SOCK_STREAM, IPPROTO_TCP);
        -: 1010:		if(listensock == -1){
        -: 1011:			continue;
        -: 1012:		}
        -: 1013:
        -: 1014:		if(bind(listensock, (struct sockaddr *)&ss, ss_len) == -1){
        -: 1015:			COMPAT_CLOSE(listensock);
        -: 1016:			continue;
        -: 1017:		}
        -: 1018:
        -: 1019:		if(listen(listensock, 1) == -1){
        -: 1020:			COMPAT_CLOSE(listensock);
        -: 1021:			continue;
        -: 1022:		}
        -: 1023:		memset(&ss, 0, sizeof(ss));
        -: 1024:		ss_len = sizeof(ss);
        -: 1025:		if(getsockname(listensock, (struct sockaddr *)&ss, &ss_len) < 0){
        -: 1026:			COMPAT_CLOSE(listensock);
        -: 1027:			continue;
        -: 1028:		}
        -: 1029:
        -: 1030:		if(family[i] == AF_INET){
        -: 1031:			sa->sin_family = family[i];
        -: 1032:			sa->sin_addr.s_addr = htonl(INADDR_LOOPBACK);
        -: 1033:			ss_len = sizeof(struct sockaddr_in);
        -: 1034:		}else if(family[i] == AF_INET6){
        -: 1035:			sa6->sin6_family = family[i];
        -: 1036:			sa6->sin6_addr = in6addr_loopback;
        -: 1037:			ss_len = sizeof(struct sockaddr_in6);
        -: 1038:		}
        -: 1039:
        -: 1040:		spR = socket(family[i], SOCK_STREAM, IPPROTO_TCP);
        -: 1041:		if(spR == -1){
        -: 1042:			COMPAT_CLOSE(listensock);
        -: 1043:			continue;
        -: 1044:		}
        -: 1045:		if(net__socket_nonblock(&spR)){
        -: 1046:			COMPAT_CLOSE(listensock);
        -: 1047:			continue;
        -: 1048:		}
        -: 1049:		if(connect(spR, (struct sockaddr *)&ss, ss_len) < 0){
        -: 1050:#ifdef WIN32
        -: 1051:			errno = WSAGetLastError();
        -: 1052:#endif
        -: 1053:			if(errno != EINPROGRESS && errno != COMPAT_EWOULDBLOCK){
        -: 1054:				COMPAT_CLOSE(spR);
        -: 1055:				COMPAT_CLOSE(listensock);
        -: 1056:				continue;
        -: 1057:			}
        -: 1058:		}
        -: 1059:		spW = accept(listensock, NULL, 0);
        -: 1060:		if(spW == -1){
        -: 1061:#ifdef WIN32
        -: 1062:			errno = WSAGetLastError();
        -: 1063:#endif
        -: 1064:			if(errno != EINPROGRESS && errno != COMPAT_EWOULDBLOCK){
        -: 1065:				COMPAT_CLOSE(spR);
        -: 1066:				COMPAT_CLOSE(listensock);
        -: 1067:				continue;
        -: 1068:			}
        -: 1069:		}
        -: 1070:
        -: 1071:		if(net__socket_nonblock(&spW)){
        -: 1072:			COMPAT_CLOSE(spR);
        -: 1073:			COMPAT_CLOSE(listensock);
        -: 1074:			continue;
        -: 1075:		}
        -: 1076:		COMPAT_CLOSE(listensock);
        -: 1077:
        -: 1078:		*pairR = spR;
        -: 1079:		*pairW = spW;
        -: 1080:		return MOSQ_ERR_SUCCESS;
        -: 1081:	}
        -: 1082:	return MOSQ_ERR_UNKNOWN;
        -: 1083:#else
        -: 1084:	int sv[2];
        -: 1085:
        -: 1086:	if(socketpair(AF_UNIX, SOCK_STREAM, 0, sv) == -1){
        -: 1087:		return MOSQ_ERR_ERRNO;
        -: 1088:	}
        -: 1089:	if(net__socket_nonblock(&sv[0])){
        -: 1090:		COMPAT_CLOSE(sv[1]);
        -: 1091:		return MOSQ_ERR_ERRNO;
        -: 1092:	}
        -: 1093:	if(net__socket_nonblock(&sv[1])){
        -: 1094:		COMPAT_CLOSE(sv[0]);
        -: 1095:		return MOSQ_ERR_ERRNO;
        -: 1096:	}
        -: 1097:	*pairR = sv[0];
        -: 1098:	*pairW = sv[1];
        -: 1099:	return MOSQ_ERR_SUCCESS;
        -: 1100:#endif
        -: 1101:}
        -: 1102:#endif
