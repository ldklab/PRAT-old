        -:    0:Source:subs.c
        -:    0:Graph:subs.gcno
        -:    0:Data:-
        -:    0:Runs:0
        -:    0:Programs:0
        -:    1:/*
        -:    2:Copyright (c) 2010-2020 Roger Light <roger@atchoo.org>
        -:    3:
        -:    4:All rights reserved. This program and the accompanying materials
        -:    5:are made available under the terms of the Eclipse Public License v1.0
        -:    6:and Eclipse Distribution License v1.0 which accompany this distribution.
        -:    7: 
        -:    8:The Eclipse Public License is available at
        -:    9:   http://www.eclipse.org/legal/epl-v10.html
        -:   10:and the Eclipse Distribution License is available at
        -:   11:  http://www.eclipse.org/org/documents/edl-v10.php.
        -:   12: 
        -:   13:Contributors:
        -:   14:   Roger Light - initial implementation and documentation.
        -:   15:*/
        -:   16:
        -:   17:/* A note on matching topic subscriptions.
        -:   18: *
        -:   19: * Topics can be up to 32767 characters in length. The / character is used as a
        -:   20: * hierarchy delimiter. Messages are published to a particular topic.
        -:   21: * Clients may subscribe to particular topics directly, but may also use
        -:   22: * wildcards in subscriptions.  The + and # characters are used as wildcards.
        -:   23: * The # wildcard can be used at the end of a subscription only, and is a
        -:   24: * wildcard for the level of hierarchy at which it is placed and all subsequent
        -:   25: * levels.
        -:   26: * The + wildcard may be used at any point within the subscription and is a
        -:   27: * wildcard for only the level of hierarchy at which it is placed.
        -:   28: * Neither wildcard may be used as part of a substring.
        -:   29: * Valid:
        -:   30: * 	a/b/+
        -:   31: * 	a/+/c
        -:   32: * 	a/#
        -:   33: * 	a/b/#
        -:   34: * 	#
        -:   35: * 	+/b/c
        -:   36: * 	+/+/+
        -:   37: * Invalid:
        -:   38: *	a/#/c
        -:   39: *	a+/b/c
        -:   40: * Valid but non-matching:
        -:   41: *	a/b
        -:   42: *	a/+
        -:   43: *	+/b
        -:   44: *	b/c/a
        -:   45: *	a/b/d
        -:   46: */
        -:   47:
        -:   48:#include "config.h"
        -:   49:
        -:   50:#include <assert.h>
        -:   51:#include <stdio.h>
        -:   52:#include <string.h>
        -:   53:
        -:   54:#include "mosquitto_broker_internal.h"
        -:   55:#include "memory_mosq.h"
        -:   56:#include "mqtt_protocol.h"
        -:   57:#include "util_mosq.h"
        -:   58:
        -:   59:#include "utlist.h"
        -:   60:
        -:   61:struct sub__token {
        -:   62:	struct sub__token *next;
        -:   63:	char *topic;
        -:   64:	uint16_t topic_len;
        -:   65:};
        -:   66:
        -:   67:
    #####:   68:static int subs__send(struct mosquitto_db *db, struct mosquitto__subleaf *leaf, const char *topic, int qos, int retain, struct mosquitto_msg_store *stored)
        -:   69:{
        -:   70:	bool client_retain;
        -:   71:	uint16_t mid;
        -:   72:	int client_qos, msg_qos;
    #####:   73:	mosquitto_property *properties = NULL;
        -:   74:	int rc2;
        -:   75:
        -:   76:	/* Check for ACL topic access. */
    #####:   77:	rc2 = mosquitto_acl_check(db, leaf->context, topic, stored->payloadlen, UHPA_ACCESS(stored->payload, stored->payloadlen), stored->qos, stored->retain, MOSQ_ACL_READ);
    #####:   78:	if(rc2 == MOSQ_ERR_ACL_DENIED){
    #####:   79:		return MOSQ_ERR_SUCCESS;
    #####:   80:	}else if(rc2 == MOSQ_ERR_SUCCESS){
    #####:   81:		client_qos = leaf->qos;
        -:   82:
    #####:   83:		if(db->config->upgrade_outgoing_qos){
    #####:   84:			msg_qos = client_qos;
    #####:   85:		}else{
    #####:   86:			if(qos > client_qos){
    #####:   87:				msg_qos = client_qos;
    #####:   88:			}else{
    #####:   89:				msg_qos = qos;
        -:   90:			}
        -:   91:		}
    #####:   92:		if(msg_qos){
    #####:   93:			mid = mosquitto__mid_generate(leaf->context);
    #####:   94:		}else{
    #####:   95:			mid = 0;
        -:   96:		}
    #####:   97:		if(leaf->retain_as_published){
    #####:   98:			client_retain = retain;
    #####:   99:		}else{
    #####:  100:			client_retain = false;
        -:  101:		}
    #####:  102:		if(leaf->identifier){
    #####:  103:			mosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, leaf->identifier);
    #####:  104:		}
    #####:  105:		if(db__message_insert(db, leaf->context, mid, mosq_md_out, msg_qos, client_retain, stored, properties) == 1){
    #####:  106:			return 1;
        -:  107:		}
    #####:  108:	}else{
    #####:  109:		return 1; /* Application error */
        -:  110:	}
    #####:  111:	return 0;
    #####:  112:}
        -:  113:
        -:  114:
    #####:  115:static int subs__shared_process(struct mosquitto_db *db, struct mosquitto__subhier *hier, const char *topic, int qos, int retain, struct mosquitto_msg_store *stored)
        -:  116:{
    #####:  117:	int rc = 0, rc2;
        -:  118:	struct mosquitto__subshared *shared, *shared_tmp;
        -:  119:	struct mosquitto__subleaf *leaf;
        -:  120:
    #####:  121:	HASH_ITER(hh, hier->shared, shared, shared_tmp){
    #####:  122:		leaf = shared->subs;
    #####:  123:		rc2 = subs__send(db, leaf, topic, qos, retain, stored);
        -:  124:		/* Remove current from the top, add back to the bottom */
    #####:  125:		DL_DELETE(shared->subs, leaf);
    #####:  126:		DL_APPEND(shared->subs, leaf);
        -:  127:
    #####:  128:		if(rc2) rc = 1;
    #####:  129:	}
        -:  130:
    #####:  131:	return rc;
        -:  132:}
        -:  133:
    #####:  134:static int subs__process(struct mosquitto_db *db, struct mosquitto__subhier *hier, const char *source_id, const char *topic, int qos, int retain, struct mosquitto_msg_store *stored, bool set_retain)
        -:  135:{
    #####:  136:	int rc = 0;
        -:  137:	int rc2;
        -:  138:	struct mosquitto__subleaf *leaf;
        -:  139:
    #####:  140:	if(retain && set_retain){
        -:  141:#ifdef WITH_PERSISTENCE
        -:  142:		if(strncmp(topic, "$SYS", 4)){
        -:  143:			/* Retained messages count as a persistence change, but only if
        -:  144:			 * they aren't for $SYS. */
        -:  145:			db->persistence_changes++;
        -:  146:		}
        -:  147:#endif
    #####:  148:		if(hier->retained){
    #####:  149:			db__msg_store_ref_dec(db, &hier->retained);
        -:  150:#ifdef WITH_SYS_TREE
        -:  151:			db->retained_count--;
        -:  152:#endif
    #####:  153:		}
    #####:  154:		if(stored->payloadlen){
    #####:  155:			hier->retained = stored;
    #####:  156:			db__msg_store_ref_inc(hier->retained);
        -:  157:#ifdef WITH_SYS_TREE
        -:  158:			db->retained_count++;
        -:  159:#endif
    #####:  160:		}else{
    #####:  161:			hier->retained = NULL;
        -:  162:		}
    #####:  163:	}
        -:  164:
    #####:  165:	rc = subs__shared_process(db, hier, topic, qos, retain, stored);
        -:  166:
    #####:  167:	leaf = hier->subs;
    #####:  168:	while(source_id && leaf){
    #####:  169:		if(!leaf->context->id || (leaf->no_local && !strcmp(leaf->context->id, source_id))){
    #####:  170:			leaf = leaf->next;
    #####:  171:			continue;
        -:  172:		}
    #####:  173:		rc2 = subs__send(db, leaf, topic, qos, retain, stored);
    #####:  174:		if(rc2){
    #####:  175:			rc = 1;
    #####:  176:		}
    #####:  177:		leaf = leaf->next;
        -:  178:	}
    #####:  179:	if(hier->subs || hier->shared){
    #####:  180:		return rc;
        -:  181:	}else{
    #####:  182:		return MOSQ_ERR_NO_SUBSCRIBERS;
        -:  183:	}
    #####:  184:}
        -:  185:
    #####:  186:static struct sub__token *sub__topic_append(struct sub__token **tail, struct sub__token **topics, char *topic)
        -:  187:{
        -:  188:	struct sub__token *new_topic;
        -:  189:
    #####:  190:	if(!topic){
    #####:  191:		return NULL;
        -:  192:	}
    #####:  193:	new_topic = mosquitto__malloc(sizeof(struct sub__token));
    #####:  194:	if(!new_topic){
    #####:  195:		return NULL;
        -:  196:	}
    #####:  197:	new_topic->next = NULL;
    #####:  198:	new_topic->topic_len = strlen(topic);
    #####:  199:	new_topic->topic = mosquitto__malloc(new_topic->topic_len+1);
    #####:  200:	if(!new_topic->topic){
    #####:  201:		mosquitto__free(new_topic);
    #####:  202:		return NULL;
        -:  203:	}
    #####:  204:	strncpy(new_topic->topic, topic, new_topic->topic_len+1);
        -:  205:
    #####:  206:	if(*tail){
    #####:  207:		(*tail)->next = new_topic;
    #####:  208:		*tail = (*tail)->next;
    #####:  209:	}else{
    #####:  210:		*topics = new_topic;
    #####:  211:		*tail = new_topic;
        -:  212:	}
    #####:  213:	return new_topic;
    #####:  214:}
        -:  215:
    #####:  216:static int sub__topic_tokenise(const char *subtopic, struct sub__token **topics)
        -:  217:{
    #####:  218:	struct sub__token *new_topic, *tail = NULL;
        -:  219:	size_t len;
        -:  220:	size_t start, stop, tlen;
        -:  221:	int i;
        -:  222:	char *topic;
    #####:  223:	int count = 0;
        -:  224:
    #####:  225:	assert(subtopic);
    #####:  226:	assert(topics);
        -:  227:
    #####:  228:	len = strlen(subtopic);
    #####:  229:	if(len == 0){
    #####:  230:		return 1;
        -:  231:	}
        -:  232:
    #####:  233:	if(subtopic[0] != '$'){
    #####:  234:		new_topic = sub__topic_append(&tail, topics, "");
    #####:  235:		if(!new_topic) goto cleanup;
    #####:  236:	}
        -:  237:
    #####:  238:	if(subtopic[0] == '/'){
    #####:  239:		new_topic = sub__topic_append(&tail, topics, "");
    #####:  240:		if(!new_topic) goto cleanup;
        -:  241:
    #####:  242:		start = 1;
    #####:  243:	}else{
    #####:  244:		start = 0;
        -:  245:	}
        -:  246:
    #####:  247:	for(i=start; i<len+1; i++){
    #####:  248:		if(subtopic[i] == '/' || subtopic[i] == '\0'){
    #####:  249:			stop = i;
    #####:  250:			count++;
        -:  251:
    #####:  252:			if(start != stop){
    #####:  253:				tlen = stop-start;
        -:  254:
    #####:  255:				topic = mosquitto__malloc(tlen+1);
    #####:  256:				if(!topic) goto cleanup;
    #####:  257:				memcpy(topic, &subtopic[start], tlen);
    #####:  258:				topic[tlen] = '\0';
    #####:  259:				new_topic = sub__topic_append(&tail, topics, topic);
    #####:  260:				mosquitto__free(topic);
    #####:  261:			}else{
    #####:  262:				new_topic = sub__topic_append(&tail, topics, "");
        -:  263:			}
    #####:  264:			if(!new_topic) goto cleanup;
    #####:  265:			start = i+1;
    #####:  266:		}
    #####:  267:	}
        -:  268:
    #####:  269:	if(count > TOPIC_HIERARCHY_LIMIT){
        -:  270:		/* Set limit on hierarchy levels, to restrict stack usage. */
    #####:  271:		goto cleanup;
        -:  272:	}
        -:  273:
    #####:  274:	if(*topics != NULL){
    #####:  275:		return MOSQ_ERR_SUCCESS;
        -:  276:	}else{
    #####:  277:		return 1;
        -:  278:	}
        -:  279:
        -:  280:cleanup:
    #####:  281:	tail = *topics;
    #####:  282:	*topics = NULL;
    #####:  283:	while(tail){
    #####:  284:		mosquitto__free(tail->topic);
    #####:  285:		new_topic = tail->next;
    #####:  286:		mosquitto__free(tail);
    #####:  287:		tail = new_topic;
        -:  288:	}
    #####:  289:	return 1;
    #####:  290:}
        -:  291:
    #####:  292:static void sub__topic_tokens_free(struct sub__token *tokens)
        -:  293:{
        -:  294:	struct sub__token *tail;
        -:  295:
    #####:  296:	while(tokens){
    #####:  297:		tail = tokens->next;
    #####:  298:		mosquitto__free(tokens->topic);
    #####:  299:		mosquitto__free(tokens);
    #####:  300:		tokens = tail;
        -:  301:	}
    #####:  302:}
        -:  303:
        -:  304:
    #####:  305:static int sub__add_leaf(struct mosquitto *context, int qos, uint32_t identifier, int options, struct mosquitto__subleaf **head, struct mosquitto__subleaf **newleaf)
        -:  306:{
        -:  307:	struct mosquitto__subleaf *leaf;
        -:  308:
    #####:  309:	*newleaf = NULL;
    #####:  310:	leaf = *head;
        -:  311:
    #####:  312:	while(leaf){
    #####:  313:		if(leaf->context && leaf->context->id && !strcmp(leaf->context->id, context->id)){
        -:  314:			/* Client making a second subscription to same topic. Only
        -:  315:			 * need to update QoS. Return MOSQ_ERR_SUB_EXISTS to
        -:  316:			 * indicate this to the calling function. */
    #####:  317:			leaf->qos = qos;
    #####:  318:			leaf->identifier = identifier;
    #####:  319:			return MOSQ_ERR_SUB_EXISTS;
        -:  320:		}
    #####:  321:		leaf = leaf->next;
        -:  322:	}
    #####:  323:	leaf = mosquitto__calloc(1, sizeof(struct mosquitto__subleaf));
    #####:  324:	if(!leaf) return MOSQ_ERR_NOMEM;
    #####:  325:	leaf->context = context;
    #####:  326:	leaf->qos = qos;
    #####:  327:	leaf->identifier = identifier;
    #####:  328:	leaf->no_local = ((options & MQTT_SUB_OPT_NO_LOCAL) != 0);
    #####:  329:	leaf->retain_as_published = ((options & MQTT_SUB_OPT_RETAIN_AS_PUBLISHED) != 0);
        -:  330:
    #####:  331:	DL_APPEND(*head, leaf);
    #####:  332:	*newleaf = leaf;
        -:  333:
    #####:  334:	return MOSQ_ERR_SUCCESS;
    #####:  335:}
        -:  336:
        -:  337:
    #####:  338:static void sub__remove_shared_leaf(struct mosquitto__subhier *subhier, struct mosquitto__subshared *shared, struct mosquitto__subleaf *leaf)
        -:  339:{
    #####:  340:	DL_DELETE(shared->subs, leaf);
    #####:  341:	if(shared->subs == NULL){
    #####:  342:		HASH_DELETE(hh, subhier->shared, shared);
    #####:  343:		mosquitto__free(shared->name);
    #####:  344:		mosquitto__free(shared);
    #####:  345:	}
    #####:  346:	mosquitto__free(leaf);
    #####:  347:}
        -:  348:
        -:  349:
    #####:  350:static int sub__add_shared(struct mosquitto_db *db, struct mosquitto *context, int qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier, char *sharename)
        -:  351:{
        -:  352:	struct mosquitto__subleaf *newleaf;
    #####:  353:	struct mosquitto__subshared *shared = NULL;
        -:  354:	struct mosquitto__subshared_ref **shared_subs;
        -:  355:	struct mosquitto__subshared_ref *shared_ref;
        -:  356:	int i;
        -:  357:	unsigned int slen;
        -:  358:	int rc;
        -:  359:
    #####:  360:	slen = strlen(sharename);
        -:  361:
    #####:  362:	HASH_FIND(hh, subhier->shared, sharename, slen, shared);
    #####:  363:	if(shared){
    #####:  364:		mosquitto__free(sharename);
    #####:  365:	}else{
    #####:  366:		shared = mosquitto__calloc(1, sizeof(struct mosquitto__subshared));
    #####:  367:		if(!shared){
    #####:  368:			mosquitto__free(sharename);
    #####:  369:			return MOSQ_ERR_NOMEM;
        -:  370:		}
    #####:  371:		shared->name = sharename;
        -:  372:
    #####:  373:		HASH_ADD_KEYPTR(hh, subhier->shared, shared->name, slen, shared);
        -:  374:	}
        -:  375:
    #####:  376:	rc = sub__add_leaf(context, qos, identifier, options, &shared->subs, &newleaf);
    #####:  377:	if(rc > 0){
    #####:  378:		if(shared->subs == NULL){
    #####:  379:			HASH_DELETE(hh, subhier->shared, shared);
    #####:  380:			mosquitto__free(shared->name);
    #####:  381:			mosquitto__free(shared);
    #####:  382:		}
    #####:  383:		return rc;
        -:  384:	}
        -:  385:
    #####:  386:	if(rc != MOSQ_ERR_SUB_EXISTS){
    #####:  387:		shared_ref = mosquitto__calloc(1, sizeof(struct mosquitto__subshared_ref));
    #####:  388:		if(!shared_ref){
    #####:  389:			sub__remove_shared_leaf(subhier, shared, newleaf);
    #####:  390:			return MOSQ_ERR_NOMEM;
        -:  391:		}
    #####:  392:		shared_ref->hier = subhier;
    #####:  393:		shared_ref->shared = shared;
        -:  394:
    #####:  395:		for(i=0; i<context->shared_sub_count; i++){
    #####:  396:			if(!context->shared_subs[i]){
    #####:  397:				context->shared_subs[i] = shared_ref;
    #####:  398:				break;
        -:  399:			}
    #####:  400:		}
    #####:  401:		if(i == context->shared_sub_count){
    #####:  402:			shared_subs = mosquitto__realloc(context->shared_subs, sizeof(struct mosquitto__subhier_ref *)*(context->shared_sub_count + 1));
    #####:  403:			if(!shared_subs){
    #####:  404:				sub__remove_shared_leaf(subhier, shared, newleaf);
    #####:  405:				return MOSQ_ERR_NOMEM;
        -:  406:			}
    #####:  407:			context->shared_subs = shared_subs;
    #####:  408:			context->shared_sub_count++;
    #####:  409:			context->shared_subs[context->shared_sub_count-1] = shared_ref;
    #####:  410:		}
        -:  411:#ifdef WITH_SYS_TREE
        -:  412:		db->shared_subscription_count++;
        -:  413:#endif
    #####:  414:	}
        -:  415:
    #####:  416:	if(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt5){
    #####:  417:		return rc;
        -:  418:	}else{
        -:  419:		/* mqttv311/mqttv5 requires retained messages are resent on
        -:  420:		 * resubscribe. */
    #####:  421:		return MOSQ_ERR_SUCCESS;
        -:  422:	}
    #####:  423:}
        -:  424:
        -:  425:
    #####:  426:static int sub__add_normal(struct mosquitto_db *db, struct mosquitto *context, int qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier)
        -:  427:{
    #####:  428:	struct mosquitto__subleaf *newleaf = NULL;
        -:  429:	struct mosquitto__subhier **subs;
        -:  430:	int i;
        -:  431:	int rc;
        -:  432:
    #####:  433:	rc = sub__add_leaf(context, qos, identifier, options, &subhier->subs, &newleaf);
    #####:  434:	if(rc > 0){
    #####:  435:		return rc;
        -:  436:	}
        -:  437:
    #####:  438:	if(rc != MOSQ_ERR_SUB_EXISTS){
    #####:  439:		for(i=0; i<context->sub_count; i++){
    #####:  440:			if(!context->subs[i]){
    #####:  441:				context->subs[i] = subhier;
    #####:  442:				break;
        -:  443:			}
    #####:  444:		}
    #####:  445:		if(i == context->sub_count){
    #####:  446:			subs = mosquitto__realloc(context->subs, sizeof(struct mosquitto__subhier *)*(context->sub_count + 1));
    #####:  447:			if(!subs){
    #####:  448:				DL_DELETE(subhier->subs, newleaf);
    #####:  449:				mosquitto__free(newleaf);
    #####:  450:				return MOSQ_ERR_NOMEM;
        -:  451:			}
    #####:  452:			context->subs = subs;
    #####:  453:			context->sub_count++;
    #####:  454:			context->subs[context->sub_count-1] = subhier;
    #####:  455:		}
        -:  456:#ifdef WITH_SYS_TREE
        -:  457:		db->subscription_count++;
        -:  458:#endif
    #####:  459:	}
        -:  460:
    #####:  461:	if(context->protocol == mosq_p_mqtt31 || context->protocol == mosq_p_mqtt5){
    #####:  462:		return rc;
        -:  463:	}else{
        -:  464:		/* mqttv311/mqttv5 requires retained messages are resent on
        -:  465:		 * resubscribe. */
    #####:  466:		return MOSQ_ERR_SUCCESS;
        -:  467:	}
    #####:  468:}
        -:  469:
        -:  470:
    #####:  471:static int sub__add_context(struct mosquitto_db *db, struct mosquitto *context, int qos, uint32_t identifier, int options, struct mosquitto__subhier *subhier, struct sub__token *tokens, char *sharename)
        -:  472:{
        -:  473:	struct mosquitto__subhier *branch;
        -:  474:
        -:  475:	/* Find leaf node */
    #####:  476:	while(tokens){
    #####:  477:		HASH_FIND(hh, subhier->children, tokens->topic, tokens->topic_len, branch);
    #####:  478:		if(!branch){
        -:  479:			/* Not found */
    #####:  480:			branch = sub__add_hier_entry(subhier, &subhier->children, tokens->topic, tokens->topic_len);
    #####:  481:			if(!branch) return MOSQ_ERR_NOMEM;
    #####:  482:		}
    #####:  483:		subhier = branch;
    #####:  484:		tokens = tokens ->next;
        -:  485:	}
        -:  486:
        -:  487:	/* Add add our context */
    #####:  488:	if(context && context->id){
    #####:  489:		if(sharename){
    #####:  490:			return sub__add_shared(db, context, qos, identifier, options, subhier, sharename);
        -:  491:		}else{
    #####:  492:			return sub__add_normal(db, context, qos, identifier, options, subhier);
        -:  493:		}
        -:  494:	}else{
    #####:  495:		return MOSQ_ERR_SUCCESS;
        -:  496:	}
    #####:  497:}
        -:  498:
        -:  499:
    #####:  500:static int sub__remove_normal(struct mosquitto_db *db, struct mosquitto *context, struct mosquitto__subhier *subhier, uint8_t *reason)
        -:  501:{
        -:  502:	struct mosquitto__subleaf *leaf;
        -:  503:	int i;
        -:  504:
    #####:  505:	leaf = subhier->subs;
    #####:  506:	while(leaf){
    #####:  507:		if(leaf->context==context){
        -:  508:#ifdef WITH_SYS_TREE
        -:  509:			db->subscription_count--;
        -:  510:#endif
    #####:  511:			DL_DELETE(subhier->subs, leaf);
    #####:  512:			mosquitto__free(leaf);
        -:  513:
        -:  514:			/* Remove the reference to the sub that the client is keeping.
        -:  515:			 * It would be nice to be able to use the reference directly,
        -:  516:			 * but that would involve keeping a copy of the topic string in
        -:  517:			 * each subleaf. Might be worth considering though. */
    #####:  518:			for(i=0; i<context->sub_count; i++){
    #####:  519:				if(context->subs[i] == subhier){
    #####:  520:					context->subs[i] = NULL;
    #####:  521:					break;
        -:  522:				}
    #####:  523:			}
    #####:  524:			*reason = 0;
    #####:  525:			return MOSQ_ERR_SUCCESS;
        -:  526:		}
    #####:  527:		leaf = leaf->next;
        -:  528:	}
    #####:  529:	return MOSQ_ERR_NO_SUBSCRIBERS;
    #####:  530:}
        -:  531:
        -:  532:
    #####:  533:static int sub__remove_shared(struct mosquitto_db *db, struct mosquitto *context, struct mosquitto__subhier *subhier, uint8_t *reason, char *sharename)
        -:  534:{
        -:  535:	struct mosquitto__subshared *shared;
        -:  536:	struct mosquitto__subleaf *leaf;
        -:  537:	int i;
        -:  538:
    #####:  539:	HASH_FIND(hh, subhier->shared, sharename, strlen(sharename), shared);
    #####:  540:	mosquitto__free(sharename);
    #####:  541:	if(shared){
    #####:  542:		leaf = shared->subs;
    #####:  543:		while(leaf){
    #####:  544:			if(leaf->context==context){
        -:  545:#ifdef WITH_SYS_TREE
        -:  546:				db->shared_subscription_count--;
        -:  547:#endif
    #####:  548:				DL_DELETE(shared->subs, leaf);
    #####:  549:				mosquitto__free(leaf);
        -:  550:
        -:  551:				/* Remove the reference to the sub that the client is keeping.
        -:  552:				* It would be nice to be able to use the reference directly,
        -:  553:				* but that would involve keeping a copy of the topic string in
        -:  554:				* each subleaf. Might be worth considering though. */
    #####:  555:				for(i=0; i<context->shared_sub_count; i++){
    #####:  556:					if(context->shared_subs[i]
    #####:  557:							&& context->shared_subs[i]->hier == subhier
    #####:  558:							&& context->shared_subs[i]->shared == shared){
        -:  559:
    #####:  560:						mosquitto__free(context->shared_subs[i]);
    #####:  561:						context->shared_subs[i] = NULL;
    #####:  562:						break;
        -:  563:					}
    #####:  564:				}
        -:  565:
    #####:  566:				if(shared->subs == NULL){
    #####:  567:					HASH_DELETE(hh, subhier->shared, shared);
    #####:  568:					mosquitto__free(shared->name);
    #####:  569:					mosquitto__free(shared);
    #####:  570:				}
        -:  571:
    #####:  572:				*reason = 0;
    #####:  573:				return MOSQ_ERR_SUCCESS;
        -:  574:			}
    #####:  575:			leaf = leaf->next;
        -:  576:		}
    #####:  577:		return MOSQ_ERR_NO_SUBSCRIBERS;
        -:  578:	}else{
    #####:  579:		return MOSQ_ERR_NO_SUBSCRIBERS;
        -:  580:	}
    #####:  581:}
        -:  582:
        -:  583:
    #####:  584:static int sub__remove_recurse(struct mosquitto_db *db, struct mosquitto *context, struct mosquitto__subhier *subhier, struct sub__token *tokens, uint8_t *reason, char *sharename)
        -:  585:{
        -:  586:	struct mosquitto__subhier *branch;
        -:  587:
    #####:  588:	if(!tokens){
    #####:  589:		if(sharename){
    #####:  590:			return sub__remove_shared(db, context, subhier, reason, sharename);
        -:  591:		}else{
    #####:  592:			return sub__remove_normal(db, context, subhier, reason);
        -:  593:		}
        -:  594:	}
        -:  595:
    #####:  596:	HASH_FIND(hh, subhier->children, tokens->topic, tokens->topic_len, branch);
    #####:  597:	if(branch){
    #####:  598:		sub__remove_recurse(db, context, branch, tokens->next, reason, sharename);
    #####:  599:		if(!branch->children && !branch->subs && !branch->retained && !branch->shared){
    #####:  600:			HASH_DELETE(hh, subhier->children, branch);
    #####:  601:			mosquitto__free(branch->topic);
    #####:  602:			mosquitto__free(branch);
    #####:  603:		}
    #####:  604:	}
    #####:  605:	return MOSQ_ERR_SUCCESS;
    #####:  606:}
        -:  607:
    #####:  608:static int sub__search(struct mosquitto_db *db, struct mosquitto__subhier *subhier, struct sub__token *tokens, const char *source_id, const char *topic, int qos, int retain, struct mosquitto_msg_store *stored, bool set_retain)
        -:  609:{
        -:  610:	/* FIXME - need to take into account source_id if the client is a bridge */
        -:  611:	struct mosquitto__subhier *branch;
        -:  612:	int rc;
    #####:  613:	bool have_subscribers = false;
        -:  614:
    #####:  615:	if(tokens){
        -:  616:		/* Check for literal match */
    #####:  617:		HASH_FIND(hh, subhier->children, tokens->topic, tokens->topic_len, branch);
        -:  618:
    #####:  619:		if(branch){
    #####:  620:			rc = sub__search(db, branch, tokens->next, source_id, topic, qos, retain, stored, set_retain);
    #####:  621:			if(rc == MOSQ_ERR_SUCCESS){
    #####:  622:				have_subscribers = true;
    #####:  623:			}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){
    #####:  624:				return rc;
        -:  625:			}
    #####:  626:			if(!tokens->next){
    #####:  627:				rc = subs__process(db, branch, source_id, topic, qos, retain, stored, set_retain);
    #####:  628:				if(rc == MOSQ_ERR_SUCCESS){
    #####:  629:					have_subscribers = true;
    #####:  630:				}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){
    #####:  631:					return rc;
        -:  632:				}
    #####:  633:			}
    #####:  634:		}
        -:  635:
        -:  636:		/* Check for + match */
    #####:  637:		HASH_FIND(hh, subhier->children, "+", 1, branch);
        -:  638:
    #####:  639:		if(branch){
    #####:  640:			rc = sub__search(db, branch, tokens->next, source_id, topic, qos, retain, stored, false);
    #####:  641:			if(rc == MOSQ_ERR_SUCCESS){
    #####:  642:				have_subscribers = true;
    #####:  643:			}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){
    #####:  644:				return rc;
        -:  645:			}
    #####:  646:			if(!tokens->next){
    #####:  647:				rc = subs__process(db, branch, source_id, topic, qos, retain, stored, false);
    #####:  648:				if(rc == MOSQ_ERR_SUCCESS){
    #####:  649:					have_subscribers = true;
    #####:  650:				}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){
    #####:  651:					return rc;
        -:  652:				}
    #####:  653:			}
    #####:  654:		}
    #####:  655:	}
        -:  656:
        -:  657:	/* Check for # match */
    #####:  658:	HASH_FIND(hh, subhier->children, "#", 1, branch);
    #####:  659:	if(branch && !branch->children){
        -:  660:		/* The topic matches due to a # wildcard - process the
        -:  661:		 * subscriptions but *don't* return. Although this branch has ended
        -:  662:		 * there may still be other subscriptions to deal with.
        -:  663:		 */
    #####:  664:		rc = subs__process(db, branch, source_id, topic, qos, retain, stored, false);
    #####:  665:		if(rc == MOSQ_ERR_SUCCESS){
    #####:  666:			have_subscribers = true;
    #####:  667:		}else if(rc != MOSQ_ERR_NO_SUBSCRIBERS){
    #####:  668:			return rc;
        -:  669:		}
    #####:  670:	}
        -:  671:
    #####:  672:	if(have_subscribers){
    #####:  673:		return MOSQ_ERR_SUCCESS;
        -:  674:	}else{
    #####:  675:		return MOSQ_ERR_NO_SUBSCRIBERS;
        -:  676:	}
    #####:  677:}
        -:  678:
        -:  679:
    #####:  680:struct mosquitto__subhier *sub__add_hier_entry(struct mosquitto__subhier *parent, struct mosquitto__subhier **sibling, const char *topic, size_t len)
        -:  681:{
        -:  682:	struct mosquitto__subhier *child;
        -:  683:
    #####:  684:	assert(sibling);
        -:  685:
    #####:  686:	child = mosquitto__calloc(1, sizeof(struct mosquitto__subhier));
    #####:  687:	if(!child){
    #####:  688:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  689:		return NULL;
        -:  690:	}
    #####:  691:	child->parent = parent;
    #####:  692:	child->topic_len = len;
    #####:  693:	child->topic = mosquitto__malloc(len+1);
    #####:  694:	if(!child->topic){
    #####:  695:		child->topic_len = 0;
    #####:  696:		mosquitto__free(child);
    #####:  697:		log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  698:		return NULL;
        -:  699:	}else{
    #####:  700:		strncpy(child->topic, topic, child->topic_len+1);
        -:  701:	}
        -:  702:
    #####:  703:	HASH_ADD_KEYPTR(hh, *sibling, child->topic, child->topic_len, child);
        -:  704:
    #####:  705:	return child;
    #####:  706:}
        -:  707:
        -:  708:
    #####:  709:int sub__add(struct mosquitto_db *db, struct mosquitto *context, const char *sub, int qos, uint32_t identifier, int options, struct mosquitto__subhier **root)
        -:  710:{
    #####:  711:	int rc = 0;
        -:  712:	struct mosquitto__subhier *subhier;
    #####:  713:	struct sub__token *tokens = NULL, *t;
    #####:  714:	char *sharename = NULL;
        -:  715:
    #####:  716:	assert(root);
    #####:  717:	assert(*root);
    #####:  718:	assert(sub);
        -:  719:
    #####:  720:	if(sub__topic_tokenise(sub, &tokens)) return 1;
        -:  721:
    #####:  722:	if(!strcmp(tokens->topic, "$share")){
    #####:  723:		if(!tokens->next || !tokens->next->next){
    #####:  724:			sub__topic_tokens_free(tokens);
    #####:  725:			return MOSQ_ERR_PROTOCOL;
        -:  726:		}
    #####:  727:		t = tokens->next;
    #####:  728:		mosquitto__free(tokens->topic);
    #####:  729:		mosquitto__free(tokens);
    #####:  730:		tokens = t;
        -:  731:
    #####:  732:		sharename = tokens->topic;
        -:  733:
    #####:  734:		tokens->topic = mosquitto__strdup("");
    #####:  735:		if(!tokens->topic){
    #####:  736:			tokens->topic = sharename;
    #####:  737:			sub__topic_tokens_free(tokens);
    #####:  738:			return MOSQ_ERR_PROTOCOL;
        -:  739:		}
    #####:  740:		tokens->topic_len = 0;
    #####:  741:	}
        -:  742:
    #####:  743:	HASH_FIND(hh, *root, tokens->topic, tokens->topic_len, subhier);
    #####:  744:	if(!subhier){
    #####:  745:		subhier = sub__add_hier_entry(NULL, root, tokens->topic, tokens->topic_len);
    #####:  746:		if(!subhier){
    #####:  747:			sub__topic_tokens_free(tokens);
    #####:  748:			log__printf(NULL, MOSQ_LOG_ERR, "Error: Out of memory.");
    #####:  749:			return MOSQ_ERR_NOMEM;
        -:  750:		}
        -:  751:
    #####:  752:	}
    #####:  753:	rc = sub__add_context(db, context, qos, identifier, options, subhier, tokens, sharename);
        -:  754:
    #####:  755:	sub__topic_tokens_free(tokens);
        -:  756:
    #####:  757:	return rc;
    #####:  758:}
        -:  759:
    #####:  760:int sub__remove(struct mosquitto_db *db, struct mosquitto *context, const char *sub, struct mosquitto__subhier *root, uint8_t *reason)
        -:  761:{
    #####:  762:	int rc = 0;
        -:  763:	struct mosquitto__subhier *subhier;
    #####:  764:	struct sub__token *tokens = NULL, *t;
    #####:  765:	char *sharename = NULL;
        -:  766:
    #####:  767:	assert(root);
    #####:  768:	assert(sub);
        -:  769:
    #####:  770:	if(sub__topic_tokenise(sub, &tokens)) return 1;
        -:  771:
    #####:  772:	if(!strcmp(tokens->topic, "$share")){
    #####:  773:		if(!tokens->next || !tokens->next->next){
    #####:  774:			sub__topic_tokens_free(tokens);
    #####:  775:			return MOSQ_ERR_PROTOCOL;
        -:  776:		}
    #####:  777:		t = tokens->next;
    #####:  778:		mosquitto__free(tokens->topic);
    #####:  779:		mosquitto__free(tokens);
    #####:  780:		tokens = t;
        -:  781:
    #####:  782:		sharename = tokens->topic;
        -:  783:
    #####:  784:		tokens->topic = mosquitto__strdup("");
    #####:  785:		if(!tokens->topic){
    #####:  786:			tokens->topic = sharename;
    #####:  787:			sub__topic_tokens_free(tokens);
    #####:  788:			return MOSQ_ERR_PROTOCOL;
        -:  789:		}
    #####:  790:		tokens->topic_len = 0;
    #####:  791:	}
        -:  792:
    #####:  793:	HASH_FIND(hh, root, tokens->topic, tokens->topic_len, subhier);
    #####:  794:	if(subhier){
    #####:  795:		*reason = MQTT_RC_NO_SUBSCRIPTION_EXISTED;
    #####:  796:		rc = sub__remove_recurse(db, context, subhier, tokens, reason, sharename);
    #####:  797:	}
        -:  798:
    #####:  799:	sub__topic_tokens_free(tokens);
        -:  800:
    #####:  801:	return rc;
    #####:  802:}
        -:  803:
    #####:  804:int sub__messages_queue(struct mosquitto_db *db, const char *source_id, const char *topic, int qos, int retain, struct mosquitto_msg_store **stored)
        -:  805:{
    #####:  806:	int rc = 0;
        -:  807:	struct mosquitto__subhier *subhier;
    #####:  808:	struct sub__token *tokens = NULL;
        -:  809:
    #####:  810:	assert(db);
    #####:  811:	assert(topic);
        -:  812:
    #####:  813:	if(sub__topic_tokenise(topic, &tokens)) return 1;
        -:  814:
        -:  815:	/* Protect this message until we have sent it to all
        -:  816:	clients - this is required because websockets client calls
        -:  817:	db__message_write(), which could remove the message if ref_count==0.
        -:  818:	*/
    #####:  819:	db__msg_store_ref_inc(*stored);
        -:  820:
    #####:  821:	HASH_FIND(hh, db->subs, tokens->topic, tokens->topic_len, subhier);
    #####:  822:	if(subhier){
    #####:  823:		if(retain){
        -:  824:			/* We have a message that needs to be retained, so ensure that the subscription
        -:  825:			 * tree for its topic exists.
        -:  826:			 */
    #####:  827:			sub__add_context(db, NULL, 0, 0, 0, subhier, tokens, NULL);
    #####:  828:		}
    #####:  829:		rc = sub__search(db, subhier, tokens, source_id, topic, qos, retain, *stored, true);
    #####:  830:	}
    #####:  831:	sub__topic_tokens_free(tokens);
        -:  832:
        -:  833:	/* Remove our reference and free if needed. */
    #####:  834:	db__msg_store_ref_dec(db, stored);
        -:  835:
    #####:  836:	return rc;
    #####:  837:}
        -:  838:
        -:  839:
        -:  840:/* Remove a subhier element, and return its parent if that needs freeing as well. */
    #####:  841:static struct mosquitto__subhier *tmp_remove_subs(struct mosquitto__subhier *sub)
        -:  842:{
        -:  843:	struct mosquitto__subhier *parent;
        -:  844:
    #####:  845:	if(!sub || !sub->parent){
    #####:  846:		return NULL;
        -:  847:	}
        -:  848:
    #####:  849:	if(sub->children || sub->subs || sub->retained){
    #####:  850:		return NULL;
        -:  851:	}
        -:  852:
    #####:  853:	parent = sub->parent;
    #####:  854:	HASH_DELETE(hh, parent->children, sub);
    #####:  855:	mosquitto__free(sub->topic);
    #####:  856:	mosquitto__free(sub);
        -:  857:
    #####:  858:	if(parent->subs == NULL
    #####:  859:			&& parent->children == NULL
    #####:  860:			&& parent->retained == NULL
    #####:  861:			&& parent->shared == NULL
    #####:  862:			&& parent->parent){
        -:  863:
    #####:  864:		return parent;
        -:  865:	}else{
    #####:  866:		return NULL;
        -:  867:	}
    #####:  868:}
        -:  869:
        -:  870:
    #####:  871:static int sub__clean_session_shared(struct mosquitto_db *db, struct mosquitto *context)
        -:  872:{
        -:  873:	int i;
        -:  874:	struct mosquitto__subleaf *leaf;
        -:  875:	struct mosquitto__subhier *hier;
        -:  876:
    #####:  877:	for(i=0; i<context->shared_sub_count; i++){
    #####:  878:		if(context->shared_subs[i] == NULL){
    #####:  879:			continue;
        -:  880:		}
    #####:  881:		leaf = context->shared_subs[i]->shared->subs;
    #####:  882:		while(leaf){
    #####:  883:			if(leaf->context==context){
        -:  884:#ifdef WITH_SYS_TREE
        -:  885:				db->shared_subscription_count--;
        -:  886:#endif
    #####:  887:				sub__remove_shared_leaf(context->shared_subs[i]->hier, context->shared_subs[i]->shared, leaf);
    #####:  888:				break;
        -:  889:			}
    #####:  890:			leaf = leaf->next;
        -:  891:		}
    #####:  892:		if(context->shared_subs[i]->hier->subs == NULL
    #####:  893:				&& context->shared_subs[i]->hier->children == NULL
    #####:  894:				&& context->shared_subs[i]->hier->retained == NULL
    #####:  895:				&& context->shared_subs[i]->hier->shared == NULL
    #####:  896:				&& context->shared_subs[i]->hier->parent){
        -:  897:
    #####:  898:			hier = context->shared_subs[i]->hier;
    #####:  899:			context->shared_subs[i]->hier = NULL;
    #####:  900:			do{
    #####:  901:				hier = tmp_remove_subs(hier);
    #####:  902:			}while(hier);
    #####:  903:		}
    #####:  904:		mosquitto__free(context->shared_subs[i]);
    #####:  905:	}
    #####:  906:	mosquitto__free(context->shared_subs);
    #####:  907:	context->shared_subs = NULL;
    #####:  908:	context->shared_sub_count = 0;
        -:  909:
    #####:  910:	return MOSQ_ERR_SUCCESS;
        -:  911:}
        -:  912:
        -:  913:/* Remove all subscriptions for a client.
        -:  914: */
    #####:  915:int sub__clean_session(struct mosquitto_db *db, struct mosquitto *context)
        -:  916:{
        -:  917:	int i;
        -:  918:	struct mosquitto__subleaf *leaf;
        -:  919:	struct mosquitto__subhier *hier;
        -:  920:
    #####:  921:	for(i=0; i<context->sub_count; i++){
    #####:  922:		if(context->subs[i] == NULL){
    #####:  923:			continue;
        -:  924:		}
    #####:  925:		leaf = context->subs[i]->subs;
    #####:  926:		while(leaf){
    #####:  927:			if(leaf->context==context){
        -:  928:#ifdef WITH_SYS_TREE
        -:  929:				db->subscription_count--;
        -:  930:#endif
    #####:  931:				DL_DELETE(context->subs[i]->subs, leaf);
    #####:  932:				mosquitto__free(leaf);
    #####:  933:				break;
        -:  934:			}
    #####:  935:			leaf = leaf->next;
        -:  936:		}
    #####:  937:		if(context->subs[i]->subs == NULL
    #####:  938:				&& context->subs[i]->children == NULL
    #####:  939:				&& context->subs[i]->retained == NULL
    #####:  940:				&& context->subs[i]->shared == NULL
    #####:  941:				&& context->subs[i]->parent){
        -:  942:
    #####:  943:			hier = context->subs[i];
    #####:  944:			context->subs[i] = NULL;
    #####:  945:			do{
    #####:  946:				hier = tmp_remove_subs(hier);
    #####:  947:			}while(hier);
    #####:  948:		}
    #####:  949:	}
    #####:  950:	mosquitto__free(context->subs);
    #####:  951:	context->subs = NULL;
    #####:  952:	context->sub_count = 0;
        -:  953:
    #####:  954:	return sub__clean_session_shared(db, context);
        -:  955:}
        -:  956:
    #####:  957:void sub__tree_print(struct mosquitto__subhier *root, int level)
        -:  958:{
        -:  959:	int i;
        -:  960:	struct mosquitto__subhier *branch, *branch_tmp;
        -:  961:	struct mosquitto__subleaf *leaf;
        -:  962:
    #####:  963:	HASH_ITER(hh, root, branch, branch_tmp){
    #####:  964:	if(level > -1){
    #####:  965:		for(i=0; i<(level+2)*2; i++){
    #####:  966:			printf(" ");
    #####:  967:		}
    #####:  968:		printf("%s", branch->topic);
    #####:  969:		leaf = branch->subs;
    #####:  970:		while(leaf){
    #####:  971:			if(leaf->context){
    #####:  972:				printf(" (%s, %d)", leaf->context->id, leaf->qos);
    #####:  973:			}else{
    #####:  974:				printf(" (%s, %d)", "", leaf->qos);
        -:  975:			}
    #####:  976:			leaf = leaf->next;
        -:  977:		}
    #####:  978:		if(branch->retained){
    #####:  979:			printf(" (r)");
    #####:  980:		}
    #####:  981:		printf("\n");
    #####:  982:	}
        -:  983:
    #####:  984:		sub__tree_print(branch->children, level+1);
    #####:  985:	}
    #####:  986:}
        -:  987:
    #####:  988:static int retain__process(struct mosquitto_db *db, struct mosquitto__subhier *branch, struct mosquitto *context, int sub_qos, uint32_t subscription_identifier, time_t now)
        -:  989:{
    #####:  990:	int rc = 0;
        -:  991:	int qos;
        -:  992:	uint16_t mid;
    #####:  993:	mosquitto_property *properties = NULL;
        -:  994:	struct mosquitto_msg_store *retained;
        -:  995:
    #####:  996:	if(branch->retained->message_expiry_time > 0 && now >= branch->retained->message_expiry_time){
    #####:  997:		db__msg_store_ref_dec(db, &branch->retained);
    #####:  998:		branch->retained = NULL;
        -:  999:#ifdef WITH_SYS_TREE
        -: 1000:		db->retained_count--;
        -: 1001:#endif
    #####: 1002:		return MOSQ_ERR_SUCCESS;
        -: 1003:	}
        -: 1004:
    #####: 1005:	retained = branch->retained;
        -: 1006:
    #####: 1007:	rc = mosquitto_acl_check(db, context, retained->topic, retained->payloadlen, UHPA_ACCESS(retained->payload, retained->payloadlen),
    #####: 1008:			retained->qos, retained->retain, MOSQ_ACL_READ);
    #####: 1009:	if(rc == MOSQ_ERR_ACL_DENIED){
    #####: 1010:		return MOSQ_ERR_SUCCESS;
    #####: 1011:	}else if(rc != MOSQ_ERR_SUCCESS){
    #####: 1012:		return rc;
        -: 1013:	}
        -: 1014:
        -: 1015:	/* Check for original source access */
    #####: 1016:	if(db->config->check_retain_source && retained->origin != mosq_mo_broker && retained->source_id){
        -: 1017:		struct mosquitto retain_ctxt;
    #####: 1018:		memset(&retain_ctxt, 0, sizeof(struct mosquitto));
        -: 1019:
    #####: 1020:		retain_ctxt.id = retained->source_id;
    #####: 1021:		retain_ctxt.username = retained->source_username;
    #####: 1022:		retain_ctxt.listener = retained->source_listener;
        -: 1023:
    #####: 1024:		rc = acl__find_acls(db, &retain_ctxt);
    #####: 1025:		if(rc) return rc;
        -: 1026:
    #####: 1027:		rc = mosquitto_acl_check(db, &retain_ctxt, retained->topic, retained->payloadlen, UHPA_ACCESS(retained->payload, retained->payloadlen),
    #####: 1028:				retained->qos, retained->retain, MOSQ_ACL_WRITE);
    #####: 1029:		if(rc == MOSQ_ERR_ACL_DENIED){
    #####: 1030:			return MOSQ_ERR_SUCCESS;
    #####: 1031:		}else if(rc != MOSQ_ERR_SUCCESS){
    #####: 1032:			return rc;
        -: 1033:		}
    #####: 1034:	}
        -: 1035:
    #####: 1036:	if (db->config->upgrade_outgoing_qos){
    #####: 1037:		qos = sub_qos;
    #####: 1038:	} else {
    #####: 1039:		qos = retained->qos;
    #####: 1040:		if(qos > sub_qos) qos = sub_qos;
        -: 1041:	}
    #####: 1042:	if(qos > 0){
    #####: 1043:		mid = mosquitto__mid_generate(context);
    #####: 1044:	}else{
    #####: 1045:		mid = 0;
        -: 1046:	}
    #####: 1047:	if(subscription_identifier > 0){
    #####: 1048:		mosquitto_property_add_varint(&properties, MQTT_PROP_SUBSCRIPTION_IDENTIFIER, subscription_identifier);
    #####: 1049:	}
    #####: 1050:	return db__message_insert(db, context, mid, mosq_md_out, qos, true, retained, properties);
    #####: 1051:}
        -: 1052:
    #####: 1053:static int retain__search(struct mosquitto_db *db, struct mosquitto__subhier *subhier, struct sub__token *tokens, struct mosquitto *context, const char *sub, int sub_qos, uint32_t subscription_identifier, time_t now, int level)
        -: 1054:{
        -: 1055:	struct mosquitto__subhier *branch, *branch_tmp;
    #####: 1056:	int flag = 0;
        -: 1057:
    #####: 1058:	if(!strcmp(tokens->topic, "#") && !tokens->next){
    #####: 1059:		HASH_ITER(hh, subhier->children, branch, branch_tmp){
        -: 1060:			/* Set flag to indicate that we should check for retained messages
        -: 1061:			 * on "foo" when we are subscribing to e.g. "foo/#" and then exit
        -: 1062:			 * this function and return to an earlier retain__search().
        -: 1063:			 */
    #####: 1064:			flag = -1;
    #####: 1065:			if(branch->retained){
    #####: 1066:				retain__process(db, branch, context, sub_qos, subscription_identifier, now);
    #####: 1067:			}
    #####: 1068:			if(branch->children){
    #####: 1069:				retain__search(db, branch, tokens, context, sub, sub_qos, subscription_identifier, now, level+1);
    #####: 1070:			}
    #####: 1071:		}
    #####: 1072:	}else{
    #####: 1073:		if(!strcmp(tokens->topic, "+")){
    #####: 1074:			HASH_ITER(hh, subhier->children, branch, branch_tmp){
    #####: 1075:				if(tokens->next){
    #####: 1076:					if(retain__search(db, branch, tokens->next, context, sub, sub_qos, subscription_identifier, now, level+1) == -1
    #####: 1077:							|| (tokens->next && !strcmp(tokens->next->topic, "#") && level>0)){
        -: 1078:
    #####: 1079:						if(branch->retained){
    #####: 1080:							retain__process(db, branch, context, sub_qos, subscription_identifier, now);
    #####: 1081:						}
    #####: 1082:					}
    #####: 1083:				}else{
    #####: 1084:					if(branch->retained){
    #####: 1085:						retain__process(db, branch, context, sub_qos, subscription_identifier, now);
    #####: 1086:					}
        -: 1087:				}
    #####: 1088:			}
    #####: 1089:		}else{
    #####: 1090:			HASH_FIND(hh, subhier->children, tokens->topic, tokens->topic_len, branch);
    #####: 1091:			if(branch){
    #####: 1092:				if(tokens->next){
    #####: 1093:					if(retain__search(db, branch, tokens->next, context, sub, sub_qos, subscription_identifier, now, level+1) == -1
    #####: 1094:							|| (tokens->next && !strcmp(tokens->next->topic, "#") && level>0)){
        -: 1095:
    #####: 1096:						if(branch->retained){
    #####: 1097:							retain__process(db, branch, context, sub_qos, subscription_identifier, now);
    #####: 1098:						}
    #####: 1099:					}
    #####: 1100:				}else{
    #####: 1101:					if(branch->retained){
    #####: 1102:						retain__process(db, branch, context, sub_qos, subscription_identifier, now);
    #####: 1103:					}
        -: 1104:				}
    #####: 1105:			}
        -: 1106:		}
        -: 1107:	}
    #####: 1108:	return flag;
        -: 1109:}
        -: 1110:
    #####: 1111:int sub__retain_queue(struct mosquitto_db *db, struct mosquitto *context, const char *sub, int sub_qos, uint32_t subscription_identifier)
        -: 1112:{
        -: 1113:	struct mosquitto__subhier *subhier;
    #####: 1114:	struct sub__token *tokens = NULL, *tail;
        -: 1115:	time_t now;
        -: 1116:
    #####: 1117:	assert(db);
    #####: 1118:	assert(context);
    #####: 1119:	assert(sub);
        -: 1120:
    #####: 1121:	if(sub__topic_tokenise(sub, &tokens)) return 1;
        -: 1122:
    #####: 1123:	HASH_FIND(hh, db->subs, tokens->topic, tokens->topic_len, subhier);
        -: 1124:
    #####: 1125:	if(subhier){
    #####: 1126:		now = time(NULL);
    #####: 1127:		retain__search(db, subhier, tokens, context, sub, sub_qos, subscription_identifier, now, 0);
    #####: 1128:	}
    #####: 1129:	while(tokens){
    #####: 1130:		tail = tokens->next;
    #####: 1131:		mosquitto__free(tokens->topic);
    #####: 1132:		mosquitto__free(tokens);
    #####: 1133:		tokens = tail;
        -: 1134:	}
        -: 1135:
    #####: 1136:	return MOSQ_ERR_SUCCESS;
    #####: 1137:}
        -: 1138:
